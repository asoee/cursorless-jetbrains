var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../node_modules/.pnpm/nearley@2.20.1_patch_hash=0_77008516667f120549eb6594bb82653f/node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "../../node_modules/.pnpm/nearley@2.20.1_patch_hash=0_77008516667f120549eb6594bb82653f/node_modules/nearley/lib/nearley.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root2.nearley = factory();
      }
    })(exports2, function() {
      function Rule(name2, symbols2, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name2;
        this.symbols = symbols2;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " \u25CF " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " \u2192 " + symbolSequence;
      };
      function State2(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State2.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State2.prototype.nextState = function(child) {
        var state = new State2(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State2.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State2.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser3.fail);
        }
      };
      function Column(grammar2, index) {
        this.grammar = grammar2;
        this.index = index;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser3.fail) {
              var wantedBy = state.wantedBy;
              for (var i2 = wantedBy.length; i2--; ) {
                var left = wantedBy[i2];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i2 = 0; i2 < nulls.length; i2++) {
                  var right = nulls[i2];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i2 = 0; i2 < rules.length; i2++) {
          var r = rules[i2];
          var wantedBy = this.wants[exp];
          var s = new State2(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
      };
      function Grammar2(rules, start2) {
        this.rules = rules;
        this.start = start2 || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar2.fromCompiled = function(rules, start2) {
        var lexer2 = rules.Lexer;
        if (rules.ParserStart) {
          start2 = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar2(rules, start2);
        g.lexer = lexer2;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1) nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i2) {
            return pad(this.line - lines.length + i2 + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
      };
      function Parser3(rules, start2, options2) {
        if (rules instanceof Grammar2) {
          var grammar2 = rules;
          var options2 = start2;
        } else {
          var grammar2 = Grammar2.fromCompiled(rules, start2);
        }
        this.grammar = grammar2;
        this.options = {
          keepHistory: false,
          lexer: grammar2.lexer || new StreamLexer()
        };
        for (var key in options2 || {}) {
          this.options[key] = options2[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar2, 0);
        var table = this.table = [column];
        column.wants[grammar2.start] = [];
        column.predict(grammar2.start);
        column.process();
        this.current = 0;
      }
      Parser3.fail = {};
      Parser3.prototype.feed = function(chunk) {
        var lexer2 = this.lexer;
        lexer2.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer2.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err2 = new Error(this.reportLexerError(e));
            err2.offset = this.current;
            err2.token = e.token;
            throw err2;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column(this.grammar, n);
          this.table.push(nextColumn);
          var literal2 = token.text !== void 0 ? token.text : token.value;
          var value = lexer2.constructor === StreamLexer ? token.value : lexer2.transform?.(token) ?? token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal2) {
              var next = state.nextState({ data: value, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err2 = new Error(this.reportError(token));
            err2.offset = this.current;
            err2.token = token;
            throw err2;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer2.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer2.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser3.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser3.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser3.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser3.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser3.prototype.getSymbolDisplay = function(symbol2) {
        return getSymbolLongDisplay(symbol2);
      };
      Parser3.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser3.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser3.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser3.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index]);
      };
      Parser3.prototype.finish = function() {
        var considerations = [];
        var start2 = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start2 && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser3.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol2) {
        var type2 = typeof symbol2;
        if (type2 === "string") {
          return symbol2;
        } else if (type2 === "object") {
          if (symbol2.literal) {
            return JSON.stringify(symbol2.literal);
          } else if (symbol2 instanceof RegExp) {
            return "character matching " + symbol2;
          } else if (symbol2.type) {
            return symbol2.type + " token";
          } else if (symbol2.test) {
            return "token matching " + String(symbol2.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol2);
          }
        }
      }
      function getSymbolShortDisplay(symbol2) {
        var type2 = typeof symbol2;
        if (type2 === "string") {
          return symbol2;
        } else if (type2 === "object") {
          if (symbol2.literal) {
            return JSON.stringify(symbol2.literal);
          } else if (symbol2 instanceof RegExp) {
            return symbol2.toString();
          } else if (symbol2.type) {
            return "%" + symbol2.type;
          } else if (symbol2.test) {
            return "<" + String(symbol2.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol2);
          }
        }
      }
      return {
        Parser: Parser3,
        Grammar: Grammar2,
        Rule
      };
    });
  }
});

// ../../node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js
var require_moo = __commonJS({
  "../../node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root2.moo = factory();
      }
    })(exports2, function() {
      "use strict";
      var hasOwnProperty12 = Object.prototype.hasOwnProperty;
      var toString4 = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === "boolean";
      function isRegExp(o) {
        return o && toString4.call(o) === "[object RegExp]";
      }
      function isObject5(o) {
        return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
      }
      function reEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function reGroups(s) {
        var re = new RegExp("|" + s);
        return re.exec("").length - 1;
      }
      function reCapture(s) {
        return "(" + s + ")";
      }
      function reUnion(regexps) {
        if (!regexps.length) return "(?!)";
        var source = regexps.map(function(s) {
          return "(?:" + s + ")";
        }).join("|");
        return "(?:" + source + ")";
      }
      function regexpOrLiteral(obj) {
        if (typeof obj === "string") {
          return "(?:" + reEscape(obj) + ")";
        } else if (isRegExp(obj)) {
          if (obj.ignoreCase) throw new Error("RegExp /i flag not allowed");
          if (obj.global) throw new Error("RegExp /g flag is implied");
          if (obj.sticky) throw new Error("RegExp /y flag is implied");
          if (obj.multiline) throw new Error("RegExp /m flag is implied");
          return obj.source;
        } else {
          throw new Error("Not a pattern: " + obj);
        }
      }
      function pad(s, length) {
        if (s.length > length) {
          return s;
        }
        return Array(length - s.length + 1).join(" ") + s;
      }
      function lastNLines(string5, numLines) {
        var position = string5.length;
        var lineBreaks = 0;
        while (true) {
          var idx = string5.lastIndexOf("\n", position - 1);
          if (idx === -1) {
            break;
          } else {
            lineBreaks++;
          }
          position = idx;
          if (lineBreaks === numLines) {
            break;
          }
          if (position === 0) {
            break;
          }
        }
        var startPosition = lineBreaks < numLines ? 0 : position + 1;
        return string5.substring(startPosition).split("\n");
      }
      function objectToRules(object2) {
        var keys2 = Object.getOwnPropertyNames(object2);
        var result = [];
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          var thing = object2[key];
          var rules = [].concat(thing);
          if (key === "include") {
            for (var j = 0; j < rules.length; j++) {
              result.push({ include: rules[j] });
            }
            continue;
          }
          var match = [];
          rules.forEach(function(rule) {
            if (isObject5(rule)) {
              if (match.length) result.push(ruleOptions(key, match));
              result.push(ruleOptions(key, rule));
              match = [];
            } else {
              match.push(rule);
            }
          });
          if (match.length) result.push(ruleOptions(key, match));
        }
        return result;
      }
      function arrayToRules(array2) {
        var result = [];
        for (var i2 = 0; i2 < array2.length; i2++) {
          var obj = array2[i2];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j = 0; j < include.length; j++) {
              result.push({ include: include[j] });
            }
            continue;
          }
          if (!obj.type) {
            throw new Error("Rule has no type: " + JSON.stringify(obj));
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result;
      }
      function ruleOptions(type2, obj) {
        if (!isObject5(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error("Matching rules cannot also include states");
        }
        var options2 = {
          defaultType: type2,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false
        };
        for (var key in obj) {
          if (hasOwnProperty12.call(obj, key)) {
            options2[key] = obj[key];
          }
        }
        if (typeof options2.type === "string" && type2 !== options2.type) {
          throw new Error("Type transform cannot be a string (type '" + options2.type + "' for token '" + type2 + "')");
        }
        var match = options2.match;
        options2.match = Array.isArray(match) ? match : match ? [match] : [];
        options2.match.sort(function(a, b) {
          return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? 1 : b.length - a.length;
        });
        return options2;
      }
      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
      }
      var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = /* @__PURE__ */ Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts2 = [];
        for (var i2 = 0; i2 < rules.length; i2++) {
          if (rules[i2].fallback) {
            fastAllowed = false;
          }
        }
        for (var i2 = 0; i2 < rules.length; i2++) {
          var options2 = rules[i2];
          if (options2.include) {
            throw new Error("Inheritance is not allowed in stateless lexers");
          }
          if (options2.error || options2.fallback) {
            if (errorRule) {
              if (!options2.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options2.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options2.defaultType + "')");
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options2.defaultType + "')");
              }
            }
            errorRule = options2;
          }
          var match = options2.match.slice();
          if (fastAllowed) {
            while (match.length && typeof match[0] === "string" && match[0].length === 1) {
              var word = match.shift();
              fast[word.charCodeAt(0)] = options2;
            }
          }
          if (options2.pop || options2.push || options2.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options2.defaultType + "')");
            }
            if (options2.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options2.defaultType + "')");
            }
          }
          if (match.length === 0) {
            continue;
          }
          fastAllowed = false;
          groups.push(options2);
          for (var j = 0; j < match.length; j++) {
            var obj = match[j];
            if (!isRegExp(obj)) {
              continue;
            }
            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options2.fallback === false) {
              throw new Error("If one rule is /u then all must be");
            }
          }
          var pat = reUnion(match.map(regexpOrLiteral));
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
          }
          if (!options2.lineBreaks && regexp.test("\n")) {
            throw new Error("Rule should declare lineBreaks: " + regexp);
          }
          parts2.push(reCapture(pat));
        }
        var fallbackRule = errorRule && errorRule.fallback;
        var flags2 = hasSticky && !fallbackRule ? "ym" : "gm";
        var suffix = hasSticky || fallbackRule ? "" : "|";
        if (unicodeFlag === true) flags2 += "u";
        var combined = new RegExp(reUnion(parts2) + suffix, flags2);
        return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
      }
      function compile(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({ start: result }, "start");
      }
      function checkStateGroup(g, name2, map4) {
        var state = g && (g.push || g.next);
        if (state && !map4[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name2 + "')");
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name2 + "')");
        }
      }
      function compileStates(states, start2) {
        var all = states.$all ? toRules(states.$all) : [];
        delete states.$all;
        var keys2 = Object.getOwnPropertyNames(states);
        if (!start2) start2 = keys2[0];
        var ruleMap = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          ruleMap[key] = toRules(states[key]).concat(all);
        }
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          var rules = ruleMap[key];
          var included = /* @__PURE__ */ Object.create(null);
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (!rule.include) continue;
            var splice3 = [j, 1];
            if (rule.include !== key && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
              }
              for (var k = 0; k < newRules.length; k++) {
                var newRule = newRules[k];
                if (rules.indexOf(newRule) !== -1) continue;
                splice3.push(newRule);
              }
            }
            rules.splice.apply(rules, splice3);
            j--;
          }
        }
        var map4 = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          map4[key] = compileRules(ruleMap[key], true);
        }
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var name2 = keys2[i2];
          var state = map4[name2];
          var groups = state.groups;
          for (var j = 0; j < groups.length; j++) {
            checkStateGroup(groups[j], name2, map4);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j = 0; j < fastKeys.length; j++) {
            checkStateGroup(state.fast[fastKeys[j]], name2, map4);
          }
        }
        return new Lexer(map4, start2);
      }
      function keywordTransform(map4) {
        var isMap2 = typeof Map !== "undefined";
        var reverseMap = isMap2 ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        var types = Object.getOwnPropertyNames(map4);
        for (var i2 = 0; i2 < types.length; i2++) {
          var tokenType = types[i2];
          var item = map4[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            if (typeof keyword !== "string") {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            if (isMap2) {
              reverseMap.set(keyword, tokenType);
            } else {
              reverseMap[keyword] = tokenType;
            }
          });
        }
        return function(k) {
          return isMap2 ? reverseMap.get(k) : reverseMap[k];
        };
      }
      var Lexer = function(states, state) {
        this.startState = state;
        this.states = states;
        this.buffer = "";
        this.stack = [];
        this.reset();
      };
      Lexer.prototype.reset = function(data, info2) {
        this.buffer = data || "";
        this.index = 0;
        this.line = info2 ? info2.line : 1;
        this.col = info2 ? info2.col : 1;
        this.queuedToken = info2 ? info2.queuedToken : null;
        this.queuedText = info2 ? info2.queuedText : "";
        this.queuedThrow = info2 ? info2.queuedThrow : null;
        this.setState(info2 ? info2.state : this.startState);
        this.stack = info2 && info2.stack ? info2.stack.slice() : [];
        return this;
      };
      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedText: this.queuedText,
          queuedThrow: this.queuedThrow
        };
      };
      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state) return;
        this.state = state;
        var info2 = this.states[state];
        this.groups = info2.groups;
        this.error = info2.error;
        this.re = info2.regexp;
        this.fast = info2.fast;
      };
      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };
      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };
      var eat = hasSticky ? function(re, buffer) {
        return re.exec(buffer);
      } : function(re, buffer) {
        var match = re.exec(buffer);
        if (match[0].length === 0) {
          return null;
        }
        return match;
      };
      Lexer.prototype._getGroup = function(match) {
        var groupCount = this.groups.length;
        for (var i2 = 0; i2 < groupCount; i2++) {
          if (match[i2 + 1] !== void 0) {
            return this.groups[i2];
          }
        }
        throw new Error("Cannot find token type for matched text");
      };
      function tokenToString() {
        return this.value;
      }
      Lexer.prototype.next = function() {
        var index = this.index;
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index);
          this.queuedGroup = null;
          this.queuedText = "";
          return token;
        }
        var buffer = this.buffer;
        if (index === buffer.length) {
          return;
        }
        var group = this.fast[buffer.charCodeAt(index)];
        if (group) {
          return this._token(group, buffer.charAt(index), index);
        }
        var re = this.re;
        re.lastIndex = index;
        var match = eat(re, buffer);
        var error48 = this.error;
        if (match == null) {
          return this._token(error48, buffer.slice(index, buffer.length), index);
        }
        var group = this._getGroup(match);
        var text = match[0];
        if (error48.fallback && match.index !== index) {
          this.queuedGroup = group;
          this.queuedText = text;
          return this._token(error48, buffer.slice(index, match.index), index);
        }
        return this._token(group, text, index);
      };
      Lexer.prototype._token = function(group, text, offset) {
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl = 1;
          if (text === "\n") {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) {
              lineBreaks++;
              nl = matchNL.lastIndex;
            }
          }
        }
        var token = {
          type: typeof group.type === "function" && group.type(text) || group.defaultType,
          value: typeof group.value === "function" ? group.value(text) : text,
          text,
          toString: tokenToString,
          offset,
          lineBreaks,
          line: this.line,
          col: this.col
        };
        var size = text.length;
        this.index += size;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size - nl + 1;
        } else {
          this.col += size;
        }
        if (group.shouldThrow) {
          var err2 = new Error(this.formatError(token, "invalid syntax"));
          throw err2;
        }
        if (group.pop) this.popState();
        else if (group.push) this.pushState(group.push);
        else if (group.next) this.setState(group.next);
        return token;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var LexerIterator = function(lexer2) {
          this.lexer = lexer2;
        };
        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return { value: token, done: !token };
        };
        LexerIterator.prototype[Symbol.iterator] = function() {
          return this;
        };
        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this);
        };
      }
      Lexer.prototype.formatError = function(token, message) {
        if (token == null) {
          var text = this.buffer.slice(this.index);
          var token = {
            text,
            offset: this.index,
            lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
            line: this.line,
            col: this.col
          };
        }
        var numLinesAround = 2;
        var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
        var lastDisplayedLine = token.line + numLinesAround;
        var lastLineDigits = String(lastDisplayedLine).length;
        var displayedLines = lastNLines(
          this.buffer,
          this.line - token.line + numLinesAround + 1
        ).slice(0, 5);
        var errorLines = [];
        errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
        errorLines.push("");
        for (var i2 = 0; i2 < displayedLines.length; i2++) {
          var line = displayedLines[i2];
          var lineNo = firstDisplayedLine + i2;
          errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
          if (lineNo === token.line) {
            errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
          }
        }
        return errorLines.join("\n");
      };
      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state);
      };
      Lexer.prototype.has = function(tokenType) {
        return true;
      };
      return {
        compile,
        states: compileStates,
        error: Object.freeze({ error: true }),
        fallback: Object.freeze({ fallback: true }),
        keywords: keywordTransform
      };
    });
  }
});

// ../../node_modules/.pnpm/immutability-helper@3.1.1/node_modules/immutability-helper/index.js
var require_immutability_helper = __commonJS({
  "../../node_modules/.pnpm/immutability-helper@3.1.1/node_modules/immutability-helper/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function stringifiable(obj) {
      return typeof obj === "object" && !("toString" in obj) ? Object.prototype.toString.call(obj).slice(8, -1) : obj;
    }
    var isProduction = typeof process === "object" && process.env.NODE_ENV === "production";
    function invariant4(condition, message) {
      if (!condition) {
        if (isProduction) {
          throw new Error("Invariant failed");
        }
        throw new Error(message());
      }
    }
    exports2.invariant = invariant4;
    var hasOwnProperty12 = Object.prototype.hasOwnProperty;
    var splice3 = Array.prototype.splice;
    var toString4 = Object.prototype.toString;
    function type2(obj) {
      return toString4.call(obj).slice(8, -1);
    }
    var assign = Object.assign || /* istanbul ignore next */
    (function(target, source) {
      getAllKeys2(source).forEach(function(key) {
        if (hasOwnProperty12.call(source, key)) {
          target[key] = source[key];
        }
      });
      return target;
    });
    var getAllKeys2 = typeof Object.getOwnPropertySymbols === "function" ? function(obj) {
      return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
    } : function(obj) {
      return Object.keys(obj);
    };
    function copy(object2) {
      return Array.isArray(object2) ? assign(object2.constructor(object2.length), object2) : type2(object2) === "Map" ? new Map(object2) : type2(object2) === "Set" ? new Set(object2) : object2 && typeof object2 === "object" ? assign(Object.create(Object.getPrototypeOf(object2)), object2) : object2;
    }
    var Context = (
      /** @class */
      (function() {
        function Context2() {
          this.commands = assign({}, defaultCommands);
          this.update = this.update.bind(this);
          this.update.extend = this.extend = this.extend.bind(this);
          this.update.isEquals = function(x, y) {
            return x === y;
          };
          this.update.newContext = function() {
            return new Context2().update;
          };
        }
        Object.defineProperty(Context2.prototype, "isEquals", {
          get: function() {
            return this.update.isEquals;
          },
          set: function(value) {
            this.update.isEquals = value;
          },
          enumerable: true,
          configurable: true
        });
        Context2.prototype.extend = function(directive, fn) {
          this.commands[directive] = fn;
        };
        Context2.prototype.update = function(object2, $spec) {
          var _this = this;
          var spec = typeof $spec === "function" ? { $apply: $spec } : $spec;
          if (!(Array.isArray(object2) && Array.isArray(spec))) {
            invariant4(!Array.isArray(spec), function() {
              return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
            });
          }
          invariant4(typeof spec === "object" && spec !== null, function() {
            return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(_this.commands).join(", ") + ".");
          });
          var nextObject = object2;
          getAllKeys2(spec).forEach(function(key) {
            if (hasOwnProperty12.call(_this.commands, key)) {
              var objectWasNextObject = object2 === nextObject;
              nextObject = _this.commands[key](spec[key], nextObject, spec, object2);
              if (objectWasNextObject && _this.isEquals(nextObject, object2)) {
                nextObject = object2;
              }
            } else {
              var nextValueForKey = type2(object2) === "Map" ? _this.update(object2.get(key), spec[key]) : _this.update(object2[key], spec[key]);
              var nextObjectValue = type2(nextObject) === "Map" ? nextObject.get(key) : nextObject[key];
              if (!_this.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === "undefined" && !hasOwnProperty12.call(object2, key)) {
                if (nextObject === object2) {
                  nextObject = copy(object2);
                }
                if (type2(nextObject) === "Map") {
                  nextObject.set(key, nextValueForKey);
                } else {
                  nextObject[key] = nextValueForKey;
                }
              }
            }
          });
          return nextObject;
        };
        return Context2;
      })()
    );
    exports2.Context = Context;
    var defaultCommands = {
      $push: function(value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, "$push");
        return value.length ? nextObject.concat(value) : nextObject;
      },
      $unshift: function(value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, "$unshift");
        return value.length ? value.concat(nextObject) : nextObject;
      },
      $splice: function(value, nextObject, spec, originalObject) {
        invariantSplices(nextObject, spec);
        value.forEach(function(args2) {
          invariantSplice(args2);
          if (nextObject === originalObject && args2.length) {
            nextObject = copy(originalObject);
          }
          splice3.apply(nextObject, args2);
        });
        return nextObject;
      },
      $set: function(value, _nextObject, spec) {
        invariantSet(spec);
        return value;
      },
      $toggle: function(targets, nextObject) {
        invariantSpecArray(targets, "$toggle");
        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;
        targets.forEach(function(target) {
          nextObjectCopy[target] = !nextObject[target];
        });
        return nextObjectCopy;
      },
      $unset: function(value, nextObject, _spec, originalObject) {
        invariantSpecArray(value, "$unset");
        value.forEach(function(key) {
          if (Object.hasOwnProperty.call(nextObject, key)) {
            if (nextObject === originalObject) {
              nextObject = copy(originalObject);
            }
            delete nextObject[key];
          }
        });
        return nextObject;
      },
      $add: function(values2, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, "$add");
        invariantSpecArray(values2, "$add");
        if (type2(nextObject) === "Map") {
          values2.forEach(function(_a10) {
            var key = _a10[0], value = _a10[1];
            if (nextObject === originalObject && nextObject.get(key) !== value) {
              nextObject = copy(originalObject);
            }
            nextObject.set(key, value);
          });
        } else {
          values2.forEach(function(value) {
            if (nextObject === originalObject && !nextObject.has(value)) {
              nextObject = copy(originalObject);
            }
            nextObject.add(value);
          });
        }
        return nextObject;
      },
      $remove: function(value, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, "$remove");
        invariantSpecArray(value, "$remove");
        value.forEach(function(key) {
          if (nextObject === originalObject && nextObject.has(key)) {
            nextObject = copy(originalObject);
          }
          nextObject.delete(key);
        });
        return nextObject;
      },
      $merge: function(value, nextObject, _spec, originalObject) {
        invariantMerge(nextObject, value);
        getAllKeys2(value).forEach(function(key) {
          if (value[key] !== nextObject[key]) {
            if (nextObject === originalObject) {
              nextObject = copy(originalObject);
            }
            nextObject[key] = value[key];
          }
        });
        return nextObject;
      },
      $apply: function(value, original) {
        invariantApply(value);
        return value(original);
      }
    };
    var defaultContext = new Context();
    exports2.isEquals = defaultContext.update.isEquals;
    exports2.extend = defaultContext.extend;
    exports2.default = defaultContext.update;
    exports2.default.default = module2.exports = assign(exports2.default, exports2);
    function invariantPushAndUnshift(value, spec, command) {
      invariant4(Array.isArray(value), function() {
        return "update(): expected target of " + stringifiable(command) + " to be an array; got " + stringifiable(value) + ".";
      });
      invariantSpecArray(spec[command], command);
    }
    function invariantSpecArray(spec, command) {
      invariant4(Array.isArray(spec), function() {
        return "update(): expected spec of " + stringifiable(command) + " to be an array; got " + stringifiable(spec) + ". Did you forget to wrap your parameter in an array?";
      });
    }
    function invariantSplices(value, spec) {
      invariant4(Array.isArray(value), function() {
        return "Expected $splice target to be an array; got " + stringifiable(value);
      });
      invariantSplice(spec.$splice);
    }
    function invariantSplice(value) {
      invariant4(Array.isArray(value), function() {
        return "update(): expected spec of $splice to be an array of arrays; got " + stringifiable(value) + ". Did you forget to wrap your parameters in an array?";
      });
    }
    function invariantApply(fn) {
      invariant4(typeof fn === "function", function() {
        return "update(): expected spec of $apply to be a function; got " + stringifiable(fn) + ".";
      });
    }
    function invariantSet(spec) {
      invariant4(Object.keys(spec).length === 1, function() {
        return "Cannot have more than one key in an object with $set";
      });
    }
    function invariantMerge(target, specValue) {
      invariant4(specValue && typeof specValue === "object", function() {
        return "update(): $merge expects a spec of type 'object'; got " + stringifiable(specValue);
      });
      invariant4(target && typeof target === "object", function() {
        return "update(): $merge expects a target of type 'object'; got " + stringifiable(target);
      });
    }
    function invariantMapOrSet(target, command) {
      var typeOfTarget = type2(target);
      invariant4(typeOfTarget === "Map" || typeOfTarget === "Set", function() {
        return "update(): " + stringifiable(command) + " expects a target of type Set or Map; got " + stringifiable(typeOfTarget);
      });
    }
  }
});

// ../common/src/constants.ts
var CURSORLESS_ORG_URL = "https://www.cursorless.org";
var DOCS_URL = `${CURSORLESS_ORG_URL}/docs`;

// ../common/src/cursorlessCommandIds.ts
var Command = class {
  constructor(baseTitle) {
    this.baseTitle = baseTitle;
  }
  get title() {
    return `Cursorless: ${this.baseTitle}`;
  }
};
var HiddenCommand = class extends Command {
  constructor() {
    super(...arguments);
    __publicField(this, "isVisible", false);
  }
};
var VisibleCommand = class extends Command {
  constructor() {
    super(...arguments);
    __publicField(this, "isVisible", true);
  }
};
var cursorlessCommandDescriptions = {
  ["cursorless.toggleDecorations"]: new VisibleCommand("Toggle decorations"),
  ["cursorless.recomputeDecorationStyles"]: new VisibleCommand(
    "Recompute decoration styles"
  ),
  ["cursorless.recordTestCase"]: new VisibleCommand("Record test case"),
  ["cursorless.recordOneTestCaseThenPause"]: new VisibleCommand(
    "Record one test case, then pause"
  ),
  ["cursorless.pauseRecording"]: new VisibleCommand(
    "Pause test case recording"
  ),
  ["cursorless.resumeRecording"]: new VisibleCommand(
    "Resume test case recording"
  ),
  ["cursorless.recordScopeTests.showUnimplementedFacets"]: new VisibleCommand(
    "Bulk record unimplemented scope facets"
  ),
  ["cursorless.recordScopeTests.saveActiveDocument"]: new VisibleCommand(
    "Bulk save scope tests for the active document"
  ),
  ["cursorless.showDocumentation"]: new VisibleCommand("Show documentation"),
  ["cursorless.showInstallationDependencies"]: new VisibleCommand(
    "Show installation dependencies"
  ),
  // showScopeVisualizer can't be called from the command palatte because it
  // requires an argument, but it still needs to be visible or the scope buttons
  // will be disabled in the sidebar
  ["cursorless.showScopeVisualizer"]: new VisibleCommand(
    "Show the scope visualizer"
  ),
  ["cursorless.hideScopeVisualizer"]: new VisibleCommand(
    "Hide the scope visualizer"
  ),
  ["cursorless.scopeVisualizer.openUrl"]: new VisibleCommand("Open in browser"),
  ["cursorless.analyzeCommandHistory"]: new VisibleCommand(
    "Analyze collected command history"
  ),
  ["cursorless.tutorial.start"]: new HiddenCommand("Start a tutorial"),
  ["cursorless.tutorial.next"]: new VisibleCommand("Tutorial next"),
  ["cursorless.tutorial.previous"]: new VisibleCommand("Tutorial previous"),
  ["cursorless.tutorial.restart"]: new VisibleCommand("Tutorial restart"),
  ["cursorless.tutorial.resume"]: new VisibleCommand("Tutorial resume"),
  ["cursorless.tutorial.list"]: new VisibleCommand("Tutorial list"),
  ["cursorless.documentationOpened"]: new HiddenCommand(
    "Used by talon to notify us that the docs have been opened; for use with tutorial"
  ),
  ["cursorless.command"]: new HiddenCommand("The core cursorless command"),
  ["cursorless.repeatPreviousCommand"]: new VisibleCommand(
    "Repeat the previous Cursorless command"
  ),
  ["cursorless.showQuickPick"]: new HiddenCommand(
    "Pop up a quick pick of all cursorless commands"
  ),
  ["cursorless.showCheatsheet"]: new HiddenCommand(
    "Display the cursorless cheatsheet"
  ),
  ["cursorless.internal.updateCheatsheetDefaults"]: new HiddenCommand(
    "Update the default values of the cheatsheet payload used on the website and for local development. Be sure to run this on stock community and cursorless."
  ),
  ["cursorless.private.logQuickActions"]: new HiddenCommand(
    "Log the quick actions available at the current cursor position"
  ),
  ["cursorless.takeSnapshot"]: new HiddenCommand(
    "Take a snapshot of the current editor state"
  ),
  ["cursorless.keyboard.escape"]: new HiddenCommand(
    "Should be mapped to the escape key when using cursorless keyboard. By default, exits modal keyboard mode, but changes behaviour when Cursorless is expecting a continuation keystroke.  For example, when you type a color and Cursorless is waiting for a character, it cancels the color and switches back to modal mode."
  ),
  ["cursorless.keyboard.targeted.targetHat"]: new HiddenCommand(
    "Sets the keyboard target to the given hat"
  ),
  ["cursorless.keyboard.targeted.targetScope"]: new HiddenCommand(
    "Sets the keyboard target to the scope containing the current target"
  ),
  ["cursorless.keyboard.targeted.targetSelection"]: new HiddenCommand(
    "Sets the keyboard target to the current selection"
  ),
  ["cursorless.keyboard.targeted.clearTarget"]: new HiddenCommand(
    "Clears the current keyboard target"
  ),
  ["cursorless.keyboard.targeted.runActionOnTarget"]: new HiddenCommand(
    "Run the given action on the current keyboard target"
  ),
  ["cursorless.keyboard.modal.modeOn"]: new HiddenCommand(
    "Turn on the cursorless modal mode"
  ),
  ["cursorless.keyboard.modal.modeOff"]: new HiddenCommand(
    "Turn off the cursorless modal mode"
  ),
  ["cursorless.keyboard.modal.modeToggle"]: new HiddenCommand(
    "Toggle the cursorless modal mode"
  ),
  ["cursorless.keyboard.undoTarget"]: new HiddenCommand(
    "Undo keyboard targeting changes"
  ),
  ["cursorless.keyboard.redoTarget"]: new HiddenCommand(
    "Redo keyboard targeting changes"
  )
};

// ../common/src/Debouncer.ts
var Debouncer = class {
  constructor(callback2, debounceDelayMs) {
    this.callback = callback2;
    this.debounceDelayMs = debounceDelayMs;
    __publicField(this, "timeoutHandle", null);
    this.run = this.run.bind(this);
  }
  run() {
    if (this.timeoutHandle != null) {
      clearTimeout(this.timeoutHandle);
    }
    this.timeoutHandle = setTimeout(() => {
      this.callback();
      this.timeoutHandle = null;
    }, this.debounceDelayMs);
  }
  dispose() {
    if (this.timeoutHandle != null) {
      clearTimeout(this.timeoutHandle);
    }
  }
};

// ../common/src/errors.ts
var UnsupportedScopeError = class extends Error {
  constructor(scopeType) {
    super(
      `Scope '${scopeType}' is not implemented yet; See ${DOCS_URL}/contributing/adding-a-new-scope`
    );
    this.name = "UnsupportedScopeError";
  }
};
var OutdatedExtensionError = class extends Error {
  constructor() {
    super(
      "Cursorless Talon version is ahead of Cursorless VSCode extension version. Please update Cursorless VSCode."
    );
  }
};
var NoContainingScopeError = class extends Error {
  /**
   *
   * @param scopeType The scopeType for the failed match to show to the user
   */
  constructor(scopeType) {
    super(`Couldn't find containing ${scopeType}.`);
    this.name = "NoContainingScopeError";
  }
};
var NamedSnippetsDeprecationError = class extends Error {
  constructor() {
    super(
      "Cursorless snippets are deprecated and have been removed. Please use community snippets."
    );
    this.name = "NamedSnippetsDeprecationError";
  }
};

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_arrayMap.js
function arrayMap(array2, iteratee) {
  var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array2[index], index, array2);
  }
  return result;
}
var arrayMap_default = arrayMap;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string5) {
  var index = string5.length;
  while (index-- && reWhitespace.test(string5.charAt(index))) {
  }
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string5) {
  return string5 ? string5.slice(0, trimmedEndIndex_default(string5) + 1).replace(reTrimStart, "") : string5;
}
var baseTrim_default = baseTrim;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_default = isObject;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary2 = reIsBinary.test(value);
  return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result = toFinite_default(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_default = toInteger;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_isMasked.js
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
})();
function isMasked(func2) {
  return !!maskSrcKey && maskSrcKey in func2;
}
var isMasked_default = isMasked;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func2) {
  if (func2 != null) {
    try {
      return funcToString.call(func2);
    } catch (e) {
    }
    try {
      return func2 + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getValue.js
function getValue2(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var getValue_default = getValue2;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getNative.js
function getNative(object2, key) {
  var value = getValue_default(object2, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ (function() {
  function object2() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object2.prototype = proto;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
})();
var baseCreate_default = baseCreate;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_apply.js
function apply(func2, thisArg, args2) {
  switch (args2.length) {
    case 0:
      return func2.call(thisArg);
    case 1:
      return func2.call(thisArg, args2[0]);
    case 2:
      return func2.call(thisArg, args2[0], args2[1]);
    case 3:
      return func2.call(thisArg, args2[0], args2[1], args2[2]);
  }
  return func2.apply(thisArg, args2);
}
var apply_default = apply;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/noop.js
function noop() {
}
var noop_default = noop;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getData.js
var getData = !metaMap_default ? noop_default : function(func2) {
  return metaMap_default.get(func2);
};
var getData_default = getData;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getFuncName.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function getFuncName(func2) {
  var result = func2.name + "", array2 = realNames_default[result], length = hasOwnProperty3.call(realNames_default, result) ? array2.length : 0;
  while (length--) {
    var data = array2[length], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func2) {
      return data.name;
    }
  }
  return result;
}
var getFuncName_default = getFuncName;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_copyArray.js
function copyArray(source, array2) {
  var index = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index < length) {
    array2[index] = source[index];
  }
  return array2;
}
var copyArray_default = copyArray;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray_default(wrapper.__actions__);
  result.__index__ = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}
var wrapperClone_default = wrapperClone;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/wrapperLodash.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function lodash(value) {
  if (isObjectLike_default(value) && !isArray_default(value) && !(value instanceof LazyWrapper_default)) {
    if (value instanceof LodashWrapper_default) {
      return value;
    }
    if (hasOwnProperty4.call(value, "__wrapped__")) {
      return wrapperClone_default(value);
    }
  }
  return new LodashWrapper_default(value);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_isLaziable.js
function isLaziable(func2) {
  var funcName = getFuncName_default(func2), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func2 === other) {
    return true;
  }
  var data = getData_default(other);
  return !!data && func2 === data[0];
}
var isLaziable_default = isLaziable;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func2) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func2.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_defineProperty.js
var defineProperty = (function() {
  try {
    var func2 = getNative_default(Object, "defineProperty");
    func2({}, "", {});
    return func2;
  } catch (e) {
  }
})();
var defineProperty_default = defineProperty;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func2, string5) {
  return defineProperty_default(func2, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string5),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array2, predicate, fromIndex, fromRight) {
  var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array2[index], index, array2)) {
      return index;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array2, value, fromIndex) {
  var index = fromIndex - 1, length = array2.length;
  while (++index < length) {
    if (array2[index] === value) {
      return index;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array2, value, fromIndex) {
  return value === value ? strictIndexOf_default(array2, value, fromIndex) : baseFindIndex_default(array2, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array2, value) {
  var length = array2 == null ? 0 : array2.length;
  return !!length && baseIndexOf_default(array2, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func2, start2, transform2) {
  start2 = nativeMax(start2 === void 0 ? func2.length - 1 : start2, 0);
  return function() {
    var args2 = arguments, index = -1, length = nativeMax(args2.length - start2, 0), array2 = Array(length);
    while (++index < length) {
      array2[index] = args2[start2 + index];
    }
    index = -1;
    var otherArgs = Array(start2 + 1);
    while (++index < start2) {
      otherArgs[index] = args2[index];
    }
    otherArgs[start2] = transform2(array2);
    return apply_default(func2, this, otherArgs);
  };
}
var overRest_default = overRest;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseRest.js
function baseRest(func2, start2) {
  return setToString_default(overRest_default(func2, start2, identity_default), func2 + "");
}
var baseRest_default = baseRest;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object2) {
  if (!isObject_default(object2)) {
    return false;
  }
  var type2 = typeof index;
  if (type2 == "number" ? isArrayLike_default(object2) && isIndex_default(index, object2.length) : type2 == "string" && index in object2) {
    return eq_default(object2[index], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_isPrototype.js
var objectProto6 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto6;
  return value === proto;
}
var isPrototype_default = isPrototype;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isArguments.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
var propertyIsEnumerable = objectProto7.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ (function() {
  return arguments;
})()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty5.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports2 ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseUnary.js
function baseUnary(func2) {
  return function(value) {
    return func2(value);
  };
}
var baseUnary_default = baseUnary;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports3 && freeGlobal_default.process;
var nodeUtil = (function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
})();
var nodeUtil_default = nodeUtil;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_arrayLikeKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty6.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_overArg.js
function overArg(func2, transform2) {
  return function(arg) {
    return func2(transform2(arg));
  };
}
var overArg_default = overArg;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseKeys.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function baseKeys(object2) {
  if (!isPrototype_default(object2)) {
    return nativeKeys_default(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty7.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/keys.js
function keys(object2) {
  return isArrayLike_default(object2) ? arrayLikeKeys_default(object2) : baseKeys_default(object2);
}
var keys_default = keys;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object2) {
  if (isArray_default(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
}
var isKey_default = isKey;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty8.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
}
var hashHas_default = hashHas;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq_default(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getMapData.js
function getMapData(map4, key) {
  var data = map4.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func2, resolver) {
  if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func2.apply(this, args2);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func2) {
  var result = memoize_default(func2, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string5) {
  var result = [];
  if (string5.charCodeAt(0) === 46) {
    result.push("");
  }
  string5.replace(rePropName, function(match, number4, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_castPath.js
function castPath(value, object2) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object2) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
}
var toKey_default = toKey;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseGet.js
function baseGet(object2, path) {
  path = castPath_default(path, object2);
  var index = 0, length = path.length;
  while (object2 != null && index < length) {
    object2 = object2[toKey_default(path[index++])];
  }
  return index && index == length ? object2 : void 0;
}
var baseGet_default = baseGet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/get.js
function get(object2, path, defaultValue) {
  var result = object2 == null ? void 0 : baseGet_default(object2, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_arrayPush.js
function arrayPush(array2, values2) {
  var index = -1, length = values2.length, offset = array2.length;
  while (++index < length) {
    array2[offset + index] = values2[index];
  }
  return array2;
}
var arrayPush_default = arrayPush;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array2, depth, predicate, isStrict, result) {
  var index = -1, length = array2.length;
  predicate || (predicate = isFlattenable_default);
  result || (result = []);
  while (++index < length) {
    var value = array2[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush_default(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var baseFlatten_default = baseFlatten;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/flatten.js
function flatten(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? baseFlatten_default(array2, 1) : [];
}
var flatten_default = flatten;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_flatRest.js
function flatRest(func2) {
  return setToString_default(overRest_default(func2, void 0, flatten_default), func2 + "");
}
var flatRest_default = flatRest;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object2) {
  return function(key) {
    return object2 == null ? void 0 : object2[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  "\xC6": "Ae",
  "\xE6": "ae",
  "\xDE": "Th",
  "\xFE": "th",
  "\xDF": "ss",
  // Latin Extended-A block.
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0152": "Oe",
  "\u0153": "oe",
  "\u0149": "'n",
  "\u017F": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsCombo = "[" + rsComboRange + "]";
var reComboMark = RegExp(rsCombo, "g");
function deburr(string5) {
  string5 = toString_default(string5);
  return string5 && string5.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs2 = data.__data__;
    if (!Map_default || pairs2.length < LARGE_ARRAY_SIZE - 1) {
      pairs2.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs2);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array2, predicate) {
  var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array2[index];
    if (predicate(value, index, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getSymbols.js
var objectProto12 = Object.prototype;
var propertyIsEnumerable2 = objectProto12.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter_default(nativeGetSymbols(object2), function(symbol2) {
    return propertyIsEnumerable2.call(object2, symbol2);
  });
};
var getSymbols_default = getSymbols;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray_default(object2) ? result : arrayPush_default(result, symbolsFunc(object2));
}
var baseGetAllKeys_default = baseGetAllKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object2) {
  return baseGetAllKeys_default(object2, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/concat.js
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args2 = Array(length - 1), array2 = arguments[0], index = length;
  while (index--) {
    args2[index - 1] = arguments[index];
  }
  return arrayPush_default(isArray_default(array2) ? copyArray_default(array2) : [array2], baseFlatten_default(args2, 1));
}
var concat_default = concat;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values2[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_arraySome.js
function arraySome(array2, predicate) {
  var index = -1, length = array2 == null ? 0 : array2.length;
  while (++index < length) {
    if (predicate(array2[index], index, array2)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
var cacheHas_default = cacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array2);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array2, other);
  stack.set(other, array2);
  while (++index < arrLength) {
    var arrValue = array2[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array2);
  stack["delete"](other);
  return result;
}
var equalArrays_default = equalArrays;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_mapToArray.js
function mapToArray(map4) {
  var index = -1, result = Array(map4.size);
  map4.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_setToArray.js
function setToArray(set4) {
  var index = -1, result = Array(set4.size);
  set4.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag3:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object2), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq_default(+object2, +other);
    case errorTag2:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object2 == other + "";
    case mapTag3:
      var convert = mapToArray_default;
    case setTag3:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object2, other);
      var result = equalArrays_default(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object2);
      return result;
    case symbolTag2:
      if (symbolValueOf) {
        return symbolValueOf.call(object2) == symbolValueOf.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto13 = Object.prototype;
var hasOwnProperty10 = objectProto13.hasOwnProperty;
function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object2), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty10.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object2);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack.set(object2, other);
  stack.set(other, object2);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object2[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object2);
  stack["delete"](other);
  return result;
}
var equalObjects_default = equalObjects;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag3 = "[object Object]";
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object2), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object2), othTag = othIsArr ? arrayTag2 : getTag_default(other);
  objTag = objTag == argsTag3 ? objectTag3 : objTag;
  othTag = othTag == argsTag3 ? objectTag3 : othTag;
  var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object2)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object2) ? equalArrays_default(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object2, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty11.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty11.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object2, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object2, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object2[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object2)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object2, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_getMatchData.js
function getMatchData(object2) {
  var result = keys_default(object2), length = result.length;
  while (length--) {
    var key = result[length], value = object2[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default = getMatchData;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch_default(object2, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object2, key) {
  return object2 != null && key in Object(object2);
}
var baseHasIn_default = baseHasIn;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_hasPath.js
function hasPath(object2, path, hasFunc) {
  path = castPath_default(path, object2);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey_default(path[index]);
    if (!(result = object2 != null && hasFunc(object2, key))) {
      break;
    }
    object2 = object2[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object2) || isArguments_default(object2));
}
var hasPath_default = hasPath;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/hasIn.js
function hasIn(object2, path) {
  return object2 != null && hasPath_default(object2, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object2) {
    var objValue = get_default(object2, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object2, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key];
  };
}
var baseProperty_default = baseProperty;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object2) {
    return baseGet_default(object2, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var createBaseFor_default = createBaseFor;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object2, iteratee) {
  return object2 && baseFor_default(object2, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array2, value, comparator) {
  var index = -1, length = array2 == null ? 0 : array2.length;
  while (++index < length) {
    if (comparator(value, array2[index])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/last.js
function last(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? array2[length - 1] : void 0;
}
var last_default = last;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string5) {
  string5 = toString_default(string5);
  return string5 && reHasRegExpChar.test(string5) ? string5.replace(reRegExpChar2, "\\$&") : string5;
}
var escapeRegExp_default = escapeRegExp;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/findLastIndex.js
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function findLastIndex(array2, predicate, fromIndex) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = fromIndex < 0 ? nativeMax2(length + index, 0) : nativeMin(index, length - 1);
  }
  return baseFindIndex_default(array2, baseIteratee_default(predicate, 3), index, true);
}
var findLastIndex_default = findLastIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee) {
  var index = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index] = iteratee(value, key, collection2);
  });
  return result;
}
var baseMap_default = baseMap;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_CURRY_FLAG = 8;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length = funcs.length, index = length, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func2 = funcs[index];
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT2);
      }
      if (prereq && !wrapper && getFuncName_default(func2) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func2 = funcs[index];
      var funcName = getFuncName_default(func2), data = funcName == "wrapper" ? getData_default(func2) : void 0;
      if (data && isLaziable_default(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName_default(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func2.length == 1 && isLaziable_default(func2) ? wrapper[funcName]() : wrapper.thru(func2);
      }
    }
    return function() {
      var args2 = arguments, value = args2[0];
      if (wrapper && args2.length == 1 && isArray_default(value)) {
        return wrapper.plant(value).value();
      }
      var index2 = 0, result = length ? funcs[index2].apply(this, args2) : value;
      while (++index2 < length) {
        result = funcs[index2].call(this, result);
      }
      return result;
    };
  });
}
var createFlow_default = createFlow;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/flow.js
var flow = createFlow_default();
var flow_default = flow;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseValues.js
function baseValues(object2, props) {
  return arrayMap_default(props, function(key) {
    return object2[key];
  });
}
var baseValues_default = baseValues;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/values.js
function values(object2) {
  return object2 == null ? [] : baseValues_default(object2, keys_default(object2));
}
var values_default = values;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default = isEqual;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseLt.js
function baseLt(value, other) {
  return value < other;
}
var baseLt_default = baseLt;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array2, iteratee, comparator) {
  var index = -1, length = array2.length;
  while (++index < length) {
    var value = array2[index], current2 = iteratee(value);
    if (current2 != null && (computed === void 0 ? current2 === current2 && !isSymbol_default(current2) : comparator(current2, computed))) {
      var computed = current2, result = value;
    }
  }
  return result;
}
var baseExtremum_default = baseExtremum;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseSum.js
function baseSum(array2, iteratee) {
  var result, index = -1, length = array2.length;
  while (++index < length) {
    var current2 = iteratee(array2[index]);
    if (current2 !== void 0) {
      result = result === void 0 ? current2 : result + current2;
    }
  }
  return result;
}
var baseSum_default = baseSum;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/min.js
function min(array2) {
  return array2 && array2.length ? baseExtremum_default(array2, identity_default, baseLt_default) : void 0;
}
var min_default = min;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array2, comparer) {
  var length = array2.length;
  array2.sort(comparer);
  while (length--) {
    array2[length] = array2[length].value;
  }
  return array2;
}
var baseSortBy_default = baseSortBy;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_compareAscending.js
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object2, other, orders) {
  var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index < length) {
    var result = compareAscending_default(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object2.index - other.index;
}
var compareMultiple_default = compareMultiple;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee) {
      if (isArray_default(iteratee)) {
        return function(value) {
          return baseGet_default(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity_default];
  }
  var index = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index, "value": value };
  });
  return baseSortBy_default(result, function(object2, other) {
    return compareMultiple_default(object2, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string5, n) {
  var result = "";
  if (!string5 || n < 1 || n > MAX_SAFE_INTEGER3) {
    return result;
  }
  do {
    if (n % 2) {
      result += string5;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string5 += string5;
    }
  } while (n);
  return result;
}
var baseRepeat_default = baseRepeat;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array2, value, fromIndex, comparator) {
  var index = fromIndex - 1, length = array2.length;
  while (++index < length) {
    if (comparator(array2[index], value)) {
      return index;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_basePullAll.js
var arrayProto2 = Array.prototype;
var splice2 = arrayProto2.splice;
function basePullAll(array2, values2, iteratee, comparator) {
  var indexOf = comparator ? baseIndexOfWith_default : baseIndexOf_default, index = -1, length = values2.length, seen = array2;
  if (array2 === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee) {
    seen = arrayMap_default(array2, baseUnary_default(iteratee));
  }
  while (++index < length) {
    var fromIndex = 0, value = values2[index], computed = iteratee ? iteratee(value) : value;
    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array2) {
        splice2.call(seen, fromIndex, 1);
      }
      splice2.call(array2, fromIndex, 1);
    }
  }
  return array2;
}
var basePullAll_default = basePullAll;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/pullAll.js
function pullAll(array2, values2) {
  return array2 && array2.length && values2 && values2.length ? basePullAll_default(array2, values2) : array2;
}
var pullAll_default = pullAll;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default = pull;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseRandom.js
var nativeFloor2 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor2(nativeRandom() * (upper - lower + 1));
}
var baseRandom_default = baseRandom;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseRange.js
var nativeCeil = Math.ceil;
var nativeMax3 = Math.max;
function baseRange(start2, end, step, fromRight) {
  var index = -1, length = nativeMax3(nativeCeil((end - start2) / (step || 1)), 0), result = Array(length);
  while (length--) {
    result[fromRight ? length : ++index] = start2;
    start2 += step;
  }
  return result;
}
var baseRange_default = baseRange;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start2, end, step) {
    if (step && typeof step != "number" && isIterateeCall_default(start2, end, step)) {
      end = step = void 0;
    }
    start2 = toFinite_default(start2);
    if (end === void 0) {
      end = start2;
      start2 = 0;
    } else {
      end = toFinite_default(end);
    }
    step = step === void 0 ? start2 < end ? 1 : -1 : toFinite_default(step);
    return baseRange_default(start2, end, step, fromRight);
  };
}
var createRange_default = createRange;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/range.js
var range = createRange_default();
var range_default = range;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/repeat.js
function repeat(string5, n, guard) {
  if (guard ? isIterateeCall_default(string5, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  return baseRepeat_default(toString_default(string5), n);
}
var repeat_default = repeat;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array2, size) {
  var index = -1, length = array2.length, lastIndex = length - 1;
  size = size === void 0 ? length : size;
  while (++index < size) {
    var rand = baseRandom_default(index, lastIndex), value = array2[rand];
    array2[rand] = array2[index];
    array2[index] = value;
  }
  array2.length = size;
  return array2;
}
var shuffleSelf_default = shuffleSelf;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array2) {
  return shuffleSelf_default(copyArray_default(array2));
}
var arrayShuffle_default = arrayShuffle;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default(collection));
}
var baseShuffle_default = baseShuffle;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/shuffle.js
function shuffle(collection) {
  var func2 = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func2(collection);
}
var shuffle_default = shuffle;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/sumBy.js
function sumBy(array2, iteratee) {
  return array2 && array2.length ? baseSum_default(array2, baseIteratee_default(iteratee, 2)) : 0;
}
var sumBy_default = sumBy;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_createSet.js
var INFINITY4 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values2) {
  return new Set_default(values2);
};
var createSet_default = createSet;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE2 = 200;
function baseUniq(array2, iteratee, comparator) {
  var index = -1, includes = arrayIncludes_default, length = array2.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE2) {
    var set4 = iteratee ? null : createSet_default(array2);
    if (set4) {
      return setToArray_default(set4);
    }
    isCommon = false;
    includes = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index < length) {
      var value = array2[index], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var baseUniq_default = baseUniq;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/uniq.js
function uniq(array2) {
  return array2 && array2.length ? baseUniq_default(array2) : [];
}
var uniq_default = uniq;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/uniqWith.js
function uniqWith(array2, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array2 && array2.length ? baseUniq_default(array2, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/unzip.js
var nativeMax4 = Math.max;
function unzip(array2) {
  if (!(array2 && array2.length)) {
    return [];
  }
  var length = 0;
  array2 = arrayFilter_default(array2, function(group) {
    if (isArrayLikeObject_default(group)) {
      length = nativeMax4(group.length, length);
      return true;
    }
  });
  return baseTimes_default(length, function(index) {
    return arrayMap_default(array2, baseProperty_default(index));
  });
}
var unzip_default = unzip;

// ../../node_modules/.pnpm/lodash-es@4.17.23/node_modules/lodash-es/zip.js
var zip = baseRest_default(unzip_default);
var zip_default = zip;

// ../common/src/util/Notifier.ts
var Notifier = class {
  constructor() {
    __publicField(this, "listeners", []);
    /**
     * Notify all listeners that something has changed
     */
    __publicField(this, "notifyListeners", (...args2) => {
      this.listeners.slice().forEach((listener) => listener(...args2));
    });
    this.registerListener = this.registerListener.bind(this);
  }
  /**
   * Register to be notified when {@link notifyListeners} is called
   * @param listener A function to be called when {@link notifyListeners} is called
   * @returns A function that can be called to unsubscribe from notifications
   */
  registerListener(listener) {
    this.listeners.push(listener);
    return {
      dispose: () => {
        pull_default(this.listeners, listener);
      }
    };
  }
};

// ../common/src/ide/types/Configuration.ts
var CONFIGURATION_DEFAULTS = {
  tokenHatSplittingMode: {
    preserveCase: false,
    lettersToPreserve: [],
    symbolsToPreserve: []
  },
  wordSeparators: ["_"],
  decorationDebounceDelayMs: 50,
  experimental: {
    hatStability: "balanced" /* balanced */,
    keyboardTargetFollowsSelection: false
  },
  commandHistory: false,
  debug: false
};

// ../common/src/ide/types/KeyValueStore.ts
var KEY_VALUE_STORE_DEFAULTS = {
  hideInferenceWarning: false,
  tutorialProgress: {}
};

// ../common/src/types/Position.ts
var Position = class _Position {
  /**
   * @param line A zero-based line value.
   * @param character A zero-based character value.
   */
  constructor(line, character) {
    /**
     * The zero-based line value.
     */
    __publicField(this, "line");
    /**
     * The zero-based character value.
     */
    __publicField(this, "character");
    this.line = line;
    this.character = character;
  }
  /**
   * Create a position from a concise string representation.
   * The string should be in the format `line:character`, where both line and character
   * are zero-based.
   *
   * @param concise A concise string representation of a position.
   * @return A position with the given line and character values.
   */
  static fromConcise(concise) {
    const parts2 = concise.split(":");
    if (parts2.length !== 2) {
      throw new Error(
        `Invalid concise position format: "${concise}". Expected "line:character" format.`
      );
    }
    const line = stringToInteger(parts2[0]);
    const character = stringToInteger(parts2[1]);
    if (line == null || character == null || line < 0 || character < 0) {
      throw new Error(
        `Invalid concise position format: "${concise}". Line and character should be non-negative integers.`
      );
    }
    return new _Position(line, character);
  }
  /**
   * Check if this position is equal to `other`.
   *
   * @param other A position.
   * @return `true` if the line and character of the given position are equal to
   * the line and character of this position.
   */
  isEqual(other) {
    return this.line === other.line && this.character === other.character;
  }
  /**
   * Check if this position is before `other`.
   *
   * @param other A position.
   * @return `true` if position is on a smaller line
   * or on the same line on a smaller character.
   */
  isBefore(other) {
    if (this.line < other.line) {
      return true;
    }
    if (this.line > other.line) {
      return false;
    }
    return this.character < other.character;
  }
  /**
   * Check if this position is after `other`.
   *
   * @param other A position.
   * @return `true` if position is on a greater line
   * or on the same line on a greater character.
   */
  isAfter(other) {
    if (this.line > other.line) {
      return true;
    }
    if (this.line < other.line) {
      return false;
    }
    return this.character > other.character;
  }
  /**
   * Check if this position is before or equal to `other`.
   *
   * @param other A position.
   * @return `true` if position is on a smaller line
   * or on the same line on a smaller or equal character.
   */
  isBeforeOrEqual(other) {
    return this.isEqual(other) || this.isBefore(other);
  }
  /**
   * Check if this position is after or equal to `other`.
   *
   * @param other A position.
   * @return `true` if position is on a greater line
   * or on the same line on a greater or equal character.
   */
  isAfterOrEqual(other) {
    return this.isEqual(other) || this.isAfter(other);
  }
  /**
   * Compare this to `other`.
   *
   * @param other A position.
   * @return A number smaller than zero if this position is before the given position,
   * a number greater than zero if this position is after the given position, or zero when
   * this and the given position are equal.
   */
  compareTo(other) {
    if (this.isBefore(other)) {
      return -1;
    }
    if (this.isAfter(other)) {
      return 1;
    }
    return 0;
  }
  /**
   * Create a new position derived from this position.
   *
   * @param line Value that should be used as line value, default is the {@link Position.line existing value}
   * @param character Value that should be used as character value, default is the {@link Position.character existing value}
   * @return A position where line and character are replaced by the given values.
   */
  with(line, character) {
    return new _Position(line ?? this.line, character ?? this.character);
  }
  /**
   * Create a new position relative to this position.
   *
   * @param lineDelta Delta value for the line value, default is `0`.
   * @param characterDelta Delta value for the character value, default is `0`.
   * @return A position which line and character is the sum of the current line and
   * character and the corresponding deltas.
   */
  translate(lineDelta, characterDelta) {
    return new _Position(
      this.line + (lineDelta ?? 0),
      this.character + (characterDelta ?? 0)
    );
  }
  /**
   * Create a new empty range from this position.
   * @returns A {@link Range}
   */
  toEmptyRange() {
    return new Range(this, this);
  }
  /**
   * Return a concise string representation of the position. 0-based.
   * @returns concise representation
   **/
  concise() {
    return `${this.line}:${this.character}`;
  }
  /**
   * Return a concise string representation of the position. 1-based.
   * @returns concise representation
   **/
  conciseOneBased() {
    return `${this.line + 1}:${this.character + 1}`;
  }
  toString() {
    return this.concise();
  }
};
function adjustPosition(doc, pos, by) {
  return doc.positionAt(doc.offsetAt(pos) + by);
}

// ../common/src/types/Range.ts
var Range = class _Range {
  constructor(...args2) {
    /**
     * The start position. It is before or equal to {@link Range.end end}.
     */
    __publicField(this, "start");
    /**
     * The end position. It is after or equal to {@link Range.start start}.
     */
    __publicField(this, "end");
    const [p1, p2] = (() => {
      if (args2.length === 2) {
        return args2;
      }
      return [new Position(args2[0], args2[1]), new Position(args2[2], args2[3])];
    })();
    if (p1.isBefore(p2)) {
      this.start = p1;
      this.end = p2;
    } else {
      this.start = p2;
      this.end = p1;
    }
  }
  /**
   * Create a new range from a concise string representation.
   * The string should be in the format `start-end`, where both start and end
   * are in the format `line:character`, where both line and character are zero-based.
   *
   * @param concise A concise string representation of a range.
   * @return A range with the given start and end positions.
   */
  static fromConcise(concise) {
    const parts2 = concise.split("-");
    if (parts2.length !== 2) {
      throw new Error(
        `Invalid concise range format: "${concise}". Expected "start-end" format.`
      );
    }
    const [start2, end] = parts2.map((s) => Position.fromConcise(s));
    return new _Range(start2, end);
  }
  /**
   * `true` if `start` and `end` are equal.
   */
  get isEmpty() {
    return this.start.isEqual(this.end);
  }
  /**
   * `true` if `start.line` and `end.line` are equal.
   */
  get isSingleLine() {
    return this.start.line === this.end.line;
  }
  /**
   * Check if `other` equals this range.
   *
   * @param other A range.
   * @return `true` when start and end are {@link Position.isEqual equal} to
   * start and end of this range.
   */
  isRangeEqual(other) {
    return this.start.isEqual(other.start) && this.end.isEqual(other.end);
  }
  /**
   * Check if a position or a range is contained in this range.
   *
   * @param positionOrRange A position or a range.
   * @return `true` if the position or range is inside or equal
   * to this range.
   */
  contains(positionOrRange) {
    const [start2, end] = positionOrRange instanceof Position ? [positionOrRange, positionOrRange] : [positionOrRange.start, positionOrRange.end];
    return start2.isAfterOrEqual(this.start) && end.isBeforeOrEqual(this.end);
  }
  /**
   * Intersect `range` with this range and returns a new range.
   * If the ranges are adjacent but non-overlapping, the resulting range is empty.
   * If the ranges have no overlap and are not adjacent, it returns `undefined`.
   *
   * @param other A range.
   * @return A range of the greater start and smaller end positions. Will
   * return undefined when there is no overlap.
   */
  intersection(other) {
    const start2 = this.start.isAfter(other.start) ? this.start : other.start;
    const end = this.end.isBefore(other.end) ? this.end : other.end;
    return start2.isBeforeOrEqual(end) ? new _Range(start2, end) : void 0;
  }
  /**
   * Compute the union of `other` with this range.
   *
   * @param other A range.
   * @return A range of smaller start position and the greater end position.
   */
  union(other) {
    return new _Range(
      this.start.isBefore(other.start) ? this.start : other.start,
      this.end.isAfter(other.end) ? this.end : other.end
    );
  }
  /**
   * Derive a new range from this range.
   * If the resulting range has end before start, they are swapped.
   *
   * @param start A position that should be used as start. The default value is the {@link Range.start current start}.
   * @param end A position that should be used as end. The default value is the {@link Range.end current end}.
   * @return A range derived from this range with the given start and end position.
   */
  with(start2, end) {
    return new _Range(start2 ?? this.start, end ?? this.end);
  }
  /**
   * Construct a new selection from this range
   * @param isReversed If true active is before anchor
   * @returns A new selection
   */
  toSelection(isReversed) {
    return isReversed ? new Selection(this.end, this.start) : new Selection(this.start, this.end);
  }
  /**
   * Return a concise string representation of the range. 0-based.
   * @returns concise representation
   **/
  concise() {
    return `${this.start.concise()}-${this.end.concise()}`;
  }
  /**
   * Return a concise string representation of the range. 1-based.
   * @returns concise representation
   **/
  conciseOneBased() {
    return `${this.start.conciseOneBased()}-${this.end.conciseOneBased()}`;
  }
  toString() {
    return `${this.start.concise()}-${this.end.concise()}`;
  }
};

// ../common/src/util/regex.ts
function _rightAnchored(regex) {
  const { source, flags: flags2 } = regex;
  return new RegExp(`(${source})$`, flags2.replace("m", ""));
}
function _leftAnchored(regex) {
  const { source, flags: flags2 } = regex;
  return new RegExp(`^(${source})`, flags2.replace("m", ""));
}
function makeCache(func2) {
  const cache = /* @__PURE__ */ new Map();
  function wrapper(arg) {
    let cachedValue = cache.get(arg);
    if (cachedValue == null) {
      cachedValue = func2(arg);
      cache.set(arg, cachedValue);
    }
    return cachedValue;
  }
  return wrapper;
}
var rightAnchored = makeCache(_rightAnchored);
var leftAnchored = makeCache(_leftAnchored);
function matchAllIterator(text, regex) {
  regex.lastIndex = 0;
  return text.matchAll(regex);
}
function matchAll(text, regex, mapfn) {
  return Array.from(matchAllIterator(text, regex), mapfn);
}
function testRegex(regex, text) {
  regex.lastIndex = 0;
  return regex.test(text);
}
function matchRegex(regex, text) {
  regex.lastIndex = 0;
  return text.match(regex);
}
function matchText(text, regex) {
  return matchAll(text, regex, (match) => ({
    index: match.index,
    text: match[0]
  }));
}
function getLeadingWhitespace(text) {
  return text.match(/^\s+/)?.[0] ?? "";
}
function getTrailingWhitespace(text) {
  return text.match(/\s+$/)?.[0] ?? "";
}

// ../common/src/ide/inMemoryTextDocument/InMemoryTextLine.ts
var InMemoryTextLine = class {
  constructor(lineNumber, offset, text, eol) {
    this.lineNumber = lineNumber;
    this.offset = offset;
    this.text = text;
    __publicField(this, "isEmptyOrWhitespace");
    __publicField(this, "range");
    __publicField(this, "rangeIncludingLineBreak");
    __publicField(this, "rangeTrimmed");
    __publicField(this, "lengthIncludingEol");
    this.isEmptyOrWhitespace = /^\s*$/.test(text);
    this.lengthIncludingEol = text.length + (eol?.length ?? 0);
    const start2 = new Position(lineNumber, 0);
    const end = new Position(lineNumber, text.length);
    const endIncludingLineBreak = eol != null ? new Position(lineNumber + 1, 0) : end;
    this.range = new Range(start2, end);
    this.rangeIncludingLineBreak = new Range(start2, endIncludingLineBreak);
    this.rangeTrimmed = this.isEmptyOrWhitespace ? void 0 : new Range(
      start2.translate(void 0, getLeadingWhitespace(text).length),
      end.translate(void 0, -getTrailingWhitespace(text).length)
    );
  }
};

// ../common/src/ide/inMemoryTextDocument/performEdits.ts
function performEdits(document2, edits) {
  const changes = createChangeEvents(document2, edits);
  let result = document2.getText();
  for (const change of changes) {
    const { text, rangeOffset, rangeLength } = change;
    result = result.slice(0, rangeOffset) + text + result.slice(rangeOffset + rangeLength);
  }
  return { text: result, changes };
}
function createChangeEvents(document2, edits) {
  const changes = [];
  const sortedEdits = edits.map((edit, index) => ({ edit, index })).sort((a, b) => {
    if (a.edit.range.start.isEqual(b.edit.range.start)) {
      return b.index - a.index;
    }
    return b.edit.range.start.compareTo(a.edit.range.start);
  }).map(({ edit }) => edit);
  const eol = document2.eol === "LF" ? "\n" : "\r\n";
  for (const edit of sortedEdits) {
    const previousChange = changes[changes.length - 1];
    const intersection2 = previousChange?.range.intersection(edit.range);
    if (intersection2 != null && !intersection2.isEmpty) {
      if (!previousChange.text && !edit.text) {
        changes[changes.length - 1] = createChangeEvent(
          document2,
          previousChange.range.union(edit.range),
          ""
        );
        continue;
      }
      throw Error("Overlapping ranges are not allowed!");
    }
    const text = edit.text.replace(/\r?\n/g, eol);
    changes.push(createChangeEvent(document2, edit.range, text));
  }
  return changes;
}
function createChangeEvent(document2, range3, text) {
  const start2 = document2.offsetAt(range3.start);
  const end = document2.offsetAt(range3.end);
  return {
    text,
    range: range3,
    rangeOffset: start2,
    rangeLength: end - start2
  };
}

// ../common/src/ide/inMemoryTextDocument/InMemoryTextDocument.ts
var InMemoryTextDocument = class {
  constructor(uri, languageId, text) {
    this.uri = uri;
    this.languageId = languageId;
    __publicField(this, "_version");
    __publicField(this, "_eol");
    __publicField(this, "_text");
    __publicField(this, "_lines");
    __publicField(this, "filename");
    this.filename = uri.path.split(/\\|\//g).at(-1) ?? "";
    this._text = "";
    this._eol = "LF";
    this._version = -1;
    this._lines = [];
    this.setTextInternal(text);
  }
  get version() {
    return this._version;
  }
  get lineCount() {
    return this._lines.length;
  }
  get eol() {
    return this._eol;
  }
  get text() {
    return this._text;
  }
  get range() {
    return new Range(this._lines[0].range.start, this._lines.at(-1).range.end);
  }
  setTextInternal(text) {
    this._text = text;
    this._eol = text.includes("\r\n") ? "CRLF" : "LF";
    this._version++;
    this._lines = createLines(text);
  }
  lineAt(lineOrPosition) {
    const value = typeof lineOrPosition === "number" ? lineOrPosition : lineOrPosition.line;
    const index = clamp(value, 0, this.lineCount - 1);
    return this._lines[index];
  }
  offsetAt(position) {
    if (position.line < 0) {
      return 0;
    }
    if (position.line > this._lines.length - 1) {
      return this._text.length;
    }
    const line = this._lines[position.line];
    return line.offset + clamp(position.character, 0, line.text.length);
  }
  positionAt(offset) {
    if (offset <= 0) {
      return this.range.start;
    }
    if (offset >= this._text.length) {
      return this.range.end;
    }
    const line = this._lines.find(
      (line2) => offset < line2.offset + line2.lengthIncludingEol
    );
    if (line == null) {
      throw Error(`Couldn't find line for offset ${offset}`);
    }
    return new Position(
      line.lineNumber,
      Math.min(offset - line.offset, line.text.length)
    );
  }
  getText(range3) {
    if (range3 == null) {
      return this.text;
    }
    const startOffset = this.offsetAt(range3.start);
    const endOffset = this.offsetAt(range3.end);
    return this.text.slice(startOffset, endOffset);
  }
  edit(edits) {
    const { text, changes } = performEdits(this, edits);
    this.setTextInternal(text);
    return changes;
  }
};
function createLines(text) {
  const documentParts = text.split(/(\r?\n)/g);
  const result = [];
  let offset = 0;
  for (let i2 = 0; i2 < documentParts.length; i2 += 2) {
    const line = new InMemoryTextLine(
      result.length,
      offset,
      documentParts[i2],
      documentParts[i2 + 1]
    );
    result.push(line);
    offset += line.lengthIncludingEol;
  }
  return result;
}
function clamp(value, min2, max) {
  return Math.min(Math.max(value, min2), max);
}

// ../common/src/ide/util/messages.ts
function showWarning(messages, id2, message, ...options2) {
  return messages.showMessage("warning" /* warning */, id2, message, ...options2);
}
function showError(messages, id2, message, ...options2) {
  return messages.showMessage("error" /* error */, id2, message, ...options2);
}

// ../common/src/scopeSupportFacets/scopeSupportFacets.types.ts
var ScopeSupportFacetLevel = /* @__PURE__ */ ((ScopeSupportFacetLevel2) => {
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["supported"] = 0] = "supported";
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["unsupported"] = 1] = "unsupported";
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["notApplicable"] = 2] = "notApplicable";
  return ScopeSupportFacetLevel2;
})(ScopeSupportFacetLevel || {});

// ../common/src/scopeSupportFacets/c.ts
var { supported, unsupported, notApplicable } = ScopeSupportFacetLevel;
var cCoreScopeSupport = {
  list: supported,
  disqualifyDelimiter: supported,
  ifStatement: supported,
  "statement.class": supported,
  "statement.enum": supported,
  "statement.field.class": supported,
  "statement.function": supported,
  "statement.functionCall": supported,
  "statement.if": supported,
  "statement.switch": supported,
  "statement.for": supported,
  "statement.while": supported,
  "statement.doWhile": supported,
  "statement.assignment": supported,
  "statement.assignment.compound": supported,
  "statement.constant": supported,
  "statement.variable.uninitialized": supported,
  "statement.variable.initialized": supported,
  "statement.update": supported,
  "statement.return": supported,
  "statement.break": supported,
  "statement.continue": supported,
  "statement.namespace": supported,
  "statement.import": supported,
  "statement.iteration.document": supported,
  "statement.iteration.class": supported,
  "statement.iteration.block": supported,
  class: supported,
  "class.iteration.document": supported,
  "collectionItem.unenclosed.singleLine": supported,
  "collectionItem.unenclosed.multiLine": supported,
  "collectionItem.unenclosed.iteration": supported,
  namedFunction: supported,
  "namedFunction.iteration.document": supported,
  functionCall: supported,
  "functionCall.method": supported,
  "functionCall.chain": supported,
  functionCallee: supported,
  "functionCallee.method": supported,
  "functionCallee.chain": supported,
  "argument.actual.singleLine": supported,
  "argument.actual.multiLine": supported,
  "argument.actual.iteration": supported,
  "argument.actual.method.singleLine": supported,
  "argument.actual.method.multiLine": supported,
  "argument.actual.method.iteration": supported,
  "argument.formal.singleLine": supported,
  "argument.formal.multiLine": supported,
  "argument.formal.iteration": supported,
  "argumentList.actual.empty": supported,
  "argumentList.actual.singleLine": supported,
  "argumentList.actual.multiLine": supported,
  "argumentList.actual.method.empty": supported,
  "argumentList.actual.method.singleLine": supported,
  "argumentList.actual.method.multiLine": supported,
  "argumentList.formal.empty": supported,
  "argumentList.formal.singleLine": supported,
  "argumentList.formal.multiLine": supported,
  "branch.if": supported,
  "branch.if.elif.else": supported,
  "branch.if.else": supported,
  "branch.if.iteration": supported,
  "branch.switchCase": supported,
  "branch.switchCase.iteration": supported,
  "branch.ternary": supported,
  "branch.ternary.iteration": supported,
  "comment.line": supported,
  "comment.block": supported,
  "string.singleLine": supported,
  "textFragment.comment.line": supported,
  "textFragment.comment.block": supported,
  "textFragment.string.singleLine": supported,
  "condition.if": supported,
  "condition.while": supported,
  "condition.doWhile": supported,
  "condition.for": supported,
  "condition.ternary": supported,
  "condition.switchCase": supported,
  "condition.switchCase.iteration": supported,
  "name.assignment": supported,
  "name.assignment.compound": supported,
  "name.constant": supported,
  "name.variable.uninitialized": supported,
  "name.variable.initialized": supported,
  "name.function": supported,
  "name.class": supported,
  "name.enum": supported,
  "name.field.class": supported,
  "name.field.enum": supported,
  "name.argument.formal": supported,
  "name.argument.formal.iteration": supported,
  "name.iteration.block": supported,
  "name.iteration.document": supported,
  "name.iteration.class": supported,
  "name.iteration.enum": supported,
  "value.assignment": supported,
  "value.assignment.compound": supported,
  "value.constant": supported,
  "value.variable": supported,
  "value.return": supported,
  "value.switch": supported,
  "value.field.enum": supported,
  "value.iteration.block": supported,
  "value.iteration.class": supported,
  "value.iteration.enum": supported,
  "value.iteration.document": supported,
  "type.constant": supported,
  "type.variable.uninitialized": supported,
  "type.variable.initialized": supported,
  "type.argument.formal": supported,
  "type.argument.formal.iteration": supported,
  "type.field.class": supported,
  "type.enum": supported,
  "type.cast": supported,
  "type.class": supported,
  "type.return": supported,
  "type.iteration.block": supported,
  "type.iteration.class": supported,
  "type.iteration.document": supported,
  "interior.class": supported,
  "interior.enum": supported,
  "interior.function": supported,
  "interior.if": supported,
  "interior.switch": supported,
  "interior.switchCase": supported,
  "interior.for": supported,
  "interior.while": supported,
  "interior.doWhile": supported,
  /* UNSUPPORTED  */
  fieldAccess: unsupported,
  /* NOT APPLICABLE (C and C++) */
  // Element and tags
  element: notApplicable,
  tags: notApplicable,
  startTag: notApplicable,
  endTag: notApplicable,
  "interior.element": notApplicable,
  "textFragment.element": notApplicable,
  // Resource syntax
  "statement.resource": notApplicable,
  "interior.resource": notApplicable,
  "type.resource": notApplicable,
  "name.resource": notApplicable,
  "value.resource": notApplicable,
  // Map literal
  map: notApplicable,
  "key.mapPair": notApplicable,
  "key.mapPair.iteration": notApplicable,
  "value.mapPair": notApplicable,
  "value.mapPair.iteration": notApplicable,
  // Keyword argument
  "name.argument.actual": notApplicable,
  "name.argument.actual.iteration": notApplicable,
  "value.argument.actual": notApplicable,
  "value.argument.actual.iteration": notApplicable,
  // Multiline string
  "string.multiLine": notApplicable,
  "textFragment.string.multiLine": notApplicable,
  // Section
  section: notApplicable,
  "section.iteration.document": notApplicable,
  "section.iteration.parent": notApplicable,
  // Pattern destructuring
  "statement.variable.destructuring": notApplicable,
  "statement.assignment.destructuring": notApplicable,
  "name.assignment.destructuring": notApplicable,
  "name.variable.destructuring": notApplicable,
  "value.variable.destructuring": notApplicable,
  "value.assignment.destructuring": notApplicable,
  // Command
  command: notApplicable,
  "statement.command": notApplicable,
  "name.command": notApplicable,
  "value.command": notApplicable,
  "interior.command": notApplicable,
  // Type alias
  "type.alias": notApplicable,
  "statement.typeAlias": notApplicable,
  "name.typeAlias": notApplicable,
  "value.typeAlias": notApplicable,
  // Notebook cell
  notebookCell: notApplicable,
  "interior.cell": notApplicable,
  // Nested class
  "class.iteration.block": notApplicable,
  // Interface
  "statement.interface": notApplicable,
  "statement.field.interface": notApplicable,
  "statement.iteration.interface": notApplicable,
  "name.interface": notApplicable,
  "name.field.interface": notApplicable,
  "name.iteration.interface": notApplicable,
  "type.interface": notApplicable,
  "type.field.interface": notApplicable,
  "type.iteration.interface": notApplicable,
  "interior.interface": notApplicable,
  "value.field.interface": notApplicable,
  // Static
  "statement.static": notApplicable,
  "interior.static": notApplicable,
  // Yield
  "statement.yield": notApplicable,
  "value.yield": notApplicable,
  // Throw statement
  "statement.throw": notApplicable,
  "value.throw": notApplicable,
  // Enum calls
  "functionCall.enum": notApplicable,
  "functionCallee.enum": notApplicable,
  // Miscellaneous
  "key.attribute": notApplicable,
  "value.attribute": notApplicable,
  "value.field.class": notApplicable,
  "branch.loop": notApplicable,
  "branch.loop.iteration": notApplicable,
  "statement.misc": notApplicable,
  environment: notApplicable,
  pairDelimiter: notApplicable,
  regularExpression: notApplicable,
  selector: notApplicable,
  unit: notApplicable
};
var cScopeSupport = {
  ...cCoreScopeSupport,
  // Not applicable for C, but supported for C++
  // These are defined here because we don't want C++ to import them and
  // accidentally forget to add support for them.
  attribute: notApplicable,
  // Lambda
  "argument.formal.lambda.iteration": notApplicable,
  "argument.formal.lambda.singleLine": notApplicable,
  "argument.formal.lambda.multiLine": notApplicable,
  "argumentList.formal.lambda.empty": notApplicable,
  "argumentList.formal.lambda.multiLine": notApplicable,
  "argumentList.formal.lambda.singleLine": notApplicable,
  "name.argument.formal.lambda": notApplicable,
  "name.argument.formal.lambda.iteration": notApplicable,
  "type.argument.formal.lambda": notApplicable,
  "type.argument.formal.lambda.iteration": notApplicable,
  "interior.lambda": notApplicable,
  "value.return.lambda": notApplicable,
  anonymousFunction: notApplicable,
  // Constructor
  "argument.actual.constructor.iteration": notApplicable,
  "argument.actual.constructor.singleLine": notApplicable,
  "argument.actual.constructor.multiLine": notApplicable,
  "argument.formal.constructor.iteration": notApplicable,
  "argument.formal.constructor.singleLine": notApplicable,
  "argument.formal.constructor.multiLine": notApplicable,
  "argumentList.actual.constructor.empty": notApplicable,
  "argumentList.actual.constructor.multiLine": notApplicable,
  "argumentList.actual.constructor.singleLine": notApplicable,
  "argumentList.formal.constructor.empty": notApplicable,
  "argumentList.formal.constructor.multiLine": notApplicable,
  "argumentList.formal.constructor.singleLine": notApplicable,
  "functionCall.constructor": notApplicable,
  "functionCallee.constructor": notApplicable,
  "name.argument.formal.constructor.iteration": notApplicable,
  "name.argument.formal.constructor": notApplicable,
  "name.constructor": notApplicable,
  "namedFunction.constructor": notApplicable,
  "statement.constructor": notApplicable,
  "type.argument.formal.constructor.iteration": notApplicable,
  "type.argument.formal.constructor": notApplicable,
  "value.argument.formal.constructor.iteration": notApplicable,
  "value.argument.formal.constructor": notApplicable,
  "interior.constructor": notApplicable,
  // Method
  "namedFunction.method": notApplicable,
  "namedFunction.iteration.class": notApplicable,
  "statement.method": notApplicable,
  "argument.formal.method.iteration": notApplicable,
  "argument.formal.method.singleLine": notApplicable,
  "argument.formal.method.multiLine": notApplicable,
  "argumentList.formal.method.empty": notApplicable,
  "argumentList.formal.method.multiLine": notApplicable,
  "argumentList.formal.method.singleLine": notApplicable,
  "name.argument.formal.method.iteration": notApplicable,
  "name.argument.formal.method": notApplicable,
  "name.method": notApplicable,
  "type.argument.formal.method.iteration": notApplicable,
  "type.argument.formal.method": notApplicable,
  "value.argument.formal.method.iteration": notApplicable,
  "value.argument.formal.method": notApplicable,
  "interior.method": notApplicable,
  "type.return.method": notApplicable,
  // Try catch
  "statement.try": notApplicable,
  "branch.try": notApplicable,
  "branch.try.iteration": notApplicable,
  "interior.try": notApplicable,
  "argument.catch": notApplicable,
  "name.argument.catch": notApplicable,
  "type.argument.catch": notApplicable,
  // Foreach
  "statement.foreach": notApplicable,
  "name.foreach": notApplicable,
  "type.foreach": notApplicable,
  "value.foreach": notApplicable,
  "interior.foreach": notApplicable,
  // Default argument value
  "value.argument.formal": notApplicable,
  "value.argument.formal.iteration": notApplicable,
  // Generic type
  "type.typeArgument": notApplicable,
  "type.typeArgument.iteration": notApplicable,
  // Namespace
  "statement.namespace": notApplicable,
  "name.namespace": notApplicable,
  "interior.namespace": notApplicable,
  // Exceptions
  // Package/import
  "statement.package": notApplicable,
  // Generic calls
  "functionCall.generic": notApplicable,
  "functionCallee.generic": notApplicable
};

// ../common/src/scopeSupportFacets/clojure.ts
var { supported: supported2, unsupported: unsupported2, notApplicable: notApplicable2 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/cpp.ts
var { supported: supported3, notApplicable: notApplicable3 } = ScopeSupportFacetLevel;
var cppScopeSupport = {
  ...cCoreScopeSupport,
  attribute: supported3,
  anonymousFunction: supported3,
  "statement.try": supported3,
  "statement.foreach": supported3,
  "statement.constructor": supported3,
  "statement.method": supported3,
  "statement.throw": supported3,
  "branch.try": supported3,
  "branch.try.iteration": supported3,
  "argument.actual.constructor.singleLine": supported3,
  "argument.actual.constructor.multiLine": supported3,
  "argument.actual.constructor.iteration": supported3,
  "argument.formal.method.singleLine": supported3,
  "argument.formal.method.multiLine": supported3,
  "argument.formal.method.iteration": supported3,
  "argument.formal.constructor.singleLine": supported3,
  "argument.formal.constructor.multiLine": supported3,
  "argument.formal.constructor.iteration": supported3,
  "argument.formal.lambda.singleLine": supported3,
  "argument.formal.lambda.multiLine": supported3,
  "argument.formal.lambda.iteration": supported3,
  "name.argument.formal.lambda": supported3,
  "name.argument.formal.lambda.iteration": supported3,
  "type.argument.formal.lambda": supported3,
  "type.argument.formal.lambda.iteration": supported3,
  "argument.catch": supported3,
  "argumentList.actual.constructor.empty": supported3,
  "argumentList.actual.constructor.singleLine": supported3,
  "argumentList.actual.constructor.multiLine": supported3,
  "argumentList.formal.constructor.empty": supported3,
  "argumentList.formal.constructor.singleLine": supported3,
  "argumentList.formal.constructor.multiLine": supported3,
  "argumentList.formal.lambda.empty": supported3,
  "argumentList.formal.lambda.singleLine": supported3,
  "argumentList.formal.lambda.multiLine": supported3,
  "argumentList.formal.method.empty": supported3,
  "argumentList.formal.method.singleLine": supported3,
  "argumentList.formal.method.multiLine": supported3,
  "functionCall.constructor": supported3,
  "functionCall.generic": supported3,
  "functionCallee.constructor": supported3,
  "functionCallee.generic": supported3,
  "namedFunction.method": supported3,
  "namedFunction.iteration.class": supported3,
  "namedFunction.constructor": supported3,
  "name.argument.formal.method": supported3,
  "name.argument.formal.method.iteration": supported3,
  "name.argument.formal.constructor": supported3,
  "name.argument.formal.constructor.iteration": supported3,
  "name.argument.catch": supported3,
  "name.constructor": supported3,
  "name.foreach": supported3,
  "name.method": supported3,
  "name.namespace": supported3,
  "name.iteration.class": supported3,
  "value.argument.formal": supported3,
  "value.argument.formal.iteration": supported3,
  "value.argument.formal.method": supported3,
  "value.argument.formal.method.iteration": supported3,
  "value.argument.formal.constructor": supported3,
  "value.argument.formal.constructor.iteration": supported3,
  "value.foreach": supported3,
  "value.field.class": supported3,
  "value.throw": supported3,
  "type.argument.formal.method": supported3,
  "type.argument.formal.method.iteration": supported3,
  "type.argument.formal.constructor": supported3,
  "type.argument.formal.constructor.iteration": supported3,
  "type.argument.catch": supported3,
  "type.foreach": supported3,
  "type.typeArgument": supported3,
  "type.typeArgument.iteration": supported3,
  "type.return.method": supported3,
  "interior.lambda": supported3,
  "interior.try": supported3,
  "interior.foreach": supported3,
  "interior.constructor": supported3,
  "interior.method": supported3,
  "interior.namespace": supported3,
  /* NOT APPLICABLE */
  "value.return.lambda": notApplicable3,
  "statement.package": notApplicable3
};

// ../common/src/scopeSupportFacets/csharp.ts
var { supported: supported4, unsupported: unsupported3, notApplicable: notApplicable4 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/css.ts
var { supported: supported5, notApplicable: notApplicable5 } = ScopeSupportFacetLevel;
var cssScopeSupport = {
  "comment.block": supported5,
  "string.singleLine": supported5,
  disqualifyDelimiter: supported5,
  map: supported5,
  functionCall: supported5,
  functionCallee: supported5,
  "argument.actual.singleLine": supported5,
  "argument.actual.multiLine": supported5,
  "argument.actual.iteration": supported5,
  "argumentList.actual.empty": supported5,
  "argumentList.actual.singleLine": supported5,
  "argumentList.actual.multiLine": supported5,
  "name.iteration.document": supported5,
  "name.iteration.block": supported5,
  "textFragment.comment.block": supported5,
  "textFragment.string.singleLine": supported5,
  "key.mapPair": supported5,
  "key.mapPair.iteration": supported5,
  "value.mapPair": supported5,
  "value.mapPair.iteration": supported5,
  "collectionItem.unenclosed.multiLine": supported5,
  "collectionItem.unenclosed.iteration": supported5,
  "statement.misc": supported5,
  "statement.iteration.document": supported5,
  selector: supported5,
  unit: supported5,
  /* NOT APPLICABLE */
  // Multiline unenclosed item
  "collectionItem.unenclosed.singleLine": notApplicable5,
  // Assignment
  "statement.assignment": notApplicable5,
  "statement.assignment.compound": notApplicable5,
  "statement.assignment.destructuring": notApplicable5,
  "name.assignment": notApplicable5,
  "name.assignment.compound": notApplicable5,
  "name.assignment.destructuring": notApplicable5,
  "value.assignment": notApplicable5,
  "value.assignment.compound": notApplicable5,
  "value.assignment.destructuring": notApplicable5,
  "statement.update": notApplicable5,
  // Variable
  "statement.variable.uninitialized": notApplicable5,
  "statement.variable.initialized": notApplicable5,
  "statement.variable.destructuring": notApplicable5,
  "name.variable.uninitialized": notApplicable5,
  "name.variable.initialized": notApplicable5,
  "name.variable.destructuring": notApplicable5,
  "type.variable.uninitialized": notApplicable5,
  "type.variable.initialized": notApplicable5,
  "value.variable": notApplicable5,
  "value.variable.destructuring": notApplicable5,
  // Constant
  "statement.constant": notApplicable5,
  "name.constant": notApplicable5,
  "value.constant": notApplicable5,
  "type.constant": notApplicable5,
  // Class
  class: notApplicable5,
  "class.iteration.block": notApplicable5,
  "class.iteration.document": notApplicable5,
  "name.class": notApplicable5,
  "name.field.class": notApplicable5,
  "name.iteration.class": notApplicable5,
  "statement.class": notApplicable5,
  "statement.field.class": notApplicable5,
  "statement.iteration.class": notApplicable5,
  "type.class": notApplicable5,
  "type.field.class": notApplicable5,
  "type.iteration.class": notApplicable5,
  "value.field.class": notApplicable5,
  "value.iteration.class": notApplicable5,
  "interior.class": notApplicable5,
  // Constructor
  "statement.constructor": notApplicable5,
  "namedFunction.constructor": notApplicable5,
  "argument.actual.constructor.singleLine": notApplicable5,
  "argument.actual.constructor.multiLine": notApplicable5,
  "argument.actual.constructor.iteration": notApplicable5,
  "argument.formal.constructor.singleLine": notApplicable5,
  "argument.formal.constructor.multiLine": notApplicable5,
  "argument.formal.constructor.iteration": notApplicable5,
  "argumentList.actual.constructor.empty": notApplicable5,
  "argumentList.actual.constructor.singleLine": notApplicable5,
  "argumentList.actual.constructor.multiLine": notApplicable5,
  "argumentList.formal.constructor.empty": notApplicable5,
  "argumentList.formal.constructor.singleLine": notApplicable5,
  "argumentList.formal.constructor.multiLine": notApplicable5,
  "interior.constructor": notApplicable5,
  "name.argument.formal.constructor": notApplicable5,
  "name.argument.formal.constructor.iteration": notApplicable5,
  "name.constructor": notApplicable5,
  "type.argument.formal.constructor": notApplicable5,
  "type.argument.formal.constructor.iteration": notApplicable5,
  "value.argument.formal.constructor": notApplicable5,
  "value.argument.formal.constructor.iteration": notApplicable5,
  "functionCall.constructor": notApplicable5,
  "functionCallee.constructor": notApplicable5,
  // Method
  "statement.method": notApplicable5,
  "namedFunction.method": notApplicable5,
  "argument.actual.method.singleLine": notApplicable5,
  "argument.actual.method.multiLine": notApplicable5,
  "argument.actual.method.iteration": notApplicable5,
  "argument.formal.method.singleLine": notApplicable5,
  "argument.formal.method.multiLine": notApplicable5,
  "argument.formal.method.iteration": notApplicable5,
  "argumentList.actual.method.empty": notApplicable5,
  "argumentList.actual.method.singleLine": notApplicable5,
  "argumentList.actual.method.multiLine": notApplicable5,
  "argumentList.formal.method.empty": notApplicable5,
  "argumentList.formal.method.singleLine": notApplicable5,
  "argumentList.formal.method.multiLine": notApplicable5,
  "interior.method": notApplicable5,
  "name.argument.formal.method": notApplicable5,
  "name.argument.formal.method.iteration": notApplicable5,
  "name.method": notApplicable5,
  "type.argument.formal.method": notApplicable5,
  "type.argument.formal.method.iteration": notApplicable5,
  "type.return.method": notApplicable5,
  "value.argument.formal.method": notApplicable5,
  "value.argument.formal.method.iteration": notApplicable5,
  "functionCall.method": notApplicable5,
  "functionCallee.method": notApplicable5,
  // Function
  namedFunction: notApplicable5,
  "namedFunction.iteration.document": notApplicable5,
  "namedFunction.iteration.class": notApplicable5,
  "statement.function": notApplicable5,
  "name.function": notApplicable5,
  "interior.function": notApplicable5,
  "argumentList.formal.empty": notApplicable5,
  "argumentList.formal.singleLine": notApplicable5,
  "argumentList.formal.multiLine": notApplicable5,
  "argument.formal.singleLine": notApplicable5,
  "argument.formal.multiLine": notApplicable5,
  "argument.formal.iteration": notApplicable5,
  "name.argument.formal": notApplicable5,
  "name.argument.formal.iteration": notApplicable5,
  "type.argument.formal": notApplicable5,
  "type.argument.formal.iteration": notApplicable5,
  "value.argument.formal": notApplicable5,
  "value.argument.formal.iteration": notApplicable5,
  // Anonymous function / lambda
  anonymousFunction: notApplicable5,
  "argumentList.formal.lambda.empty": notApplicable5,
  "argumentList.formal.lambda.singleLine": notApplicable5,
  "argumentList.formal.lambda.multiLine": notApplicable5,
  "argument.formal.lambda.singleLine": notApplicable5,
  "argument.formal.lambda.multiLine": notApplicable5,
  "argument.formal.lambda.iteration": notApplicable5,
  "name.argument.formal.lambda": notApplicable5,
  "name.argument.formal.lambda.iteration": notApplicable5,
  "type.argument.formal.lambda": notApplicable5,
  "type.argument.formal.lambda.iteration": notApplicable5,
  "value.return.lambda": notApplicable5,
  "interior.lambda": notApplicable5,
  // Function call chain
  "functionCall.chain": notApplicable5,
  "functionCallee.chain": notApplicable5,
  // Generic function calls
  "functionCall.generic": notApplicable5,
  "statement.functionCall": notApplicable5,
  "functionCallee.generic": notApplicable5,
  // Keyword argument
  "name.argument.actual": notApplicable5,
  "name.argument.actual.iteration": notApplicable5,
  "value.argument.actual": notApplicable5,
  "value.argument.actual.iteration": notApplicable5,
  // Return statement
  "statement.return": notApplicable5,
  "type.return": notApplicable5,
  "value.return": notApplicable5,
  // Yield statement
  "statement.yield": notApplicable5,
  "value.yield": notApplicable5,
  // Throw statement
  "statement.throw": notApplicable5,
  "value.throw": notApplicable5,
  // Interface
  "statement.interface": notApplicable5,
  "statement.field.interface": notApplicable5,
  "statement.iteration.interface": notApplicable5,
  "interior.interface": notApplicable5,
  "name.interface": notApplicable5,
  "name.field.interface": notApplicable5,
  "name.iteration.interface": notApplicable5,
  "type.interface": notApplicable5,
  "type.field.interface": notApplicable5,
  "value.field.interface": notApplicable5,
  "type.iteration.interface": notApplicable5,
  // Enum
  "statement.enum": notApplicable5,
  "functionCallee.enum": notApplicable5,
  "functionCall.enum": notApplicable5,
  "name.enum": notApplicable5,
  "name.field.enum": notApplicable5,
  "name.iteration.enum": notApplicable5,
  "value.field.enum": notApplicable5,
  "value.iteration.enum": notApplicable5,
  "type.enum": notApplicable5,
  "interior.enum": notApplicable5,
  // Command
  command: notApplicable5,
  "statement.command": notApplicable5,
  "name.command": notApplicable5,
  "value.command": notApplicable5,
  "interior.command": notApplicable5,
  // Try catch
  "statement.try": notApplicable5,
  "branch.try": notApplicable5,
  "branch.try.iteration": notApplicable5,
  "interior.try": notApplicable5,
  "argument.catch": notApplicable5,
  "name.argument.catch": notApplicable5,
  "type.argument.catch": notApplicable5,
  // If statement
  ifStatement: notApplicable5,
  "statement.if": notApplicable5,
  "branch.if": notApplicable5,
  "branch.if.elif.else": notApplicable5,
  "branch.if.else": notApplicable5,
  "branch.if.iteration": notApplicable5,
  "condition.if": notApplicable5,
  "interior.if": notApplicable5,
  // Switch statement
  "statement.switch": notApplicable5,
  "branch.switchCase": notApplicable5,
  "branch.switchCase.iteration": notApplicable5,
  "condition.switchCase": notApplicable5,
  "condition.switchCase.iteration": notApplicable5,
  "interior.switch": notApplicable5,
  "interior.switchCase": notApplicable5,
  "value.switch": notApplicable5,
  // Loop
  "branch.loop": notApplicable5,
  "branch.loop.iteration": notApplicable5,
  // For loop
  "statement.for": notApplicable5,
  "condition.for": notApplicable5,
  "interior.for": notApplicable5,
  // For-each loop
  "statement.foreach": notApplicable5,
  "interior.foreach": notApplicable5,
  "name.foreach": notApplicable5,
  "type.foreach": notApplicable5,
  "value.foreach": notApplicable5,
  // While loop
  "statement.while": notApplicable5,
  "condition.while": notApplicable5,
  "interior.while": notApplicable5,
  // Do-while loop
  "statement.doWhile": notApplicable5,
  "condition.doWhile": notApplicable5,
  "interior.doWhile": notApplicable5,
  // Resource statement
  "statement.resource": notApplicable5,
  "interior.resource": notApplicable5,
  "name.resource": notApplicable5,
  "type.resource": notApplicable5,
  "value.resource": notApplicable5,
  // Multi-line string
  "string.multiLine": notApplicable5,
  "textFragment.string.multiLine": notApplicable5,
  // Line comment
  "comment.line": notApplicable5,
  "textFragment.comment.line": notApplicable5,
  // Static
  "statement.static": notApplicable5,
  "interior.static": notApplicable5,
  // Namespace
  "statement.namespace": notApplicable5,
  "interior.namespace": notApplicable5,
  "name.namespace": notApplicable5,
  // Ternary
  "branch.ternary": notApplicable5,
  "branch.ternary.iteration": notApplicable5,
  "condition.ternary": notApplicable5,
  // Section
  section: notApplicable5,
  "section.iteration.document": notApplicable5,
  "section.iteration.parent": notApplicable5,
  // Element
  element: notApplicable5,
  "interior.element": notApplicable5,
  "textFragment.element": notApplicable5,
  tags: notApplicable5,
  startTag: notApplicable5,
  endTag: notApplicable5,
  // Attribute
  attribute: notApplicable5,
  "key.attribute": notApplicable5,
  "value.attribute": notApplicable5,
  // Notebook cell
  notebookCell: notApplicable5,
  "interior.cell": notApplicable5,
  // Type alias
  "type.alias": notApplicable5,
  "statement.typeAlias": notApplicable5,
  "name.typeAlias": notApplicable5,
  "value.typeAlias": notApplicable5,
  // Miscellaneous statements
  "statement.break": notApplicable5,
  "statement.continue": notApplicable5,
  "statement.package": notApplicable5,
  "statement.import": notApplicable5,
  "statement.iteration.block": notApplicable5,
  // Miscellaneous
  environment: notApplicable5,
  fieldAccess: notApplicable5,
  pairDelimiter: notApplicable5,
  regularExpression: notApplicable5,
  "type.cast": notApplicable5,
  "type.typeArgument": notApplicable5,
  "type.typeArgument.iteration": notApplicable5,
  "type.iteration.block": notApplicable5,
  "type.iteration.document": notApplicable5,
  "value.iteration.block": notApplicable5,
  "value.iteration.document": notApplicable5,
  list: notApplicable5
};

// ../common/src/scopeSupportFacets/dart.ts
var { supported: supported6, unsupported: unsupported4, notApplicable: notApplicable6 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/go.ts
var { supported: supported7, unsupported: unsupported5, notApplicable: notApplicable7 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/html.ts
var { supported: supported8, notApplicable: notApplicable8 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/java.ts
var { supported: supported9, unsupported: unsupported6, notApplicable: notApplicable9 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/javascript.ts
var { supported: supported10, notApplicable: notApplicable10 } = ScopeSupportFacetLevel;
var javascriptCoreScopeSupport = {
  list: supported10,
  map: supported10,
  regularExpression: supported10,
  fieldAccess: supported10,
  disqualifyDelimiter: supported10,
  pairDelimiter: supported10,
  "collectionItem.unenclosed.singleLine": supported10,
  "collectionItem.unenclosed.multiLine": supported10,
  "collectionItem.unenclosed.iteration": supported10,
  "textFragment.string.singleLine": supported10,
  "textFragment.string.multiLine": supported10,
  "textFragment.comment.line": supported10,
  "textFragment.comment.block": supported10,
  ifStatement: supported10,
  "statement.class": supported10,
  "statement.field.class": supported10,
  "statement.function": supported10,
  "statement.constructor": supported10,
  "statement.method": supported10,
  "statement.functionCall": supported10,
  "statement.if": supported10,
  "statement.try": supported10,
  "statement.switch": supported10,
  "statement.for": supported10,
  "statement.foreach": supported10,
  "statement.while": supported10,
  "statement.doWhile": supported10,
  "statement.assignment": supported10,
  "statement.assignment.destructuring": supported10,
  "statement.assignment.compound": supported10,
  "statement.constant": supported10,
  "statement.variable.uninitialized": supported10,
  "statement.variable.initialized": supported10,
  "statement.variable.destructuring": supported10,
  "statement.update": supported10,
  "statement.return": supported10,
  "statement.yield": supported10,
  "statement.throw": supported10,
  "statement.break": supported10,
  "statement.continue": supported10,
  "statement.static": supported10,
  "statement.import": supported10,
  "statement.iteration.document": supported10,
  "statement.iteration.class": supported10,
  "statement.iteration.block": supported10,
  class: supported10,
  "class.iteration.document": supported10,
  anonymousFunction: supported10,
  namedFunction: supported10,
  "namedFunction.iteration.document": supported10,
  "namedFunction.method": supported10,
  "namedFunction.iteration.class": supported10,
  "namedFunction.constructor": supported10,
  functionCall: supported10,
  "functionCall.constructor": supported10,
  "functionCall.method": supported10,
  "functionCall.chain": supported10,
  functionCallee: supported10,
  "functionCallee.constructor": supported10,
  "functionCallee.method": supported10,
  "functionCallee.chain": supported10,
  "argument.actual.singleLine": supported10,
  "argument.actual.multiLine": supported10,
  "argument.actual.iteration": supported10,
  "argument.actual.method.singleLine": supported10,
  "argument.actual.method.multiLine": supported10,
  "argument.actual.method.iteration": supported10,
  "argument.actual.constructor.singleLine": supported10,
  "argument.actual.constructor.multiLine": supported10,
  "argument.actual.constructor.iteration": supported10,
  "argument.formal.singleLine": supported10,
  "argument.formal.multiLine": supported10,
  "argument.formal.iteration": supported10,
  "argument.formal.method.singleLine": supported10,
  "argument.formal.method.multiLine": supported10,
  "argument.formal.method.iteration": supported10,
  "argument.formal.constructor.singleLine": supported10,
  "argument.formal.constructor.multiLine": supported10,
  "argument.formal.constructor.iteration": supported10,
  "argument.formal.lambda.singleLine": supported10,
  "argument.formal.lambda.multiLine": supported10,
  "argument.formal.lambda.iteration": supported10,
  "argument.catch": supported10,
  "argumentList.actual.empty": supported10,
  "argumentList.actual.singleLine": supported10,
  "argumentList.actual.multiLine": supported10,
  "argumentList.actual.method.empty": supported10,
  "argumentList.actual.method.singleLine": supported10,
  "argumentList.actual.method.multiLine": supported10,
  "argumentList.actual.constructor.empty": supported10,
  "argumentList.actual.constructor.singleLine": supported10,
  "argumentList.actual.constructor.multiLine": supported10,
  "argumentList.formal.empty": supported10,
  "argumentList.formal.singleLine": supported10,
  "argumentList.formal.multiLine": supported10,
  "argumentList.formal.lambda.empty": supported10,
  "argumentList.formal.lambda.singleLine": supported10,
  "argumentList.formal.lambda.multiLine": supported10,
  "argumentList.formal.method.empty": supported10,
  "argumentList.formal.method.singleLine": supported10,
  "argumentList.formal.method.multiLine": supported10,
  "argumentList.formal.constructor.empty": supported10,
  "argumentList.formal.constructor.singleLine": supported10,
  "argumentList.formal.constructor.multiLine": supported10,
  "comment.line": supported10,
  "comment.block": supported10,
  "string.singleLine": supported10,
  "string.multiLine": supported10,
  "branch.if": supported10,
  "branch.if.elif.else": supported10,
  "branch.if.else": supported10,
  "branch.if.iteration": supported10,
  "branch.try": supported10,
  "branch.try.iteration": supported10,
  "branch.switchCase": supported10,
  "branch.switchCase.iteration": supported10,
  "branch.ternary": supported10,
  "branch.ternary.iteration": supported10,
  "condition.if": supported10,
  "condition.while": supported10,
  "condition.doWhile": supported10,
  "condition.for": supported10,
  "condition.ternary": supported10,
  "condition.switchCase": supported10,
  "condition.switchCase.iteration": supported10,
  "name.argument.formal": supported10,
  "name.argument.formal.iteration": supported10,
  "name.argument.formal.method": supported10,
  "name.argument.formal.method.iteration": supported10,
  "name.argument.formal.lambda": supported10,
  "name.argument.formal.lambda.iteration": supported10,
  "name.argument.formal.constructor": supported10,
  "name.argument.formal.constructor.iteration": supported10,
  "name.argument.catch": supported10,
  "name.foreach": supported10,
  "name.assignment": supported10,
  "name.assignment.destructuring": supported10,
  "name.assignment.compound": supported10,
  "name.constant": supported10,
  "name.variable.uninitialized": supported10,
  "name.variable.initialized": supported10,
  "name.variable.destructuring": supported10,
  "name.function": supported10,
  "name.method": supported10,
  "name.constructor": supported10,
  "name.class": supported10,
  "name.field.class": supported10,
  "name.iteration.document": supported10,
  "name.iteration.class": supported10,
  "name.iteration.block": supported10,
  "key.mapPair": supported10,
  "key.mapPair.iteration": supported10,
  "value.argument.formal": supported10,
  "value.argument.formal.iteration": supported10,
  "value.argument.formal.method": supported10,
  "value.argument.formal.method.iteration": supported10,
  "value.argument.formal.constructor": supported10,
  "value.argument.formal.constructor.iteration": supported10,
  "value.mapPair": supported10,
  "value.mapPair.iteration": supported10,
  "value.assignment": supported10,
  "value.assignment.destructuring": supported10,
  "value.assignment.compound": supported10,
  "value.constant": supported10,
  "value.variable": supported10,
  "value.variable.destructuring": supported10,
  "value.foreach": supported10,
  "value.return": supported10,
  "value.return.lambda": supported10,
  "value.field.class": supported10,
  "value.yield": supported10,
  "value.throw": supported10,
  "value.switch": supported10,
  "value.iteration.block": supported10,
  "value.iteration.class": supported10,
  "value.iteration.document": supported10,
  "interior.class": supported10,
  "interior.function": supported10,
  "interior.constructor": supported10,
  "interior.method": supported10,
  "interior.if": supported10,
  "interior.lambda": supported10,
  "interior.for": supported10,
  "interior.foreach": supported10,
  "interior.while": supported10,
  "interior.doWhile": supported10,
  "interior.switch": supported10,
  "interior.switchCase": supported10,
  "interior.try": supported10,
  "interior.static": supported10,
  /* NOT APPLICABLE (JS & TS) */
  // Nested classes
  "class.iteration.block": notApplicable10,
  // Section
  section: notApplicable10,
  "section.iteration.document": notApplicable10,
  "section.iteration.parent": notApplicable10,
  // Command
  command: notApplicable10,
  "statement.command": notApplicable10,
  "name.command": notApplicable10,
  "value.command": notApplicable10,
  "interior.command": notApplicable10,
  // Notebook cell
  notebookCell: notApplicable10,
  "interior.cell": notApplicable10,
  // Resource
  "statement.resource": notApplicable10,
  "interior.resource": notApplicable10,
  "name.resource": notApplicable10,
  "type.resource": notApplicable10,
  "value.resource": notApplicable10,
  // Keyword argument
  "name.argument.actual.iteration": notApplicable10,
  "name.argument.actual": notApplicable10,
  "value.argument.actual.iteration": notApplicable10,
  "value.argument.actual": notApplicable10,
  // Namespace
  "statement.namespace": notApplicable10,
  "name.namespace": notApplicable10,
  "interior.namespace": notApplicable10,
  // Branch loop
  "branch.loop": notApplicable10,
  "branch.loop.iteration": notApplicable10,
  // Miscellaneous
  "statement.misc": notApplicable10,
  environment: notApplicable10,
  selector: notApplicable10,
  unit: notApplicable10
};
var javascriptJsxScopeSupport = {
  element: supported10,
  tags: supported10,
  startTag: supported10,
  endTag: supported10,
  attribute: supported10,
  "key.attribute": supported10,
  "value.attribute": supported10,
  "interior.element": supported10,
  "textFragment.element": supported10
};
var javascriptScopeSupport = {
  ...javascriptCoreScopeSupport,
  ...javascriptJsxScopeSupport,
  // These are defined here because we don't want typescript to import them and
  // accidentally forget to add support for them.
  // Type
  "type.argument.formal": notApplicable10,
  "type.argument.formal.iteration": notApplicable10,
  "type.argument.formal.method": notApplicable10,
  "type.argument.formal.method.iteration": notApplicable10,
  "type.argument.formal.lambda": notApplicable10,
  "type.argument.formal.lambda.iteration": notApplicable10,
  "type.argument.formal.constructor": notApplicable10,
  "type.argument.formal.constructor.iteration": notApplicable10,
  "type.argument.catch": notApplicable10,
  "type.cast": notApplicable10,
  "type.class": notApplicable10,
  "type.field.class": notApplicable10,
  "type.foreach": notApplicable10,
  "type.return": notApplicable10,
  "type.return.method": notApplicable10,
  "type.constant": notApplicable10,
  "type.variable.uninitialized": notApplicable10,
  "type.variable.initialized": notApplicable10,
  "type.typeArgument": notApplicable10,
  "type.typeArgument.iteration": notApplicable10,
  "type.iteration.block": notApplicable10,
  "type.iteration.class": notApplicable10,
  "type.iteration.document": notApplicable10,
  "type.alias": notApplicable10,
  "value.typeAlias": notApplicable10,
  "statement.typeAlias": notApplicable10,
  "name.typeAlias": notApplicable10,
  "functionCall.generic": notApplicable10,
  "functionCallee.generic": notApplicable10,
  // Interface
  "statement.interface": notApplicable10,
  "statement.field.interface": notApplicable10,
  "statement.iteration.interface": notApplicable10,
  "name.interface": notApplicable10,
  "name.field.interface": notApplicable10,
  "name.iteration.interface": notApplicable10,
  "value.field.interface": notApplicable10,
  "type.interface": notApplicable10,
  "type.field.interface": notApplicable10,
  "type.iteration.interface": notApplicable10,
  "interior.interface": notApplicable10,
  // Enum
  "statement.enum": notApplicable10,
  "name.enum": notApplicable10,
  "name.field.enum": notApplicable10,
  "name.iteration.enum": notApplicable10,
  "value.field.enum": notApplicable10,
  "value.iteration.enum": notApplicable10,
  "type.enum": notApplicable10,
  "interior.enum": notApplicable10,
  "functionCall.enum": notApplicable10,
  "functionCallee.enum": notApplicable10,
  // Miscellaneous
  "statement.package": notApplicable10
};

// ../common/src/scopeSupportFacets/javascriptreact.ts
var javascriptreactScopeSupport = {
  ...javascriptScopeSupport
};

// ../common/src/scopeSupportFacets/json.ts
var { supported: supported11, notApplicable: notApplicable11 } = ScopeSupportFacetLevel;
var jsonScopeSupport = {
  list: supported11,
  map: supported11,
  "string.singleLine": supported11,
  "key.mapPair.iteration": supported11,
  "key.mapPair": supported11,
  "value.mapPair.iteration": supported11,
  "value.mapPair": supported11,
  "comment.block": supported11,
  "comment.line": supported11,
  "textFragment.comment.block": supported11,
  "textFragment.comment.line": supported11,
  "textFragment.string.singleLine": supported11,
  /* NOT APPLICABLE */
  // Assignment
  "statement.assignment": notApplicable11,
  "statement.assignment.compound": notApplicable11,
  "statement.assignment.destructuring": notApplicable11,
  "name.assignment": notApplicable11,
  "name.assignment.compound": notApplicable11,
  "name.assignment.destructuring": notApplicable11,
  "value.assignment": notApplicable11,
  "value.assignment.compound": notApplicable11,
  "value.assignment.destructuring": notApplicable11,
  "statement.update": notApplicable11,
  // Variable
  "statement.variable.uninitialized": notApplicable11,
  "statement.variable.initialized": notApplicable11,
  "statement.variable.destructuring": notApplicable11,
  "name.variable.uninitialized": notApplicable11,
  "name.variable.initialized": notApplicable11,
  "name.variable.destructuring": notApplicable11,
  "type.variable.uninitialized": notApplicable11,
  "type.variable.initialized": notApplicable11,
  "value.variable": notApplicable11,
  "value.variable.destructuring": notApplicable11,
  // Constant
  "statement.constant": notApplicable11,
  "name.constant": notApplicable11,
  "value.constant": notApplicable11,
  "type.constant": notApplicable11,
  // Class
  class: notApplicable11,
  "class.iteration.block": notApplicable11,
  "class.iteration.document": notApplicable11,
  "name.class": notApplicable11,
  "name.field.class": notApplicable11,
  "name.iteration.class": notApplicable11,
  "statement.class": notApplicable11,
  "statement.field.class": notApplicable11,
  "statement.iteration.class": notApplicable11,
  "type.class": notApplicable11,
  "type.field.class": notApplicable11,
  "type.iteration.class": notApplicable11,
  "value.field.class": notApplicable11,
  "value.iteration.class": notApplicable11,
  "interior.class": notApplicable11,
  // Constructor
  "statement.constructor": notApplicable11,
  "namedFunction.constructor": notApplicable11,
  "argument.actual.constructor.singleLine": notApplicable11,
  "argument.actual.constructor.multiLine": notApplicable11,
  "argument.actual.constructor.iteration": notApplicable11,
  "argument.formal.constructor.singleLine": notApplicable11,
  "argument.formal.constructor.multiLine": notApplicable11,
  "argument.formal.constructor.iteration": notApplicable11,
  "argumentList.actual.constructor.empty": notApplicable11,
  "argumentList.actual.constructor.singleLine": notApplicable11,
  "argumentList.actual.constructor.multiLine": notApplicable11,
  "argumentList.formal.constructor.empty": notApplicable11,
  "argumentList.formal.constructor.singleLine": notApplicable11,
  "argumentList.formal.constructor.multiLine": notApplicable11,
  "interior.constructor": notApplicable11,
  "name.argument.formal.constructor": notApplicable11,
  "name.argument.formal.constructor.iteration": notApplicable11,
  "name.constructor": notApplicable11,
  "type.argument.formal.constructor": notApplicable11,
  "type.argument.formal.constructor.iteration": notApplicable11,
  "value.argument.formal.constructor": notApplicable11,
  "value.argument.formal.constructor.iteration": notApplicable11,
  "functionCall.constructor": notApplicable11,
  "functionCallee.constructor": notApplicable11,
  // Method
  "statement.method": notApplicable11,
  "namedFunction.method": notApplicable11,
  "argument.actual.method.singleLine": notApplicable11,
  "argument.actual.method.multiLine": notApplicable11,
  "argument.actual.method.iteration": notApplicable11,
  "argument.formal.method.singleLine": notApplicable11,
  "argument.formal.method.multiLine": notApplicable11,
  "argument.formal.method.iteration": notApplicable11,
  "argumentList.actual.method.empty": notApplicable11,
  "argumentList.actual.method.singleLine": notApplicable11,
  "argumentList.actual.method.multiLine": notApplicable11,
  "argumentList.formal.method.empty": notApplicable11,
  "argumentList.formal.method.singleLine": notApplicable11,
  "argumentList.formal.method.multiLine": notApplicable11,
  "interior.method": notApplicable11,
  "name.argument.formal.method": notApplicable11,
  "name.argument.formal.method.iteration": notApplicable11,
  "name.method": notApplicable11,
  "type.argument.formal.method": notApplicable11,
  "type.argument.formal.method.iteration": notApplicable11,
  "type.return.method": notApplicable11,
  "value.argument.formal.method": notApplicable11,
  "value.argument.formal.method.iteration": notApplicable11,
  "functionCall.method": notApplicable11,
  "functionCallee.method": notApplicable11,
  // Function
  namedFunction: notApplicable11,
  "namedFunction.iteration.document": notApplicable11,
  "namedFunction.iteration.class": notApplicable11,
  "statement.function": notApplicable11,
  "name.function": notApplicable11,
  "interior.function": notApplicable11,
  "argumentList.formal.empty": notApplicable11,
  "argumentList.formal.singleLine": notApplicable11,
  "argumentList.formal.multiLine": notApplicable11,
  "argument.formal.singleLine": notApplicable11,
  "argument.formal.multiLine": notApplicable11,
  "argument.formal.iteration": notApplicable11,
  "name.argument.formal": notApplicable11,
  "name.argument.formal.iteration": notApplicable11,
  "type.argument.formal": notApplicable11,
  "type.argument.formal.iteration": notApplicable11,
  "value.argument.formal": notApplicable11,
  "value.argument.formal.iteration": notApplicable11,
  // Anonymous function / lambda
  anonymousFunction: notApplicable11,
  "argumentList.formal.lambda.empty": notApplicable11,
  "argumentList.formal.lambda.singleLine": notApplicable11,
  "argumentList.formal.lambda.multiLine": notApplicable11,
  "argument.formal.lambda.singleLine": notApplicable11,
  "argument.formal.lambda.multiLine": notApplicable11,
  "argument.formal.lambda.iteration": notApplicable11,
  "name.argument.formal.lambda": notApplicable11,
  "name.argument.formal.lambda.iteration": notApplicable11,
  "type.argument.formal.lambda": notApplicable11,
  "type.argument.formal.lambda.iteration": notApplicable11,
  "value.return.lambda": notApplicable11,
  "interior.lambda": notApplicable11,
  // Function call
  functionCall: notApplicable11,
  "functionCall.generic": notApplicable11,
  "statement.functionCall": notApplicable11,
  functionCallee: notApplicable11,
  "functionCallee.generic": notApplicable11,
  "functionCall.chain": notApplicable11,
  "functionCallee.chain": notApplicable11,
  "argumentList.actual.empty": notApplicable11,
  "argumentList.actual.singleLine": notApplicable11,
  "argumentList.actual.multiLine": notApplicable11,
  "argument.actual.singleLine": notApplicable11,
  "argument.actual.multiLine": notApplicable11,
  "argument.actual.iteration": notApplicable11,
  "name.argument.actual": notApplicable11,
  "name.argument.actual.iteration": notApplicable11,
  "value.argument.actual": notApplicable11,
  "value.argument.actual.iteration": notApplicable11,
  // Return statement
  "statement.return": notApplicable11,
  "type.return": notApplicable11,
  "value.return": notApplicable11,
  // Yield statement
  "statement.yield": notApplicable11,
  "value.yield": notApplicable11,
  // Throw statement
  "statement.throw": notApplicable11,
  "value.throw": notApplicable11,
  // Interface
  "statement.interface": notApplicable11,
  "statement.field.interface": notApplicable11,
  "statement.iteration.interface": notApplicable11,
  "interior.interface": notApplicable11,
  "name.interface": notApplicable11,
  "name.field.interface": notApplicable11,
  "name.iteration.interface": notApplicable11,
  "type.interface": notApplicable11,
  "type.field.interface": notApplicable11,
  "value.field.interface": notApplicable11,
  "type.iteration.interface": notApplicable11,
  // Enum
  "statement.enum": notApplicable11,
  "functionCallee.enum": notApplicable11,
  "functionCall.enum": notApplicable11,
  "name.enum": notApplicable11,
  "name.field.enum": notApplicable11,
  "name.iteration.enum": notApplicable11,
  "value.field.enum": notApplicable11,
  "value.iteration.enum": notApplicable11,
  "type.enum": notApplicable11,
  "interior.enum": notApplicable11,
  // Command
  command: notApplicable11,
  "statement.command": notApplicable11,
  "name.command": notApplicable11,
  "value.command": notApplicable11,
  "interior.command": notApplicable11,
  // Try catch
  "statement.try": notApplicable11,
  "branch.try": notApplicable11,
  "branch.try.iteration": notApplicable11,
  "interior.try": notApplicable11,
  "argument.catch": notApplicable11,
  "name.argument.catch": notApplicable11,
  "type.argument.catch": notApplicable11,
  // If statement
  ifStatement: notApplicable11,
  "statement.if": notApplicable11,
  "branch.if": notApplicable11,
  "branch.if.elif.else": notApplicable11,
  "branch.if.else": notApplicable11,
  "branch.if.iteration": notApplicable11,
  "condition.if": notApplicable11,
  "interior.if": notApplicable11,
  // Switch statement
  "statement.switch": notApplicable11,
  "branch.switchCase": notApplicable11,
  "branch.switchCase.iteration": notApplicable11,
  "condition.switchCase": notApplicable11,
  "condition.switchCase.iteration": notApplicable11,
  "interior.switch": notApplicable11,
  "interior.switchCase": notApplicable11,
  "value.switch": notApplicable11,
  // Loop
  "branch.loop": notApplicable11,
  "branch.loop.iteration": notApplicable11,
  // For loop
  "statement.for": notApplicable11,
  "condition.for": notApplicable11,
  "interior.for": notApplicable11,
  // For-each loop
  "statement.foreach": notApplicable11,
  "interior.foreach": notApplicable11,
  "name.foreach": notApplicable11,
  "type.foreach": notApplicable11,
  "value.foreach": notApplicable11,
  // While loop
  "statement.while": notApplicable11,
  "condition.while": notApplicable11,
  "interior.while": notApplicable11,
  // Do-while loop
  "statement.doWhile": notApplicable11,
  "condition.doWhile": notApplicable11,
  "interior.doWhile": notApplicable11,
  // Resource statement
  "statement.resource": notApplicable11,
  "interior.resource": notApplicable11,
  "name.resource": notApplicable11,
  "type.resource": notApplicable11,
  "value.resource": notApplicable11,
  // Multiline string
  "string.multiLine": notApplicable11,
  "textFragment.string.multiLine": notApplicable11,
  // Static
  "statement.static": notApplicable11,
  "interior.static": notApplicable11,
  // Namespace
  "statement.namespace": notApplicable11,
  "interior.namespace": notApplicable11,
  "name.namespace": notApplicable11,
  // Ternary
  "branch.ternary": notApplicable11,
  "branch.ternary.iteration": notApplicable11,
  "condition.ternary": notApplicable11,
  // Section
  section: notApplicable11,
  "section.iteration.document": notApplicable11,
  "section.iteration.parent": notApplicable11,
  // Element
  element: notApplicable11,
  "interior.element": notApplicable11,
  "textFragment.element": notApplicable11,
  tags: notApplicable11,
  startTag: notApplicable11,
  endTag: notApplicable11,
  // Attribute
  attribute: notApplicable11,
  "key.attribute": notApplicable11,
  "value.attribute": notApplicable11,
  // Notebook cell
  notebookCell: notApplicable11,
  "interior.cell": notApplicable11,
  // Type alias
  "type.alias": notApplicable11,
  "statement.typeAlias": notApplicable11,
  "name.typeAlias": notApplicable11,
  "value.typeAlias": notApplicable11,
  // Collection item
  "collectionItem.unenclosed.singleLine": notApplicable11,
  "collectionItem.unenclosed.multiLine": notApplicable11,
  "collectionItem.unenclosed.iteration": notApplicable11,
  // Miscellaneous statements
  "statement.misc": notApplicable11,
  "statement.break": notApplicable11,
  "statement.continue": notApplicable11,
  "statement.package": notApplicable11,
  "statement.import": notApplicable11,
  "statement.iteration.document": notApplicable11,
  "statement.iteration.block": notApplicable11,
  // Miscellaneous
  environment: notApplicable11,
  fieldAccess: notApplicable11,
  "name.iteration.block": notApplicable11,
  "name.iteration.document": notApplicable11,
  pairDelimiter: notApplicable11,
  regularExpression: notApplicable11,
  "type.cast": notApplicable11,
  "type.typeArgument": notApplicable11,
  "type.typeArgument.iteration": notApplicable11,
  "type.iteration.block": notApplicable11,
  "type.iteration.document": notApplicable11,
  "value.iteration.block": notApplicable11,
  "value.iteration.document": notApplicable11,
  selector: notApplicable11,
  unit: notApplicable11,
  disqualifyDelimiter: notApplicable11
};

// ../common/src/scopeSupportFacets/jsonc.ts
var { supported: supported12, unsupported: unsupported7, notApplicable: notApplicable12 } = ScopeSupportFacetLevel;
var jsoncScopeSupport = {
  ...jsonScopeSupport
};

// ../common/src/scopeSupportFacets/jsonl.ts
var { supported: supported13, unsupported: unsupported8, notApplicable: notApplicable13 } = ScopeSupportFacetLevel;
var jsonlScopeSupport = {
  ...jsonScopeSupport
};

// ../common/src/scopeSupportFacets/kotlin.ts
var { supported: supported14, unsupported: unsupported9, notApplicable: notApplicable14 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/latex.ts
var { supported: supported15, notApplicable: notApplicable15 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/lua.ts
var { supported: supported16, unsupported: unsupported10, notApplicable: notApplicable16 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/markdown.ts
var { supported: supported17, notApplicable: notApplicable17 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/php.ts
var { supported: supported18, notApplicable: notApplicable18 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/properties.ts
var { supported: supported19, notApplicable: notApplicable19 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/python.ts
var { supported: supported20, notApplicable: notApplicable20 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/r.ts
var { supported: supported21, unsupported: unsupported11, notApplicable: notApplicable21 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/ruby.ts
var { supported: supported22, unsupported: unsupported12, notApplicable: notApplicable22 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/rust.ts
var { supported: supported23, unsupported: unsupported13, notApplicable: notApplicable23 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/scala.ts
var { supported: supported24, unsupported: unsupported14, notApplicable: notApplicable24 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/scm.ts
var { supported: supported25, notApplicable: notApplicable25 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/scss.ts
var { supported: supported26 } = ScopeSupportFacetLevel;
var scssScopeSupport = {
  ...cssScopeSupport,
  "comment.line": supported26,
  namedFunction: supported26,
  "namedFunction.iteration.class": supported26,
  "namedFunction.iteration.document": supported26,
  "name.argument.formal": supported26,
  "name.argument.formal.iteration": supported26,
  "name.function": supported26,
  "name.iteration.document": supported26,
  "name.iteration.block": supported26,
  "value.argument.formal": supported26,
  "value.argument.formal.iteration": supported26,
  "value.return": supported26,
  "textFragment.comment.line": supported26,
  ifStatement: supported26,
  "branch.if": supported26,
  "branch.if.elif.else": supported26,
  "branch.if.else": supported26,
  "branch.if.iteration": supported26,
  "condition.if": supported26,
  "interior.if": supported26,
  "interior.function": supported26,
  "argument.actual.singleLine": supported26,
  "argument.actual.multiLine": supported26
};

// ../common/src/scopeSupportFacets/talon.ts
var { supported: supported27, unsupported: unsupported15, notApplicable: notApplicable26 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/talonList.ts
var { supported: supported28, notApplicable: notApplicable27 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/typescript.ts
var { supported: supported29, notApplicable: notApplicable28 } = ScopeSupportFacetLevel;
var typescriptScopeSupport = {
  ...javascriptCoreScopeSupport,
  "type.argument.formal": supported29,
  "type.argument.formal.iteration": supported29,
  "type.argument.formal.method": supported29,
  "type.argument.formal.method.iteration": supported29,
  "type.argument.formal.lambda": supported29,
  "type.argument.formal.lambda.iteration": supported29,
  "type.argument.formal.constructor": supported29,
  "type.argument.formal.constructor.iteration": supported29,
  "type.argument.catch": supported29,
  "type.alias": supported29,
  "type.cast": supported29,
  "type.class": supported29,
  "type.field.class": supported29,
  "type.field.interface": supported29,
  "type.interface": supported29,
  "type.enum": supported29,
  "type.return": supported29,
  "type.constant": supported29,
  "type.variable.uninitialized": supported29,
  "type.variable.initialized": supported29,
  "type.typeArgument": supported29,
  "type.typeArgument.iteration": supported29,
  "type.iteration.block": supported29,
  "type.iteration.class": supported29,
  "type.iteration.interface": supported29,
  "type.iteration.document": supported29,
  "type.return.method": supported29,
  "functionCall.generic": supported29,
  "functionCallee.generic": supported29,
  "name.interface": supported29,
  "name.enum": supported29,
  "name.field.interface": supported29,
  "name.field.enum": supported29,
  "name.typeAlias": supported29,
  "name.iteration.interface": supported29,
  "name.iteration.enum": supported29,
  "statement.interface": supported29,
  "statement.enum": supported29,
  "statement.field.interface": supported29,
  "statement.iteration.interface": supported29,
  "statement.typeAlias": supported29,
  "value.typeAlias": supported29,
  "value.field.enum": supported29,
  "value.iteration.enum": supported29,
  "interior.interface": supported29,
  "interior.enum": supported29,
  /* NOT APPLICABLE */
  // Element and tags
  element: notApplicable28,
  tags: notApplicable28,
  startTag: notApplicable28,
  endTag: notApplicable28,
  attribute: notApplicable28,
  "key.attribute": notApplicable28,
  "value.attribute": notApplicable28,
  "interior.element": notApplicable28,
  "textFragment.element": notApplicable28,
  // Enum calls
  "functionCall.enum": notApplicable28,
  "functionCallee.enum": notApplicable28,
  // Miscellaneous
  "type.foreach": notApplicable28,
  "statement.package": notApplicable28,
  "value.field.interface": notApplicable28
};

// ../common/src/scopeSupportFacets/typescriptreact.ts
var typescriptreactScopeSupport = {
  ...typescriptScopeSupport,
  ...javascriptJsxScopeSupport
};

// ../common/src/scopeSupportFacets/xml.ts
var { supported: supported30, notApplicable: notApplicable29 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/yaml.ts
var { supported: supported31, unsupported: unsupported16, notApplicable: notApplicable30 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/scopeSupportFacetInfos.ts
var scopeSupportFacetInfos = {
  command: {
    description: "A command, for example Talon spoken command or bash",
    scopeType: "command"
  },
  element: {
    description: "A xml/html element. Also used for LaTeX environments",
    scopeType: "xmlElement"
  },
  startTag: {
    description: "The start tag of a xml element",
    scopeType: "xmlStartTag"
  },
  endTag: {
    description: "The end tag of a xml element",
    scopeType: "xmlEndTag"
  },
  tags: {
    description: "Both tags in a xml element",
    scopeType: "xmlBothTags"
  },
  attribute: {
    description: "A attribute, eg of a html element or a C++ attribute",
    scopeType: "attribute"
  },
  environment: {
    description: "An environment, eg in LaTeX",
    scopeType: "environment"
  },
  section: {
    description: "A document section",
    scopeType: "section"
  },
  "section.iteration.document": documentIter("section", "sections"),
  "section.iteration.parent": iteration(
    "section",
    "sections",
    "the parent section"
  ),
  list: {
    description: "A list/array",
    scopeType: "list"
  },
  map: {
    description: "A map/dictionary",
    scopeType: "map"
  },
  regularExpression: {
    description: "A regular expression",
    scopeType: "regularExpression"
  },
  fieldAccess: {
    description: "A field access",
    scopeType: "private.fieldAccess"
  },
  ifStatement: {
    description: "An if statement",
    scopeType: "ifStatement"
  },
  "statement.class": {
    description: "A class/struct declaration",
    scopeType: "statement"
  },
  "statement.interface": {
    description: "An interface declaration",
    scopeType: "statement"
  },
  "statement.enum": {
    description: "An enum declaration",
    scopeType: "statement"
  },
  "statement.field.class": {
    description: "A field declaration in a class/struct",
    scopeType: "statement"
  },
  "statement.field.interface": {
    description: "A field declaration in a interface",
    scopeType: "statement"
  },
  "statement.function": {
    description: "A named function declaration",
    scopeType: "statement"
  },
  "statement.constructor": {
    description: "A constructor declaration",
    scopeType: "statement"
  },
  "statement.method": {
    description: "A method declaration",
    scopeType: "statement"
  },
  "statement.functionCall": {
    description: "A function call statement",
    scopeType: "statement"
  },
  "statement.if": {
    description: "A if/elif/else statement",
    scopeType: "statement"
  },
  "statement.try": {
    description: "A try/catch/finally statement",
    scopeType: "statement"
  },
  "statement.switch": {
    description: "A switch statement",
    scopeType: "statement"
  },
  "statement.for": {
    description: "A for loop statement",
    scopeType: "statement"
  },
  "statement.foreach": {
    description: "A for-each loop statement",
    scopeType: "statement"
  },
  "statement.while": {
    description: "A while loop statement",
    scopeType: "statement"
  },
  "statement.doWhile": {
    description: "A do-while loop statement",
    scopeType: "statement"
  },
  "statement.variable.uninitialized": {
    description: "An uninitialized variable declaration",
    scopeType: "statement"
  },
  "statement.variable.initialized": {
    description: "An initialized variable declaration",
    scopeType: "statement"
  },
  "statement.variable.destructuring": {
    description: "A variable declaration pattern destructuring",
    scopeType: "statement"
  },
  "statement.constant": {
    description: "A constant declaration",
    scopeType: "statement"
  },
  "statement.assignment": {
    description: "An assignment statement",
    scopeType: "statement"
  },
  "statement.assignment.destructuring": {
    description: "An assignment statement with pattern destructuring",
    scopeType: "statement"
  },
  "statement.assignment.compound": {
    description: "A compound assignment statement, eg +=/-=",
    scopeType: "statement"
  },
  "statement.typeAlias": {
    description: "A type alias declaration",
    scopeType: "statement"
  },
  "statement.update": {
    description: "An update statement, eg ++/--",
    scopeType: "statement"
  },
  "statement.return": {
    description: "A return statement",
    scopeType: "statement"
  },
  "statement.yield": {
    description: "A yield statement",
    scopeType: "statement"
  },
  "statement.throw": {
    description: "A throw statement",
    scopeType: "statement"
  },
  "statement.break": {
    description: "A break statement",
    scopeType: "statement"
  },
  "statement.continue": {
    description: "A continue statement",
    scopeType: "statement"
  },
  "statement.resource": {
    description: "A 'with' / 'use' / 'using' statement",
    scopeType: "statement"
  },
  "statement.command": {
    description: "A command statement, eg Talon spoken command or bash",
    scopeType: "statement"
  },
  "statement.package": {
    description: "A package declaration",
    scopeType: "statement"
  },
  "statement.namespace": {
    description: "A namespace declaration",
    scopeType: "statement"
  },
  "statement.static": {
    description: "A static statement",
    scopeType: "statement"
  },
  "statement.import": {
    description: "An import statement",
    scopeType: "statement"
  },
  "statement.misc": {
    description: "A miscellaneous statement",
    scopeType: "statement"
  },
  "statement.iteration.document": documentIter("statement", "statements"),
  "statement.iteration.class": classIter("statement", "statements"),
  "statement.iteration.interface": interfaceIter("statement", "statements"),
  "statement.iteration.block": blockIter("statement", "statements"),
  class: {
    description: "A class/struct in an object-oriented language",
    scopeType: "class"
  },
  "class.iteration.document": documentIter("class", "classes"),
  "class.iteration.block": blockIter("class", "classes"),
  namedFunction: {
    description: "A named function declaration",
    scopeType: "namedFunction"
  },
  "namedFunction.method": {
    description: "A named method declaration in a class",
    scopeType: "namedFunction"
  },
  "namedFunction.constructor": {
    description: "A constructor declaration in a class",
    scopeType: "namedFunction"
  },
  "namedFunction.iteration.document": documentIter(
    "namedFunction",
    "named functions"
  ),
  "namedFunction.iteration.class": classIter(
    "namedFunction",
    "named functions"
  ),
  anonymousFunction: {
    description: "An anonymous function, eg a lambda function, an arrow function, etc.",
    scopeType: "anonymousFunction"
  },
  functionCall: {
    description: "A function call",
    scopeType: "functionCall"
  },
  "functionCall.constructor": {
    description: "A constructor call",
    scopeType: "functionCall"
  },
  "functionCall.method": {
    description: "A method call",
    scopeType: "functionCall"
  },
  "functionCall.chain": {
    description: "A chain of function calls, eg `foo().bar()`",
    scopeType: "functionCall"
  },
  "functionCall.generic": {
    description: "A function call with generic type arguments",
    scopeType: "functionCall"
  },
  "functionCall.enum": {
    description: "An enum constructor call",
    scopeType: "functionCall"
  },
  functionCallee: {
    description: "The function being called in a function call",
    scopeType: "functionCallee"
  },
  "functionCallee.constructor": {
    description: "The class being constructed in a class instantiation, including the `new` keyword.",
    scopeType: "functionCallee"
  },
  "functionCallee.method": {
    description: "The function being called in a method call, including parent objects.",
    scopeType: "functionCallee"
  },
  "functionCallee.chain": {
    description: "The function being called in a chain of function calls, including parent objects.",
    scopeType: "functionCallee"
  },
  "functionCallee.generic": {
    description: "The function being called in a function call with generic type arguments",
    scopeType: "functionCallee"
  },
  "functionCallee.enum": {
    description: "The enum constructor being called",
    scopeType: "functionCallee"
  },
  "argument.actual.singleLine": {
    description: "A single line argument in a function call",
    scopeType: "argumentOrParameter"
  },
  "argument.actual.multiLine": {
    description: "A multiline argument in a function call. Insertion delimiter should include new line.",
    scopeType: "argumentOrParameter"
  },
  "argument.actual.iteration": iteration(
    "argumentOrParameter",
    "arguments in a function call",
    "the argument list. The domain should be the entire function call"
  ),
  "argument.actual.method.singleLine": {
    description: "A single line argument in a method call",
    scopeType: "argumentOrParameter"
  },
  "argument.actual.method.multiLine": {
    description: "A multi line argument in a method call. Insertion delimiter should include new line.",
    scopeType: "argumentOrParameter"
  },
  "argument.actual.method.iteration": iteration(
    "argumentOrParameter",
    "arguments in a method call",
    "the argument list. The domain should be the entire method call."
  ),
  "argument.actual.constructor.singleLine": {
    description: "A single line argument in a constructor call",
    scopeType: "argumentOrParameter"
  },
  "argument.actual.constructor.multiLine": {
    description: "A multi line argument in a constructor call. Insertion delimiter should include new line.",
    scopeType: "argumentOrParameter"
  },
  "argument.actual.constructor.iteration": iteration(
    "argumentOrParameter",
    "arguments in a constructor call",
    "the argument list. The domain should be the entire constructor call."
  ),
  "argument.formal.singleLine": {
    description: "A single line parameter in a function declaration",
    scopeType: "argumentOrParameter"
  },
  "argument.formal.multiLine": {
    description: "A multi line parameter in a function declaration. Insertion delimiter should include new line.",
    scopeType: "argumentOrParameter"
  },
  "argument.formal.iteration": iteration(
    "argumentOrParameter",
    "formal parameters in a function declaration",
    "the parameters list. The domain should be the entire function"
  ),
  "argument.formal.method.singleLine": {
    description: "A single line parameter in a class method declaration",
    scopeType: "argumentOrParameter"
  },
  "argument.formal.method.multiLine": {
    description: "A multi line parameter in a class method declaration. Insertion delimiter should include new line.",
    scopeType: "argumentOrParameter"
  },
  "argument.formal.method.iteration": iteration(
    "argumentOrParameter",
    "formal parameters in a method declaration",
    "the parameter list. The domain should be the entire method"
  ),
  "argument.formal.constructor.singleLine": {
    description: "A single line parameter in a constructor declaration",
    scopeType: "argumentOrParameter"
  },
  "argument.formal.constructor.multiLine": {
    description: "A multi line parameter in a constructor declaration. Insertion delimiter should include new line.",
    scopeType: "argumentOrParameter"
  },
  "argument.formal.constructor.iteration": iteration(
    "argumentOrParameter",
    "formal parameters in a constructor declaration",
    "the parameter list. The domain should be the entire constructor"
  ),
  "argument.formal.lambda.singleLine": {
    description: "A single line parameter in a lambda declaration",
    scopeType: "argumentOrParameter"
  },
  "argument.formal.lambda.multiLine": {
    description: "A multi line parameter in a lambda declaration. Insertion delimiter should include new line.",
    scopeType: "argumentOrParameter"
  },
  "argument.formal.lambda.iteration": iteration(
    "argumentOrParameter",
    "formal parameters in a lambda declaration",
    "the parameter list. The domain should be the entire lambda"
  ),
  "argument.catch": {
    description: "A parameter in a catch clause",
    scopeType: "argumentOrParameter"
  },
  "argumentList.actual.empty": {
    description: "An empty list of arguments in a function call. Insertion delimiter should be empty.",
    scopeType: "argumentList"
  },
  "argumentList.actual.singleLine": {
    description: "A single line list of arguments in a function call",
    scopeType: "argumentList"
  },
  "argumentList.actual.multiLine": {
    description: "A multi line list of arguments in a function call. Insertion delimiter should include new line.",
    scopeType: "argumentList"
  },
  "argumentList.actual.method.empty": {
    description: "An empty list of arguments in a method call. Insertion delimiter should be empty.",
    scopeType: "argumentList"
  },
  "argumentList.actual.method.singleLine": {
    description: "A single line list of arguments in a method call",
    scopeType: "argumentList"
  },
  "argumentList.actual.method.multiLine": {
    description: "A multi line list of arguments in a method call. Insertion delimiter should include new line.",
    scopeType: "argumentList"
  },
  "argumentList.actual.constructor.empty": {
    description: "An empty list of arguments in a constructor call. Insertion delimiter should be empty.",
    scopeType: "argumentList"
  },
  "argumentList.actual.constructor.singleLine": {
    description: "A single line list of arguments in a constructor call",
    scopeType: "argumentList"
  },
  "argumentList.actual.constructor.multiLine": {
    description: "A multi line list of arguments in a constructor call. Insertion delimiter should include new line.",
    scopeType: "argumentList"
  },
  "argumentList.formal.empty": {
    description: "An empty list of parameters in a function declaration. Insertion delimiter should be empty.",
    scopeType: "argumentList"
  },
  "argumentList.formal.singleLine": {
    description: "A single line list of parameters in a function declaration",
    scopeType: "argumentList"
  },
  "argumentList.formal.multiLine": {
    description: "A multi line list of parameters in a function declaration. Insertion delimiter should include new line.",
    scopeType: "argumentList"
  },
  "argumentList.formal.lambda.empty": {
    description: "An empty list of parameters in a lambda declaration. Insertion delimiter should be empty.",
    scopeType: "argumentList"
  },
  "argumentList.formal.lambda.singleLine": {
    description: "A single line list of parameters in a lambda declaration",
    scopeType: "argumentList"
  },
  "argumentList.formal.lambda.multiLine": {
    description: "A multi line list of parameters in a lambda declaration. Insertion delimiter should include new line.",
    scopeType: "argumentList"
  },
  "argumentList.formal.method.empty": {
    description: "An empty list of parameters in a class method declaration. Insertion delimiter should be empty.",
    scopeType: "argumentList"
  },
  "argumentList.formal.method.singleLine": {
    description: "A single line list of parameters in a class method declaration",
    scopeType: "argumentList"
  },
  "argumentList.formal.method.multiLine": {
    description: "A multi line list of parameters in a class method declaration. Insertion delimiter should include new line.",
    scopeType: "argumentList"
  },
  "argumentList.formal.constructor.empty": {
    description: "An empty list of parameters in a constructor declaration. Insertion delimiter should be empty.",
    scopeType: "argumentList"
  },
  "argumentList.formal.constructor.singleLine": {
    description: "A single line list of parameters in a constructor declaration",
    scopeType: "argumentList"
  },
  "argumentList.formal.constructor.multiLine": {
    description: "A multi line list of parameters in a constructor declaration. Insertion delimiter should include new line.",
    scopeType: "argumentList"
  },
  "comment.line": {
    description: "A line comment",
    scopeType: "comment"
  },
  "comment.block": {
    description: "A block comment",
    scopeType: "comment"
  },
  "string.singleLine": {
    description: "A single-line string",
    scopeType: "string"
  },
  "string.multiLine": {
    description: "A multi-line string",
    scopeType: "string"
  },
  "branch.if": {
    description: "An if branch",
    scopeType: "branch"
  },
  "branch.if.elif.else": {
    description: "An if-elif-else branch. The removal range for the if branch should include the trailing `else` keyword.",
    scopeType: "branch"
  },
  "branch.if.else": {
    description: "An if-else branch",
    scopeType: "branch"
  },
  "branch.if.iteration": iteration(
    "branch",
    "if/elif/else branches",
    "the if-else statement"
  ),
  "branch.loop": {
    description: "A for / while loop branch. For most languages this is not supported, but eg in Python you can have an else branch for a loop.",
    scopeType: "branch"
  },
  "branch.loop.iteration": iteration(
    "branch",
    "loop branches",
    "the loop statement"
  ),
  "branch.try": {
    description: "A try/catch/finally branch",
    scopeType: "branch"
  },
  "branch.try.iteration": iteration(
    "branch",
    "try/catch/finally branches",
    "the try-catch statement"
  ),
  "branch.switchCase": {
    description: "A case/default branch in a switch statement",
    scopeType: "branch"
  },
  "branch.switchCase.iteration": iteration(
    "branch",
    "switch branches",
    "the switch statement body"
  ),
  "branch.ternary": {
    description: "A branch in a ternary expression",
    scopeType: "branch"
  },
  "branch.ternary.iteration": iteration(
    "branch",
    "ternary expression branches",
    "the ternary expression"
  ),
  "collectionItem.unenclosed.singleLine": {
    description: "An item in a comma-separated single line list without enclosing delimiters. This could be multi-variable declarations, import statements, etc.",
    scopeType: "collectionItem"
  },
  "collectionItem.unenclosed.multiLine": {
    description: "An item in a comma-separated multi line list without enclosing delimiters. This could be multi-variable declarations, import statements, etc. Insertion delimiter should include new line.",
    scopeType: "collectionItem"
  },
  "collectionItem.unenclosed.iteration": iteration(
    "collectionItem",
    "items in a comma-separated list without enclosing delimiters"
  ),
  "condition.if": {
    description: "A condition in an if statement",
    scopeType: "condition"
  },
  "condition.while": {
    description: "A condition in a while loop",
    scopeType: "condition"
  },
  "condition.doWhile": {
    description: "A condition in a do while loop",
    scopeType: "condition"
  },
  "condition.for": {
    description: "A condition in a for loop",
    scopeType: "condition"
  },
  "condition.ternary": {
    description: "A condition in a ternary expression",
    scopeType: "condition"
  },
  "condition.switchCase": {
    description: "A condition in a switch statement",
    scopeType: "condition"
  },
  "condition.switchCase.iteration": iteration(
    "condition",
    "conditions in a switch statement",
    "the switch statement body"
  ),
  "name.command": {
    description: "LHS of a command, eg Talon spoken command or bash",
    scopeType: "name"
  },
  "name.variable.uninitialized": {
    description: "Name (LHS) of an uninitialized variable declaration",
    scopeType: "name"
  },
  "name.variable.initialized": {
    description: "Name (LHS) of an initialized variable declaration",
    scopeType: "name"
  },
  "name.variable.destructuring": {
    description: "Name (LHS) of a variable declaration with pattern destructuring",
    scopeType: "name"
  },
  "name.constant": {
    description: "Name (LHS) of a constant declaration",
    scopeType: "name"
  },
  "name.assignment": {
    description: "Name (LHS) of an assignment",
    scopeType: "name"
  },
  "name.assignment.destructuring": {
    description: "LHS of an assignment with pattern destructuring",
    scopeType: "name"
  },
  "name.assignment.compound": {
    description: "Name (LHS) of a compound assignment, eg +=/-=",
    scopeType: "name"
  },
  "name.foreach": {
    description: "Iteration variable name in a for each loop",
    scopeType: "name"
  },
  "name.function": {
    description: "Name of a function",
    scopeType: "name"
  },
  "name.method": {
    description: "Name of a class method",
    scopeType: "name"
  },
  "name.constructor": {
    description: "Name of a constructor",
    scopeType: "name"
  },
  "name.class": {
    description: "Name of a class",
    scopeType: "name"
  },
  "name.interface": {
    description: "Name of a interface",
    scopeType: "name"
  },
  "name.enum": {
    description: "Name of an enum",
    scopeType: "name"
  },
  "name.typeAlias": {
    description: "Name of a type alias",
    scopeType: "name"
  },
  "name.namespace": {
    description: "Name of a namespace",
    scopeType: "name"
  },
  "name.field.class": {
    description: "Name (LHS) of a field in a class",
    scopeType: "name"
  },
  "name.field.interface": {
    description: "Name (LHS) of a field in an interface",
    scopeType: "name"
  },
  "name.field.enum": {
    description: "Name (LHS) of a field in an enum",
    scopeType: "name"
  },
  "name.iteration.block": blockIter("name", "names"),
  "name.iteration.class": classIter("name", "names"),
  "name.iteration.interface": interfaceIter("name", "names"),
  "name.iteration.enum": enumIter("name", "names"),
  "name.iteration.document": documentIter("name", "names"),
  "name.resource": {
    description: "Name in a 'with' / 'use' / 'using' statement",
    scopeType: "name"
  },
  "name.argument.actual": {
    description: "Name of a (keyword) argument in a function call",
    scopeType: "name"
  },
  "name.argument.actual.iteration": iteration(
    "name",
    "names of (keyword) arguments in a function call",
    "the argument list"
  ),
  "name.argument.formal": {
    description: "Name of a parameter in a function declaration",
    scopeType: "name"
  },
  "name.argument.formal.iteration": iteration(
    "name",
    "names of formal parameters in a function declaration",
    "the parameters list"
  ),
  "name.argument.formal.method": {
    description: "Name of a parameter in a class method declaration",
    scopeType: "name"
  },
  "name.argument.formal.method.iteration": iteration(
    "name",
    "names of formal parameters in a method declaration",
    "the parameters list"
  ),
  "name.argument.formal.lambda": {
    description: "Name of a parameter in a lambda declaration",
    scopeType: "name"
  },
  "name.argument.formal.lambda.iteration": iteration(
    "name",
    "names of formal parameters in a lambda declaration",
    "the parameters list"
  ),
  "name.argument.formal.constructor": {
    description: "The name of a parameter in a constructor declaration",
    scopeType: "name"
  },
  "name.argument.formal.constructor.iteration": iteration(
    "name",
    "names of formal parameters in a constructor declaration",
    "the parameters list"
  ),
  "name.argument.catch": {
    description: "Name of a parameter in a catch clause",
    scopeType: "name"
  },
  "key.attribute": {
    description: "Key (LHS) of an attribute eg in a xml element",
    scopeType: "collectionKey"
  },
  "key.mapPair": {
    description: "Key (LHS) of a key-value pair of a map",
    scopeType: "collectionKey"
  },
  "key.mapPair.iteration": iteration(
    "collectionKey",
    "keys of key-value pairs in a map",
    "should be between the braces"
  ),
  "value.command": {
    description: "Value (RHS) of an command, eg Talon spoken command",
    scopeType: "value"
  },
  "value.variable": {
    description: "Value (RHS) of a variable declaration",
    scopeType: "value"
  },
  "value.variable.destructuring": {
    description: "Value (RHS) of a variable declaration with pattern destructuring",
    scopeType: "value"
  },
  "value.constant": {
    description: "Value (RHS) of a constant declaration",
    scopeType: "value"
  },
  "value.assignment": {
    description: "Value (RHS) of an assignment",
    scopeType: "value"
  },
  "value.assignment.destructuring": {
    description: "Value (RHS) of an assignment with pattern destructuring",
    scopeType: "value"
  },
  "value.assignment.compound": {
    description: "Value (RHS) of a compound assignment, eg +=/-=",
    scopeType: "value"
  },
  "value.mapPair": {
    description: "Value (RHS) of a key-value pair in a map",
    scopeType: "value"
  },
  "value.mapPair.iteration": iteration(
    "value",
    "values of key-value pairs in a map",
    "should be between the braces"
  ),
  "value.foreach": {
    description: "Iterable in a for each loop",
    scopeType: "value"
  },
  "value.attribute": {
    description: "Value (RHS) of an attribute eg in a xml element",
    scopeType: "value"
  },
  "value.return": {
    description: "Return value of a function",
    scopeType: "value"
  },
  "value.return.lambda": {
    description: "Implicit return value from a lambda",
    scopeType: "value"
  },
  "value.field.class": {
    description: "Value (RHS) of a field in a class",
    scopeType: "value"
  },
  "value.field.interface": {
    description: "Value (RHS) of a field in an interface",
    scopeType: "value"
  },
  "value.field.enum": {
    description: "Value (RHS) of a field in an enum",
    scopeType: "value"
  },
  "value.yield": {
    description: "Value of a yield statement",
    scopeType: "value"
  },
  "value.throw": {
    description: "Value of a throw statement",
    scopeType: "value"
  },
  "value.switch": {
    description: "The value / subject of a switch statement",
    scopeType: "value"
  },
  "value.iteration.block": blockIter("value", "values"),
  "value.iteration.class": classIter("value", "values"),
  "value.iteration.enum": enumIter("value", "values"),
  "value.iteration.document": documentIter("value", "values"),
  "value.resource": {
    description: "Value of a 'with' / 'use' / 'using' statement",
    scopeType: "value"
  },
  "value.argument.actual": {
    description: "The value of a (keyword) argument in a function call",
    scopeType: "value"
  },
  "value.argument.actual.iteration": iteration(
    "value",
    "values of (keyword) arguments in a function call",
    "the arguments list"
  ),
  "value.argument.formal": {
    description: "The value of a (keyword) argument in a function declaration",
    scopeType: "value"
  },
  "value.argument.formal.iteration": iteration(
    "value",
    "values of formal parameters in a function declaration",
    "the parameters list"
  ),
  "value.argument.formal.method": {
    description: "The value of a parameter in a class method declaration",
    scopeType: "value"
  },
  "value.argument.formal.method.iteration": iteration(
    "value",
    "values of formal parameters in a method declaration",
    "the parameters list"
  ),
  "value.argument.formal.constructor": {
    description: "The value of a parameter in a constructor declaration",
    scopeType: "value"
  },
  "value.argument.formal.constructor.iteration": iteration(
    "value",
    "values of formal parameters in a constructor declaration",
    "the parameters list"
  ),
  "value.typeAlias": {
    description: "Value of a type alias declaration",
    scopeType: "value"
  },
  "type.variable.uninitialized": {
    description: "Type of an uninitialized variable declaration",
    scopeType: "type"
  },
  "type.variable.initialized": {
    description: "Type of an initialized variable declaration",
    scopeType: "type"
  },
  "type.constant": {
    description: "Type of a constant declaration",
    scopeType: "type"
  },
  "type.argument.formal": {
    description: "Type of a formal parameter in a function declaration",
    scopeType: "type"
  },
  "type.argument.formal.iteration": iteration(
    "type",
    "types of formal parameters in a function declaration",
    "the parameters list"
  ),
  "type.argument.formal.method": {
    description: "Type of a formal parameter in a class method declaration",
    scopeType: "type"
  },
  "type.argument.formal.method.iteration": iteration(
    "type",
    "types of formal parameters in a method declaration",
    "the parameters list"
  ),
  "type.argument.formal.lambda": {
    description: "Type of a formal parameter in a lambda declaration",
    scopeType: "type"
  },
  "type.argument.formal.lambda.iteration": iteration(
    "type",
    "types of formal parameters in a lambda declaration",
    "the parameters list"
  ),
  "type.argument.formal.constructor": {
    description: "Type of a formal parameter in a constructor declaration",
    scopeType: "type"
  },
  "type.argument.formal.constructor.iteration": iteration(
    "type",
    "types of formal parameters in a constructor declaration",
    "the parameters list"
  ),
  "type.argument.catch": {
    description: "Type of a parameter in a catch clause",
    scopeType: "type"
  },
  "type.return": {
    description: "Type of a return value in a function declaration",
    scopeType: "type"
  },
  "type.return.method": {
    description: "Type of a return value in a method declaration",
    scopeType: "type"
  },
  "type.field.class": {
    description: "Type of a field in a class",
    scopeType: "type"
  },
  "type.field.interface": {
    description: "Type of a field in a interface",
    scopeType: "type"
  },
  "type.foreach": {
    description: "Type of a variable in a for each loop",
    scopeType: "type"
  },
  "type.enum": {
    description: "An enum declaration",
    scopeType: "type"
  },
  "type.class": {
    description: "A class declaration",
    scopeType: "type"
  },
  "type.interface": {
    description: "An interface declaration",
    scopeType: "type"
  },
  "type.alias": {
    description: "A type alias declaration",
    scopeType: "type"
  },
  "type.cast": {
    description: "A type cast",
    scopeType: "type"
  },
  "type.typeArgument": {
    description: "Type argument to a generic / parametrized type",
    scopeType: "type"
  },
  "type.typeArgument.iteration": iteration(
    "type",
    "type arguments to a generic / parametrized type",
    "the type argument list"
  ),
  "type.resource": {
    description: "Type in a 'with' / 'use' / 'using' statement",
    scopeType: "type"
  },
  "type.iteration.block": blockIter("type", "types"),
  "type.iteration.class": classIter("type", "types"),
  "type.iteration.interface": interfaceIter("type", "types"),
  "type.iteration.document": documentIter("type", "types"),
  "interior.element": {
    description: "The interior/children of a XML element",
    scopeType: { type: "interior" }
  },
  "interior.command": {
    description: "The body of a command, eg Talon spoken command",
    scopeType: { type: "interior" }
  },
  "interior.cell": {
    description: "The body of a code cell in markdown",
    scopeType: { type: "interior" }
  },
  "interior.class": {
    description: "The body of a class",
    scopeType: { type: "interior" }
  },
  "interior.interface": {
    description: "The body of a interface",
    scopeType: { type: "interior" }
  },
  "interior.enum": {
    description: "The body of an enum",
    scopeType: { type: "interior" }
  },
  "interior.function": {
    description: "The body of a function declaration",
    scopeType: { type: "interior" }
  },
  "interior.constructor": {
    description: "The body of a constructor declaration",
    scopeType: { type: "interior" }
  },
  "interior.method": {
    description: "The body of a method declaration",
    scopeType: { type: "interior" }
  },
  "interior.lambda": {
    description: "The block body of a lambda/anonymous function",
    scopeType: { type: "interior" }
  },
  "interior.if": {
    description: "The body of an if/elif/else branch",
    scopeType: { type: "interior" }
  },
  "interior.try": {
    description: "The body of a try/catch/finally branch",
    scopeType: { type: "interior" }
  },
  "interior.switch": {
    description: "The body of a switch statement",
    scopeType: { type: "interior" }
  },
  "interior.switchCase": {
    description: "The body of a switch case branch",
    scopeType: { type: "interior" }
  },
  "interior.for": {
    description: "The body of a for loop",
    scopeType: { type: "interior" }
  },
  "interior.foreach": {
    description: "The body of a for-each loop",
    scopeType: { type: "interior" }
  },
  "interior.while": {
    description: "The body of a while loop",
    scopeType: { type: "interior" }
  },
  "interior.doWhile": {
    description: "The body of a do-while loop",
    scopeType: { type: "interior" }
  },
  "interior.resource": {
    description: "the body of a 'with' / 'use' / 'using' statement",
    scopeType: { type: "interior" }
  },
  "interior.namespace": {
    description: "the body of a namespace statement",
    scopeType: { type: "interior" }
  },
  "interior.static": {
    description: "the body of a static statement",
    scopeType: { type: "interior" }
  },
  notebookCell: {
    description: "A cell in a notebook or a markdown code block",
    scopeType: "notebookCell"
  },
  selector: {
    description: "A selector in a css rule set",
    scopeType: "selector"
  },
  unit: {
    description: "A unit in a css rule set",
    scopeType: "unit"
  },
  // Internal scope facets
  "textFragment.comment.line": {
    description: "Internally used text fragment consisting of a line comment",
    scopeType: "textFragment"
  },
  "textFragment.comment.block": {
    description: "Internally used text fragment consisting of a block comment",
    scopeType: "textFragment"
  },
  "textFragment.string.singleLine": {
    description: "Internally used text fragment consisting of a single-line string",
    scopeType: "textFragment"
  },
  "textFragment.string.multiLine": {
    description: "Internally used text fragment consisting of a multi-line string",
    scopeType: "textFragment"
  },
  "textFragment.element": {
    description: "Internally used text fragment consisting of a xml element interior",
    scopeType: "textFragment"
  },
  disqualifyDelimiter: {
    description: "Internally used to disqualify a token from being treated as a surrounding pair delimiter. This will usually be operators containing `>` or `<`, eg `<`, `<=`, `->`, etc.",
    scopeType: "disqualifyDelimiter"
  },
  pairDelimiter: {
    description: 'Internally used to add additional language specific surrounding pair delimiters in addition to the text based definitions. eg `r"`.',
    scopeType: "pairDelimiter"
  }
};
function documentIter(scopeType, label) {
  return iteration(
    scopeType,
    label,
    "the entire document including leading and trailing empty lines"
  );
}
function classIter(scopeType, label) {
  return iteration(scopeType, label, "class bodies");
}
function interfaceIter(scopeType, label) {
  return iteration(scopeType, label, "interface bodies");
}
function enumIter(scopeType, label) {
  return iteration(scopeType, label, "enum bodies");
}
function blockIter(scopeType, label) {
  return iteration(
    scopeType,
    label,
    "statement blocks (body of functions/if-statements/for-loops/etc)"
  );
}
function iteration(scopeType, label, desc) {
  const description = desc != null ? `Iteration scope for ${label}: ${desc}.` : `Iteration scope for ${label}`;
  return {
    description,
    scopeType,
    isIteration: true
  };
}

// ../../node_modules/.pnpm/itertools@2.5.0/node_modules/itertools/dist/index.js
function* flatten2(iterableOfIterables) {
  for (const iterable of iterableOfIterables) {
    for (const item of iterable) {
      yield item;
    }
  }
}
function* itake(n, iterable) {
  const it = iter(iterable);
  let count2 = n;
  while (count2-- > 0) {
    const s = it.next();
    if (!s.done) {
      yield s.value;
    } else {
      return;
    }
  }
}
function* pairwise(iterable) {
  const it = iter(iterable);
  const first2 = it.next();
  if (first2.done) {
    return;
  }
  let r1 = first2.value;
  for (const r2 of it) {
    yield [r1, r2];
    r1 = r2;
  }
}
function* count(start2 = 0, step = 1) {
  let n = start2;
  for (; ; ) {
    yield n;
    n += step;
  }
}
function* ifilter(iterable, predicate) {
  let index = 0;
  for (const value of iterable) {
    if (predicate(value, index++)) {
      yield value;
    }
  }
}
function* imap(iterable, mapper) {
  for (const value of iterable) {
    yield mapper(value);
  }
}
function* islice(iterable, stopOrStart, possiblyStop, step = 1) {
  let start2, stop2;
  if (possiblyStop !== void 0) {
    start2 = stopOrStart;
    stop2 = possiblyStop;
  } else {
    start2 = 0;
    stop2 = stopOrStart;
  }
  if (start2 < 0) throw new Error("start cannot be negative");
  if (stop2 !== null && stop2 < 0) throw new Error("stop cannot be negative");
  if (step <= 0) throw new Error("step cannot be negative");
  let i2 = -1;
  const it = iter(iterable);
  let res;
  while (true) {
    i2++;
    if (stop2 !== null && i2 >= stop2) return;
    res = it.next();
    if (res.done) return;
    if (i2 < start2) continue;
    if ((i2 - start2) % step === 0) {
      yield res.value;
    }
  }
}
function* takewhile(iterable, predicate) {
  let index = 0;
  const it = iter(iterable);
  let res;
  while (!(res = it.next()).done) {
    const value = res.value;
    if (!predicate(value, index++)) return;
    yield value;
  }
}
function find(iterable, predicate) {
  const it = iter(iterable);
  if (predicate === void 0) {
    const value = it.next();
    return value.done ? void 0 : value.value;
  } else {
    let res;
    let i2 = 0;
    while (!(res = it.next()).done) {
      const value = res.value;
      if (predicate(value, i2++)) {
        return value;
      }
    }
    return void 0;
  }
}
function iter(iterable) {
  return iterable[Symbol.iterator]();
}
function map(iterable, mapper) {
  return Array.from(imap(iterable, mapper));
}
function range_(start2, stop2, step) {
  const counter = count(start2, step);
  const pred = step >= 0 ? (n) => n < stop2 : (n) => n > stop2;
  return takewhile(counter, pred);
}
function range2(startOrStop, definitelyStop, step = 1) {
  if (definitelyStop !== void 0) {
    return range_(startOrStop, definitelyStop, step);
  } else {
    return range_(0, startOrStop, step);
  }
}
function flatmap(iterable, mapper) {
  return flatten2(imap(iterable, mapper));
}

// ../common/src/StoredTargetKey.ts
var storedTargetKeys = [
  "that",
  "source",
  "instanceReference",
  "keyboard"
];

// ../common/src/types/Selection.ts
var Selection = class extends Range {
  constructor(...args2) {
    const [anchor, active] = (() => {
      if (args2.length === 2) {
        return args2;
      }
      return [new Position(args2[0], args2[1]), new Position(args2[2], args2[3])];
    })();
    super(anchor, active);
    /**
     * The position at which the selection starts.
     * This position might be before or after {@link Selection.active active}.
     */
    __publicField(this, "anchor");
    /**
     * The position of the cursor.
     * This position might be before or after {@link Selection.anchor anchor}.
     */
    __publicField(this, "active");
    this.anchor = anchor;
    this.active = active;
  }
  /**
   * Is true if active position is before anchor position.
   */
  get isReversed() {
    return this.active.isBefore(this.anchor);
  }
  /**
   * Check if `other` equals this range.
   *
   * @param other A selection.
   * @return `true` when anchor and active are {@link Position.isEqual equal} to
   * anchor and active of this range.
   */
  isEqual(other) {
    return this.anchor.isEqual(other.anchor) && this.active.isEqual(other.active);
  }
  /**
   * Return a concise string representation of the selection. 0-based.
   * @returns concise representation
   **/
  concise() {
    return `${this.anchor.concise()}->${this.active.concise()}`;
  }
  /**
   * Return a concise string representation of the selection. 1-based.
   * @returns concise representation
   **/
  conciseOneBased() {
    return `${this.start.conciseOneBased()}->${this.end.conciseOneBased()}`;
  }
  toString() {
    return this.concise();
  }
};

// ../common/src/types/GeneralizedRange.ts
function toLineRange({ start: start2, end }) {
  return { type: "line", start: start2.line, end: end.line };
}
function toCharacterRange({ start: start2, end }) {
  return { type: "character", start: start2, end };
}

// ../common/src/util/toPlainObject.ts
function rangeToPlainObject(range3) {
  return {
    start: positionToPlainObject(range3.start),
    end: positionToPlainObject(range3.end)
  };
}
function positionToPlainObject({
  line,
  character
}) {
  return { line, character };
}

// ../../node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject2(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat2(string5, count2) {
  var result = "", cycle;
  for (cycle = 0; cycle < count2; cycle += 1) {
    result += string5;
  }
  return result;
}
function isNegativeZero(number4) {
  return number4 === 0 && Number.NEGATIVE_INFINITY === 1 / number4;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject2;
var toArray_1 = toArray;
var repeat_1 = repeat2;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString2(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string5, max) {
  return common.repeat(" ", max - string5.length) + string5;
}
function makeSnippet(mark, options2) {
  options2 = Object.create(options2 || null);
  if (!mark.buffer) return null;
  if (!options2.maxLength) options2.maxLength = 79;
  if (typeof options2.indent !== "number") options2.indent = 1;
  if (typeof options2.linesBefore !== "number") options2.linesBefore = 3;
  if (typeof options2.linesAfter !== "number") options2.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i2, line;
  var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options2.linesBefore; i2++) {
    if (foundLineNo - i2 < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i2],
      lineEnds[foundLineNo - i2],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
      maxLineLength
    );
    result = common.repeat(" ", options2.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i2 = 1; i2 <= options2.linesAfter; i2++) {
    if (foundLineNo + i2 >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i2],
      lineEnds[foundLineNo + i2],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
      maxLineLength
    );
    result += common.repeat(" ", options2.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map4) {
  var result = {};
  if (map4 !== null) {
    Object.keys(map4).forEach(function(style) {
      map4[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options2) {
  options2 = options2 || {};
  Object.keys(options2).forEach(function(name2) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
      throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options2;
  this.tag = tag;
  this.kind = options2["kind"] || null;
  this.resolve = options2["resolve"] || function() {
    return true;
  };
  this.construct = options2["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options2["instanceOf"] || null;
  this.predicate = options2["predicate"] || null;
  this.represent = options2["represent"] || null;
  this.representName = options2["representName"] || null;
  this.defaultStyle = options2["defaultStyle"] || null;
  this.multi = options2["multi"] || false;
  this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema3, name2) {
  var result = [];
  schema3[name2].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map2 = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map2
  ]
});
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object2) {
  return object2 === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object2) {
  return Object.prototype.toString.call(object2) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object2) {
      return object2 ? "true" : "false";
    },
    uppercase: function(object2) {
      return object2 ? "TRUE" : "FALSE";
    },
    camelcase: function(object2) {
      return object2 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 === 0 && !common.isNegativeZero(object2));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object2, style) {
  var res;
  if (isNaN(object2)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object2)) {
    return "-0.0";
  }
  res = object2.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 !== 0 || common.isNegativeZero(object2));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date5;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date5 = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date5.setTime(date5.getTime() - delta);
  return date5;
}
function representYamlTimestamp(object2) {
  return object2.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map4.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map4 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map4.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object2) {
  var result = "", bits = 0, idx, tail, max = object2.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map4[bits >> 18 & 63];
      result += map4[bits >> 12 & 63];
      result += map4[bits >> 6 & 63];
      result += map4[bits & 63];
    }
    bits = (bits << 8) + object2[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map4[bits >> 18 & 63];
    result += map4[bits >> 12 & 63];
    result += map4[bits >> 6 & 63];
    result += map4[bits & 63];
  } else if (tail === 2) {
    result += map4[bits >> 10 & 63];
    result += map4[bits >> 4 & 63];
    result += map4[bits << 2 & 63];
    result += map4[64];
  } else if (tail === 1) {
    result += map4[bits >> 2 & 63];
    result += map4[bits << 4 & 63];
    result += map4[64];
    result += map4[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary2 = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object2 = data;
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys2, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys2 = Object.keys(pair);
    if (keys2.length !== 1) return false;
    result[index] = [keys2[0], pair[keys2[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys2, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    keys2 = Object.keys(pair);
    result[index] = [keys2[0], pair[keys2[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object2 = data;
  for (key in object2) {
    if (_hasOwnProperty$2.call(object2, key)) {
      if (object2[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary2,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function setProperty(object2, key, value) {
  if (key === "__proto__") {
    Object.defineProperty(object2, key, {
      configurable: true,
      enumerable: true,
      writable: true,
      value
    });
  } else {
    object2[key] = value;
  }
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i2 = 0; i2 < 256; i2++) {
  simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
  simpleEscapeMap[i2] = simpleEscapeSequence(i2);
}
var i2;
function State$1(input, options2) {
  this.input = input;
  this.filename = options2["filename"] || null;
  this.schema = options2["schema"] || _default;
  this.onWarning = options2["onWarning"] || null;
  this.legacy = options2["legacy"] || false;
  this.json = options2["json"] || false;
  this.listener = options2["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name2, args2) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args2.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args2[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args2[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name2, args2) {
    var handle2, prefix;
    if (args2.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle2 = args2[0];
    prefix = args2[1];
    if (!PATTERN_TAG_HANDLE.test(handle2)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle2)) {
      throwError(state, 'there is a previously declared suffix for "' + handle2 + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err2) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle2] = prefix;
  }
};
function captureSegment(state, start2, end, checkJson) {
  var _position, _length2, _character, _result;
  if (start2 < end) {
    _result = state.input.slice(start2, end);
    if (checkJson) {
      for (_position = 0, _length2 = _result.length; _position < _length2; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      setProperty(destination, key, source[key]);
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    setProperty(_result, keyNode, valueNode);
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count2) {
  if (count2 === 1) {
    state.result += " ";
  } else if (count2 > 1) {
    state.result += common.repeat("\n", count2 - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err2) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options2) {
  input = String(input);
  options2 = options2 || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options2);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options2) {
  if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options2);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options2) {
  var documents = loadDocuments(input, options2);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema3, map4) {
  var result, keys2, index, length, tag, style, type2;
  if (map4 === null) return {};
  result = {};
  keys2 = Object.keys(map4);
  for (index = 0, length = keys2.length; index < length; index += 1) {
    tag = keys2[index];
    style = String(map4[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema3.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string5, handle2, length;
  string5 = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle2 = "x";
    length = 2;
  } else if (character <= 65535) {
    handle2 = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle2 = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle2 + common.repeat("0", length - string5.length) + string5;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options2) {
  this.schema = options2["schema"] || _default;
  this.indent = Math.max(1, options2["indent"] || 2);
  this.noArrayIndent = options2["noArrayIndent"] || false;
  this.skipInvalid = options2["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
  this.sortKeys = options2["sortKeys"] || false;
  this.lineWidth = options2["lineWidth"] || 80;
  this.noRefs = options2["noRefs"] || false;
  this.noCompatMode = options2["noCompatMode"] || false;
  this.condenseFlow = options2["condenseFlow"] || false;
  this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options2["forceQuotes"] || false;
  this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string5, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string5.length;
  while (position < length) {
    next = string5.indexOf("\n", position);
    if (next === -1) {
      line = string5.slice(position);
      position = length;
    } else {
      line = string5.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string5, pos) {
  var first = string5.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string5.length) {
    second = string5.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string5) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string5);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string5, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i2;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string5, 0)) && isPlainSafeLast(codePointAt(string5, string5.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i2 = 0; i2 < string5.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string5, i2);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i2 = 0; i2 < string5.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string5, i2);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i2 - previousLineBreak - 1 > lineWidth && string5[previousLineBreak + 1] !== " ";
          previousLineBreak = i2;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string5[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string5)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string5)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string5, level, iskey, inblock) {
  state.dump = (function() {
    if (string5.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string5) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string5)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string5 + '"' : "'" + string5 + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string6) {
      return testImplicitResolving(state, string6);
    }
    switch (chooseScalarStyle(
      string5,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string5;
      case STYLE_SINGLE:
        return "'" + string5.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string5, state.indent) + dropEndingNewline(indentString(string5, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string5, state.indent) + dropEndingNewline(indentString(foldString(string5, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string5) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  })();
}
function blockHeader(string5, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string5) ? String(indentPerLevel) : "";
  var clip = string5[string5.length - 1] === "\n";
  var keep = clip && (string5[string5.length - 2] === "\n" || string5 === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string5) {
  return string5[string5.length - 1] === "\n" ? string5.slice(0, -1) : string5;
}
function foldString(string5, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = (function() {
    var nextLF = string5.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string5.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string5.slice(0, nextLF), width);
  })();
  var prevMoreIndented = string5[0] === "\n" || string5[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string5)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start2 = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start2 > width) {
      end = curr > start2 ? curr : next;
      result += "\n" + line.slice(start2, end);
      start2 = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start2 > width && curr > start2) {
    result += line.slice(start2, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start2);
  }
  return result.slice(1);
}
function escapeString(string5) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i2 = 0; i2 < string5.length; char >= 65536 ? i2 += 2 : i2++) {
    char = codePointAt(string5, i2);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string5[i2];
      if (char >= 65536) result += string5[i2 + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object2) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object2.length; index < length; index += 1) {
    value = object2[index];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object2, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object2.length; index < length; index += 1) {
    value = object2[index];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object2) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object2, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object2, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object2 === "object" && object2 instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object2))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object2);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object2, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object2, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object2, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object2;
  if (!detectType(state, object2, false)) {
    detectType(state, object2, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object2);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object2, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object2, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object2, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object2 !== null && typeof object2 === "object") {
    index = objects.indexOf(object2);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object2);
      if (Array.isArray(object2)) {
        for (index = 0, length = object2.length; index < length; index += 1) {
          inspectNode(object2[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object2);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object2[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options2) {
  options2 = options2 || {};
  var state = new State(options2);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// ../common/src/testUtil/serialize.ts
var CustomDump = class {
  constructor(data, opts) {
    this.data = data;
    this.opts = opts;
  }
  represent() {
    let result = dump(
      this.data,
      Object.assign({ replacer, schema: schema2 }, this.opts)
    );
    result = result.trim();
    if (result.includes("\n")) {
      result = "\n" + result;
    }
    return result;
  }
};
var customDumpType = new Type("!format", {
  kind: "scalar",
  resolve: () => false,
  instanceOf: CustomDump,
  represent: (d) => d.represent()
});
var schema2 = DEFAULT_SCHEMA.extend({ implicit: [customDumpType] });
var isObject3 = (value) => typeof value === "object" && value != null;
function hasSimpleChildren(value) {
  if (isObject3(value)) {
    return Object.values(value).every(
      (value2) => !isObject3(value2) && !Array.isArray(value2)
    );
  }
  if (Array.isArray(value)) {
    return value.every((value2) => !isObject3(value2) && !Array.isArray(value2));
  }
}
function replacer(key, value) {
  if (key === "") {
    return value;
  }
  if (hasSimpleChildren(value)) {
    return new CustomDump(value, { flowLevel: 0 });
  }
  return value;
}

// ../common/src/types/command/ActionDescriptor.ts
var simpleActionNames = [
  "addSelection",
  "addSelectionAfter",
  "addSelectionBefore",
  "breakLine",
  "clearAndSetSelection",
  "copyToClipboard",
  "cutToClipboard",
  "decrement",
  "deselect",
  "editNewLineAfter",
  "editNewLineBefore",
  "experimental.setInstanceReference",
  "extractVariable",
  "findInDocument",
  "findInWorkspace",
  "flashTargets",
  "foldRegion",
  "followLink",
  "followLinkAside",
  "gitAccept",
  "gitRevert",
  "gitStage",
  "gitUnstage",
  "increment",
  "indentLine",
  "insertCopyAfter",
  "insertCopyBefore",
  "insertEmptyLineAfter",
  "insertEmptyLineBefore",
  "insertEmptyLinesAround",
  "joinLines",
  "outdentLine",
  "randomizeTargets",
  "remove",
  "rename",
  "revealDefinition",
  "revealTypeDefinition",
  "reverseTargets",
  "scrollToBottom",
  "scrollToCenter",
  "scrollToTop",
  "setSelection",
  "setSelectionAfter",
  "setSelectionBefore",
  "showDebugHover",
  "showHover",
  "showQuickFix",
  "showReferences",
  "sortTargets",
  "toggleLineBreakpoint",
  "toggleLineComment",
  "unfoldRegion",
  "private.getTargets",
  "private.setKeyboardTarget",
  "private.showParseTree"
];
var complexActionNames = [
  "callAsFunction",
  "editNew",
  "executeCommand",
  "generateSnippet",
  "getText",
  "highlight",
  "insertSnippet",
  "moveToTarget",
  "pasteFromClipboard",
  "replace",
  "replaceWithTarget",
  "rewrapWithPairedDelimiter",
  "swapTargets",
  "wrapWithPairedDelimiter",
  "wrapWithSnippet",
  "parsed"
];
var actionNames = [
  ...simpleActionNames,
  ...complexActionNames
];

// ../common/src/types/command/command.types.ts
var LATEST_VERSION = 7;

// ../common/src/types/command/PartialTargetDescriptor.types.ts
var simpleSurroundingPairNames = [
  "angleBrackets",
  "backtickQuotes",
  "curlyBrackets",
  "doubleQuotes",
  "escapedDoubleQuotes",
  "escapedParentheses",
  "escapedSingleQuotes",
  "escapedSquareBrackets",
  "parentheses",
  "singleQuotes",
  "squareBrackets",
  "tripleBacktickQuotes",
  "tripleDoubleQuotes",
  "tripleSingleQuotes"
];
var complexSurroundingPairNames = [
  "string",
  "any",
  "collectionBoundary"
];
var surroundingPairNames = [
  ...simpleSurroundingPairNames,
  ...complexSurroundingPairNames
];
var simpleScopeTypeTypes = [
  "argumentOrParameter",
  "argumentList",
  "anonymousFunction",
  "attribute",
  "branch",
  "class",
  "className",
  "collectionItem",
  "collectionKey",
  "comment",
  "private.fieldAccess",
  "functionCall",
  "functionCallee",
  "functionName",
  "ifStatement",
  "instance",
  "list",
  "map",
  "name",
  "namedFunction",
  "regularExpression",
  "statement",
  "string",
  "type",
  "value",
  "condition",
  "section",
  "sectionLevelOne",
  "sectionLevelTwo",
  "sectionLevelThree",
  "sectionLevelFour",
  "sectionLevelFive",
  "sectionLevelSix",
  "selector",
  "unit",
  "xmlBothTags",
  "xmlElement",
  "xmlEndTag",
  "xmlStartTag",
  // Latex scope types
  "part",
  "chapter",
  "subSection",
  "subSubSection",
  "namedParagraph",
  "subParagraph",
  "environment",
  // Text based scopes
  "character",
  "word",
  "token",
  "identifier",
  "line",
  "fullLine",
  "sentence",
  "paragraph",
  "boundedParagraph",
  "document",
  "nonWhitespaceSequence",
  "boundedNonWhitespaceSequence",
  "url",
  "notebookCell",
  // Talon
  "command",
  // Private scope types
  "textFragment",
  "disqualifyDelimiter",
  "pairDelimiter",
  "interior"
];
function isSimpleScopeType(scopeType) {
  return simpleScopeTypeTypes.includes(scopeType.type);
}
var pseudoScopes = /* @__PURE__ */ new Set([
  "instance",
  "interior",
  "className",
  "functionName"
]);

// ../common/src/types/TalonSpokenForms.ts
var SUPPORTED_ENTRY_TYPES = [
  "simpleScopeTypeType",
  "complexScopeTypeType",
  "customRegex",
  "pairedDelimiter",
  "action",
  "customAction",
  "grapheme"
];
var NeedsInitialTalonUpdateError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NeedsInitialTalonUpdateError";
  }
};
var DisabledCustomSpokenFormsError = class extends Error {
  constructor() {
    super("Custom spoken forms are not currently supported in this ide");
    this.name = "DisabledCustomSpokenFormsError";
  }
};

// ../../node_modules/.pnpm/tinycolor2@1.6.0/node_modules/tinycolor2/esm/tinycolor.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;
    else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G = GsRGB / 12.92;
    else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B = BsRGB / 12.92;
    else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString3(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args2) {
    var color = fn.apply(null, [this].concat([].slice.call(args2)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args2) {
    return fn.apply(null, [this].concat([].slice.call(args2)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i2 in color) {
      if (color.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color[i2];
        } else {
          newColor[i2] = convertToPercentage(color[i2]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min2 = Math.min(r, g, b);
  var h, s, l = (max + min2) / 2;
  if (max == min2) {
    h = s = 0;
  } else {
    var d = max - min2;
    s = l > 0.5 ? d / (2 - max - min2) : d / (max + min2);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    l
  };
}
function hslToRgb(h, s, l) {
  var r, g, b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p2, q3, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p2 + (q3 - p2) * 6 * t;
    if (t < 1 / 2) return q3;
    if (t < 2 / 3) return p2 + (q3 - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  if (s === 0) {
    r = g = b = l;
  } else {
    var q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q2;
    r = hue2rgb(p, q2, h + 1 / 3);
    g = hue2rgb(p, q2, h);
    b = hue2rgb(p, q2, h - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min2 = Math.min(r, g, b);
  var h, s, v = max;
  var d = max - min2;
  s = max === 0 ? 0 : d / max;
  if (max == min2) {
    h = 0;
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    v
  };
}
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i2 = Math.floor(h), f = h - i2, p = v * (1 - s), q2 = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i2 % 6, r = [v, q2, p, p, t, v][mod], g = [t, v, v, q2, p, p][mod], b = [p, p, t, v, v, q2][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex3 = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex3[0].charAt(0) == hex3[0].charAt(1) && hex3[1].charAt(0) == hex3[1].charAt(1) && hex3[2].charAt(0) == hex3[2].charAt(1)) {
    return hex3[0].charAt(0) + hex3[1].charAt(0) + hex3[2].charAt(0);
  }
  return hex3.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex3 = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
  if (allow4Char && hex3[0].charAt(0) == hex3[0].charAt(1) && hex3[1].charAt(0) == hex3[1].charAt(1) && hex3[2].charAt(0) == hex3[2].charAt(1) && hex3[3].charAt(0) == hex3[3].charAt(1)) {
    return hex3[0].charAt(0) + hex3[1].charAt(0) + hex3[2].charAt(0) + hex3[3].charAt(0);
  }
  return hex3.join("");
}
function rgbaToArgbHex(r, g, b, a) {
  var hex3 = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex3.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number4) {
  if (isNaN(number4) || number4 <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number4;
  for (var i2 = 1; i2 < number4; i2++) {
    result.push(tinycolor({
      h: (hsl.h + i2 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h = hsv.h, s = hsv.s, v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h,
      s,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out2;
  out2 = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out2 = readability >= 4.5;
      break;
    case "AAlarge":
      out2 = readability >= 3;
      break;
    case "AAAsmall":
      out2 = readability >= 7;
      break;
  }
  return out2;
};
tinycolor.mostReadable = function(baseColor, colorList, args2) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args2 = args2 || {};
  includeFallbackColors = args2.includeFallbackColors;
  level = args2.level;
  size = args2.size;
  for (var i2 = 0; i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args2.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args2);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o) {
  var flipped = {};
  for (var i2 in o) {
    if (o.hasOwnProperty(i2)) {
      flipped[o[i2]] = i2;
    }
  }
  return flipped;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function bound01(n, max) {
  if (isOnePointZero(n)) n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }
  if (Math.abs(n - max) < 1e-6) {
    return 1;
  }
  return n % max / parseFloat(max);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}
function pad2(c) {
  return c.length == 1 ? "0" + c : "" + c;
}
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = (function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
})();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}

// ../common/src/util/clientSupportsFallback.ts
function clientSupportsFallback(command) {
  return command.version >= 7;
}

// ../common/src/util/CompositeKeyMap.ts
var CompositeKeyMap = class {
  /**
   *
   * @param hashFunction A function that maps from a key to a list whose entries can be converted to string
   */
  constructor(hashFunction) {
    this.hashFunction = hashFunction;
    __publicField(this, "map", /* @__PURE__ */ new Map());
  }
  hash(key) {
    return this.hashFunction(key).join("\0");
  }
  set(key, item) {
    this.map.set(this.hash(key), item);
    return this;
  }
  has(key) {
    return this.map.has(this.hash(key));
  }
  get(key) {
    return this.map.get(this.hash(key));
  }
  delete(key) {
    this.map.delete(this.hash(key));
    return this;
  }
  clear() {
    this.map.clear();
    return this;
  }
};

// ../common/src/util/DefaultMap.ts
var DefaultMap = class extends Map {
  /**
   * @param getDefaultValue A function that returns the default value for a given key
   */
  constructor(getDefaultValue) {
    super();
    this.getDefaultValue = getDefaultValue;
  }
  get(key) {
    const currentValue = super.get(key);
    if (currentValue != null) {
      return currentValue;
    }
    const value = this.getDefaultValue(key);
    this.set(key, value);
    return value;
  }
};

// ../common/src/util/disposableFrom.ts
function disposableFrom(...disposables) {
  return {
    dispose() {
      disposables.forEach((disposable) => {
        try {
          disposable.dispose();
        } catch (e) {
          console.error(e);
        }
      });
    }
  };
}

// ../common/src/util/type.ts
function isString(arg) {
  return typeof arg === "string" || arg instanceof String;
}

// ../common/src/util/ensureCommandShape.ts
function ensureCommandShape(args2) {
  const [spokenFormOrCommand, ...rest] = args2;
  return handleLegacyCommandShape(spokenFormOrCommand, rest);
}
function handleLegacyCommandShape(spokenFormOrCommand, rest) {
  let command;
  if (isString(spokenFormOrCommand)) {
    const spokenForm = spokenFormOrCommand;
    const [action, targets, ...extraArgs] = rest;
    command = {
      version: 0,
      spokenForm,
      action,
      targets,
      extraArgs,
      usePrePhraseSnapshot: false
    };
  } else {
    command = spokenFormOrCommand;
  }
  return command;
}

// ../common/src/util/itertools.ts
function groupBy(list, func2) {
  const map4 = /* @__PURE__ */ new Map();
  list.forEach((element) => {
    const key = func2(element);
    let group;
    if (map4.has(key)) {
      group = map4.get(key);
    } else {
      group = [];
      map4.set(key, group);
    }
    group.push(element);
  });
  return map4;
}
function isEmptyIterable(iterable) {
  for (const _ of iterable) {
    return false;
  }
  return true;
}

// ../common/src/util/object.ts
function unsafeKeys(o) {
  return Object.keys(o);
}

// ../common/src/util/stringUtils.ts
function camelCaseToAllDown(input) {
  return input.replace(/(?<=[a-z0-9])([A-Z])/g, " $1").split(" ").map((word) => word.toLowerCase()).join(" ");
}
function stringToInteger(input) {
  const trimmedValue = input.trim();
  if (trimmedValue.length === 0) {
    return void 0;
  }
  const value = Number(trimmedValue);
  if (Number.isInteger(value)) {
    return value;
  }
  return void 0;
}

// ../common/src/util/selectionsEqual.ts
function selectionsEqual(a, b) {
  return a.length === b.length && a.every((selection, i2) => selection.isEqual(b[i2]));
}

// ../common/src/util/splitKey.ts
function getKey(hatStyle, character) {
  return `${hatStyle}.${character}`;
}

// ../common/src/util/uniqWithHash.ts
function uniqWithHash(array2, isEqual2, hash2) {
  if (array2.length < 2) {
    return [...array2];
  }
  if (array2.length === 2) {
    if (isEqual2(array2[0], array2[1])) {
      return [array2[0]];
    }
    return [...array2];
  }
  const needsUniq = [];
  const hashToItems = array2.reduce((acc, item) => {
    const key = hash2(item);
    const items = acc.get(key);
    if (items == null) {
      acc.set(key, [item]);
      return acc;
    }
    acc.get(key).push(item);
    if (items.length === 2) {
      needsUniq.push(key);
    }
    return acc;
  }, /* @__PURE__ */ new Map());
  if (needsUniq.length === 0) {
    return [...array2];
  }
  needsUniq.forEach((key) => {
    hashToItems.set(key, uniqWith_default(hashToItems.get(key), isEqual2));
  });
  return array2.flatMap((item) => {
    const key = hash2(item);
    const items = hashToItems.get(key);
    if (items == null || items.length === 0) {
      return [];
    }
    const first = items[0];
    if (!isEqual2(first, item)) {
      return [];
    }
    items.shift();
    return first;
  });
}

// ../common/src/util/zipStrict.ts
function zipStrict(list1, list2) {
  if (list1.length !== list2.length) {
    throw new Error("Lists must have the same length");
  }
  return list1.map((value, index) => [value, list2[index]]);
}

// src/ide/JetbrainsHats.ts
var JetbrainsHats = class {
  constructor(client) {
    this.isEnabledNotifier = new Notifier();
    this.hatStyleChangedNotifier = new Notifier();
    this.hatRanges = [];
    this.enabledHatShapes = ["default"];
    this.hatShapePenalties = /* @__PURE__ */ new Map([["default", 0]]);
    this.enabledHatColors = ["default"];
    this.hatColorPenalties = /* @__PURE__ */ new Map([["default", 0]]);
    this.isEnabled = true;
    this.client = client;
    this.enabledHatStyles = this.generateHatStyles();
  }
  setHatRanges(hatRanges) {
    this.hatRanges = hatRanges;
    const jbHatRanges = this.toJetbransHatRanges(hatRanges);
    const hatsJson = JSON.stringify(jbHatRanges);
    this.client.hatsUpdated(hatsJson);
    return Promise.resolve();
  }
  setEnabledHatShapes(enabledHatShapes) {
    this.enabledHatShapes = enabledHatShapes;
    this.enabledHatStyles = this.generateHatStyles();
    this.hatStyleChangedNotifier.notifyListeners(this.enabledHatStyles);
  }
  setHatShapePenalties(hatShapePenalties) {
    this.hatShapePenalties = new Map(
      Object.entries(hatShapePenalties)
    );
    this.enabledHatStyles = this.generateHatStyles();
    this.hatStyleChangedNotifier.notifyListeners(this.enabledHatStyles);
  }
  setEnabledHatColors(enabledHatColors) {
    this.enabledHatColors = enabledHatColors;
    this.enabledHatStyles = this.generateHatStyles();
    this.hatStyleChangedNotifier.notifyListeners(this.enabledHatStyles);
  }
  setHatColorPenalties(hatColorPenalties) {
    this.hatColorPenalties = new Map(
      Object.entries(hatColorPenalties)
    );
    this.enabledHatStyles = this.generateHatStyles();
    this.hatStyleChangedNotifier.notifyListeners(this.enabledHatStyles);
  }
  toJetbransHatRanges(hatRanges) {
    return hatRanges.map((range3) => {
      return {
        styleName: range3.styleName,
        editorId: range3.editor.id,
        range: range3.range
      };
    });
  }
  generateHatStyles() {
    const res = /* @__PURE__ */ new Map();
    for (const color of this.enabledHatColors) {
      const colorPenalty = this.getColorPenalty(color);
      for (const shape of this.enabledHatShapes) {
        const shapePenalty = this.getShapePenalty(shape);
        let styleName;
        if (shape === "default") {
          styleName = color;
        } else {
          styleName = `${color}-${shape}`;
        }
        res.set(styleName, { penalty: colorPenalty + shapePenalty });
      }
    }
    return Object.fromEntries(res);
  }
  getShapePenalty(shape) {
    let shapePenalty = this.hatShapePenalties.get(shape);
    if (shapePenalty == null) {
      shapePenalty = shape === "default" ? 0 : 2;
    } else {
      shapePenalty = shape === "default" ? shapePenalty : shapePenalty + 1;
    }
    return shapePenalty;
  }
  getColorPenalty(color) {
    let colorPenalty = this.hatColorPenalties.get(color);
    if (colorPenalty == null) {
      colorPenalty = color === "default" ? 0 : 1;
    }
    return colorPenalty;
  }
  onDidChangeEnabledHatStyles(listener) {
    return this.hatStyleChangedNotifier.registerListener(listener);
  }
  onDidChangeIsEnabled(listener) {
    return this.isEnabledNotifier.registerListener(listener);
  }
  toggle(isEnabled) {
    this.isEnabled = isEnabled ?? !this.isEnabled;
    this.isEnabledNotifier.notifyListeners(this.isEnabled);
  }
};

// src/ide/JetbrainsPlugin.ts
var JetbrainsPlugin = class {
  constructor(client, ide2, hats) {
    this.client = client;
    this.ide = ide2;
    this.hats = hats;
  }
};
function createPlugin(client, ide2) {
  const hats = new JetbrainsHats(client);
  return new JetbrainsPlugin(client, ide2, hats);
}

// src/ide/JetbrainsConfiguration.ts
var JetbrainsConfiguration = class {
  constructor(configuration) {
    this.notifier = new Notifier();
    this.configuration = CONFIGURATION_DEFAULTS;
    this.onDidChangeConfiguration = this.notifier.registerListener;
    this.configuration = configuration;
  }
  getOwnConfiguration(path, _scope) {
    return get_default(this.configuration, path);
  }
  updateConfiguration(configuration) {
    this.configuration = configuration;
    this.notifier.notifyListeners();
  }
};
function createJetbrainsConfiguration(configuration) {
  return new JetbrainsConfiguration(configuration);
}

// src/ide/JetbrainsCapabilities.ts
var COMMAND_CAPABILITIES = {
  clipboardCopy: { acceptsLocation: true },
  clipboardPaste: true,
  toggleLineComment: { acceptsLocation: true },
  indentLine: { acceptsLocation: true },
  outdentLine: { acceptsLocation: true },
  rename: { acceptsLocation: true },
  quickFix: { acceptsLocation: true },
  revealDefinition: { acceptsLocation: true },
  revealTypeDefinition: { acceptsLocation: true },
  showHover: void 0,
  showDebugHover: void 0,
  extractVariable: { acceptsLocation: true },
  fold: { acceptsLocation: true },
  highlight: { acceptsLocation: true },
  unfold: { acceptsLocation: true },
  showReferences: { acceptsLocation: true },
  insertLineAfter: { acceptsLocation: true },
  gitAccept: { acceptsLocation: false },
  gitRevert: { acceptsLocation: false },
  gitStage: { acceptsLocation: false },
  gitUnstage: { acceptsLocation: false }
};
var JetbrainsCapabilities = class {
  constructor() {
    this.commands = COMMAND_CAPABILITIES;
  }
};

// src/ide/JetbrainsEvents.ts
function fromJetbrainsContentChange(document2, firstLine, lastLine, linedata) {
  const result = [];
  const text = linedata.join("\n");
  const range3 = new Range(
    new Position(firstLine, 0),
    new Position(lastLine - 1, document2.lineAt(lastLine - 1).text.length)
  );
  const rangeOffset = document2.offsetAt(range3.start);
  const rangeLength = document2.offsetAt(range3.end) - rangeOffset;
  result.push({
    range: range3,
    rangeOffset,
    rangeLength,
    text
  });
  return result;
}

// src/ide/JetbrainsClipboard.ts
var JetbrainsClipboard = class {
  constructor(client) {
    this.client = client;
  }
  async readText() {
    return "";
  }
  async writeText(_value) {
    return;
  }
  async copy(editorId, ranges) {
    const rangesJson = JSON.stringify(ranges);
    this.client.clipboardCopy(editorId, rangesJson);
  }
  async paste(editorId) {
    this.client.clipboardPaste(editorId);
  }
};

// src/ide/JetbrainsMessages.ts
var JetbrainsMessages = class {
  async showMessage(_type, _id, _message, ..._options) {
    return void 0;
  }
};

// src/ide/JetbrainsKeyValueStore.ts
var JetbrainsKeyValueStore = class {
  constructor() {
    this.data = { ...KEY_VALUE_STORE_DEFAULTS };
  }
  get(key) {
    return this.data[key];
  }
  set(key, value) {
    this.data[key] = value;
    return Promise.resolve();
  }
};

// ../../node_modules/.pnpm/vscode-uri@3.1.0/node_modules/vscode-uri/lib/esm/index.mjs
var LIB;
(() => {
  "use strict";
  var t = { 975: (t2) => {
    function e2(t3) {
      if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", i3 = 0, o2 = -1, s2 = 0, h2 = 0; h2 <= t3.length; ++h2) {
        if (h2 < t3.length) r3 = t3.charCodeAt(h2);
        else {
          if (47 === r3) break;
          r3 = 47;
        }
        if (47 === r3) {
          if (o2 === h2 - 1 || 1 === s2) ;
          else if (o2 !== h2 - 1 && 2 === s2) {
            if (n3.length < 2 || 2 !== i3 || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
              if (n3.length > 2) {
                var a2 = n3.lastIndexOf("/");
                if (a2 !== n3.length - 1) {
                  -1 === a2 ? (n3 = "", i3 = 0) : i3 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), o2 = h2, s2 = 0;
                  continue;
                }
              } else if (2 === n3.length || 1 === n3.length) {
                n3 = "", i3 = 0, o2 = h2, s2 = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i3 = 2);
          } else n3.length > 0 ? n3 += "/" + t3.slice(o2 + 1, h2) : n3 = t3.slice(o2 + 1, h2), i3 = h2 - o2 - 1;
          o2 = h2, s2 = 0;
        } else 46 === r3 && -1 !== s2 ? ++s2 : s2 = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", i3 = false, o2 = arguments.length - 1; o2 >= -1 && !i3; o2--) {
        var s2;
        o2 >= 0 ? s2 = arguments[o2] : (void 0 === t3 && (t3 = process.cwd()), s2 = t3), e2(s2), 0 !== s2.length && (n3 = s2 + "/" + n3, i3 = 47 === s2.charCodeAt(0));
      }
      return n3 = r2(n3, !i3), i3 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      var n3 = 47 === t3.charCodeAt(0), i3 = 47 === t3.charCodeAt(t3.length - 1);
      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i3 && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
    }, join: function() {
      if (0 === arguments.length) return ".";
      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
        var i3 = arguments[r3];
        e2(i3), i3.length > 0 && (void 0 === t3 ? t3 = i3 : t3 += "/" + i3);
      }
      return void 0 === t3 ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3) return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
      for (var i3 = 1; i3 < t3.length && 47 === t3.charCodeAt(i3); ++i3) ;
      for (var o2 = t3.length, s2 = o2 - i3, h2 = 1; h2 < r3.length && 47 === r3.charCodeAt(h2); ++h2) ;
      for (var a2 = r3.length - h2, c2 = s2 < a2 ? s2 : a2, f2 = -1, u2 = 0; u2 <= c2; ++u2) {
        if (u2 === c2) {
          if (a2 > c2) {
            if (47 === r3.charCodeAt(h2 + u2)) return r3.slice(h2 + u2 + 1);
            if (0 === u2) return r3.slice(h2 + u2);
          } else s2 > c2 && (47 === t3.charCodeAt(i3 + u2) ? f2 = u2 : 0 === u2 && (f2 = 0));
          break;
        }
        var l2 = t3.charCodeAt(i3 + u2);
        if (l2 !== r3.charCodeAt(h2 + u2)) break;
        47 === l2 && (f2 = u2);
      }
      var g2 = "";
      for (u2 = i3 + f2 + 1; u2 <= o2; ++u2) u2 !== o2 && 47 !== t3.charCodeAt(u2) || (0 === g2.length ? g2 += ".." : g2 += "/..");
      return g2.length > 0 ? g2 + r3.slice(h2 + f2) : (h2 += f2, 47 === r3.charCodeAt(h2) && ++h2, r3.slice(h2));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i3 = -1, o2 = true, s2 = t3.length - 1; s2 >= 1; --s2) if (47 === (r3 = t3.charCodeAt(s2))) {
        if (!o2) {
          i3 = s2;
          break;
        }
      } else o2 = false;
      return -1 === i3 ? n3 ? "/" : "." : n3 && 1 === i3 ? "//" : t3.slice(0, i3);
    }, basename: function(t3, r3) {
      if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, i3 = 0, o2 = -1, s2 = true;
      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3) return "";
        var h2 = r3.length - 1, a2 = -1;
        for (n3 = t3.length - 1; n3 >= 0; --n3) {
          var c2 = t3.charCodeAt(n3);
          if (47 === c2) {
            if (!s2) {
              i3 = n3 + 1;
              break;
            }
          } else -1 === a2 && (s2 = false, a2 = n3 + 1), h2 >= 0 && (c2 === r3.charCodeAt(h2) ? -1 == --h2 && (o2 = n3) : (h2 = -1, o2 = a2));
        }
        return i3 === o2 ? o2 = a2 : -1 === o2 && (o2 = t3.length), t3.slice(i3, o2);
      }
      for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
        if (!s2) {
          i3 = n3 + 1;
          break;
        }
      } else -1 === o2 && (s2 = false, o2 = n3 + 1);
      return -1 === o2 ? "" : t3.slice(i3, o2);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, i3 = -1, o2 = true, s2 = 0, h2 = t3.length - 1; h2 >= 0; --h2) {
        var a2 = t3.charCodeAt(h2);
        if (47 !== a2) -1 === i3 && (o2 = false, i3 = h2 + 1), 46 === a2 ? -1 === r3 ? r3 = h2 : 1 !== s2 && (s2 = 1) : -1 !== r3 && (s2 = -1);
        else if (!o2) {
          n3 = h2 + 1;
          break;
        }
      }
      return -1 === r3 || -1 === i3 || 0 === s2 || 1 === s2 && r3 === i3 - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i3);
    }, format: function(t3) {
      if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return (function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      })(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (0 === t3.length) return r3;
      var n3, i3 = t3.charCodeAt(0), o2 = 47 === i3;
      o2 ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var s2 = -1, h2 = 0, a2 = -1, c2 = true, f2 = t3.length - 1, u2 = 0; f2 >= n3; --f2) if (47 !== (i3 = t3.charCodeAt(f2))) -1 === a2 && (c2 = false, a2 = f2 + 1), 46 === i3 ? -1 === s2 ? s2 = f2 : 1 !== u2 && (u2 = 1) : -1 !== s2 && (u2 = -1);
      else if (!c2) {
        h2 = f2 + 1;
        break;
      }
      return -1 === s2 || -1 === a2 || 0 === u2 || 1 === u2 && s2 === a2 - 1 && s2 === h2 + 1 ? -1 !== a2 && (r3.base = r3.name = 0 === h2 && o2 ? t3.slice(1, a2) : t3.slice(h2, a2)) : (0 === h2 && o2 ? (r3.name = t3.slice(1, s2), r3.base = t3.slice(1, a2)) : (r3.name = t3.slice(h2, s2), r3.base = t3.slice(h2, a2)), r3.ext = t3.slice(s2, a2)), h2 > 0 ? r3.dir = t3.slice(0, h2 - 1) : o2 && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  } }, e = {};
  function r(n2) {
    var i3 = e[n2];
    if (void 0 !== i3) return i3.exports;
    var o2 = e[n2] = { exports: {} };
    return t[n2](o2, o2.exports, r), o2.exports;
  }
  r.d = (t2, e2) => {
    for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  };
  var n = {};
  let i2;
  if (r.r(n), r.d(n, { URI: () => l, Utils: () => I }), "object" == typeof process) i2 = "win32" === process.platform;
  else if ("object" == typeof navigator) {
    let t2 = navigator.userAgent;
    i2 = t2.indexOf("Windows") >= 0;
  }
  const o = /^\w[\w\d+.-]*$/, s = /^\//, h = /^\/\//;
  function a(t2, e2) {
    if (!t2.scheme && e2) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t2.authority}", path: "${t2.path}", query: "${t2.query}", fragment: "${t2.fragment}"}`);
    if (t2.scheme && !o.test(t2.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
    if (t2.path) {
      if (t2.authority) {
        if (!s.test(t2.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      } else if (h.test(t2.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
    }
  }
  const c = "", f = "/", u = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  class l {
    constructor(t2, e2, r2, n2, i3, o2 = false) {
      __publicField(this, "scheme");
      __publicField(this, "authority");
      __publicField(this, "path");
      __publicField(this, "query");
      __publicField(this, "fragment");
      "object" == typeof t2 ? (this.scheme = t2.scheme || c, this.authority = t2.authority || c, this.path = t2.path || c, this.query = t2.query || c, this.fragment = t2.fragment || c) : (this.scheme = /* @__PURE__ */ (function(t3, e3) {
        return t3 || e3 ? t3 : "file";
      })(t2, o2), this.authority = e2 || c, this.path = (function(t3, e3) {
        switch (t3) {
          case "https":
          case "http":
          case "file":
            e3 ? e3[0] !== f && (e3 = f + e3) : e3 = f;
        }
        return e3;
      })(this.scheme, r2 || c), this.query = n2 || c, this.fragment = i3 || c, a(this, o2));
    }
    static isUri(t2) {
      return t2 instanceof l || !!t2 && "string" == typeof t2.authority && "string" == typeof t2.fragment && "string" == typeof t2.path && "string" == typeof t2.query && "string" == typeof t2.scheme && "string" == typeof t2.fsPath && "function" == typeof t2.with && "function" == typeof t2.toString;
    }
    get fsPath() {
      return v(this, false);
    }
    with(t2) {
      if (!t2) return this;
      let { scheme: e2, authority: r2, path: n2, query: i3, fragment: o2 } = t2;
      return void 0 === e2 ? e2 = this.scheme : null === e2 && (e2 = c), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = c), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = c), void 0 === i3 ? i3 = this.query : null === i3 && (i3 = c), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = c), e2 === this.scheme && r2 === this.authority && n2 === this.path && i3 === this.query && o2 === this.fragment ? this : new d(e2, r2, n2, i3, o2);
    }
    static parse(t2, e2 = false) {
      const r2 = u.exec(t2);
      return r2 ? new d(r2[2] || c, w(r2[4] || c), w(r2[5] || c), w(r2[7] || c), w(r2[9] || c), e2) : new d(c, c, c, c, c);
    }
    static file(t2) {
      let e2 = c;
      if (i2 && (t2 = t2.replace(/\\/g, f)), t2[0] === f && t2[1] === f) {
        const r2 = t2.indexOf(f, 2);
        -1 === r2 ? (e2 = t2.substring(2), t2 = f) : (e2 = t2.substring(2, r2), t2 = t2.substring(r2) || f);
      }
      return new d("file", e2, t2, c, c);
    }
    static from(t2) {
      const e2 = new d(t2.scheme, t2.authority, t2.path, t2.query, t2.fragment);
      return a(e2, true), e2;
    }
    toString(t2 = false) {
      return b(this, t2);
    }
    toJSON() {
      return this;
    }
    static revive(t2) {
      if (t2) {
        if (t2 instanceof l) return t2;
        {
          const e2 = new d(t2);
          return e2._formatted = t2.external, e2._fsPath = t2._sep === g ? t2.fsPath : null, e2;
        }
      }
      return t2;
    }
  }
  const g = i2 ? 1 : void 0;
  class d extends l {
    constructor() {
      super(...arguments);
      __publicField(this, "_formatted", null);
      __publicField(this, "_fsPath", null);
    }
    get fsPath() {
      return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
    }
    toString(t2 = false) {
      return t2 ? b(this, true) : (this._formatted || (this._formatted = b(this, false)), this._formatted);
    }
    toJSON() {
      const t2 = { $mid: 1 };
      return this._fsPath && (t2.fsPath = this._fsPath, t2._sep = g), this._formatted && (t2.external = this._formatted), this.path && (t2.path = this.path), this.scheme && (t2.scheme = this.scheme), this.authority && (t2.authority = this.authority), this.query && (t2.query = this.query), this.fragment && (t2.fragment = this.fragment), t2;
    }
  }
  const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
  function m(t2, e2, r2) {
    let n2, i3 = -1;
    for (let o2 = 0; o2 < t2.length; o2++) {
      const s2 = t2.charCodeAt(o2);
      if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e2 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i3 && (n2 += encodeURIComponent(t2.substring(i3, o2)), i3 = -1), void 0 !== n2 && (n2 += t2.charAt(o2));
      else {
        void 0 === n2 && (n2 = t2.substr(0, o2));
        const e3 = p[s2];
        void 0 !== e3 ? (-1 !== i3 && (n2 += encodeURIComponent(t2.substring(i3, o2)), i3 = -1), n2 += e3) : -1 === i3 && (i3 = o2);
      }
    }
    return -1 !== i3 && (n2 += encodeURIComponent(t2.substring(i3))), void 0 !== n2 ? n2 : t2;
  }
  function y(t2) {
    let e2;
    for (let r2 = 0; r2 < t2.length; r2++) {
      const n2 = t2.charCodeAt(r2);
      35 === n2 || 63 === n2 ? (void 0 === e2 && (e2 = t2.substr(0, r2)), e2 += p[n2]) : void 0 !== e2 && (e2 += t2[r2]);
    }
    return void 0 !== e2 ? e2 : t2;
  }
  function v(t2, e2) {
    let r2;
    return r2 = t2.authority && t2.path.length > 1 && "file" === t2.scheme ? `//${t2.authority}${t2.path}` : 47 === t2.path.charCodeAt(0) && (t2.path.charCodeAt(1) >= 65 && t2.path.charCodeAt(1) <= 90 || t2.path.charCodeAt(1) >= 97 && t2.path.charCodeAt(1) <= 122) && 58 === t2.path.charCodeAt(2) ? e2 ? t2.path.substr(1) : t2.path[1].toLowerCase() + t2.path.substr(2) : t2.path, i2 && (r2 = r2.replace(/\//g, "\\")), r2;
  }
  function b(t2, e2) {
    const r2 = e2 ? y : m;
    let n2 = "", { scheme: i3, authority: o2, path: s2, query: h2, fragment: a2 } = t2;
    if (i3 && (n2 += i3, n2 += ":"), (o2 || "file" === i3) && (n2 += f, n2 += f), o2) {
      let t3 = o2.indexOf("@");
      if (-1 !== t3) {
        const e3 = o2.substr(0, t3);
        o2 = o2.substr(t3 + 1), t3 = e3.lastIndexOf(":"), -1 === t3 ? n2 += r2(e3, false, false) : (n2 += r2(e3.substr(0, t3), false, false), n2 += ":", n2 += r2(e3.substr(t3 + 1), false, true)), n2 += "@";
      }
      o2 = o2.toLowerCase(), t3 = o2.lastIndexOf(":"), -1 === t3 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t3), false, true), n2 += o2.substr(t3));
    }
    if (s2) {
      if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
        const t3 = s2.charCodeAt(1);
        t3 >= 65 && t3 <= 90 && (s2 = `/${String.fromCharCode(t3 + 32)}:${s2.substr(3)}`);
      } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
        const t3 = s2.charCodeAt(0);
        t3 >= 65 && t3 <= 90 && (s2 = `${String.fromCharCode(t3 + 32)}:${s2.substr(2)}`);
      }
      n2 += r2(s2, true, false);
    }
    return h2 && (n2 += "?", n2 += r2(h2, false, false)), a2 && (n2 += "#", n2 += e2 ? a2 : m(a2, false, false)), n2;
  }
  function C2(t2) {
    try {
      return decodeURIComponent(t2);
    } catch {
      return t2.length > 3 ? t2.substr(0, 3) + C2(t2.substr(3)) : t2;
    }
  }
  const A = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function w(t2) {
    return t2.match(A) ? t2.replace(A, ((t3) => C2(t3))) : t2;
  }
  var x = r(975);
  const P = x.posix || x, _ = "/";
  var I;
  !(function(t2) {
    t2.joinPath = function(t3, ...e2) {
      return t3.with({ path: P.join(t3.path, ...e2) });
    }, t2.resolvePath = function(t3, ...e2) {
      let r2 = t3.path, n2 = false;
      r2[0] !== _ && (r2 = _ + r2, n2 = true);
      let i3 = P.resolve(r2, ...e2);
      return n2 && i3[0] === _ && !t3.authority && (i3 = i3.substring(1)), t3.with({ path: i3 });
    }, t2.dirname = function(t3) {
      if (0 === t3.path.length || t3.path === _) return t3;
      let e2 = P.dirname(t3.path);
      return 1 === e2.length && 46 === e2.charCodeAt(0) && (e2 = ""), t3.with({ path: e2 });
    }, t2.basename = function(t3) {
      return P.basename(t3.path);
    }, t2.extname = function(t3) {
      return P.extname(t3.path);
    };
  })(I || (I = {})), LIB = n;
})();
var { URI, Utils } = LIB;

// src/ide/setSelections.ts
function setSelections(client, document2, editorId, selections) {
  const selectionsJson = JSON.stringify(selections);
  client.setSelection(editorId, selectionsJson);
  return Promise.resolve();
}

// src/ide/jetbrainsPerformEdits.ts
function jetbrainsPerformEdits(client, ide2, document2, id2, edits) {
  const changes = document2.edit(edits);
  const editorEdit = {
    text: document2.text,
    changes: changes.map((change) => ({
      rangeOffset: change.rangeOffset,
      rangeLength: change.rangeLength,
      text: change.text
    }))
  };
  client.documentUpdated(id2, JSON.stringify(editorEdit));
  ide2.emitDidChangeTextDocument({
    document: document2,
    contentChanges: changes
  });
}

// src/ide/JetbrainsEditorCommand.ts
var JetbrainsEditorCommand = class {
  constructor(ranges, singleRange, restoreSelection, ideCommand) {
    this.ranges = ranges;
    this.singleRange = singleRange;
    this.restoreSelection = restoreSelection;
    this.ideCommand = ideCommand;
  }
};

// src/ide/JetbrainsEditor.ts
var JetbrainsEditor = class {
  constructor(client, ide2, id2, document2, visibleRanges, selections) {
    this.client = client;
    this.ide = ide2;
    this.id = id2;
    this.document = document2;
    this.visibleRanges = visibleRanges;
    this.selections = selections;
    this.options = {
      tabSize: 4,
      insertSpaces: true
    };
    this.isActive = true;
    this.isVisible = true;
    this.isEditable = true;
    this.isWritable = true;
  }
  isEqual(other) {
    return this.id === other.id;
  }
  async setSelections(selections, _opts) {
    if (!selectionsEqual(this.selections, selections)) {
      await setSelections(this.client, this.document, this.id, selections);
      this.selections = selections;
    }
  }
  edit(edits) {
    if (!this.isWritable) {
      return Promise.resolve(false);
    }
    jetbrainsPerformEdits(this.client, this.ide, this.document, this.id, edits);
    return Promise.resolve(true);
  }
  async clipboardCopy(ranges) {
    await this.ide.clipboard.copy(this.id, ranges);
  }
  async clipboardPaste() {
    await this.ide.clipboard.paste(this.id);
  }
  async indentLine(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      true,
      "EditorIndentSelection"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async outdentLine(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      true,
      "EditorUnindentSelection"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async insertLineAfter(ranges) {
    await this.client.insertLineAfter(this.id, JSON.stringify(ranges));
  }
  focus() {
    throw new Error("focus not implemented.");
  }
  revealRange(_range) {
    return Promise.resolve();
  }
  async revealLine(lineNumber, at) {
    await this.client.revealLine(this.id, lineNumber, at);
  }
  async openLink(range3, _options) {
    const command = new JetbrainsEditorCommand(
      [range3],
      true,
      false,
      "GotoDeclaration"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async fold(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      false,
      "CollapseRegion"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async unfold(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      false,
      "ExpandRegion"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async toggleBreakpoint(_ranges) {
    throw new Error("toggleBreakpoint not implemented.");
  }
  async toggleLineComment(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      false,
      "CommentByLineComment"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async insertSnippet(snippet2, ranges) {
    console.log("insertSnippet" + snippet2);
    if (ranges != null) {
      await this.setSelections(ranges.map((range3) => range3.toSelection(false)));
    }
    await this.client.insertSnippet(this.id, snippet2);
  }
  async rename(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "RenameElement"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async showReferences(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "FindUsages"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async quickFix(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "ShowIntentionActions"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async revealDefinition(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "GotoDeclaration"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async revealTypeDefinition(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "QuickImplementations"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  showHover(_range) {
    throw new Error("showHover not implemented.");
  }
  showDebugHover(_range) {
    throw new Error("showDebugHover not implemented.");
  }
  async extractVariable(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "IntroduceVariable"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  editNewNotebookCellAbove() {
    throw new Error("editNewNotebookCellAbove not implemented.");
  }
  editNewNotebookCellBelow() {
    throw new Error("editNewNotebookCellBelow not implemented.");
  }
  async gitAccept(_range) {
    throw new Error("gitAccept not implemented.");
  }
  async gitRevert(_range) {
    throw new Error("gitRevert not implemented.");
  }
  async gitStage(_range) {
    throw new Error("gitStage not implemented.");
  }
  async gitUnstage(_range) {
    throw new Error("gitUnstage not implemented.");
  }
};

// src/ide/createTextEditor.ts
function createTextEditor(client, ide2, editorState) {
  const id2 = editorState.id;
  const uri = URI.parse(`talon-jetbrains://${id2}`);
  const languageId = editorState.languageId ?? "plaintext";
  const document2 = new InMemoryTextDocument(uri, languageId, editorState.text);
  const visibleRanges = [
    new Range(editorState.firstVisibleLine, 0, editorState.lastVisibleLine, 0)
  ];
  const selections = editorState.selections.map(
    (selection) => createSelection(document2, selection)
  );
  const editor = new JetbrainsEditor(
    client,
    ide2,
    id2,
    document2,
    visibleRanges,
    selections
  );
  editor.isActive = editorState.active;
  editor.isVisible = editorState.visible;
  editor.isEditable = editorState.editable;
  editor.isWritable = editorState.writable;
  return editor;
}
function createSelection(document2, selection) {
  return new Selection(
    createPosition(selection.anchor),
    createPosition(selection.active)
  );
}
function createPosition(jbPosition) {
  return new Position(jbPosition.line, jbPosition.column);
}

// src/ide/JetbrainsIDE.ts
var JetbrainsIDE = class {
  constructor(client, configuration) {
    this.client = client;
    this.runMode = "production";
    this.visibleNotebookEditors = [];
    this.disposables = [];
    this.quickPickReturnValue = void 0;
    this.editors = /* @__PURE__ */ new Map();
    this.onDidChangeTextDocumentNotifier = new Notifier();
    this.onDidOpenTextDocumentNotifier = new Notifier();
    this.onDidChangeTextDocumentContentNotifier = new Notifier();
    this.onDidCloseTextDocument = dummyEvent;
    this.onDidChangeActiveTextEditor = dummyEvent;
    this.onDidChangeVisibleTextEditors = dummyEvent;
    this.onDidChangeTextEditorSelection = dummyEvent;
    this.onDidChangeTextEditorVisibleRanges = dummyEvent;
    this.configuration = configuration;
    this.keyValueStore = new JetbrainsKeyValueStore();
    this.messages = new JetbrainsMessages();
    this.clipboard = new JetbrainsClipboard(this.client);
    this.capabilities = new JetbrainsCapabilities();
    this.activeProject = void 0;
    this.activeEditor = void 0;
  }
  async init() {
  }
  async showQuickPick(_items, _options) {
    throw Error("showQuickPick Not implemented");
  }
  async setHighlightRanges(highlightId, editor, ranges) {
    const editorId = editor.id;
    const rangesJson = JSON.stringify(ranges);
    this.client.setHighlightRanges(highlightId, editorId, rangesJson);
  }
  async flashRanges(flashDescriptors) {
    console.log("flashRangeses");
    const jbfs = flashDescriptors.map((flashDescriptor) => {
      const jbf = {
        editorId: flashDescriptor.editor.id,
        range: flashDescriptor.range,
        style: flashDescriptor.style
      };
      return jbf;
    });
    this.client.flashRanges(JSON.stringify(jbfs));
  }
  get assetsRoot() {
    console.log("get assetsRoot");
    throw new Error("assetsRoot not implemented.");
  }
  get cursorlessVersion() {
    console.log("get cursorlessVersion");
    throw new Error("cursorlessVersion not implemented.");
  }
  get workspaceFolders() {
    console.log("get workspaceFolders");
    throw new Error("workspaceFolders not get implemented.");
  }
  get activeTextEditor() {
    return this.activeEditor;
  }
  get activeEditableTextEditor() {
    return this.activeEditor?.isEditable ? this.activeEditor : void 0;
  }
  get visibleTextEditors() {
    return [...this.editors.values()].filter((editor) => editor.isVisible);
  }
  getEditableTextEditor(editor) {
    if (editor instanceof JetbrainsEditor) {
      if (editor.isEditable) {
        return editor;
      } else {
        throw Error(`Editor is not editable: ${editor}`);
      }
    }
    throw Error(`Unsupported text editor type: ${editor}`);
  }
  async findInDocument(_query, _editor) {
    throw Error("findInDocument Not implemented");
  }
  async findInWorkspace(_query) {
    throw Error("findInWorkspace Not implemented");
  }
  async openTextDocument(_path) {
    throw Error("openTextDocument Not implemented");
  }
  async openUntitledTextDocument(_options) {
    throw Error("openUntitledTextDocument Not implemented");
  }
  async showInputBox(_options) {
    throw Error("showInputBox Not implemented");
  }
  async executeCommand(_command, ..._args) {
    throw new Error("executeCommand Method not implemented.");
  }
  onDidChangeTextDocument(listener) {
    return this.onDidChangeTextDocumentNotifier.registerListener(listener);
  }
  onDidOpenTextDocument(listener, _thisArgs, _disposables) {
    return this.onDidOpenTextDocumentNotifier.registerListener(listener);
  }
  handleCommandError(_err) {
  }
  disposeOnExit(...disposables) {
    this.disposables.push(...disposables);
    return () => pull_default(this.disposables, ...disposables);
  }
  documentClosed(editorId) {
    this.editors.delete(editorId);
  }
  documentCreated(editorStateJson) {
    this.documentChanged(editorStateJson);
    const editorState = editorStateJson;
    const editor = this.editors.get(editorState.id);
    if (editor) {
      this.onDidOpenTextDocumentNotifier.notifyListeners(editor.document);
    }
  }
  documentChanged(editorStateJson) {
    const editorState = editorStateJson;
    const editor = this.updateTextEditors(editorState);
    const linedata = getLines(
      editorState.text,
      editorState.firstVisibleLine,
      editorState.lastVisibleLine
    );
    const contentChangeEvents = fromJetbrainsContentChange(
      editor.document,
      editorState.firstVisibleLine,
      editorState.lastVisibleLine,
      linedata
    );
    const documentChangeEvent = {
      document: editor.document,
      contentChanges: contentChangeEvents
    };
    this.emitDidChangeTextDocument(documentChangeEvent);
  }
  emitDidChangeTextDocument(event) {
    this.onDidChangeTextDocumentNotifier.notifyListeners(event);
  }
  updateTextEditors(editorState) {
    let editor = this.editors.get(editorState.id);
    if (editor) {
      updateEditor(editor, editorState);
    } else {
      editor = createTextEditor(this.client, this, editorState);
      this.editors.set(editorState.id, editor);
    }
    if (editorState.active) {
      this.activeEditor = editor;
    }
    return editor;
  }
  readQuery(filename) {
    return this.client.readQuery(filename);
  }
};
function updateEditor(editor, editorState) {
  const oldDocument = editor.document;
  editor.document = new InMemoryTextDocument(
    oldDocument.uri,
    oldDocument.languageId,
    editorState.text
  );
  editor.visibleRanges = [
    new Range(
      editorState.firstVisibleLine,
      0,
      editorState.lastVisibleLine + 1,
      0
    )
  ];
  editor.selections = editorState.selections.map(
    (selection) => createSelection(editor.document, selection)
  );
  editor.isActive = editorState.active;
  editor.isVisible = editorState.visible;
  editor.isEditable = editorState.editable;
  editor.isWritable = editorState.writable;
}
function getLines(text, firstLine, lastLine) {
  const lines = text.split("\n");
  return lines.slice(firstLine, lastLine);
}
function dummyEvent() {
  return {
    dispose() {
    }
  };
}
function createIDE(client, configuration) {
  return new JetbrainsIDE(client, configuration);
}

// ../../node_modules/.pnpm/immer@11.1.4/node_modules/immer/dist/immer.mjs
var NOTHING = /* @__PURE__ */ Symbol.for("immer-nothing");
var DRAFTABLE = /* @__PURE__ */ Symbol.for("immer-draftable");
var DRAFT_STATE = /* @__PURE__ */ Symbol.for("immer-state");
var errors = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error48, ...args2) {
  if (process.env.NODE_ENV !== "production") {
    const e = errors[error48];
    const msg = isFunction2(e) ? e.apply(null, args2) : e;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error48}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var O = Object;
var getPrototypeOf = O.getPrototypeOf;
var CONSTRUCTOR = "constructor";
var PROTOTYPE = "prototype";
var CONFIGURABLE = "configurable";
var ENUMERABLE = "enumerable";
var WRITABLE = "writable";
var VALUE = "value";
var isDraft = (value) => !!value && !!value[DRAFT_STATE];
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject(value) || isArray2(value) || !!value[DRAFTABLE] || !!value[CONSTRUCTOR]?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString();
var cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject(value) {
  if (!value || !isObjectish(value))
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null || proto === O[PROTOTYPE])
    return true;
  const Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR];
  if (Ctor === Object)
    return true;
  if (!isFunction2(Ctor))
    return false;
  let ctorString = cachedCtorStrings.get(Ctor);
  if (ctorString === void 0) {
    ctorString = Function.toString.call(Ctor);
    cachedCtorStrings.set(Ctor, ctorString);
  }
  return ctorString === objectCtorString;
}
function each(obj, iter2, strict = true) {
  if (getArchtype(obj) === 0) {
    const keys2 = strict ? Reflect.ownKeys(obj) : O.keys(obj);
    keys2.forEach((key) => {
      iter2(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter2(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : isArray2(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
var has = (thing, prop, type2 = getArchtype(thing)) => type2 === 2 ? thing.has(prop) : O[PROTOTYPE].hasOwnProperty.call(thing, prop);
var get2 = (thing, prop, type2 = getArchtype(thing)) => (
  // @ts-ignore
  type2 === 2 ? thing.get(prop) : thing[prop]
);
var set2 = (thing, propOrOldValue, value, type2 = getArchtype(thing)) => {
  if (type2 === 2)
    thing.set(propOrOldValue, value);
  else if (type2 === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
};
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
var isArray2 = Array.isArray;
var isMap = (target) => target instanceof Map;
var isSet = (target) => target instanceof Set;
var isObjectish = (target) => typeof target === "object";
var isFunction2 = (target) => typeof target === "function";
var isBoolean2 = (target) => typeof target === "boolean";
function isArrayIndex(value) {
  const n = +value;
  return Number.isInteger(n) && String(n) === value;
}
var latest = (state) => state.copy_ || state.base_;
var getFinalValue = (state) => state.modified_ ? state.copy_ : state.base_;
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (isArray2(base))
    return Array[PROTOTYPE].slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = O.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys2 = Reflect.ownKeys(descriptors);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      const desc = descriptors[key];
      if (desc[WRITABLE] === false) {
        desc[WRITABLE] = true;
        desc[CONFIGURABLE] = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          [CONFIGURABLE]: true,
          [WRITABLE]: true,
          // could live with !!desc.set as well here...
          [ENUMERABLE]: desc[ENUMERABLE],
          [VALUE]: base[key]
        };
    }
    return O.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = O.create(proto);
    return O.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    O.defineProperties(obj, {
      set: dontMutateMethodOverride,
      add: dontMutateMethodOverride,
      clear: dontMutateMethodOverride,
      delete: dontMutateMethodOverride
    });
  }
  O.freeze(obj);
  if (deep)
    each(
      obj,
      (_key, value) => {
        freeze(value, true);
      },
      false
    );
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
var dontMutateMethodOverride = {
  [VALUE]: dontMutateFrozenCollections
};
function isFrozen(obj) {
  if (obj === null || !isObjectish(obj))
    return true;
  return O.isFrozen(obj);
}
var PluginMapSet = "MapSet";
var PluginPatches = "Patches";
var PluginArrayMethods = "ArrayMethods";
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var isPluginLoaded = (pluginKey) => !!plugins[pluginKey];
var currentScope;
var getCurrentScope = () => currentScope;
var createScope = (parent_, immer_) => ({
  drafts_: [],
  parent_,
  immer_,
  // Whenever the modified draft contains a draft from another scope, we
  // need to prevent auto-freezing so the unowned draft can be finalized.
  canAutoFreeze_: true,
  unfinalizedDrafts_: 0,
  handledSet_: /* @__PURE__ */ new Set(),
  processedForPatches_: /* @__PURE__ */ new Set(),
  mapSetPlugin_: isPluginLoaded(PluginMapSet) ? getPlugin(PluginMapSet) : void 0,
  arrayMethodsPlugin_: isPluginLoaded(PluginArrayMethods) ? getPlugin(PluginArrayMethods) : void 0
});
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    scope.patchPlugin_ = getPlugin(PluginPatches);
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
var enterScope = (immer2) => currentScope = createScope(currentScope, immer2);
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
    }
    const { patchPlugin_ } = scope;
    if (patchPlugin_) {
      patchPlugin_.generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope
      );
    }
  } else {
    result = finalize(scope, baseDraft);
  }
  maybeFreeze(scope, result, true);
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    const finalValue = handleValue(value, rootScope.handledSet_, rootScope);
    return finalValue;
  }
  if (!isSameScope(state, rootScope)) {
    return value;
  }
  if (!state.modified_) {
    return state.base_;
  }
  if (!state.finalized_) {
    const { callbacks_ } = state;
    if (callbacks_) {
      while (callbacks_.length > 0) {
        const callback2 = callbacks_.pop();
        callback2(rootScope);
      }
    }
    generatePatchesAndFinalize(state, rootScope);
  }
  return state.copy_;
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function markStateFinalized(state) {
  state.finalized_ = true;
  state.scope_.unfinalizedDrafts_--;
}
var isSameScope = (state, rootScope) => state.scope_ === rootScope;
var EMPTY_LOCATIONS_RESULT = [];
function updateDraftInParent(parent, draftValue, finalizedValue, originalKey) {
  const parentCopy = latest(parent);
  const parentType = parent.type_;
  if (originalKey !== void 0) {
    const currentValue = get2(parentCopy, originalKey, parentType);
    if (currentValue === draftValue) {
      set2(parentCopy, originalKey, finalizedValue, parentType);
      return;
    }
  }
  if (!parent.draftLocations_) {
    const draftLocations = parent.draftLocations_ = /* @__PURE__ */ new Map();
    each(parentCopy, (key, value) => {
      if (isDraft(value)) {
        const keys2 = draftLocations.get(value) || [];
        keys2.push(key);
        draftLocations.set(value, keys2);
      }
    });
  }
  const locations = parent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT;
  for (const location of locations) {
    set2(parentCopy, location, finalizedValue, parentType);
  }
}
function registerChildFinalizationCallback(parent, child, key) {
  parent.callbacks_.push(function childCleanup(rootScope) {
    const state = child;
    if (!state || !isSameScope(state, rootScope)) {
      return;
    }
    rootScope.mapSetPlugin_?.fixSetContents(state);
    const finalizedValue = getFinalValue(state);
    updateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key);
    generatePatchesAndFinalize(state, rootScope);
  });
}
function generatePatchesAndFinalize(state, rootScope) {
  const shouldFinalize = state.modified_ && !state.finalized_ && (state.type_ === 3 || state.type_ === 1 && state.allIndicesReassigned_ || (state.assigned_?.size ?? 0) > 0);
  if (shouldFinalize) {
    const { patchPlugin_ } = rootScope;
    if (patchPlugin_) {
      const basePath = patchPlugin_.getPath(state);
      if (basePath) {
        patchPlugin_.generatePatches_(state, basePath, rootScope);
      }
    }
    markStateFinalized(state);
  }
}
function handleCrossReference(target, key, value) {
  const { scope_ } = target;
  if (isDraft(value)) {
    const state = value[DRAFT_STATE];
    if (isSameScope(state, scope_)) {
      state.callbacks_.push(function crossReferenceCleanup() {
        prepareCopy(target);
        const finalizedValue = getFinalValue(state);
        updateDraftInParent(target, value, finalizedValue, key);
      });
    }
  } else if (isDraftable(value)) {
    target.callbacks_.push(function nestedDraftCleanup() {
      const targetCopy = latest(target);
      if (target.type_ === 3) {
        if (targetCopy.has(value)) {
          handleValue(value, scope_.handledSet_, scope_);
        }
      } else {
        if (get2(targetCopy, key, target.type_) === value) {
          if (scope_.drafts_.length > 1 && (target.assigned_.get(key) ?? false) === true && target.copy_) {
            handleValue(
              get2(target.copy_, key, target.type_),
              scope_.handledSet_,
              scope_
            );
          }
        }
      }
    });
  }
}
function handleValue(target, handledSet, rootScope) {
  if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
    return target;
  }
  if (isDraft(target) || handledSet.has(target) || !isDraftable(target) || isFrozen(target)) {
    return target;
  }
  handledSet.add(target);
  each(target, (key, value) => {
    if (isDraft(value)) {
      const state = value[DRAFT_STATE];
      if (isSameScope(state, rootScope)) {
        const updatedValue = getFinalValue(state);
        set2(target, key, updatedValue, target.type_);
        markStateFinalized(state);
      }
    } else if (isDraftable(value)) {
      handleValue(value, handledSet, rootScope);
    }
  });
  return target;
}
function createProxyProxy(base, parent) {
  const baseIsArray = isArray2(base);
  const state = {
    type_: baseIsArray ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    // actually instantiated in `prepareCopy()`
    assigned_: void 0,
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false,
    // `callbacks` actually gets assigned in `createProxy`
    callbacks_: void 0
  };
  let target = state;
  let traps = objectTraps;
  if (baseIsArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy: proxy2 } = Proxy.revocable(target, traps);
  state.draft_ = proxy2;
  state.revoke_ = revoke;
  return [proxy2, state];
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    let arrayPlugin = state.scope_.arrayMethodsPlugin_;
    const isArrayWithStringProp = state.type_ === 1 && typeof prop === "string";
    if (isArrayWithStringProp) {
      if (arrayPlugin?.isArrayOperationMethod(prop)) {
        return arrayPlugin.createMethodInterceptor(state, prop);
      }
    }
    const source = latest(state);
    if (!has(source, prop, state.type_)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (isArrayWithStringProp && state.operationMethod && arrayPlugin?.isMutatingArrayMethod(
      state.operationMethod
    ) && isArrayIndex(prop)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      const childKey = state.type_ === 1 ? +prop : prop;
      const childDraft = createProxy(state.scope_, value, state, childKey);
      return state.copy_[childKey] = childDraft;
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_.set(prop, false);
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop, state.type_)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_.set(prop, true);
    handleCrossReference(state, prop, value);
    return true;
  },
  deleteProperty(state, prop) {
    prepareCopy(state);
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_.set(prop, false);
      markChanged(state);
    } else {
      state.assigned_.delete(prop);
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      [WRITABLE]: true,
      [CONFIGURABLE]: state.type_ !== 1 || prop !== "length",
      [ENUMERABLE]: desc[ENUMERABLE],
      [VALUE]: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
for (let key in objectTraps) {
  let fn = objectTraps[key];
  arrayTraps[key] = function() {
    const args2 = arguments;
    args2[0] = args2[0][0];
    return fn.apply(this, args2);
  };
}
arrayTraps.deleteProperty = function(state, prop) {
  if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? VALUE in desc ? desc[VALUE] : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.assigned_ = /* @__PURE__ */ new Map();
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config2) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.useStrictIteration_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (isFunction2(base) && !isFunction2(recipe)) {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args2) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args2));
        };
      }
      if (!isFunction2(recipe))
        die(6);
      if (patchListener !== void 0 && !isFunction2(patchListener))
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy2 = createProxy(scope, base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy2);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || !isObjectish(base)) {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin(PluginPatches).generateReplacementPatches_(base, result, {
            patches_: p,
            inversePatches_: ip
          });
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (isFunction2(base)) {
        return (state, ...args2) => this.produceWithPatches(state, (draft) => base(draft, ...args2));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (isBoolean2(config2?.autoFreeze))
      this.setAutoFreeze(config2.autoFreeze);
    if (isBoolean2(config2?.useStrictShallowCopy))
      this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
    if (isBoolean2(config2?.useStrictIteration))
      this.setUseStrictIteration(config2.useStrictIteration);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy2 = createProxy(scope, base, void 0);
    proxy2[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy2;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */
  setUseStrictIteration(value) {
    this.useStrictIteration_ = value;
  }
  shouldUseStrictIteration() {
    return this.useStrictIteration_;
  }
  applyPatches(base, patches) {
    let i2;
    for (i2 = patches.length - 1; i2 >= 0; i2--) {
      const patch = patches[i2];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i2 > -1) {
      patches = patches.slice(i2 + 1);
    }
    const applyPatchesImpl = getPlugin(PluginPatches).applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(rootScope, value, parent, key) {
  const [draft, state] = isMap(value) ? getPlugin(PluginMapSet).proxyMap_(value, parent) : isSet(value) ? getPlugin(PluginMapSet).proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent?.scope_ ?? getCurrentScope();
  scope.drafts_.push(draft);
  state.callbacks_ = parent?.callbacks_ ?? [];
  state.key_ = key;
  if (parent && key !== void 0) {
    registerChildFinalizationCallback(parent, state, key);
  } else {
    state.callbacks_.push(function rootDraftCleanup(rootScope2) {
      rootScope2.mapSetPlugin_?.fixSetContents(state);
      const { patchPlugin_ } = rootScope2;
      if (state.modified_ && patchPlugin_) {
        patchPlugin_.generatePatches_(state, [], rootScope2);
      }
    });
  }
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  let strict = true;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    strict = state.scope_.immer_.shouldUseStrictIteration();
  } else {
    copy = shallowCopy(value, true);
  }
  each(
    copy,
    (key, childValue) => {
      set2(copy, key, currentImpl(childValue));
    },
    strict
  );
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer = new Immer2();
var produce = immer.produce;

// ../cursorless-engine/src/core/indexArrayStrict.ts
function indexArrayStrict(arr, idx, name2) {
  if (idx >= arr.length) {
    throw Error(
      `Expected at least ${idx + 1} ${name2} but received only ${arr.length}`
    );
  }
  return arr[idx];
}

// ../cursorless-engine/src/customCommandGrammar/fillPlaceholders.ts
function fillPlaceholders(input, values2) {
  if (Array.isArray(input)) {
    return input.map((item) => fillPlaceholders(item, values2));
  }
  if (typeof input === "object" && input != null) {
    if (isPlaceholder(input)) {
      return indexArrayStrict(values2, input.index, "placeholder value");
    }
    const result = {};
    for (const key in input) {
      if (Object.prototype.hasOwnProperty.call(input, key)) {
        result[key] = fillPlaceholders(input[key], values2);
      }
    }
    return result;
  }
  return input;
}
function isPlaceholder(value) {
  return typeof value === "object" && value != null && "type" in value && value.type === "placeholder";
}

// ../cursorless-engine/src/customCommandGrammar/parseCommand.ts
var import_nearley = __toESM(require_nearley(), 1);

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/marks.ts
var hatColors = {
  blue: "blue",
  green: "green",
  red: "red",
  pink: "pink",
  yellow: "yellow",
  userColor1: "navy",
  userColor2: "apricot",
  default: null
};
var hatShapes = {
  ex: "ex",
  fox: "fox",
  wing: "wing",
  hole: "hole",
  frame: "frame",
  curve: "curve",
  eye: "eye",
  play: "play",
  crosshairs: "cross",
  bolt: "bolt",
  default: null
};
var marks = {
  cursor: "this",
  that: "that",
  source: "source",
  nothing: "nothing",
  keyboard: null,
  explicit: null,
  decoratedSymbol: null,
  lineNumber: null,
  range: null,
  target: null
};
var lineDirections = {
  modulo100: "row",
  relativeUp: "up",
  relativeDown: "down"
};
function hatColorToSpokenForm(color) {
  const result = hatColors[color];
  if (result == null) {
    throw Error(`Unknown hat color '${color}'`);
  }
  return result;
}
function hatShapeToSpokenForm(shape) {
  const result = hatShapes[shape];
  if (result == null) {
    throw Error(`Unknown hat shape '${shape}'`);
  }
  return result;
}

// ../cursorless-engine/src/spokenForms/SpokenFormMap.ts
function mapSpokenForms(input, mapper) {
  return Object.fromEntries(
    Object.entries(input).map(([spokenFormType, map4]) => [
      spokenFormType,
      Object.fromEntries(
        Object.entries(map4).map(([id2, inputValue]) => [
          id2,
          mapper(inputValue, spokenFormType, id2)
        ])
      )
    ])
    // FIXME: Don't cast here; need to make our own mapValues with stronger typing
    // using tricks from our object.d.ts
  );
}

// ../cursorless-engine/src/spokenForms/graphemes.ts
var alphabet = Object.fromEntries(
  "air bat cap drum each fine gust harp sit jury crunch look made near odd pit quench red sun trap urge vest whale plex yank zip".split(" ").map((word, index) => [
    String.fromCharCode("a".charCodeAt(0) + index),
    word
  ])
);
var digits = Object.fromEntries(
  "zero one two three four five six seven eight nine".split(" ").map((word, index) => [index.toString(), word])
);
var symbols = {
  ".": "dot",
  ",": "comma",
  ";": "semicolon",
  ":": "colon",
  "!": "bang",
  "*": "asterisk",
  "@": "at sign",
  "&": "ampersand",
  "?": "question",
  "/": "slash",
  "\\": "backslash",
  "-": "dash",
  "=": "equals",
  "+": "plus",
  "~": "tilde",
  _: "underscore",
  "#": "hash",
  "%": "percent",
  "^": "caret",
  "|": "pipe",
  $: "dollar",
  "\xA3": "pound",
  "'": "quote",
  '"': "double quote",
  "`": "back tick",
  "(": "paren",
  ")": "right paren",
  "{": "brace",
  "}": "right brace",
  "[": "square",
  "]": "right square",
  "<": "angle",
  ">": "right angle",
  "\uFFFD": "special"
};
var graphemeDefaultSpokenForms = {
  ...alphabet,
  ...digits,
  ...symbols
};

// ../cursorless-engine/src/spokenForms/spokenFormMapUtil.ts
function isDisabledByDefault(...spokenForms) {
  return {
    defaultSpokenForms: spokenForms,
    isDisabledByDefault: true,
    isPrivate: false
  };
}
function isPrivate(...spokenForms) {
  return {
    defaultSpokenForms: spokenForms,
    isDisabledByDefault: true,
    isPrivate: true
  };
}

// ../cursorless-engine/src/spokenForms/defaultSpokenFormMapCore.ts
var defaultSpokenFormMapCore = {
  pairedDelimiter: {
    curlyBrackets: "curly",
    angleBrackets: "diamond",
    escapedDoubleQuotes: "escaped quad",
    escapedSingleQuotes: "escaped twin",
    escapedParentheses: "escaped round",
    escapedSquareBrackets: "escaped box",
    doubleQuotes: "quad",
    parentheses: "round",
    backtickQuotes: "skis",
    squareBrackets: "box",
    singleQuotes: "twin",
    tripleDoubleQuotes: isPrivate("triple quad"),
    tripleSingleQuotes: isPrivate("triple twin"),
    tripleBacktickQuotes: isPrivate("triple skis"),
    any: "pair",
    string: "string",
    whitespace: "void",
    collectionBoundary: isPrivate("collection boundary")
  },
  simpleScopeTypeType: {
    argumentOrParameter: "arg",
    argumentList: "arg list",
    attribute: "attribute",
    functionCall: "call",
    functionCallee: "callee",
    className: "class name",
    class: "class",
    comment: "comment",
    functionName: "funk name",
    namedFunction: "funk",
    ifStatement: "if state",
    instance: "instance",
    collectionItem: "item",
    collectionKey: "key",
    anonymousFunction: "lambda",
    list: "list",
    map: "map",
    name: "name",
    regularExpression: "regex",
    section: "section",
    sectionLevelOne: isDisabledByDefault("one section"),
    sectionLevelTwo: isDisabledByDefault("two section"),
    sectionLevelThree: isDisabledByDefault("three section"),
    sectionLevelFour: isDisabledByDefault("four section"),
    sectionLevelFive: isDisabledByDefault("five section"),
    sectionLevelSix: isDisabledByDefault("six section"),
    selector: "selector",
    statement: "state",
    branch: "branch",
    type: "type",
    value: "value",
    condition: "condition",
    unit: "unit",
    //  XML, JSX
    xmlElement: "element",
    xmlBothTags: "tags",
    xmlStartTag: "start tag",
    xmlEndTag: "end tag",
    // LaTeX
    part: "part",
    chapter: "chapter",
    subSection: "subsection",
    subSubSection: "subsubsection",
    namedParagraph: "paragraph",
    subParagraph: "subparagraph",
    environment: "environment",
    // Talon
    command: "command",
    // Text-based scope types
    character: "char",
    word: "sub",
    token: "token",
    identifier: "identifier",
    line: "line",
    fullLine: "full line",
    sentence: "sentence",
    paragraph: "block",
    boundedParagraph: "short block",
    document: "file",
    nonWhitespaceSequence: "paint",
    boundedNonWhitespaceSequence: "short paint",
    url: "link",
    notebookCell: "cell",
    string: isPrivate("parse tree string"),
    textFragment: isPrivate("text fragment"),
    disqualifyDelimiter: isPrivate("disqualify delimiter"),
    pairDelimiter: isPrivate("pair delimiter"),
    interior: isPrivate("interior"),
    ["private.fieldAccess"]: isPrivate("access")
  },
  complexScopeTypeType: {
    glyph: "glyph"
  },
  simpleModifier: {
    excludeInterior: "bounds",
    toRawSelection: "just",
    leading: "leading",
    trailing: "trailing",
    keepContentFilter: "content",
    keepEmptyFilter: "empty",
    inferPreviousMark: "its",
    startOf: "start of",
    endOf: "end of",
    interiorOnly: "inside",
    visible: "visible",
    extendThroughStartOf: "head",
    extendThroughEndOf: "tail",
    everyScope: "every"
  },
  modifierExtra: {
    first: "first",
    last: "last",
    previous: "previous",
    next: "next",
    forward: "forward",
    backward: "backward",
    ancestor: "grand"
  },
  customRegex: {},
  action: {
    addSelection: "append",
    addSelectionAfter: "append post",
    addSelectionBefore: "append pre",
    breakLine: "break",
    scrollToBottom: "bottom",
    toggleLineBreakpoint: "break point",
    cutToClipboard: "carve",
    scrollToCenter: "center",
    clearAndSetSelection: "change",
    remove: "chuck",
    insertCopyBefore: "clone up",
    insertCopyAfter: "clone",
    toggleLineComment: "comment",
    copyToClipboard: "copy",
    scrollToTop: "crown",
    outdentLine: "dedent",
    revealDefinition: "define",
    editNewLineBefore: "drink",
    insertEmptyLineBefore: "drop",
    extractVariable: "extract",
    insertEmptyLineAfter: "float",
    foldRegion: "fold",
    followLink: "follow",
    followLinkAside: "follow split",
    flashTargets: "flash",
    deselect: "give",
    highlight: "highlight",
    showHover: "hover",
    increment: "increment",
    decrement: "decrement",
    indentLine: "indent",
    showDebugHover: "inspect",
    setSelectionAfter: "post",
    editNewLineAfter: "pour",
    setSelectionBefore: "pre",
    insertEmptyLinesAround: "puff",
    showQuickFix: "quick fix",
    showReferences: "reference",
    rename: "rename",
    reverseTargets: "reverse",
    findInDocument: "scout",
    findInWorkspace: "scout all",
    randomizeTargets: "shuffle",
    generateSnippet: "snippet make",
    sortTargets: "sort",
    setSelection: "take",
    revealTypeDefinition: "type deaf",
    unfoldRegion: "unfold",
    callAsFunction: "call",
    swapTargets: "swap",
    replaceWithTarget: "bring",
    moveToTarget: "move",
    wrapWithPairedDelimiter: "wrap",
    wrapWithSnippet: "wrap",
    rewrapWithPairedDelimiter: "repack",
    insertSnippet: "snippet",
    pasteFromClipboard: "paste",
    joinLines: "join",
    gitAccept: "git accept",
    gitRevert: "git revert",
    gitStage: "git stage",
    gitUnstage: "git unstage",
    // Was disabled by default before, but is now enabled by default
    ["experimental.setInstanceReference"]: "from",
    ["private.showParseTree"]: isPrivate("parse tree"),
    editNew: isPrivate("edit new"),
    executeCommand: isPrivate("execute command"),
    parsed: isPrivate("parsed"),
    getText: isPrivate("get text"),
    replace: isPrivate("replace"),
    ["private.getTargets"]: isPrivate("get targets"),
    ["private.setKeyboardTarget"]: isPrivate("set keyboard target")
    // These actions are implemented talon-side, usually using `getText` followed
    // by some other action.
    // applyFormatter: "format",
    // nextHomophone: "phones",
  },
  customAction: {},
  grapheme: graphemeDefaultSpokenForms
};

// ../cursorless-engine/src/spokenForms/defaultSpokenFormMap.ts
var defaultSpokenFormInfoMap = mapSpokenForms(
  defaultSpokenFormMapCore,
  (value) => typeof value === "string" ? {
    defaultSpokenForms: [value],
    isDisabledByDefault: false,
    isPrivate: false
  } : value
);
var defaultSpokenFormMap = mapSpokenForms(
  defaultSpokenFormInfoMap,
  ({ defaultSpokenForms, isDisabledByDefault: isDisabledByDefault2, isPrivate: isPrivate2 }) => ({
    spokenForms: isDisabledByDefault2 ? [] : defaultSpokenForms,
    isCustom: false,
    defaultSpokenForms,
    requiresTalonUpdate: false,
    isPrivate: isPrivate2
  })
);

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/connectives.ts
var connectives = {
  rangeExclusive: "between",
  rangeInclusive: "past",
  // Note: rangeExcludingStart has no default spoken form
  rangeExcludingStart: null,
  rangeExcludingEnd: "until",
  listConnective: "and",
  swapConnective: "with",
  sourceDestinationConnective: "to",
  before: "before",
  after: "after",
  verticalRange: "slice",
  previous: "previous",
  next: "next",
  forward: "forward",
  backward: "backward"
};

// ../cursorless-engine/src/customCommandGrammar/CommandLexer.ts
var import_moo = __toESM(require_moo(), 1);
var CommandLexer = class {
  constructor(rules) {
    __publicField(this, "mooLexer");
    this.mooLexer = import_moo.default.compile(rules);
  }
  reset(chunk, state) {
    const { mooState } = state ?? {};
    this.mooLexer.reset(chunk, mooState);
    return this;
  }
  formatError(token, message) {
    return this.mooLexer.formatError(token, message);
  }
  has(tokenType) {
    return this.mooLexer.has(tokenType);
  }
  save() {
    return {
      mooState: this.mooLexer.save()
    };
  }
  next() {
    const token = this.mooLexer.next();
    if (this.skipToken(token)) {
      return this.next();
    }
    return token;
  }
  transform({ value }) {
    return value;
  }
  skipToken(token) {
    return token?.type === "ws";
  }
};

// ../cursorless-engine/src/customCommandGrammar/lexer.ts
var tokens = {};
for (const simpleActionName2 of simpleActionNames) {
  const { spokenForms } = defaultSpokenFormMap.action[simpleActionName2];
  for (const spokenForm of spokenForms) {
    tokens[spokenForm] = {
      type: "simpleActionName",
      value: simpleActionName2
    };
  }
}
var bringMoveActionNames = [
  "replaceWithTarget",
  "moveToTarget"
];
for (const bringMoveActionName of bringMoveActionNames) {
  const { spokenForms } = defaultSpokenFormMap.action[bringMoveActionName];
  for (const spokenForm of spokenForms) {
    tokens[spokenForm] = {
      type: "bringMove",
      value: bringMoveActionName
    };
  }
}
var insertionModes = ["before", "after", "to"];
for (const insertionMode2 of insertionModes) {
  const spokenForm = connectives[insertionMode2 === "to" ? "sourceDestinationConnective" : insertionMode2];
  tokens[spokenForm] = {
    type: "insertionMode",
    value: insertionMode2
  };
}
for (const simpleScopeTypeType2 of simpleScopeTypeTypes) {
  const { spokenForms } = defaultSpokenFormMap.simpleScopeTypeType[simpleScopeTypeType2];
  for (const spokenForm of spokenForms) {
    tokens[spokenForm] = {
      type: "simpleScopeTypeType",
      value: simpleScopeTypeType2
    };
  }
}
for (const pairedDelimiter2 of surroundingPairNames) {
  const { spokenForms } = defaultSpokenFormMap.pairedDelimiter[pairedDelimiter2];
  for (const spokenForm of spokenForms) {
    tokens[spokenForm] = {
      type: "pairedDelimiter",
      value: pairedDelimiter2
    };
  }
}
for (const [mark, spokenForm] of Object.entries(marks)) {
  if (spokenForm != null) {
    tokens[spokenForm] = {
      type: "simpleMarkType",
      value: mark
    };
  }
}
defaultSpokenFormMap.modifierExtra.next.spokenForms.forEach((spokenForm) => {
  tokens[spokenForm] = {
    type: "direction",
    value: "forward"
  };
});
defaultSpokenFormMap.modifierExtra.previous.spokenForms.forEach(
  (spokenForm) => {
    tokens[spokenForm] = {
      type: "direction",
      value: "backward"
    };
  }
);
var lexer = new CommandLexer({
  ws: /[ \t]+/,
  placeholderTarget: {
    match: /<target\d*>/,
    value: (text) => text.slice(7, -1)
  },
  token: {
    match: Object.keys(tokens),
    type: (text) => tokens[text].type,
    value: (text) => tokens[text].value
  }
});

// ../cursorless-engine/src/customCommandGrammar/grammarUtil.ts
function simpleActionDescriptor(name2, target) {
  return { name: name2, target };
}
function bringMoveActionDescriptor(name2, source, destination) {
  return { name: name2, source, destination };
}
function partialPrimitiveTargetDescriptor(modifiers, mark) {
  const target = {
    type: "primitive"
  };
  if (modifiers != null) {
    target.modifiers = modifiers;
  }
  if (mark != null) {
    target.mark = mark;
  }
  return target;
}
function primitiveDestinationDescriptor(insertionMode2, target) {
  return { type: "primitive", insertionMode: insertionMode2, target };
}
function containingScopeModifier(scopeType) {
  return {
    type: "containingScope",
    scopeType
  };
}
function relativeScopeModifier(scopeType, direction2) {
  return {
    type: "relativeScope",
    scopeType,
    offset: 1,
    length: 1,
    direction: direction2
  };
}
function simpleScopeType(type2) {
  return { type: type2 };
}
function surroundingPairScopeType(delimiter) {
  return { type: "surroundingPair", delimiter };
}
function simplePartialMark(type2) {
  return { type: type2 };
}
function createPlaceholderTarget(index) {
  return {
    type: "target",
    target: {
      type: "placeholder",
      index: index.length === 0 ? 0 : parseInt(index) - 1
    }
  };
}

// ../cursorless-engine/src/customCommandGrammar/generated/grammar.ts
function id(d) {
  return d[0];
}
var grammar = {
  Lexer: lexer,
  ParserRules: [
    { "name": "main", "symbols": ["action"], "postprocess": id },
    {
      "name": "action",
      "symbols": [lexer.has("simpleActionName") ? { type: "simpleActionName" } : simpleActionName, "target"],
      "postprocess": ([simpleActionName2, target]) => simpleActionDescriptor(simpleActionName2, target)
    },
    {
      "name": "action",
      "symbols": [lexer.has("bringMove") ? { type: "bringMove" } : bringMove, "target", "destination"],
      "postprocess": ([bringMove2, target, destination]) => bringMoveActionDescriptor(bringMove2, target, destination)
    },
    { "name": "destination", "symbols": ["primitiveDestination"], "postprocess": id },
    {
      "name": "destination",
      "symbols": [lexer.has("insertionMode") ? { type: "insertionMode" } : insertionMode, "target"],
      "postprocess": ([insertionMode2, target]) => primitiveDestinationDescriptor(insertionMode2, target)
    },
    { "name": "target", "symbols": ["primitiveTarget"], "postprocess": id },
    { "name": "primitiveTarget$ebnf$1", "symbols": ["modifier"] },
    { "name": "primitiveTarget$ebnf$1", "symbols": ["primitiveTarget$ebnf$1", "modifier"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "primitiveTarget",
      "symbols": ["primitiveTarget$ebnf$1"],
      "postprocess": ([modifiers]) => partialPrimitiveTargetDescriptor(modifiers, void 0)
    },
    {
      "name": "primitiveTarget",
      "symbols": ["mark"],
      "postprocess": ([mark]) => partialPrimitiveTargetDescriptor(void 0, mark)
    },
    { "name": "primitiveTarget$ebnf$2", "symbols": ["modifier"] },
    { "name": "primitiveTarget$ebnf$2", "symbols": ["primitiveTarget$ebnf$2", "modifier"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "primitiveTarget",
      "symbols": ["primitiveTarget$ebnf$2", "mark"],
      "postprocess": ([modifiers, mark]) => partialPrimitiveTargetDescriptor(modifiers, mark)
    },
    {
      "name": "modifier",
      "symbols": ["scopeType"],
      "postprocess": ([scopeType]) => containingScopeModifier(scopeType)
    },
    {
      "name": "modifier",
      "symbols": [lexer.has("direction") ? { type: "direction" } : direction, "scopeType"],
      "postprocess": ([direction2, scopeType]) => relativeScopeModifier(scopeType, direction2)
    },
    {
      "name": "scopeType",
      "symbols": [lexer.has("simpleScopeTypeType") ? { type: "simpleScopeTypeType" } : simpleScopeTypeType],
      "postprocess": ([simpleScopeTypeType2]) => simpleScopeType(simpleScopeTypeType2)
    },
    {
      "name": "scopeType",
      "symbols": [lexer.has("pairedDelimiter") ? { type: "pairedDelimiter" } : pairedDelimiter],
      "postprocess": ([delimiter]) => surroundingPairScopeType(delimiter)
    },
    {
      "name": "mark",
      "symbols": [lexer.has("simpleMarkType") ? { type: "simpleMarkType" } : simpleMarkType],
      "postprocess": ([simpleMarkType2]) => simplePartialMark(simpleMarkType2)
    },
    {
      "name": "mark",
      "symbols": [lexer.has("placeholderTarget") ? { type: "placeholderTarget" } : placeholderTarget],
      "postprocess": ([placeholderTarget2]) => createPlaceholderTarget(placeholderTarget2)
    }
  ],
  ParserStart: "main"
};
var grammar_default = grammar;

// ../cursorless-engine/src/customCommandGrammar/parseCommand.ts
function getActionParser() {
  return new import_nearley.Parser(import_nearley.Grammar.fromCompiled(grammar_default));
}
function parseAction(input) {
  const parser = getActionParser();
  parser.feed(input);
  if (parser.results.length !== 1) {
    throw new Error(
      `Expected exactly one result, got ${parser.results.length}`
    );
  }
  return parser.results[0];
}

// ../cursorless-engine/src/customCommandGrammar/parseAndFillOutAction.ts
function parseAndFillOutAction(content, args2) {
  const parsed = parseAction(content);
  return fillPlaceholders(parsed, args2);
}

// ../cursorless-engine/src/util/getPartialTargetDescriptors.ts
function getPartialTargetDescriptors(action) {
  switch (action.name) {
    case "callAsFunction":
      return [action.callee, action.argument];
    case "replaceWithTarget":
    case "moveToTarget":
      return [
        action.source,
        ...getPartialTargetDescriptorsFromDestination(action.destination)
      ];
    case "swapTargets":
      return [action.target1, action.target2];
    case "pasteFromClipboard":
    case "insertSnippet":
    case "replace":
    case "editNew":
      return getPartialTargetDescriptorsFromDestination(action.destination);
    case "parsed":
      return getPartialTargetDescriptors(
        parseAndFillOutAction(action.content, action.arguments)
      );
    default:
      return [action.target];
  }
}
function getPartialTargetDescriptorsFromDestination(destination) {
  switch (destination.type) {
    case "list":
      return destination.destinations.map(({ target }) => target);
    case "primitive":
      return [destination.target];
    case "implicit":
      return [];
  }
}

// ../cursorless-engine/src/util/getPrimitiveTargets.ts
function getPartialPrimitiveTargets(targets) {
  return targets.flatMap(getPartialPrimitiveTargetsHelper);
}
function getPartialPrimitiveTargetsHelper(target) {
  switch (target.type) {
    case "primitive":
      return [target];
    case "list":
      return target.elements.flatMap(getPartialPrimitiveTargetsHelper);
    case "range":
      return [target.anchor, target.active].flatMap(
        getPartialPrimitiveTargetsHelper
      );
    case "implicit":
      return [];
  }
}

// ../cursorless-engine/src/core/commandVersionUpgrades/canonicalizeTargetsInPlace.ts
var SCOPE_TYPE_CANONICALIZATION_MAPPING = {
  arrowFunction: "anonymousFunction",
  dictionary: "map",
  regex: "regularExpression"
};
var COLOR_CANONICALIZATION_MAPPING = {
  purple: "pink"
};
function canonicalizeScopeTypesInPlace(target) {
  target.modifiers?.forEach((mod) => {
    if (mod.type === "containingScope" || mod.type === "everyScope") {
      mod.scopeType.type = SCOPE_TYPE_CANONICALIZATION_MAPPING[mod.scopeType.type] ?? mod.scopeType.type;
    }
  });
}
function canonicalizeColorsInPlace(target) {
  if (target.mark?.type === "decoratedSymbol") {
    target.mark.symbolColor = COLOR_CANONICALIZATION_MAPPING[target.mark.symbolColor] ?? target.mark.symbolColor;
  }
}
function canonicalizeTargetsInPlace(partialTargets) {
  getPartialPrimitiveTargets(partialTargets).forEach((target) => {
    canonicalizeScopeTypesInPlace(target);
    canonicalizeColorsInPlace(target);
  });
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV0ToV1/upgradeV0ToV1.ts
function upgradeV0ToV1(command) {
  return { ...command, version: 1 };
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV1ToV2/upgradeStrictHere.ts
var STRICT_HERE = {
  type: "primitive",
  mark: { type: "cursor" },
  selectionType: "token",
  position: "contents",
  modifier: { type: "identity" },
  insideOutsideType: "inside"
};
var IMPLICIT_TARGET = {
  type: "primitive",
  isImplicit: true
};
var upgradeStrictHere = (target) => isEqual_default(target, STRICT_HERE) ? IMPLICIT_TARGET : target;

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV1ToV2/upgradeV1ToV2.ts
function upgradeV1ToV2(command) {
  const actionName = command.action;
  return {
    spokenForm: command.spokenForm,
    action: {
      name: actionName,
      args: command.extraArgs
    },
    targets: upgradeTargets(command.targets, actionName),
    usePrePhraseSnapshot: command.usePrePhraseSnapshot ?? false,
    version: 2
  };
}
function upgradeModifier(modifier) {
  switch (modifier.type) {
    case "identity":
      return [];
    case "containingScope": {
      const { includeSiblings, scopeType, type: type2, ...rest } = modifier;
      return [
        {
          type: includeSiblings ? "everyScope" : "containingScope",
          scopeType: {
            type: scopeType
          },
          ...rest
        }
      ];
    }
    case "surroundingPair": {
      const { delimiterInclusion, ...rest } = modifier;
      const surroundingPairModifier = {
        type: "containingScope",
        scopeType: rest
      };
      if (delimiterInclusion === "interiorOnly" || delimiterInclusion === "excludeInterior") {
        if (surroundingPairModifier.scopeType.delimiter === "any") {
          return [{ type: delimiterInclusion }];
        }
        return [{ type: delimiterInclusion }, surroundingPairModifier];
      }
      return [surroundingPairModifier];
    }
    case "subpiece": {
      const { type: type2, pieceType, ...rest } = modifier;
      return [
        {
          type: "ordinalRange",
          scopeType: { type: pieceType },
          ...rest
        }
      ];
    }
    case "head":
      return [{ type: "extendThroughStartOf" }];
    case "tail":
      return [{ type: "extendThroughEndOf" }];
    default:
      return [modifier];
  }
}
function upgradePrimitiveTarget(target, action) {
  const {
    type: type2,
    isImplicit,
    mark,
    insideOutsideType,
    modifier,
    selectionType,
    position
  } = target;
  const modifiers = [];
  if (position && position !== "contents") {
    if (position === "before") {
      if (insideOutsideType === "inside") {
        modifiers.push({ type: "position", position: "start" });
      } else if (action === "remove") {
        modifiers.push({ type: "leading" });
      } else {
        modifiers.push({ type: "position", position: "before" });
      }
    } else {
      if (insideOutsideType === "inside") {
        modifiers.push({ type: "position", position: "end" });
      } else if (action === "remove") {
        modifiers.push({ type: "trailing" });
      } else {
        modifiers.push({ type: "position", position: "after" });
      }
    }
  }
  if (selectionType) {
    switch (selectionType) {
      case "token":
        if (modifier?.type === "subpiece") {
          break;
        }
      // fallthrough
      case "line":
        if (mark?.type === "lineNumber") {
          break;
        }
      // fallthrough
      default:
        modifiers.push({
          type: "containingScope",
          scopeType: { type: selectionType }
        });
    }
  }
  if (modifier) {
    modifiers.push(...upgradeModifier(modifier));
  }
  return {
    type: type2,
    isImplicit,
    // Empty array of modifiers is not allowed
    modifiers: modifiers.length > 0 ? modifiers : void 0,
    // Cursor token is just cursor position but treated as a token. This is done in the pipeline for normal cursor now
    mark: mark?.type === "cursorToken" ? void 0 : mark
  };
}
function upgradeTarget(target, action) {
  switch (target.type) {
    case "list":
      return {
        ...target,
        elements: target.elements.map(
          (target2) => upgradeTarget(target2, action)
        )
      };
    case "range": {
      const { type: type2, rangeType, start: start2, end, excludeStart, excludeEnd } = target;
      return {
        type: type2,
        rangeType,
        anchor: upgradePrimitiveTarget(start2, action),
        active: upgradePrimitiveTarget(end, action),
        excludeAnchor: excludeStart ?? false,
        excludeActive: excludeEnd ?? false
      };
    }
    case "primitive":
      return upgradePrimitiveTarget(target, action);
  }
}
function upgradeTargets(partialTargets, action) {
  return partialTargets.map((target) => upgradeTarget(target, action)).map(
    (target) => target.type === "primitive" ? upgradeStrictHere(target) : target
  );
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV2ToV3/upgradeV2ToV3.ts
function upgradeV2ToV3(command) {
  return {
    ...command,
    version: 3,
    targets: command.targets.map(upgradeTarget2)
  };
}
function upgradeTarget2(target) {
  switch (target.type) {
    case "list":
      return {
        ...target,
        elements: target.elements.map(
          (target2) => upgradeTarget2(target2)
        )
      };
    case "range": {
      const { anchor, active, ...rest } = target;
      return {
        anchor: upgradePrimitiveTarget2(
          anchor
        ),
        active: upgradePrimitiveTarget2(
          active
        ),
        ...rest
      };
    }
    case "primitive":
      return upgradePrimitiveTarget2(target);
  }
}
function upgradePrimitiveTarget2(target) {
  const modifiers = target.modifiers != null ? target.modifiers.map(updateModifier) : void 0;
  if (target.mark?.type === "lineNumber") {
    const { anchor, active } = target.mark;
    if (anchor.type !== active.type || anchor.lineNumber < 0 !== active.lineNumber < 0) {
      return {
        type: "range",
        anchor: {
          type: "primitive",
          mark: createLineNumberMarkFromPos(anchor),
          modifiers
        },
        active: {
          type: "primitive",
          mark: createLineNumberMarkFromPos(active)
        },
        excludeAnchor: false,
        excludeActive: false
      };
    }
  }
  return {
    ...target,
    mark: target.mark != null ? updateMark(target.mark) : void 0,
    modifiers
  };
}
function updateMark(mark) {
  switch (mark.type) {
    case "lineNumber":
      return createLineNumberMark(mark);
    default:
      return mark;
  }
}
function updateModifier(modifier) {
  switch (modifier.type) {
    case "ordinalRange":
      return createOrdinalModifier(modifier);
    default:
      return modifier;
  }
}
function createLineNumberMark(mark) {
  if (isEqual_default(mark.anchor, mark.active)) {
    return createLineNumberMarkFromPos(mark.anchor);
  }
  return {
    type: "range",
    anchor: createLineNumberMarkFromPos(mark.anchor),
    active: createLineNumberMarkFromPos(mark.active)
  };
}
function createOrdinalModifier(modifier) {
  if (modifier.anchor === modifier.active) {
    return createAbsoluteOrdinalModifier(modifier.scopeType, modifier.anchor);
  }
  if (modifier.anchor === 0 && modifier.active > modifier.anchor) {
    return createAbsoluteOrdinalModifier(
      modifier.scopeType,
      modifier.anchor,
      modifier.active - modifier.anchor + 1
    );
  }
  if (modifier.anchor < 0 && modifier.active === -1) {
    return createAbsoluteOrdinalModifier(
      modifier.scopeType,
      modifier.anchor,
      -modifier.anchor
    );
  }
  return {
    type: "range",
    anchor: createAbsoluteOrdinalModifier(modifier.scopeType, modifier.anchor),
    active: createAbsoluteOrdinalModifier(modifier.scopeType, modifier.active),
    excludeAnchor: modifier.excludeAnchor,
    excludeActive: modifier.excludeActive
  };
}
function createLineNumberMarkFromPos(position) {
  return {
    type: "lineNumber",
    lineNumberType: position.type,
    lineNumber: position.lineNumber
  };
}
function createAbsoluteOrdinalModifier(scopeType, start2, length = 1) {
  return {
    type: "ordinalScope",
    scopeType,
    start: start2,
    length
  };
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV3ToV4/upgradeV3ToV4.ts
function upgradeV3ToV4(command) {
  return {
    ...command,
    version: 4,
    targets: command.targets.map(upgradeTarget3)
  };
}
function upgradeTarget3(target) {
  switch (target.type) {
    case "primitive":
      return upgradePrimitiveTarget3(target);
    case "range": {
      const { anchor, ...rest } = target;
      return {
        ...rest,
        anchor: upgradePrimitiveTarget3(anchor)
      };
    }
    case "list": {
      const { elements, ...rest } = target;
      return {
        ...rest,
        elements: elements.map(upgradeTarget3)
      };
    }
  }
}
function upgradePrimitiveTarget3(target) {
  if (target.mark == null && target.modifiers == null || target.isImplicit) {
    return { type: "implicit" };
  }
  return target;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV4ToV5/upgradeV4ToV5.ts
function upgradeV4ToV5(command) {
  return {
    ...command,
    version: 5,
    action: upgradeAction(command.action),
    targets: command.targets.map(upgradeTarget4)
  };
}
function upgradeAction(action) {
  switch (action.name) {
    case "wrapWithSnippet": {
      const [name2, variableName] = parseSnippetLocation(
        action.args[0]
      );
      return {
        name: "wrapWithSnippet",
        args: [
          {
            type: "named",
            name: name2,
            variableName
          }
        ]
      };
    }
    case "insertSnippet": {
      const [name2, substitutions] = action.args;
      const snippetDescription = {
        type: "named",
        name: name2
      };
      if (substitutions != null) {
        snippetDescription.substitutions = substitutions;
      }
      return {
        name: "insertSnippet",
        args: [snippetDescription]
      };
    }
    default:
      return action;
  }
}
function parseSnippetLocation(snippetLocation) {
  const [snippetName, placeholderName] = snippetLocation.split(".");
  if (snippetName == null || placeholderName == null) {
    throw new Error("Snippet location missing '.'");
  }
  return [snippetName, placeholderName];
}
function upgradeTarget4(target) {
  switch (target.type) {
    case "implicit":
      return target;
    case "list":
      return {
        ...target,
        elements: target.elements.map(
          upgradeTarget4
        )
      };
    case "range":
      return {
        ...target,
        anchor: upgradeTarget4(
          target.anchor
        ),
        active: upgradeTarget4(
          target.active
        )
      };
    case "primitive":
      return {
        ...target,
        mark: target.mark != null ? upgradeMark(target.mark) : void 0,
        modifiers: target.modifiers != null && target.modifiers.length > 0 ? target.modifiers.map(upgradeModifier2) : void 0
      };
  }
}
function upgradeMark(mark) {
  if (mark.type === "range") {
    return {
      ...mark,
      anchor: upgradeMark(mark.anchor),
      active: upgradeMark(mark.active),
      excludeAnchor: mark.excludeAnchor ?? false,
      excludeActive: mark.excludeActive ?? false
    };
  }
  return mark;
}
function upgradeModifier2(modifier) {
  if (modifier.type === "range") {
    return {
      ...modifier,
      anchor: upgradeModifier2(modifier.anchor),
      active: upgradeModifier2(modifier.active),
      excludeAnchor: modifier.excludeAnchor ?? false,
      excludeActive: modifier.excludeActive ?? false
    };
  }
  return modifier;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV5ToV6/canonicalizeActionName.ts
var actionAliasToCanonicalName = {
  bring: "replaceWithTarget",
  call: "callAsFunction",
  clear: "clearAndSetSelection",
  commentLines: "toggleLineComment",
  copy: "copyToClipboard",
  cut: "cutToClipboard",
  delete: "remove",
  editNewLineAbove: "editNewLineBefore",
  editNewLineBelow: "editNewLineAfter",
  findInFiles: "findInWorkspace",
  fold: "foldRegion",
  indentLines: "indentLine",
  insertEmptyLineAbove: "insertEmptyLineBefore",
  insertEmptyLineBelow: "insertEmptyLineAfter",
  insertLineAfter: "editNewLineAfter",
  insertLineBefore: "editNewLineBefore",
  move: "moveToTarget",
  outdentLines: "outdentLine",
  paste: "pasteFromClipboard",
  reverse: "reverseTargets",
  setBreakpoint: "toggleLineBreakpoint",
  sort: "sortTargets",
  swap: "swapTargets",
  unfold: "unfoldRegion",
  use: "replaceWithTarget",
  wrap: "wrapWithPairedDelimiter"
};
function canonicalizeActionName(actionName) {
  const canonicalName = actionAliasToCanonicalName[actionName] ?? actionName;
  if (!actionNames.includes(canonicalName)) {
    throw new Error(`Unknown action name: ${canonicalName}`);
  }
  return canonicalName;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV5ToV6/upgradeV5ToV6.ts
function upgradeV5ToV6(command) {
  return {
    version: 6,
    spokenForm: command.spokenForm,
    usePrePhraseSnapshot: command.usePrePhraseSnapshot,
    action: upgradeAction2(command.action, command.targets)
  };
}
function upgradeAction2(action, targets) {
  const name2 = canonicalizeActionName(action.name);
  switch (name2) {
    case "replaceWithTarget":
    case "moveToTarget":
      return {
        name: name2,
        source: upgradeTarget5(targets[0]),
        destination: targetToDestination(targets[1])
      };
    case "swapTargets":
      return {
        name: name2,
        target1: upgradeTarget5(targets[0]),
        target2: upgradeTarget5(targets[1])
      };
    case "callAsFunction":
      return {
        name: name2,
        callee: upgradeTarget5(targets[0]),
        argument: upgradeTarget5(targets[1])
      };
    case "pasteFromClipboard":
      return {
        name: name2,
        destination: targetToDestination(targets[0])
      };
    case "wrapWithPairedDelimiter":
    case "rewrapWithPairedDelimiter":
      return {
        name: name2,
        left: action.args[0],
        right: action.args[1],
        target: upgradeTarget5(targets[0])
      };
    case "generateSnippet":
      return {
        name: name2,
        snippetName: action.args?.[0],
        target: upgradeTarget5(targets[0])
      };
    case "insertSnippet":
      return {
        name: name2,
        snippetDescription: action.args[0],
        destination: targetToDestination(targets[0])
      };
    case "wrapWithSnippet":
      return {
        name: name2,
        snippetDescription: action.args[0],
        target: upgradeTarget5(targets[0])
      };
    case "executeCommand":
      return {
        name: name2,
        commandId: action.args[0],
        options: action.args?.[1],
        target: upgradeTarget5(targets[0])
      };
    case "replace":
      return {
        name: name2,
        replaceWith: action.args[0],
        destination: targetToDestination(targets[0])
      };
    case "highlight": {
      const result = {
        name: name2,
        target: upgradeTarget5(targets[0])
      };
      if (action.args?.[0] != null) {
        result.highlightId = action.args?.[0];
      }
      return result;
    }
    case "editNew":
      return {
        name: name2,
        destination: targetToDestination(targets[0])
      };
    case "getText":
      return {
        name: name2,
        options: action.args?.[0],
        target: upgradeTarget5(targets[0])
      };
    case "parsed":
      throw Error("Parsed action should not be present in V5");
    default:
      return {
        name: name2,
        target: upgradeTarget5(targets[0])
      };
  }
}
function upgradeTarget5(target) {
  switch (target.type) {
    case "list":
    case "range":
    case "primitive":
      return upgradeNonImplicitTarget(target);
    case "implicit":
      return target;
  }
}
function upgradeNonImplicitTarget(target) {
  switch (target.type) {
    case "list":
      return upgradeListTarget(target);
    case "range":
    case "primitive":
      return upgradeRangeOrPrimitiveTarget(target);
  }
}
function upgradeListTarget(target) {
  return {
    ...target,
    elements: target.elements.map(upgradeRangeOrPrimitiveTarget)
  };
}
function upgradeRangeOrPrimitiveTarget(target) {
  switch (target.type) {
    case "range":
      return upgradeRangeTarget(target);
    case "primitive":
      return upgradePrimitiveTarget4(target);
  }
}
function upgradeRangeTarget(target) {
  const { anchor, active } = target;
  const result = {
    type: "range",
    anchor: anchor.type === "implicit" ? anchor : upgradePrimitiveTarget4(anchor),
    active: upgradePrimitiveTarget4(active),
    excludeAnchor: target.excludeAnchor,
    excludeActive: target.excludeActive
  };
  if (target.rangeType != null) {
    result.rangeType = target.rangeType;
  }
  return result;
}
function upgradePrimitiveTarget4(target) {
  const result = {
    type: "primitive"
  };
  const modifiers = upgradeModifiers(target.modifiers);
  if (modifiers != null) {
    result.modifiers = modifiers;
  }
  if (target.mark != null) {
    result.mark = target.mark;
  }
  return result;
}
function targetToDestination(target) {
  switch (target.type) {
    case "list":
      return listTargetToDestination(target);
    case "range":
      return rangeTargetToDestination(target);
    case "primitive":
      return primitiveTargetToDestination(target);
    case "implicit":
      return implicitTargetToDestination();
  }
}
function listTargetToDestination(target) {
  const destinations = [];
  let currentElements = [];
  let currentInsertionMode = void 0;
  const potentiallyAddDestination = () => {
    if (currentElements.length > 0) {
      destinations.push({
        type: "primitive",
        insertionMode: currentInsertionMode ?? "to",
        target: currentElements.length === 1 ? currentElements[0] : {
          type: "list",
          elements: currentElements
        }
      });
    }
  };
  target.elements.forEach((element) => {
    const insertionMode2 = getInsertionMode(element);
    if (insertionMode2 != null) {
      potentiallyAddDestination();
      currentElements = [upgradeRangeOrPrimitiveTarget(element)];
      currentInsertionMode = insertionMode2;
    } else {
      currentElements.push(upgradeRangeOrPrimitiveTarget(element));
    }
  });
  potentiallyAddDestination();
  if (destinations.length > 1) {
    return {
      type: "list",
      destinations
    };
  }
  return destinations[0];
}
function rangeTargetToDestination(target) {
  return {
    type: "primitive",
    insertionMode: getInsertionMode(target.anchor) ?? "to",
    target: upgradeRangeTarget(target)
  };
}
function primitiveTargetToDestination(target) {
  return {
    type: "primitive",
    insertionMode: getInsertionMode(target) ?? "to",
    target: upgradePrimitiveTarget4(target)
  };
}
function implicitTargetToDestination() {
  return { type: "implicit" };
}
function getInsertionMode(target) {
  switch (target.type) {
    case "implicit":
      return "to";
    case "primitive":
      return getInsertionModeFromPrimitive(target);
    case "range":
      return getInsertionMode(target.anchor);
  }
}
function getInsertionModeFromPrimitive(target) {
  const positionModifier = target.modifiers?.find(
    (m) => m.type === "position"
  );
  if (positionModifier != null) {
    if (target.modifiers.indexOf(positionModifier) !== 0) {
      throw Error("Position modifier has to be at first index");
    }
    if (positionModifier?.position === "before" || positionModifier?.position === "after") {
      return positionModifier.position;
    }
  }
  return void 0;
}
function upgradeModifiers(modifiers) {
  const result = [];
  if (modifiers != null) {
    for (const modifier of modifiers) {
      if (modifier.type === "position") {
        if (modifier.position === "start") {
          result.push({ type: "startOf" });
        } else if (modifier.position === "end") {
          result.push({ type: "endOf" });
        }
      } else {
        result.push(modifier);
      }
    }
  }
  return result.length > 0 ? result : void 0;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV6ToV7.ts
function upgradeV6ToV7(command) {
  return { ...command, version: 7 };
}

// ../cursorless-engine/src/core/commandVersionUpgrades/canonicalizeAndValidateCommand.ts
function canonicalizeAndValidateCommand(command) {
  const commandUpgraded = upgradeCommand(command, LATEST_VERSION);
  const { action, usePrePhraseSnapshot = false, spokenForm } = commandUpgraded;
  return {
    version: LATEST_VERSION,
    spokenForm,
    action: produce(action, (draft) => {
      const partialTargets = getPartialTargetDescriptors(draft);
      canonicalizeTargetsInPlace(partialTargets);
      validateCommand(action.name, partialTargets);
    }),
    usePrePhraseSnapshot
  };
}
function upgradeCommand(command, minimumVersion) {
  if (command.version > LATEST_VERSION) {
    throw new OutdatedExtensionError();
  }
  while (command.version < minimumVersion) {
    switch (command.version) {
      case 0:
        command = upgradeV0ToV1(command);
        break;
      case 1:
        command = upgradeV1ToV2(command);
        break;
      case 2:
        command = upgradeV2ToV3(command);
        break;
      case 3:
        command = upgradeV3ToV4(command);
        break;
      case 4:
        command = upgradeV4ToV5(command);
        break;
      case 5:
        command = upgradeV5ToV6(command);
        break;
      case 6:
        command = upgradeV6ToV7(command);
        break;
      default:
        throw new Error(
          `Can't upgrade from unknown version ${command.version}`
        );
    }
  }
  return command;
}
function validateCommand(_actionName, _partialTargets) {
}

// ../cursorless-engine/src/singletons/ide.singleton.ts
var ide_;
function injectIde(ide2) {
  ide_ = ide2;
}
function ide() {
  if (ide_ == null) {
    throw Error("Tried to access ide before it was injected");
  }
  return ide_;
}

// ../cursorless-engine/src/core/UndoStack.ts
var UndoStack = class {
  constructor(maxLength) {
    this.maxLength = maxLength;
    __publicField(this, "stack", []);
    __publicField(this, "index");
  }
  /**
   * Push a new state onto the stack. If {@link undo} has been called, the
   * future states will be dropped and the new state will be pushed onto the
   * stack.
   *
   * @param item The new state to push onto the stack
   */
  push(item) {
    if (this.index != null) {
      this.stack.splice(
        this.index + 1,
        this.stack.length - this.index - 1,
        item
      );
    } else {
      this.stack.push(item);
    }
    if (this.stack.length > this.maxLength) {
      this.stack.shift();
    }
    this.index = this.stack.length - 1;
  }
  /**
   * Undo to the previous state.
   *
   * @returns The previous state, or `undefined` if there are no previous states
   */
  undo() {
    if (this.index != null && this.index > 0) {
      this.index--;
      return this.stack[this.index];
    }
    return void 0;
  }
  /**
   * Redo to the next state.
   *
   * @returns The next state, or `undefined` if there are no future states
   */
  redo() {
    if (this.index != null && this.index < this.stack.length - 1) {
      this.index++;
      return this.stack[this.index];
    }
    return void 0;
  }
};

// ../cursorless-engine/src/core/StoredTargets.ts
var MAX_HISTORY_LENGTH = 25;
var StoredTargetMap = class {
  constructor() {
    __publicField(this, "targetMap", /* @__PURE__ */ new Map());
    // FIXME: Keep these targets up to date as document changes
    __publicField(this, "targetHistory", new DefaultMap(() => new UndoStack(MAX_HISTORY_LENGTH)));
    __publicField(this, "notifier", new Notifier());
  }
  set(key, targets, { history = false } = {}) {
    this.targetMap.set(key, targets);
    if (history && targets != null) {
      this.targetHistory.get(key).push(targets);
    }
    this.notifier.notifyListeners(key, targets);
  }
  get(key) {
    return this.targetMap.get(key);
  }
  undo(key) {
    const targets = this.targetHistory.get(key).undo();
    if (targets != null) {
      this.set(key, targets, { history: false });
    }
  }
  redo(key) {
    const targets = this.targetHistory.get(key).redo();
    if (targets != null) {
      this.set(key, targets, { history: false });
    }
  }
  onStoredTargets(callback2) {
    for (const key of storedTargetKeys) {
      callback2(key, this.get(key));
    }
    return this.notifier.registerListener(callback2);
  }
};

// ../cursorless-engine/src/util/targetUtils.ts
function ensureSingleEditor(targets) {
  if (targets.length === 0) {
    throw new Error("Require at least one target with this action");
  }
  const editors = targets.map((target) => target.editor);
  if (new Set(editors).size > 1) {
    throw new Error("Can only have one editor with this action");
  }
  return editors[0];
}
function ensureSingleTarget(targets) {
  if (targets.length !== 1) {
    throw new Error("Can only have one target with this action");
  }
  return targets[0];
}
async function runForEachEditor(targets, getEditor2, func2) {
  return Promise.all(
    groupForEachEditor(targets, getEditor2).map(
      ([editor, editorTargets]) => func2(editor, editorTargets)
    )
  );
}
async function runOnTargetsForEachEditor(targets, func2) {
  return runForEachEditor(targets, (target) => target.editor, func2);
}
async function runOnTargetsForEachEditorSequentially(targets, func2) {
  const editorGroups = groupForEachEditor(targets, (target) => target.editor);
  const result = [];
  for (const [editor, targets2] of editorGroups) {
    result.push(await func2(editor, targets2));
  }
  return result;
}
function groupTargetsForEachEditor(targets) {
  return groupForEachEditor(targets, (target) => target.editor);
}
function groupForEachEditor(targets, getEditor2) {
  const getDocumentUri = (target) => getEditor2(target).document.uri;
  const editorMap = groupBy(targets, getDocumentUri);
  return Array.from(editorMap.values(), (editorTargets) => {
    const editor = getEditor2(editorTargets[0]);
    return [editor, editorTargets];
  });
}
function createThatMark(targets, ranges) {
  const thatMark = ranges != null ? zip_default(targets, ranges).map(([target, range3]) => ({
    editor: target.editor,
    selection: target?.isReversed ? new Selection(range3.end, range3.start) : new Selection(range3.start, range3.end)
  })) : targets.map((target) => ({
    editor: target.editor,
    selection: target.contentSelection
  }));
  return thatMark;
}
function toGeneralizedRange(target, range3) {
  return target.textualType === "line" ? toLineRange(range3) : toCharacterRange(range3);
}
function toGeneralizedContentRange(target) {
  return toGeneralizedRange(target, target.contentRange);
}
function flashTargets(ide2, targets, style, getRange = toGeneralizedContentRange) {
  return ide2.flashRanges(
    targets.map((target) => ({
      editor: target.editor,
      range: getRange(target),
      style
    }))
  );
}

// ../cursorless-engine/src/util/rangeUtils.ts
function expandToFullLine(editor, range3) {
  return new Range(
    new Position(range3.start.line, 0),
    editor.document.lineAt(range3.end).range.end
  );
}
function getRangeLength(editor, range3) {
  if (range3.isEmpty) {
    return 0;
  }
  if (range3.isSingleLine) {
    return range3.end.character - range3.start.character;
  }
  return editor.document.offsetAt(range3.end) - editor.document.offsetAt(range3.start);
}
function strictlyContains(range1, rangeOrPosition) {
  const [start2, end] = rangeOrPosition instanceof Position ? [rangeOrPosition, rangeOrPosition] : [rangeOrPosition.start, rangeOrPosition.end];
  return range1.start.isBefore(start2) && range1.end.isAfter(end);
}
function union(range3, ...unionWith) {
  for (const r of unionWith) {
    if (r != null) {
      range3 = range3.union(r);
    }
  }
  return range3;
}

// ../cursorless-engine/src/processTargets/targets/DestinationImpl.ts
var DestinationImpl = class _DestinationImpl {
  constructor(target, insertionMode2, indentationString) {
    this.target = target;
    this.insertionMode = insertionMode2;
    __publicField(this, "contentRange");
    __publicField(this, "isLineDelimiter");
    __publicField(this, "isBefore");
    __publicField(this, "indentationString");
    __publicField(this, "insertionPrefix");
    this.contentRange = getContentRange(target.contentRange, insertionMode2);
    this.isBefore = insertionMode2 === "before";
    this.isLineDelimiter = target.insertionDelimiter.includes("\n");
    this.indentationString = indentationString ?? this.isLineDelimiter ? getIndentationString(target.editor, target.contentRange) : "";
    this.insertionPrefix = target.prefixRange != null ? target.editor.document.getText(target.prefixRange) : void 0;
  }
  get contentSelection() {
    return this.contentRange.toSelection(this.target.isReversed);
  }
  get editor() {
    return this.target.editor;
  }
  get insertionDelimiter() {
    return this.target.insertionDelimiter;
  }
  get isRaw() {
    return this.target.isRaw;
  }
  /**
   * Creates a new destination with the given target while preserving insertion
   * mode and indentation string from this destination. This is important
   * because our "edit new" code updates the content range of the target when
   * multiple edits are performed in the same document, but we want to insert
   * the original indentation.
   */
  withTarget(target) {
    return new _DestinationImpl(
      target,
      this.insertionMode,
      this.indentationString
    );
  }
  getEditNewActionType() {
    if (this.insertionMode === "after" && this.target.contentRange.isSingleLine && this.insertionDelimiter === "\n" && this.insertionPrefix == null) {
      return "insertLineAfter";
    }
    return "edit";
  }
  constructChangeEdit(text, skipIndentation = false) {
    return this.insertionMode === "before" || this.insertionMode === "after" ? this.constructEditWithDelimiters(text, skipIndentation) : this.constructEditWithoutDelimiters(text);
  }
  constructEditWithDelimiters(text, skipIndentation) {
    const range3 = this.getEditRange();
    const editText2 = this.getEditText(text, skipIndentation);
    const updateRange = (range4) => {
      return this.updateRange(range4, text, skipIndentation);
    };
    return {
      range: range3,
      text: editText2,
      isReplace: this.insertionMode === "after",
      updateRange
    };
  }
  constructEditWithoutDelimiters(text) {
    return {
      range: this.contentRange,
      text,
      updateRange: (range3) => range3
    };
  }
  getEditRange() {
    const position = (() => {
      const insertionPosition = this.isBefore ? union(this.target.contentRange, this.target.prefixRange).start : this.target.contentRange.end;
      if (this.isLineDelimiter) {
        const line = this.editor.document.lineAt(insertionPosition);
        const trimmedPosition = this.isBefore ? line.rangeTrimmed?.start ?? line.range.start : line.rangeTrimmed?.end ?? line.range.end;
        if (insertionPosition.isEqual(trimmedPosition)) {
          return this.isBefore ? line.range.start : line.range.end;
        }
      }
      return insertionPosition;
    })();
    return new Range(position, position);
  }
  getEditText(text, skipIndentation) {
    const indentationString = skipIndentation ? "" : this.indentationString;
    const insertionText = indentationString + (this.insertionPrefix ?? "") + text;
    return this.isBefore ? insertionText + this.insertionDelimiter : this.insertionDelimiter + insertionText;
  }
  updateRange(range3, text, skipIndentation) {
    const baseStartOffset = this.editor.document.offsetAt(range3.start) + (skipIndentation ? 0 : this.indentationString.length) + (this.insertionPrefix?.length ?? 0);
    const startIndex = this.isBefore ? baseStartOffset : baseStartOffset + this.getLengthOfInsertionDelimiter();
    const endIndex = startIndex + text.length;
    return new Range(
      this.editor.document.positionAt(startIndex),
      this.editor.document.positionAt(endIndex)
    );
  }
  getLengthOfInsertionDelimiter() {
    if (this.editor.document.eol === "CRLF") {
      const matches = this.insertionDelimiter.match(/\n/g);
      if (matches != null) {
        return this.insertionDelimiter.length + matches.length;
      }
    }
    return this.insertionDelimiter.length;
  }
};
function getIndentationString(editor, range3) {
  let length = Number.MAX_SAFE_INTEGER;
  let indentationString = "";
  for (let i2 = range3.start.line; i2 <= range3.end.line; ++i2) {
    const line = editor.document.lineAt(i2);
    if (line.range.isEmpty || line.isEmptyOrWhitespace && !range3.isSingleLine) {
      continue;
    }
    const trimmedPosition = line.rangeTrimmed?.start ?? line.range.end;
    if (trimmedPosition.character < length) {
      length = trimmedPosition.character;
      indentationString = line.text.slice(0, length);
    }
  }
  return indentationString;
}
function getContentRange(contentRange, insertionMode2) {
  switch (insertionMode2) {
    case "before":
      return contentRange.start.toEmptyRange();
    case "after":
      return contentRange.end.toEmptyRange();
    case "to":
      return contentRange;
  }
}

// ../cursorless-engine/src/processTargets/targets/util/createContinuousRange.ts
function createContinuousRange(startTarget, endTarget, includeStart, includeEnd) {
  return createContinuousRangeFromRanges(
    startTarget.contentRange,
    endTarget.contentRange,
    includeStart,
    includeEnd
  );
}
function createContinuousRangeFromRanges(startRange, endRange, includeStart, includeEnd) {
  return new Range(
    includeStart ? startRange.start : startRange.end,
    includeEnd ? endRange.end : endRange.start
  );
}
function createContinuousLineRange(startTarget, endTarget, includeStart, includeEnd) {
  const start2 = includeStart ? startTarget.contentRange.start : new Position(startTarget.contentRange.end.line + 1, 0);
  const end = includeEnd ? endTarget.contentRange.end : endTarget.editor.document.lineAt(endTarget.contentRange.start.line - 1).range.end;
  return new Range(start2, end);
}

// ../cursorless-engine/src/processTargets/targets/BaseTarget.ts
var BaseTarget = class _BaseTarget {
  constructor(parameters) {
    __publicField(this, "state");
    __publicField(this, "hasExplicitScopeType", true);
    __publicField(this, "hasExplicitRange", true);
    __publicField(this, "isRaw", false);
    __publicField(this, "isImplicit", false);
    __publicField(this, "isNotebookCell", false);
    __publicField(this, "textualType", "token");
    this.state = {
      editor: parameters.editor,
      isReversed: parameters.isReversed,
      contentRange: parameters.contentRange,
      thatTarget: parameters.thatTarget
    };
  }
  get editor() {
    return this.state.editor;
  }
  get isReversed() {
    return this.state.isReversed;
  }
  get thatTarget() {
    return this.state.thatTarget != null ? this.state.thatTarget.thatTarget : this;
  }
  get contentText() {
    return this.editor.document.getText(this.contentRange);
  }
  get contentSelection() {
    return this.contentRange.toSelection(this.isReversed);
  }
  get contentRange() {
    return this.state.contentRange;
  }
  constructRemovalEdit() {
    return {
      range: this.getRemovalRange(),
      text: "",
      updateRange: (range3) => range3
    };
  }
  getRemovalHighlightRange() {
    return toGeneralizedRange(this, this.getRemovalRange());
  }
  withThatTarget(thatTarget) {
    return this.cloneWith({ thatTarget });
  }
  withContentRange(contentRange) {
    return this.cloneWith({ contentRange });
  }
  getInterior() {
    return void 0;
  }
  getBoundary() {
    return void 0;
  }
  cloneWith(parameters) {
    const constructor = Object.getPrototypeOf(this).constructor;
    return new constructor({
      ...this.getCloneParameters(),
      ...parameters
    });
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    const { constructor } = Object.getPrototypeOf(this);
    return new constructor({
      ...this.getCloneParameters(),
      isReversed,
      contentRange: createContinuousRange(this, endTarget, true, true)
    });
  }
  isEqual(otherTarget) {
    return otherTarget instanceof _BaseTarget && isEqual_default(this.getEqualityParameters(), otherTarget.getEqualityParameters());
  }
  /**
   * Constructs an object that can be used for determining equality between two
   * {@link BaseTarget} objects. We proceed by just getting the objects clone
   * parameters and removing the `thatTarget`.
   *
   * We would prefer to instead merge the `thatTarget`s into a list. See #780
   * for more details.
   *
   * @returns The object to be used for determining equality
   */
  getEqualityParameters() {
    const { thatTarget, ...otherCloneParameters } = this.getCloneParameters();
    return {
      ...otherCloneParameters
    };
  }
  toDestination(insertionMode2) {
    return new DestinationImpl(this, insertionMode2);
  }
  /**
   * Converts the target to a plain object representation.
   *
   * Note that this implementation is quite incomplete, but is suitable for
   * round-tripping {@link UntypedTarget} objects and capturing the fact that an
   * object is not an un typed target if it is not, via the {@link type}
   * attribute.  In the future, we should override this method in subclasses to
   * provide a more complete representation.
   * @returns A plain object representation of the target
   */
  toPlainObject() {
    return {
      type: this.type,
      contentRange: rangeToPlainObject(this.contentRange),
      isReversed: this.isReversed,
      hasExplicitRange: this.hasExplicitRange
    };
  }
};

// ../cursorless-engine/src/util/selectionUtils.ts
function shrinkRangeToFitContent(editor, range3) {
  const { document: document2 } = editor;
  const text = document2.getText(range3);
  const startDelta = text.length - text.trimStart().length;
  const endDelta = text.length - text.trimEnd().length;
  const startOffset = document2.offsetAt(range3.start) + startDelta;
  const endOffset = document2.offsetAt(range3.end) - endDelta;
  const start2 = document2.positionAt(startOffset);
  const end = document2.positionAt(endOffset);
  return new Range(start2, end);
}

// ../cursorless-engine/src/util/tryConstructTarget.ts
function tryConstructTarget(constructor, editor, range3, isReversed) {
  return range3 == null ? void 0 : new constructor({
    editor,
    isReversed,
    contentRange: range3
  });
}

// ../cursorless-engine/src/processTargets/targets/PlainTarget.ts
var PlainTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", "PlainTarget");
    __publicField(this, "insertionDelimiter");
    __publicField(this, "getLeadingDelimiterTarget", () => void 0);
    __publicField(this, "getTrailingDelimiterTarget", () => void 0);
    __publicField(this, "getRemovalRange", () => this.contentRange);
    this.textualType = parameters.textualType ?? "token";
    this.insertionDelimiter = parameters.insertionDelimiter ?? "";
  }
  getCloneParameters() {
    return {
      ...this.state,
      textualType: this.textualType,
      insertionDelimiter: this.insertionDelimiter
    };
  }
};
function tryConstructPlainTarget(editor, range3, isReversed) {
  return tryConstructTarget(PlainTarget, editor, range3, isReversed);
}

// ../cursorless-engine/src/processTargets/targets/DocumentTarget.ts
var DocumentTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", "DocumentTarget");
    __publicField(this, "textualType", "line");
    __publicField(this, "insertionDelimiter", "\n\n");
  }
  getInterior() {
    return [
      // Use plain target instead of interior target since we want the same content and removal range for a document interior.
      new PlainTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange: shrinkRangeToFitContent(this.editor, this.contentRange)
      })
    ];
  }
  getRemovalRange() {
    return this.contentRange;
  }
  getLeadingDelimiterTarget() {
    return void 0;
  }
  getTrailingDelimiterTarget() {
    return void 0;
  }
  getCloneParameters() {
    return this.state;
  }
};

// ../cursorless-engine/src/processTargets/targets/LineTarget.ts
var LineTarget = class _LineTarget extends BaseTarget {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "LineTarget");
    __publicField(this, "textualType", "line");
    __publicField(this, "insertionDelimiter", "\n");
    __publicField(this, "getRemovalHighlightRange", () => {
      return toLineRange(this.fullLineContentRange);
    });
  }
  get fullLineContentRange() {
    return expandToFullLine(this.editor, this.contentRange);
  }
  getLeadingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      getLeadingDelimiterRange(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getTrailingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      getTrailingDelimiterRange(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getRemovalRange() {
    const contentRemovalRange = this.fullLineContentRange;
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    return delimiterTarget == null ? contentRemovalRange : contentRemovalRange.union(delimiterTarget.contentRange);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _LineTarget({
      editor: this.editor,
      isReversed,
      contentRange: createContinuousLineRange(this, endTarget, true, true)
    });
  }
  getCloneParameters() {
    return this.state;
  }
};
function getLeadingDelimiterRange(editor, range3) {
  const { start: start2 } = range3;
  return start2.line > 0 ? new Range(editor.document.lineAt(start2.line - 1).range.end, range3.start) : void 0;
}
function getTrailingDelimiterRange(editor, range3) {
  const { end } = range3;
  return end.line + 1 < editor.document.lineCount ? new Range(range3.end, new Position(end.line + 1, 0)) : void 0;
}
function constructLineTarget(editor, range3, isReversed) {
  return tryConstructTarget(LineTarget, editor, range3, isReversed);
}
function createLineTarget(editor, isReversed, line, useFullRange = false) {
  return new LineTarget({
    editor,
    isReversed,
    contentRange: useFullRange || line.rangeTrimmed == null ? line.range : line.rangeTrimmed
  });
}

// ../cursorless-engine/src/processTargets/targets/NotebookCellDestination.ts
var NotebookCellDestination = class _NotebookCellDestination {
  constructor(target, insertionMode2) {
    this.target = target;
    this.insertionMode = insertionMode2;
  }
  get editor() {
    return this.target.editor;
  }
  get contentRange() {
    return this.target.contentRange;
  }
  get contentSelection() {
    return this.target.contentSelection;
  }
  get insertionDelimiter() {
    return this.target.insertionDelimiter;
  }
  get isRaw() {
    return this.target.isRaw;
  }
  withTarget(target) {
    return new _NotebookCellDestination(target, this.insertionMode);
  }
  getEditNewActionType() {
    throw new Error("Method not implemented.");
  }
  constructChangeEdit(_text) {
    throw new Error("Method not implemented.");
  }
};

// ../cursorless-engine/src/processTargets/targets/NotebookCellTarget.ts
var NotebookCellTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", "NotebookCellTarget");
    __publicField(this, "insertionDelimiter", "\n");
    __publicField(this, "isNotebookCell", true);
    __publicField(this, "getLeadingDelimiterTarget", () => void 0);
    __publicField(this, "getTrailingDelimiterTarget", () => void 0);
    __publicField(this, "getRemovalRange", () => this.contentRange);
  }
  getCloneParameters() {
    return this.state;
  }
  toDestination(insertionMode2) {
    return new NotebookCellDestination(this, insertionMode2);
  }
};

// ../cursorless-engine/src/processTargets/targets/ParagraphTarget.ts
var ParagraphTarget = class _ParagraphTarget extends BaseTarget {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "ParagraphTarget");
    __publicField(this, "textualType", "line");
    __publicField(this, "insertionDelimiter", "\n\n");
  }
  getLeadingDelimiterTarget() {
    return constructLineTarget(
      this.editor,
      getLeadingDelimiterRange2(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getTrailingDelimiterTarget() {
    return constructLineTarget(
      this.editor,
      getTrailingDelimiterRange2(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getRemovalRange() {
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    const removalContentRange = delimiterTarget != null ? this.contentRange.union(delimiterTarget.contentRange) : this.contentRange;
    return new LineTarget({
      contentRange: removalContentRange,
      editor: this.editor,
      isReversed: this.isReversed
    }).getRemovalRange();
  }
  get fullLineContentRange() {
    return expandToFullLine(this.editor, this.contentRange);
  }
  getRemovalHighlightRange() {
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    const range3 = delimiterTarget != null ? this.fullLineContentRange.union(delimiterTarget.contentRange) : this.fullLineContentRange;
    return toLineRange(range3);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _ParagraphTarget({
      ...this.getCloneParameters(),
      isReversed,
      contentRange: createContinuousLineRange(this, endTarget, true, true)
    });
  }
  getCloneParameters() {
    return this.state;
  }
};
function getLeadingDelimiterRange2(editor, contentRange) {
  const { document: document2 } = editor;
  const startLine = document2.lineAt(contentRange.start);
  const leadingLine = getPreviousNonEmptyLine(document2, startLine);
  if (leadingLine != null) {
    if (leadingLine.lineNumber + 1 === startLine.lineNumber) {
      return void 0;
    }
    return new Range(
      new Position(leadingLine.lineNumber + 1, 0),
      document2.lineAt(startLine.lineNumber - 1).range.end
    );
  }
  if (startLine.lineNumber > 0) {
    return new Range(
      new Position(0, 0),
      document2.lineAt(startLine.lineNumber - 1).range.end
    );
  }
  return void 0;
}
function getTrailingDelimiterRange2(editor, contentRange) {
  const { document: document2 } = editor;
  const endLine = document2.lineAt(contentRange.end);
  const trailingLine = getNextNonEmptyLine(document2, endLine);
  if (trailingLine != null) {
    if (trailingLine.lineNumber - 1 === endLine.lineNumber) {
      return void 0;
    }
    return new Range(
      new Position(endLine.lineNumber + 1, 0),
      document2.lineAt(trailingLine.lineNumber - 1).range.end
    );
  }
  if (endLine.lineNumber < document2.lineCount - 1) {
    return new Range(
      new Position(endLine.lineNumber + 1, 0),
      document2.lineAt(document2.lineCount - 1).range.end
    );
  }
  return void 0;
}
function getPreviousNonEmptyLine(document2, line) {
  while (line.lineNumber > 0) {
    const previousLine = document2.lineAt(line.lineNumber - 1);
    if (!previousLine.isEmptyOrWhitespace) {
      return previousLine;
    }
    line = previousLine;
  }
  return null;
}
function getNextNonEmptyLine(document2, line) {
  while (line.lineNumber + 1 < document2.lineCount) {
    const nextLine = document2.lineAt(line.lineNumber + 1);
    if (!nextLine.isEmptyOrWhitespace) {
      return nextLine;
    }
    line = nextLine;
  }
  return null;
}

// ../cursorless-engine/src/processTargets/targets/RawSelectionTarget.ts
var RawSelectionTarget = class extends BaseTarget {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "RawSelectionTarget");
    __publicField(this, "textualType", "character");
    __publicField(this, "insertionDelimiter", "");
    __publicField(this, "isRaw", true);
    __publicField(this, "getLeadingDelimiterTarget", () => void 0);
    __publicField(this, "getTrailingDelimiterTarget", () => void 0);
    __publicField(this, "getRemovalRange", () => this.contentRange);
    __publicField(this, "getCloneParameters", () => this.state);
  }
};

// ../cursorless-engine/src/processTargets/targets/util/insertionRemovalBehaviors/DelimitedSequenceInsertionRemovalBehavior.ts
function getDelimitedSequenceRemovalRange(target) {
  const contentRange = union(target.contentRange, target.prefixRange);
  const delimiterTarget = target.getTrailingDelimiterTarget() ?? target.getLeadingDelimiterTarget();
  return delimiterTarget != null ? contentRange.union(delimiterTarget.contentRange) : contentRange;
}

// ../cursorless-engine/src/processTargets/targets/util/insertionRemovalBehaviors/TokenInsertionRemovalBehavior.ts
var leadingDelimiters = ['"', "'", "(", "[", "{", "<"];
var trailingDelimiters = ['"', "'", ")", "]", "}", ">", ",", ";", ":"];
function getTokenLeadingDelimiterTarget(target) {
  const { editor } = target;
  const { start: start2 } = union(target.contentRange, target.prefixRange);
  const startLine = editor.document.lineAt(start2);
  const leadingText = startLine.text.slice(0, start2.character);
  const leadingDelimiters2 = leadingText.match(/\s+$/);
  return leadingDelimiters2 == null ? void 0 : new PlainTarget({
    contentRange: new Range(
      start2.line,
      start2.character - leadingDelimiters2[0].length,
      start2.line,
      start2.character
    ),
    editor,
    isReversed: target.isReversed
  });
}
function getTokenTrailingDelimiterTarget(target) {
  const { editor } = target;
  const { end } = target.contentRange;
  const endLine = editor.document.lineAt(end);
  const trailingText = endLine.text.slice(end.character);
  const trailingDelimiters2 = trailingText.match(/^\s+/);
  return trailingDelimiters2 == null ? void 0 : new PlainTarget({
    contentRange: new Range(
      end.line,
      end.character,
      end.line,
      end.character + trailingDelimiters2[0].length
    ),
    editor,
    isReversed: target.isReversed
  });
}
function getTokenRemovalRange(target) {
  const { editor } = target;
  const contentRange = union(target.contentRange, target.prefixRange);
  const { start: start2, end } = contentRange;
  const leadingWhitespaceRange = target.getLeadingDelimiterTarget()?.contentRange ?? start2.toEmptyRange();
  const trailingWhitespaceRange = target.getTrailingDelimiterTarget()?.contentRange ?? end.toEmptyRange();
  const fullLineRange = expandToFullLine(editor, contentRange);
  if (leadingWhitespaceRange.union(trailingWhitespaceRange).isRangeEqual(fullLineRange)) {
    return fullLineRange;
  }
  if (!trailingWhitespaceRange.isEmpty) {
    if (!leadingWhitespaceRange.isEmpty || contentRange.start.isEqual(fullLineRange.start) || leadingDelimiters.includes(getLeadingCharacter(editor, contentRange))) {
      return contentRange.union(trailingWhitespaceRange);
    }
  }
  if (!leadingWhitespaceRange.isEmpty) {
    if (contentRange.end.isEqual(fullLineRange.end) || trailingDelimiters.includes(getTrailingCharacter(editor, contentRange))) {
      return contentRange.union(leadingWhitespaceRange);
    }
  }
  return contentRange;
}
function getLeadingCharacter(editor, contentRange) {
  const { start: start2 } = contentRange;
  const line = editor.document.lineAt(start2);
  return start2.isAfter(line.range.start) ? editor.document.getText(new Range(start2.translate(void 0, -1), start2)) : "";
}
function getTrailingCharacter(editor, contentRange) {
  const { end } = contentRange;
  const line = editor.document.lineAt(end);
  return end.isBefore(line.range.end) ? editor.document.getText(new Range(end.translate(void 0, 1), end)) : "";
}

// ../cursorless-engine/src/processTargets/targets/TokenTarget.ts
var TokenTarget = class extends BaseTarget {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "TokenTarget");
    __publicField(this, "textualType", "token");
    __publicField(this, "insertionDelimiter", " ");
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return getTokenRemovalRange(this);
  }
  getCloneParameters() {
    return this.state;
  }
};

// ../cursorless-engine/src/processTargets/targets/util/insertionRemovalBehaviors/getSmartRemovalTarget.ts
function getSmartRemovalTarget(target) {
  const { editor, isReversed } = target;
  const { document: document2 } = editor;
  const contentRange = union(target.contentRange, target.prefixRange);
  if (isWholeLines(document2, contentRange)) {
    if (hasLeadingAndTrailingEmptyLines(document2, contentRange)) {
      return new ParagraphTarget({
        editor,
        isReversed,
        contentRange
      });
    }
    return new LineTarget({
      editor,
      isReversed,
      contentRange
    });
  }
  return new TokenTarget({
    editor,
    isReversed,
    contentRange
  });
}
function isWholeLines(document2, contentRange) {
  const start2 = document2.lineAt(contentRange.start).rangeTrimmed?.start;
  const end = document2.lineAt(contentRange.end).rangeTrimmed?.end;
  return start2 != null && end != null && start2.isEqual(contentRange.start) && end.isEqual(contentRange.end);
}
function hasLeadingAndTrailingEmptyLines(document2, contentRange) {
  const { start: start2, end } = contentRange;
  return (start2.line === 0 || document2.lineAt(start2.line - 1).isEmptyOrWhitespace) && (end.line === document2.lineCount - 1 || document2.lineAt(end.line + 1).isEmptyOrWhitespace);
}

// ../cursorless-engine/src/processTargets/targets/ScopeTypeTarget.ts
var ScopeTypeTarget = class _ScopeTypeTarget extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", "ScopeTypeTarget");
    __publicField(this, "scopeTypeType_");
    __publicField(this, "removalRange_");
    __publicField(this, "leadingDelimiterRange_");
    __publicField(this, "trailingDelimiterRange_");
    __publicField(this, "hasDelimiterRange_");
    __publicField(this, "prefixRange");
    __publicField(this, "insertionDelimiter");
    this.scopeTypeType_ = parameters.scopeTypeType;
    this.removalRange_ = parameters.removalRange;
    this.leadingDelimiterRange_ = parameters.leadingDelimiterRange;
    this.trailingDelimiterRange_ = parameters.trailingDelimiterRange;
    this.prefixRange = parameters.prefixRange;
    this.insertionDelimiter = parameters.insertionDelimiter ?? getInsertionDelimiter(parameters.scopeTypeType);
    this.hasDelimiterRange_ = !!this.leadingDelimiterRange_ || !!this.trailingDelimiterRange_;
  }
  getLeadingDelimiterTarget() {
    if (this.leadingDelimiterRange_ != null) {
      return new PlainTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange: this.leadingDelimiterRange_
      });
    }
    if (!this.hasDelimiterRange_) {
      return getTokenLeadingDelimiterTarget(this);
    }
    return void 0;
  }
  getTrailingDelimiterTarget() {
    if (this.trailingDelimiterRange_ != null) {
      return new PlainTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange: this.trailingDelimiterRange_
      });
    }
    if (!this.hasDelimiterRange_) {
      return getTokenTrailingDelimiterTarget(this);
    }
    return void 0;
  }
  getRemovalRange() {
    if (this.removalRange_ != null) {
      return this.removalRange_;
    }
    if (this.hasDelimiterRange_) {
      return getDelimitedSequenceRemovalRange(this);
    }
    return getSmartRemovalTarget(this).getRemovalRange();
  }
  getRemovalHighlightRange() {
    if (this.removalRange_ != null) {
      return toGeneralizedRange(this, this.removalRange_);
    }
    if (this.hasDelimiterRange_) {
      return toGeneralizedRange(this, getDelimitedSequenceRemovalRange(this));
    }
    return getSmartRemovalTarget(this).getRemovalHighlightRange();
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    if (this.scopeTypeType_ !== endTarget.scopeTypeType_) {
      return null;
    }
    const contentRemovalRange = this.removalRange_ != null || endTarget.removalRange_ != null ? (this.removalRange_ ?? this.contentRange).union(
      endTarget.removalRange_ ?? endTarget.contentRange
    ) : void 0;
    return new _ScopeTypeTarget({
      ...this.getCloneParameters(),
      isReversed,
      leadingDelimiterRange: this.leadingDelimiterRange_,
      trailingDelimiterRange: endTarget.trailingDelimiterRange_,
      removalRange: contentRemovalRange,
      contentRange: this.contentRange.union(endTarget.contentRange)
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      insertionDelimiter: this.insertionDelimiter,
      prefixRange: this.prefixRange,
      removalRange: void 0,
      interiorRange: void 0,
      scopeTypeType: this.scopeTypeType_,
      leadingDelimiterRange: this.leadingDelimiterRange_,
      trailingDelimiterRange: this.trailingDelimiterRange_
    };
  }
};
function getInsertionDelimiter(scopeType) {
  switch (scopeType) {
    case "class":
    case "namedFunction":
    case "section":
    case "sectionLevelOne":
    case "sectionLevelTwo":
    case "sectionLevelThree":
    case "sectionLevelFour":
    case "sectionLevelFive":
    case "sectionLevelSix":
    case "part":
    case "chapter":
    case "subSection":
    case "subSubSection":
    case "namedParagraph":
    case "subParagraph":
      return "\n\n";
    case "anonymousFunction":
    case "statement":
    case "ifStatement":
    case "comment":
    case "xmlElement":
    case "collectionItem":
    case "branch":
    case "environment":
      return "\n";
    default:
      return " ";
  }
}

// ../cursorless-engine/src/processTargets/targets/SubTokenWordTarget.ts
var SubTokenWordTarget = class _SubTokenWordTarget extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", "SubTokenWordTarget");
    __publicField(this, "textualType", "word");
    __publicField(this, "leadingDelimiterRange_");
    __publicField(this, "trailingDelimiterRange_");
    __publicField(this, "insertionDelimiter");
    this.leadingDelimiterRange_ = parameters.leadingDelimiterRange;
    this.trailingDelimiterRange_ = parameters.trailingDelimiterRange;
    this.insertionDelimiter = parameters.insertionDelimiter;
  }
  getLeadingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      this.leadingDelimiterRange_,
      this.isReversed
    );
  }
  getTrailingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      this.trailingDelimiterRange_,
      this.isReversed
    );
  }
  getRemovalRange() {
    return getDelimitedSequenceRemovalRange(this);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _SubTokenWordTarget({
      ...this.getCloneParameters(),
      isReversed,
      contentRange: createContinuousRange(this, endTarget, true, true),
      trailingDelimiterRange: endTarget.trailingDelimiterRange_
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      leadingDelimiterRange: this.leadingDelimiterRange_,
      trailingDelimiterRange: this.trailingDelimiterRange_,
      insertionDelimiter: this.insertionDelimiter
    };
  }
};

// ../cursorless-engine/src/processTargets/targets/InteriorTarget.ts
var InteriorTarget = class _InteriorTarget extends BaseTarget {
  constructor(parameters) {
    super({
      ...parameters,
      contentRange: shrinkRangeToFitContent(
        parameters.editor,
        parameters.fullInteriorRange
      )
    });
    __publicField(this, "type", "InteriorTarget");
    __publicField(this, "insertionDelimiter", " ");
    __publicField(this, "fullInteriorRange");
    __publicField(this, "getLeadingDelimiterTarget", () => void 0);
    __publicField(this, "getTrailingDelimiterTarget", () => void 0);
    __publicField(this, "getRemovalRange", () => this.fullInteriorRange);
    this.fullInteriorRange = parameters.fullInteriorRange;
  }
  getCloneParameters() {
    return {
      ...this.state,
      fullInteriorRange: this.fullInteriorRange
    };
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _InteriorTarget({
      ...this.getCloneParameters(),
      isReversed,
      fullInteriorRange: this.fullInteriorRange.union(
        endTarget.fullInteriorRange
      )
    });
  }
};

// ../cursorless-engine/src/processTargets/targets/SurroundingPairTarget.ts
var SurroundingPairTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", "SurroundingPairTarget");
    __publicField(this, "insertionDelimiter", " ");
    __publicField(this, "interiorRange_");
    __publicField(this, "boundary_");
    this.boundary_ = parameters.boundary;
    this.interiorRange_ = parameters.interiorRange;
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return getTokenRemovalRange(this);
  }
  getInterior() {
    return [
      new InteriorTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        fullInteriorRange: this.interiorRange_
      })
    ];
  }
  getBoundary() {
    return this.boundary_.map(
      (contentRange) => new TokenTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange
      })
    );
  }
  getCloneParameters() {
    return {
      ...this.state,
      interiorRange: this.interiorRange_,
      boundary: this.boundary_
    };
  }
};

// ../cursorless-engine/src/processTargets/targets/UntypedTarget.ts
var UntypedTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", "UntypedTarget");
    __publicField(this, "insertionDelimiter", " ");
    __publicField(this, "hasExplicitScopeType", false);
    this.hasExplicitRange = parameters.hasExplicitRange;
    this.textualType = parameters.textualType ?? "token";
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return this.editor.document.getText(this.contentRange).trim().length === 0 ? this.contentRange : getTokenRemovalRange(this);
  }
  maybeCreateRichRangeTarget() {
    return null;
  }
  getCloneParameters() {
    return {
      ...this.state,
      textualType: this.textualType,
      hasExplicitRange: this.hasExplicitRange
    };
  }
};

// ../cursorless-engine/src/processTargets/targets/ImplicitTarget.ts
var ImplicitTarget = class extends BaseTarget {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "ImplicitTarget");
    __publicField(this, "textualType", "character");
    __publicField(this, "insertionDelimiter", "");
    __publicField(this, "isRaw", true);
    __publicField(this, "hasExplicitScopeType", false);
    __publicField(this, "isImplicit", true);
    __publicField(this, "getLeadingDelimiterTarget", () => void 0);
    __publicField(this, "getTrailingDelimiterTarget", () => void 0);
    __publicField(this, "getRemovalRange", () => this.contentRange);
    __publicField(this, "getCloneParameters", () => this.state);
  }
};

// ../cursorless-engine/src/processTargets/targets/HeadTailTarget.ts
var HeadTailTarget = class extends BaseTarget {
  constructor(parameters) {
    const { inputTarget, modifiedTarget, isHead } = parameters;
    super({
      ...parameters,
      contentRange: constructRange(
        inputTarget.contentRange,
        modifiedTarget.contentRange,
        isHead
      )
    });
    __publicField(this, "type", "HeadTailTarget");
    __publicField(this, "insertionDelimiter", " ");
    __publicField(this, "inputTarget");
    __publicField(this, "modifiedTarget");
    __publicField(this, "isHead");
    this.inputTarget = inputTarget;
    this.modifiedTarget = modifiedTarget;
    this.isHead = isHead;
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return getTokenRemovalRange(this);
  }
  getInterior() {
    const modifiedInterior = this.modifiedTarget.getInterior();
    if (modifiedInterior == null) {
      return void 0;
    }
    return modifiedInterior.map((target) => {
      return new PlainTarget({
        editor: this.editor,
        contentRange: constructRange(
          this.inputTarget.contentRange,
          target.contentRange,
          this.isHead
        ),
        isReversed: this.isReversed
      });
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      inputTarget: this.inputTarget,
      modifiedTarget: this.modifiedTarget,
      isHead: this.isHead
    };
  }
};
function constructRange(originalRange, modifiedRange, isHead) {
  return isHead ? new Range(modifiedRange.start, originalRange.end) : new Range(originalRange.start, modifiedRange.end);
}

// ../cursorless-engine/src/processTargets/targets/BoundedParagraphTarget.ts
var BoundedParagraphTarget = class _BoundedParagraphTarget extends BaseTarget {
  constructor(parameters) {
    super({
      ...parameters,
      contentRange: getIntersectionStrict(
        parameters.paragraphTarget.contentRange,
        parameters.containingInterior.contentRange
      )
    });
    __publicField(this, "type", "BoundedParagraphTarget");
    __publicField(this, "textualType", "line");
    __publicField(this, "insertionDelimiter", "\n\n");
    __publicField(this, "containingInterior");
    __publicField(this, "paragraphTarget");
    __publicField(this, "startLineGap");
    __publicField(this, "endLineGap");
    this.containingInterior = parameters.containingInterior;
    this.paragraphTarget = parameters.paragraphTarget;
    this.startLineGap = this.contentRange.start.line - this.containingInterior.fullInteriorRange.start.line;
    this.endLineGap = this.containingInterior.fullInteriorRange.end.line - this.contentRange.end.line;
  }
  getLeadingDelimiterTarget() {
    return this.startLineGap > 1 ? this.paragraphTarget.getLeadingDelimiterTarget() : void 0;
  }
  getTrailingDelimiterTarget() {
    return this.endLineGap > 1 ? this.paragraphTarget.getTrailingDelimiterTarget() : void 0;
  }
  getRemovalRange() {
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    const removalContentRange = delimiterTarget != null ? this.contentRange.union(delimiterTarget.contentRange) : this.contentRange;
    if (this.startLineGap <= 0 || this.endLineGap <= 0) {
      return removalContentRange;
    }
    return new LineTarget({
      contentRange: removalContentRange,
      editor: this.editor,
      isReversed: this.isReversed
    }).getRemovalRange();
  }
  get fullLineContentRange() {
    return expandToFullLine(this.editor, this.contentRange);
  }
  getRemovalHighlightRange() {
    const range3 = (() => {
      if (this.startLineGap < 1 || this.endLineGap < 1) {
        return this.getRemovalRange();
      }
      const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
      return delimiterTarget != null ? this.fullLineContentRange.union(delimiterTarget.contentRange) : this.fullLineContentRange;
    })();
    return toLineRange(range3);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _BoundedParagraphTarget({
      ...this.getCloneParameters(),
      isReversed,
      containingInterior: this.containingInterior.maybeCreateRichRangeTarget(
        isReversed,
        endTarget.containingInterior
      ),
      paragraphTarget: this.paragraphTarget.maybeCreateRichRangeTarget(
        isReversed,
        endTarget.paragraphTarget
      )
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      paragraphTarget: this.paragraphTarget,
      containingInterior: this.containingInterior
    };
  }
};
function getIntersectionStrict(range1, range22) {
  const intersection2 = range1.intersection(range22);
  if (intersection2 == null || intersection2.isEmpty) {
    throw new Error("Ranges do not intersect");
  }
  return intersection2;
}

// ../cursorless-engine/src/processTargets/marks/getActiveSelections.ts
function getActiveSelections(ide2) {
  return ide2.activeTextEditor?.selections.map((selection) => ({
    selection,
    editor: ide2.activeTextEditor
  })) ?? [];
}

// ../cursorless-engine/src/processTargets/marks/CursorStage.ts
var CursorStage = class {
  run() {
    return getActiveSelections(ide()).map(
      (selection) => new UntypedTarget({
        editor: selection.editor,
        isReversed: selection.selection.isReversed,
        contentRange: selection.selection,
        hasExplicitRange: !selection.selection.isEmpty,
        textualType: "character"
      })
    );
  }
};

// ../cursorless-engine/src/util/DecorationDebouncer.ts
var DecorationDebouncer = class {
  constructor(configuration, callback2) {
    __publicField(this, "debouncer");
    this.debouncer = new Debouncer(
      callback2,
      configuration.getOwnConfiguration("decorationDebounceDelayMs")
    );
    this.run = this.run.bind(this);
  }
  run() {
    this.debouncer.run();
  }
  dispose() {
    this.debouncer.dispose();
  }
};

// ../cursorless-engine/src/KeyboardTargetUpdater.ts
var KeyboardTargetUpdater = class {
  constructor(ide2, storedTargets) {
    this.ide = ide2;
    this.storedTargets = storedTargets;
    __publicField(this, "disposables", []);
    __publicField(this, "selectionWatcherDisposable");
    __publicField(this, "debouncer");
    this.debouncer = new DecorationDebouncer(
      ide2.configuration,
      () => this.updateKeyboardTarget()
    );
    this.disposables.push(
      ide2.configuration.onDidChangeConfiguration(() => this.maybeActivate()),
      this.debouncer
    );
    this.maybeActivate();
  }
  maybeActivate() {
    const isActive = this.ide.configuration.getOwnConfiguration(
      "experimental.keyboardTargetFollowsSelection"
    );
    if (isActive) {
      if (this.selectionWatcherDisposable == null) {
        this.selectionWatcherDisposable = this.ide.onDidChangeTextEditorSelection(this.debouncer.run);
      }
      return;
    }
    if (this.selectionWatcherDisposable != null) {
      this.selectionWatcherDisposable.dispose();
      this.selectionWatcherDisposable = void 0;
    }
  }
  updateKeyboardTarget() {
    const activeEditor = this.ide.activeTextEditor;
    if (activeEditor == null || this.storedTargets.get("keyboard") == null) {
      return;
    }
    this.storedTargets.set("keyboard", new CursorStage().run());
  }
  dispose() {
    this.disposables.forEach((disposable) => disposable.dispose());
    this.selectionWatcherDisposable?.dispose();
  }
};

// ../cursorless-engine/src/core/Debug.ts
var Debug = class {
  constructor(ide2) {
    this.ide = ide2;
    __publicField(this, "disposableConfiguration");
    __publicField(this, "active");
    ide2.disposeOnExit(this);
    this.evaluateSetting = this.evaluateSetting.bind(this);
    this.active = true;
    switch (ide2.runMode) {
      // Development mode. Always enable.
      case "development":
        this.enableDebugLog();
        break;
      // Test mode. Always disable.
      case "test":
        this.disableDebugLog();
        break;
      // Production mode. Enable based on user setting.
      case "production":
        this.evaluateSetting();
        this.disposableConfiguration = ide2.configuration.onDidChangeConfiguration(this.evaluateSetting);
        break;
    }
  }
  log(...args2) {
    if (this.active) {
      console.log(...args2);
    }
  }
  dispose() {
    if (this.disposableConfiguration) {
      this.disposableConfiguration.dispose();
    }
  }
  enableDebugLog() {
    this.active = true;
  }
  disableDebugLog() {
    this.active = false;
  }
  evaluateSetting() {
    const debugEnabled = this.ide.configuration.getOwnConfiguration("debug");
    if (debugEnabled) {
      this.enableDebugLog();
    } else {
      this.disableDebugLog();
    }
  }
};

// ../cursorless-engine/src/tokenGraphemeSplitter/tokenGraphemeSplitter.ts
var KNOWN_SYMBOLS = [
  "!",
  "#",
  "$",
  "%",
  "&",
  "'",
  "(",
  ")",
  "*",
  "+",
  ",",
  "-",
  ".",
  "/",
  ":",
  ";",
  "<",
  "=",
  ">",
  "?",
  "@",
  "[",
  "\\",
  "]",
  "^",
  "_",
  "`",
  "{",
  "|",
  "}",
  "~",
  "\xA3",
  '"'
];
var KNOWN_SYMBOL_REGEXP_STR = KNOWN_SYMBOLS.map(escapeRegExp_default).join("|");
var KNOWN_GRAPHEME_REGEXP_STR = ["[a-zA-Z0-9]", KNOWN_SYMBOL_REGEXP_STR].join(
  "|"
);
var KNOWN_GRAPHEME_MATCHER = new RegExp(
  `^(${KNOWN_GRAPHEME_REGEXP_STR})$`,
  "u"
);
var UNKNOWN = "[unk]";
var GRAPHEME_SPLIT_REGEX = /\p{L}\p{M}*|[\p{N}\p{P}\p{S}]/gu;
var TokenGraphemeSplitter = class {
  constructor() {
    __publicField(this, "disposables", []);
    __publicField(this, "algorithmChangeNotifier", new Notifier());
    __publicField(this, "tokenHatSplittingMode");
    /**
     * Splits {@link token} into a list of graphemes, normalised as per
     * {@link normalizeGrapheme}.
     * @param token The token to split
     * @returns A list of normalised graphemes in {@link token}
     */
    __publicField(this, "getTokenGraphemes", (token) => matchAll(token, GRAPHEME_SPLIT_REGEX, (match) => ({
      text: this.normalizeGrapheme(match[0]),
      tokenStartOffset: match.index,
      tokenEndOffset: match.index + match[0].length
    })));
    /**
     * Register to be notified when the graphing splitting algorithm changes, for example if
     * the user changes the setting to enable preserving case
     * @param listener A function to be called when graphing splitting algorithm changes
     * @returns A function that can be called to unsubscribe from notifications
     */
    __publicField(this, "registerAlgorithmChangeListener", this.algorithmChangeNotifier.registerListener);
    ide().disposeOnExit(this);
    this.updateTokenHatSplittingMode = this.updateTokenHatSplittingMode.bind(this);
    this.getTokenGraphemes = this.getTokenGraphemes.bind(this);
    this.updateTokenHatSplittingMode();
    this.disposables.push(
      // Notify listeners in case the user changed their token hat splitting
      // setting.
      ide().configuration.onDidChangeConfiguration(
        this.updateTokenHatSplittingMode
      )
    );
  }
  updateTokenHatSplittingMode() {
    const { lettersToPreserve, symbolsToPreserve, ...rest } = ide().configuration.getOwnConfiguration("tokenHatSplittingMode");
    this.tokenHatSplittingMode = {
      lettersToPreserve: lettersToPreserve.map(
        (grapheme) => grapheme.toLowerCase().normalize("NFC")
      ),
      symbolsToPreserve: symbolsToPreserve.map(
        (grapheme) => grapheme.normalize("NFC")
      ),
      ...rest
    };
    this.algorithmChangeNotifier.notifyListeners();
  }
  /**
   * Normalizes the grapheme {@link rawGraphemeText} based on user
   * configuration.  Proceeds as follows:
   *
   * 1. Runs text through Unicode NFC normalization to ensure that characters
   *    that look identical are handled the same (eg whether they use combining
   *    mark or single codepoint for diacritics).
   * 2. If the grapheme is a known grapheme, returns it.
   * 3. Transforms grapheme to lowercase if
   *    {@link TokenHatSplittingMode.preserveCase} is `false`
   * 3. Returns the (possibly case-normalised) grapheme if it appears in
   *    {@link TokenHatSplittingMode.lettersToPreserve}
   * 4. Strips diacritics from the grapheme
   * 5. If the grapheme doesn't match {@link KNOWN_GRAPHEME_MATCHER}, maps the
   *    grapheme to the constant {@link UNKNOWN}, so that it can be referred to
   *    using "special", "red special", etc.
   * 6. Returns the grapheme.
   *
   * @param rawGraphemeText The raw grapheme text to normalise
   * @returns The normalised grapheme
   */
  normalizeGrapheme(rawGraphemeText) {
    const { preserveCase, lettersToPreserve, symbolsToPreserve } = this.tokenHatSplittingMode;
    let returnValue = rawGraphemeText.normalize("NFC");
    if (symbolsToPreserve.includes(returnValue)) {
      return returnValue;
    }
    if (!preserveCase) {
      returnValue = returnValue.toLowerCase();
    }
    if (lettersToPreserve.includes(returnValue.toLowerCase())) {
      return returnValue;
    }
    returnValue = deburr_default(returnValue);
    if (!KNOWN_GRAPHEME_MATCHER.test(returnValue)) {
      returnValue = UNKNOWN;
    }
    return returnValue;
  }
  dispose() {
    this.disposables.forEach(({ dispose }) => dispose());
  }
};

// ../cursorless-engine/src/singletons/tokenGraphemeSplitter.singleton.ts
function tokenGraphemeSplitter() {
  if (tokenGraphemeSplitter_ == null) {
    tokenGraphemeSplitter_ = new TokenGraphemeSplitter();
  }
  return tokenGraphemeSplitter_;
}
var tokenGraphemeSplitter_;

// ../cursorless-engine/src/tokenizer/tokenizer.ts
var REPEATABLE_SYMBOLS = [
  "-",
  "+",
  "*",
  "/",
  "=",
  "<",
  ">",
  "_",
  "#",
  ".",
  "|",
  "&",
  ":"
];
var FIXED_TOKENS = [
  "!==",
  "!=",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "<=",
  ">=",
  "=>",
  "->",
  "??",
  '"""',
  "```",
  "/*",
  "*/",
  "<!--",
  "-->"
];
var IDENTIFIER_WORD_REGEXES = ["\\p{L}", "\\p{M}", "\\p{N}"];
var SINGLE_SYMBOLS_REGEX = "[^\\s\\w]";
var NUMBERS_REGEX = "(?<![.\\d])\\d+\\.\\d+(?![.\\d])";
function generateMatcher(languageComponents) {
  const {
    fixedTokens,
    repeatableSymbols,
    identifierWordRegexes,
    identifierWordDelimiters,
    numbersRegex,
    singleSymbolsRegex
  } = languageComponents;
  const repeatableSymbolsRegex = repeatableSymbols.map(escapeRegExp_default).map((s) => `${s}+`).join("|");
  const fixedTokensRegex = fixedTokens.map(escapeRegExp_default).join("|");
  const identifierComponents = identifierWordRegexes.concat(
    identifierWordDelimiters.map(escapeRegExp_default)
  );
  const identifiersRegex = `(${identifierComponents.join("|")})+`;
  const wordRegex = `(${identifierWordRegexes.join("|")})+`;
  const regex = [
    fixedTokensRegex,
    numbersRegex,
    identifiersRegex,
    repeatableSymbolsRegex,
    singleSymbolsRegex
  ].join("|");
  return {
    identifierMatcher: new RegExp(identifiersRegex, "gu"),
    wordMatcher: new RegExp(wordRegex, "gu"),
    tokenMatcher: new RegExp(regex, "gu")
  };
}
var matchers2 = /* @__PURE__ */ new Map();
function getMatcher(languageId) {
  const wordSeparators = ide().configuration.getOwnConfiguration(
    "wordSeparators",
    {
      languageId
    }
  );
  const key = wordSeparators.join("\0");
  if (!matchers2.has(key)) {
    const components = {
      fixedTokens: FIXED_TOKENS,
      repeatableSymbols: REPEATABLE_SYMBOLS,
      identifierWordRegexes: IDENTIFIER_WORD_REGEXES,
      identifierWordDelimiters: wordSeparators,
      numbersRegex: NUMBERS_REGEX,
      singleSymbolsRegex: SINGLE_SYMBOLS_REGEX
    };
    matchers2.set(key, generateMatcher(components));
  }
  return matchers2.get(key);
}
function tokenize(text, languageId, mapfn) {
  return matchAll(text, getMatcher(languageId).tokenMatcher, mapfn);
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/WordScopeHandler/WordTokenizer.ts
var CAMEL_REGEX = /\p{Lu}?\p{Ll}+|\p{Lu}+(?!\p{Ll})|\p{N}+/gu;
var WordTokenizer = class {
  constructor(languageId) {
    __publicField(this, "wordRegex");
    this.wordRegex = getMatcher(languageId).wordMatcher;
  }
  splitIdentifier(text) {
    const wordMatches = matchText(text, this.wordRegex);
    return wordMatches.length > 1 ? wordMatches : (
      // Secondly try split on camel case
      matchText(text, CAMEL_REGEX)
    );
  }
};

// ../cursorless-engine/src/util/allocateHats/HatMetrics.ts
var negativePenalty = ({ penalty }) => -penalty;
var avoidFirstLetter = ({ isFirstLetter }) => isFirstLetter ? -1 : 0;
function hatOldTokenRank(hatOldTokenRanks) {
  return ({ grapheme: { text: grapheme }, style }) => {
    const hatOldTokenRank2 = hatOldTokenRanks.get({
      grapheme,
      hatStyle: style
    });
    return hatOldTokenRank2 == null ? Infinity : -hatOldTokenRank2;
  };
}
function minimumTokenRankContainingGrapheme(tokenRank, graphemeTokenRanks) {
  const coreMetric = memoize_default((graphemeText) => {
    return min_default(graphemeTokenRanks[graphemeText].filter((r) => r > tokenRank)) ?? Infinity;
  });
  return ({ grapheme: { text } }) => coreMetric(text);
}
function isOldTokenHat(oldTokenHat) {
  return (hat) => hat.grapheme.text === oldTokenHat?.grapheme && hat.style === oldTokenHat?.hatStyle ? 1 : 0;
}
function penaltyEquivalenceClass(hatStability) {
  switch (hatStability) {
    case "greedy" /* greedy */:
      return ({ penalty }) => -penalty;
    case "balanced" /* balanced */:
      return ({ penalty }) => -(penalty < 2 ? 0 : 1);
    case "stable" /* stable */:
      return (_) => 0;
  }
}

// ../cursorless-engine/src/util/allocateHats/maxByFirstDiffering.ts
function maxByFirstDiffering(arr, fns) {
  if (arr.length === 0) {
    return void 0;
  }
  let remainingValues = arr;
  for (const fn of fns) {
    if (remainingValues.length === 1) {
      return remainingValues[0];
    }
    remainingValues = maxByAllowingTies(remainingValues, fn);
  }
  return remainingValues[0];
}
function maxByAllowingTies(arr, fn) {
  let best = -Infinity;
  const keep = [];
  for (const item of arr) {
    const value = fn(item);
    if (value < best) {
      continue;
    }
    if (value > best) {
      best = value;
      keep.length = 0;
    }
    keep.push(item);
  }
  return keep;
}

// ../cursorless-engine/src/util/allocateHats/chooseTokenHat.ts
function chooseTokenHat({ hatOldTokenRanks, graphemeTokenRanks }, hatStability, tokenRank, forcedTokenHat, oldTokenHat, candidates) {
  return maxByFirstDiffering(candidates, [
    // Use forced hat
    isOldTokenHat(forcedTokenHat),
    // Discard any hats that are sufficiently worse than the best hat that we
    // wouldn't use them even if they were our old hat
    penaltyEquivalenceClass(hatStability),
    // Use our old hat if it's still in the running
    isOldTokenHat(oldTokenHat),
    // Use a free hat if possible; if not, steal the hat of the token with
    // lowest rank
    hatOldTokenRank(hatOldTokenRanks),
    // Narrow to the hats with the lowest penalty
    negativePenalty,
    // Avoid the first grapheme of the token if possible
    avoidFirstLetter,
    // Prefer hats that sit on a grapheme that doesn't appear in any highly
    // ranked token
    minimumTokenRankContainingGrapheme(tokenRank, graphemeTokenRanks)
  ]);
}

// ../cursorless-engine/src/util/allocateHats/getHatRankingContext.ts
function getHatRankingContext(tokens2, oldTokenHatMap, tokenGraphemeSplitter2) {
  const graphemeTokenRanks = {};
  const hatOldTokenRanks = new CompositeKeyMap(({ grapheme, hatStyle }) => [grapheme, hatStyle]);
  tokens2.forEach(({ token, rank }) => {
    const existingTokenHat = oldTokenHatMap.get(token);
    if (existingTokenHat != null) {
      hatOldTokenRanks.set(existingTokenHat, rank);
    }
    tokenGraphemeSplitter2.getTokenGraphemes(token.text).forEach(({ text: graphemeText }) => {
      let tokenRanksForGrapheme;
      if (graphemeText in graphemeTokenRanks) {
        tokenRanksForGrapheme = graphemeTokenRanks[graphemeText];
      } else {
        tokenRanksForGrapheme = [];
        graphemeTokenRanks[graphemeText] = tokenRanksForGrapheme;
      }
      tokenRanksForGrapheme.push(rank);
    });
  });
  return {
    hatOldTokenRanks,
    graphemeTokenRanks
  };
}

// ../cursorless-engine/src/util/allocateHats/getDisplayLineMap.ts
function getDisplayLineMap(editor, extraLines = []) {
  return new Map(
    flow_default(
      flatten_default,
      uniq_default
    )(
      concat_default(
        [extraLines],
        editor.visibleRanges.map(
          (visibleRange) => range_default(visibleRange.start.line, visibleRange.end.line + 1)
        )
      )
    ).sort((a, b) => a - b).map((value, index) => [value, index])
  );
}

// ../cursorless-engine/src/util/allocateHats/getTokenComparator.ts
function getTokenComparator(selectionDisplayLine, selectionCharacterIndex) {
  return (token1, token2) => {
    const token1LineDiff = Math.abs(token1.displayLine - selectionDisplayLine);
    const token2LineDiff = Math.abs(token2.displayLine - selectionDisplayLine);
    if (token1LineDiff < token2LineDiff) {
      return -1;
    }
    if (token1LineDiff > token2LineDiff) {
      return 1;
    }
    const token1CharacterDiff = Math.abs(
      token1.range.start.character - selectionCharacterIndex
    );
    const token2CharacterDiff = Math.abs(
      token2.range.start.character - selectionCharacterIndex
    );
    return token1CharacterDiff - token2CharacterDiff;
  };
}

// ../cursorless-engine/src/util/allocateHats/getTokensInRange.ts
function getTokensInRange(editor, range3) {
  const languageId = editor.document.languageId;
  const text = editor.document.getText(range3);
  const rangeOffset = editor.document.offsetAt(range3.start);
  return tokenize(text, languageId, (match) => {
    const startOffset = rangeOffset + match.index;
    const endOffset = rangeOffset + match.index + match[0].length;
    const range4 = new Range(
      editor.document.positionAt(startOffset),
      editor.document.positionAt(endOffset)
    );
    return {
      editor,
      text: match[0],
      range: range4,
      offsets: { start: startOffset, end: endOffset }
    };
  });
}

// ../cursorless-engine/src/util/allocateHats/getRankedTokens.ts
function getRankedTokens(activeTextEditor, visibleTextEditors, forcedHatMap) {
  const editors = getRankedEditors(
    activeTextEditor,
    visibleTextEditors
  );
  const tokens2 = editors.flatMap((editor) => {
    const referencePosition = editor.selections[0].active;
    const displayLineMap = getDisplayLineMap(editor, [referencePosition.line]);
    const tokens3 = flatten_default(
      editor.visibleRanges.map(
        (range3) => getTokensInRange(editor, range3).map((partialToken) => ({
          ...partialToken,
          displayLine: displayLineMap.get(partialToken.range.start.line)
        }))
      )
    );
    tokens3.sort(
      getTokenComparator(
        displayLineMap.get(referencePosition.line),
        referencePosition.character
      )
    );
    return tokens3;
  });
  return moveForcedHatsToFront(forcedHatMap, tokens2).map((token, index) => ({
    token,
    rank: -index
  }));
}
function moveForcedHatsToFront(forcedHatMap, tokens2) {
  if (forcedHatMap == null) {
    return tokens2;
  }
  return tokens2.sort((a, b) => {
    const aIsForced = forcedHatMap.has(a);
    const bIsForced = forcedHatMap.has(b);
    if (aIsForced && !bIsForced) {
      return -1;
    }
    if (!aIsForced && bIsForced) {
      return 1;
    }
    return 0;
  });
}
function getRankedEditors(activeTextEditor, visibleTextEditors) {
  let editors;
  if (activeTextEditor == null) {
    editors = visibleTextEditors;
  } else {
    editors = [
      activeTextEditor,
      ...visibleTextEditors.filter((editor) => editor !== activeTextEditor)
    ];
  }
  return editors;
}

// ../cursorless-engine/src/util/allocateHats/allocateHats.ts
function allocateHats({
  tokenGraphemeSplitter: tokenGraphemeSplitter2,
  enabledHatStyles,
  forceTokenHats,
  oldTokenHats,
  hatStability,
  activeTextEditor,
  visibleTextEditors
}) {
  const forcedHatMap = forceTokenHats == null ? void 0 : getTokenOldHatMap(forceTokenHats);
  const tokenOldHatMap = getTokenOldHatMap(oldTokenHats);
  const rankedTokens = getRankedTokens(
    activeTextEditor,
    visibleTextEditors,
    forcedHatMap
  );
  const context = getHatRankingContext(
    rankedTokens,
    tokenOldHatMap,
    tokenGraphemeSplitter2
  );
  const enabledHatStyleNames = Object.keys(enabledHatStyles);
  const graphemeRemainingHatCandidates = new DefaultMap(
    () => [...enabledHatStyleNames]
  );
  return rankedTokens.map(({ token, rank: tokenRank }) => {
    const tokenRemainingHatCandidates = getTokenRemainingHatCandidates(
      tokenGraphemeSplitter2,
      token,
      graphemeRemainingHatCandidates,
      enabledHatStyles
    );
    const chosenHat = chooseTokenHat(
      context,
      hatStability,
      tokenRank,
      forcedHatMap?.get(token),
      tokenOldHatMap.get(token),
      tokenRemainingHatCandidates
    );
    if (chosenHat == null) {
      return void 0;
    }
    graphemeRemainingHatCandidates.set(
      chosenHat.grapheme.text,
      graphemeRemainingHatCandidates.get(chosenHat.grapheme.text).filter((style) => style !== chosenHat.style)
    );
    return constructHatRangeDescriptor(token, chosenHat);
  }).filter((value) => value != null);
}
function getTokenOldHatMap(oldTokenHats) {
  const tokenOldHatMap = new CompositeKeyMap(
    ({ editor, offsets }) => [editor.id, offsets.start, offsets.end]
  );
  oldTokenHats.forEach(
    (descriptor) => tokenOldHatMap.set(descriptor.token, descriptor)
  );
  return tokenOldHatMap;
}
function getTokenRemainingHatCandidates(tokenGraphemeSplitter2, token, graphemeRemainingHatCandidates, enabledHatStyles) {
  const candidates = [];
  const graphemes = tokenGraphemeSplitter2.getTokenGraphemes(token.text);
  const firstLetterOffsets = new Set(
    new WordTokenizer(token.editor.document.languageId).splitIdentifier(token.text).map((word) => word.index)
  );
  for (const grapheme of graphemes) {
    const isFirstLetter = firstLetterOffsets.has(grapheme.tokenStartOffset);
    for (const style of graphemeRemainingHatCandidates.get(grapheme.text)) {
      candidates.push({
        grapheme,
        style,
        penalty: enabledHatStyles[style].penalty,
        isFirstLetter
      });
    }
  }
  return candidates;
}
function constructHatRangeDescriptor(token, chosenHat) {
  return {
    hatStyle: chosenHat.style,
    grapheme: chosenHat.grapheme.text,
    token,
    hatRange: new Range(
      token.range.start.translate(
        void 0,
        chosenHat.grapheme.tokenStartOffset
      ),
      token.range.start.translate(void 0, chosenHat.grapheme.tokenEndOffset)
    )
  };
}

// ../cursorless-engine/src/core/HatAllocator.ts
var HatAllocator = class {
  constructor(hats, context) {
    this.hats = hats;
    this.context = context;
    __publicField(this, "disposables", []);
    ide().disposeOnExit(this);
    const debouncer = new DecorationDebouncer(
      ide().configuration,
      () => this.allocateHats()
    );
    this.disposables.push(
      this.hats.onDidChangeEnabledHatStyles(debouncer.run),
      this.hats.onDidChangeIsEnabled(debouncer.run),
      // An event that fires when a text document opens
      ide().onDidOpenTextDocument(debouncer.run),
      // An event that fires when a text document closes
      ide().onDidCloseTextDocument(debouncer.run),
      // An Event which fires when the active editor has changed. Note that the event also fires when the active editor changes to undefined.
      ide().onDidChangeActiveTextEditor(debouncer.run),
      // An Event which fires when the array of visible editors has changed.
      ide().onDidChangeVisibleTextEditors(debouncer.run),
      // An event that is emitted when a text document is changed. This usually happens when the contents changes but also when other things like the dirty-state changes.
      ide().onDidChangeTextDocument(debouncer.run),
      // An Event which fires when the selection in an editor has changed.
      ide().onDidChangeTextEditorSelection(debouncer.run),
      // An Event which fires when the visible ranges of an editor has changed.
      ide().onDidChangeTextEditorVisibleRanges(debouncer.run),
      // Re-draw hats on grapheme splitting algorithm change in case they
      // changed their token hat splitting setting.
      tokenGraphemeSplitter().registerAlgorithmChangeListener(debouncer.run),
      debouncer
    );
  }
  /**
   * Allocate hats to the visible tokens.
   *
   * @param forceTokenHats If supplied, force the allocator to use these hats
   * for the given tokens. This is used for the tutorial, and for testing.
   */
  async allocateHats(forceTokenHats) {
    const activeMap = await this.context.getActiveMap();
    forceTokenHats = forceTokenHats?.map((tokenHat) => ({
      ...tokenHat,
      grapheme: tokenGraphemeSplitter().normalizeGrapheme(tokenHat.grapheme)
    }));
    const tokenHats = this.hats.isEnabled ? allocateHats({
      tokenGraphemeSplitter: tokenGraphemeSplitter(),
      enabledHatStyles: this.hats.enabledHatStyles,
      forceTokenHats,
      oldTokenHats: activeMap.tokenHats,
      hatStability: ide().configuration.getOwnConfiguration(
        "experimental.hatStability"
      ),
      activeTextEditor: ide().activeTextEditor,
      visibleTextEditors: ide().visibleTextEditors
    }) : [];
    activeMap.setTokenHats(tokenHats);
    await this.hats.setHatRanges(
      tokenHats.map(({ hatStyle, hatRange, token: { editor } }) => ({
        editor,
        range: hatRange,
        styleName: hatStyle
      }))
    );
  }
  dispose() {
    this.disposables.forEach(({ dispose }) => dispose());
  }
};

// ../cursorless-engine/src/core/IndividualHatMap.ts
var IndividualHatMap = class _IndividualHatMap {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    __publicField(this, "isExpired", false);
    __publicField(this, "documentTokenLists", /* @__PURE__ */ new Map());
    __publicField(this, "deregisterFunctions", []);
    __publicField(this, "map", {});
    __publicField(this, "_tokenHats", []);
  }
  get tokenHats() {
    return this._tokenHats;
  }
  getDocumentTokenList(document2) {
    const key = document2.uri.toString();
    let currentValue = this.documentTokenLists.get(key);
    if (currentValue == null) {
      currentValue = [];
      this.documentTokenLists.set(key, currentValue);
      this.deregisterFunctions.push(
        this.rangeUpdater.registerRangeInfoList(document2, currentValue)
      );
    }
    return currentValue;
  }
  clone() {
    const ret = new _IndividualHatMap(this.rangeUpdater);
    ret.setTokenHats(this._tokenHats);
    return ret;
  }
  /**
   * Overwrites the hat assignment for this hat token map.
   *
   * @param tokenHats The new hat assignments
   */
  setTokenHats(tokenHats) {
    this.map = {};
    this.documentTokenLists = /* @__PURE__ */ new Map();
    this.deregisterFunctions.forEach((func2) => func2());
    this.deregisterFunctions = [];
    const liveTokenHats = tokenHats.map((tokenHat) => {
      const { hatStyle, grapheme, token } = tokenHat;
      const liveToken = this.makeTokenLive(token);
      this.map[getKey(hatStyle, grapheme)] = liveToken;
      return { ...tokenHat, token: liveToken };
    });
    this._tokenHats = liveTokenHats;
  }
  makeTokenLive(token) {
    const { tokenMatcher } = getMatcher(token.editor.document.languageId);
    const liveToken = {
      ...token,
      expansionBehavior: {
        start: {
          type: "regex",
          regex: tokenMatcher
        },
        end: {
          type: "regex",
          regex: tokenMatcher
        }
      }
    };
    this.getDocumentTokenList(token.editor.document).push(liveToken);
    return liveToken;
  }
  getEntries() {
    this.checkExpired();
    return Object.entries(this.map);
  }
  getToken(hatStyle, character) {
    this.checkExpired();
    return this.map[getKey(hatStyle, tokenGraphemeSplitter().normalizeGrapheme(character))];
  }
  checkExpired() {
    if (this.isExpired) {
      throw Error("Map snapshot has expired");
    }
  }
  dispose() {
    this.isExpired = true;
    this.deregisterFunctions.forEach((func2) => func2());
    this.deregisterFunctions = [];
  }
};

// ../cursorless-engine/src/core/HatTokenMapImpl.ts
var PRE_PHRASE_SNAPSHOT_MAX_AGE_MS = 6e4;
var HatTokenMapImpl = class {
  constructor(rangeUpdater, debug, hats, commandServerApi) {
    this.debug = debug;
    this.commandServerApi = commandServerApi;
    /**
     * This is the active map that changes every time we reallocate hats. It is
     * liable to change in the middle of a phrase.
     */
    __publicField(this, "activeMap");
    /**
     * This is a snapshot of the hat map that remains stable over the course of a
     * phrase. Ranges will be updated to account for changes to the document, but a
     * hat with the same color and shape will refer to the same logical range.
     */
    __publicField(this, "prePhraseMapSnapshot");
    __publicField(this, "prePhraseMapsSnapshotTimestamp", null);
    __publicField(this, "lastSignalVersion", null);
    __publicField(this, "hatAllocator");
    ide().disposeOnExit(this);
    this.activeMap = new IndividualHatMap(rangeUpdater);
    this.getActiveMap = this.getActiveMap.bind(this);
    this.allocateHats = this.allocateHats.bind(this);
    this.hatAllocator = new HatAllocator(hats, {
      getActiveMap: this.getActiveMap
    });
  }
  /**
   * Allocate hats to the visible tokens.
   *
   * @param forceTokenHats If supplied, force the allocator to use these hats
   * for the given tokens. This is used for the tutorial, and for testing.
   */
  allocateHats(forceTokenHats) {
    return this.hatAllocator.allocateHats(forceTokenHats);
  }
  async getActiveMap() {
    await this.maybeTakePrePhraseSnapshot();
    return this.activeMap;
  }
  /**
   * Returns a transient, read-only hat map for use during the course of a
   * single command.
   *
   * Please do not hold onto this copy beyond the lifetime of a single command,
   * because it will get stale.
   * @param usePrePhraseSnapshot Whether to use pre-phrase snapshot
   * @returns A readable snapshot of the map
   */
  async getReadableMap(usePrePhraseSnapshot) {
    await this.maybeTakePrePhraseSnapshot();
    if (usePrePhraseSnapshot) {
      if (this.lastSignalVersion == null) {
        console.error(
          "Pre phrase snapshot requested but no signal was present; please upgrade command client"
        );
        return this.activeMap;
      }
      if (this.prePhraseMapSnapshot == null) {
        console.error(
          "Navigation map pre-phrase snapshot requested, but no snapshot has been taken"
        );
        return this.activeMap;
      }
      if (performance.now() - this.prePhraseMapsSnapshotTimestamp > PRE_PHRASE_SNAPSHOT_MAX_AGE_MS) {
        console.error(
          "Navigation map pre-phrase snapshot requested, but snapshot is more than a minute old"
        );
        return this.activeMap;
      }
      return this.prePhraseMapSnapshot;
    }
    return this.activeMap;
  }
  dispose() {
    this.activeMap.dispose();
    if (this.prePhraseMapSnapshot != null) {
      this.prePhraseMapSnapshot.dispose();
    }
  }
  async maybeTakePrePhraseSnapshot() {
    const newSignalVersion = await this.commandServerApi.signals.prePhrase.getVersion();
    if (newSignalVersion !== this.lastSignalVersion) {
      this.debug.log("taking snapshot");
      this.lastSignalVersion = newSignalVersion;
      if (newSignalVersion != null) {
        this.takePrePhraseSnapshot();
      }
    }
  }
  takePrePhraseSnapshot() {
    if (this.prePhraseMapSnapshot != null) {
      this.prePhraseMapSnapshot.dispose();
    }
    this.prePhraseMapSnapshot = this.activeMap.clone();
    this.prePhraseMapsSnapshotTimestamp = performance.now();
  }
};

// ../cursorless-engine/src/util/map.ts
function getDefault(map4, key, factory) {
  let currentValue = map4.get(key);
  if (currentValue == null) {
    currentValue = factory();
    map4.set(key, currentValue);
  }
  return currentValue;
}

// ../cursorless-engine/src/core/updateSelections/getOffsetsForDeleteOrReplace.ts
var import_immutability_helper = __toESM(require_immutability_helper(), 1);
function getOffsetsForDeleteOrReplace(changeEventInfo, rangeInfo) {
  const {
    originalOffsets: {
      start: changeOriginalStartOffset,
      end: changeOriginalEndOffset
    },
    finalOffsets: { end: changeFinalEndOffset },
    displacement
  } = changeEventInfo;
  const {
    offsets: { start: rangeStart, end: rangeEnd }
  } = rangeInfo;
  (0, import_immutability_helper.invariant)(
    changeOriginalEndOffset > changeOriginalStartOffset,
    () => "Change range expected to be nonempty"
  );
  (0, import_immutability_helper.invariant)(
    changeOriginalEndOffset >= rangeStart && changeOriginalStartOffset <= rangeEnd,
    () => "Change range expected to intersect with selection range"
  );
  return {
    start: changeOriginalEndOffset <= rangeStart ? rangeStart + displacement : Math.min(rangeStart, changeFinalEndOffset),
    end: changeOriginalEndOffset <= rangeEnd ? rangeEnd + displacement : Math.min(rangeEnd, changeFinalEndOffset)
  };
}

// ../cursorless-engine/src/core/updateSelections/getOffsetsForEmptyRangeInsert.ts
var import_immutability_helper2 = __toESM(require_immutability_helper(), 1);
function getOffsetsForEmptyRangeInsert(changeEventInfo, rangeInfo) {
  const {
    event: { text, isReplace: isReplace2 },
    finalOffsets: { start: start2, end }
  } = changeEventInfo;
  (0, import_immutability_helper2.invariant)(
    start2 === changeEventInfo.originalOffsets.end && start2 === rangeInfo.offsets.start && start2 === rangeInfo.offsets.end,
    () => "Selection range and change range expected to be same empty range"
  );
  if (isReplace2) {
    const expansionBehavior = rangeInfo.expansionBehavior.end;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: start2,
          end: start2
        };
      case "open":
        return { start: start2, end };
      case "regex": {
        const matches = text.match(leftAnchored(expansionBehavior.regex));
        return matches == null ? {
          start: start2,
          end: start2
        } : {
          start: start2,
          end: start2 + matches[0].length
        };
      }
    }
  } else {
    const expansionBehavior = rangeInfo.expansionBehavior.start;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: end,
          end
        };
      case "open":
        return { start: start2, end };
      case "regex": {
        const index = text.search(rightAnchored(expansionBehavior.regex));
        return index === -1 ? {
          start: end,
          end
        } : {
          start: start2 + index,
          end
        };
      }
    }
  }
}

// ../cursorless-engine/src/core/updateSelections/getOffsetsForNonEmptyRangeInsert.ts
var import_immutability_helper3 = __toESM(require_immutability_helper(), 1);
function getOffsetsForNonEmptyRangeInsert(changeEventInfo, rangeInfo) {
  const {
    event: { text: insertedText },
    originalOffsets: { start: insertOffset },
    displacement
  } = changeEventInfo;
  const {
    offsets: { start: rangeStart, end: rangeEnd },
    text: originalRangeText
  } = rangeInfo;
  (0, import_immutability_helper3.invariant)(
    rangeEnd > rangeStart,
    () => "Selection range expected to be nonempty"
  );
  (0, import_immutability_helper3.invariant)(
    insertOffset >= rangeStart && insertOffset <= rangeEnd,
    () => "Insertion offset expected to intersect with selection range"
  );
  if (insertOffset > rangeStart && insertOffset < rangeEnd) {
    return { start: rangeStart, end: rangeEnd + displacement };
  }
  if (insertOffset === rangeStart) {
    const expansionBehavior = rangeInfo.expansionBehavior.start;
    const newRangeEnd = rangeEnd + displacement;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: rangeStart + displacement,
          end: newRangeEnd
        };
      case "open":
        return {
          start: rangeStart,
          end: newRangeEnd
        };
      case "regex": {
        let text = insertedText + originalRangeText;
        const regex = rightAnchored(expansionBehavior.regex);
        let index = text.search(regex);
        while (index > insertedText.length) {
          text = text.slice(0, index);
          index = text.search(regex);
        }
        return index === -1 ? {
          start: rangeStart,
          end: newRangeEnd
        } : {
          start: rangeStart + index,
          end: newRangeEnd
        };
      }
    }
  } else {
    const expansionBehavior = rangeInfo.expansionBehavior.end;
    const newRangeStart = rangeStart;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: newRangeStart,
          end: rangeEnd
        };
      case "open":
        return {
          start: newRangeStart,
          end: rangeEnd + displacement
        };
      case "regex": {
        let text = originalRangeText + insertedText;
        const regex = leftAnchored(expansionBehavior.regex);
        let matches = text.match(regex);
        let matchLength = matches == null ? 0 : matches[0].length;
        while (matchLength !== 0 && matchLength < originalRangeText.length) {
          text = originalRangeText.slice(matchLength) + insertedText;
          matches = text.match(regex);
          matchLength = matches == null ? 0 : matchLength + matches[0].length;
        }
        return matchLength === 0 ? {
          start: newRangeStart,
          end: rangeEnd
        } : {
          start: newRangeStart,
          end: rangeStart + matchLength
        };
      }
    }
  }
}

// ../cursorless-engine/src/core/updateSelections/getUpdatedText.ts
function getUpdatedText(changeEventInfo, rangeInfo, newOffsets) {
  const { start: changeOriginalOffsetsStart, end: changeOriginalOffsetsEnd } = changeEventInfo.originalOffsets;
  const { start: rangeOriginalOffsetsStart, end: rangeOriginalOffsetsEnd } = rangeInfo.offsets;
  const newTextStartOffset = Math.min(
    changeOriginalOffsetsStart,
    rangeOriginalOffsetsStart
  );
  let result = "";
  if (rangeOriginalOffsetsStart < changeOriginalOffsetsStart) {
    result += rangeInfo.text.substring(
      0,
      changeOriginalOffsetsStart - rangeOriginalOffsetsStart
    );
  }
  result += changeEventInfo.event.text;
  if (changeOriginalOffsetsEnd < rangeOriginalOffsetsEnd) {
    result += rangeInfo.text.substring(
      rangeOriginalOffsetsEnd - changeOriginalOffsetsEnd,
      rangeInfo.text.length
    );
  }
  return result.substring(
    newOffsets.start - newTextStartOffset,
    newOffsets.end - newTextStartOffset
  );
}

// ../cursorless-engine/src/core/updateSelections/updateRangeInfos.ts
function updateRangeInfos(changeEvent, rangeInfoGenerator) {
  const { document: document2, contentChanges } = changeEvent;
  const changeEventInfos = contentChanges.map((change) => {
    const changeDisplacement = change.text.length - change.rangeLength;
    const changeOriginalStartOffset = change.rangeOffset;
    const changeOriginalEndOffset = changeOriginalStartOffset + change.rangeLength;
    const changeFinalStartOffset = changeOriginalStartOffset;
    const changeFinalEndOffset = changeOriginalEndOffset + changeDisplacement;
    return {
      displacement: changeDisplacement,
      event: change,
      originalOffsets: {
        start: changeOriginalStartOffset,
        end: changeOriginalEndOffset
      },
      finalOffsets: {
        start: changeFinalStartOffset,
        end: changeFinalEndOffset
      }
    };
  });
  for (const rangeInfo of rangeInfoGenerator) {
    const originalOffsets = rangeInfo.offsets;
    const displacements = changeEventInfos.map((changeEventInfo) => {
      let newOffsets2;
      if (changeEventInfo.originalOffsets.start > originalOffsets.end) {
        return {
          start: 0,
          end: 0
        };
      }
      if (changeEventInfo.originalOffsets.end < originalOffsets.start) {
        return {
          start: changeEventInfo.displacement,
          end: changeEventInfo.displacement
        };
      }
      if (changeEventInfo.event.rangeLength === 0) {
        if (rangeInfo.range.isEmpty) {
          newOffsets2 = getOffsetsForEmptyRangeInsert(
            changeEventInfo,
            rangeInfo
          );
        } else {
          newOffsets2 = getOffsetsForNonEmptyRangeInsert(
            changeEventInfo,
            rangeInfo
          );
        }
      } else {
        newOffsets2 = getOffsetsForDeleteOrReplace(changeEventInfo, rangeInfo);
      }
      rangeInfo.text = getUpdatedText(changeEventInfo, rangeInfo, newOffsets2);
      return {
        start: newOffsets2.start - originalOffsets.start,
        end: newOffsets2.end - originalOffsets.end
      };
    });
    const newOffsets = {
      start: originalOffsets.start + sumBy_default(displacements, ({ start: start2 }) => start2),
      end: originalOffsets.end + sumBy_default(displacements, ({ end }) => end)
    };
    rangeInfo.range = rangeInfo.range.with(
      document2.positionAt(newOffsets.start),
      document2.positionAt(newOffsets.end)
    );
    rangeInfo.offsets = newOffsets;
  }
}

// ../cursorless-engine/src/core/updateSelections/RangeUpdater.ts
var RangeUpdater = class {
  constructor() {
    __publicField(this, "rangeInfoLists", /* @__PURE__ */ new Map());
    __publicField(this, "replaceEditLists", /* @__PURE__ */ new Map());
    __publicField(this, "disposables", []);
    this.listenForDocumentChanges();
  }
  /**
   * Registers a list of range infos to be kept up to date.  It is ok to
   * add to this list after registering it; any items in the list at the time of
   * a document change will be kept up to date.  Please be sure to call the
   * returned deregister function when you no longer need the ranges
   * updated.
   * @param document The document containing the ranges
   * @param rangeInfoList The ranges to keep up to date; it is ok to add to this list after the fact
   * @returns A function that can be used to deregister the list
   */
  registerRangeInfoList(document2, rangeInfoList) {
    const key = document2.uri.toString();
    const documentRangeInfoLists = getDefault(
      this.rangeInfoLists,
      key,
      () => []
    );
    documentRangeInfoLists.push(rangeInfoList);
    return () => {
      pull_default(documentRangeInfoLists, rangeInfoList);
      if (documentRangeInfoLists.length === 0 && this.rangeInfoLists.get(key) === documentRangeInfoLists) {
        this.rangeInfoLists.delete(key);
      }
    };
  }
  /**
   * Registers a list of edits to treat as replace edits. These edits are
   * insertions that will not shift an empty selection to the right. Call this
   * function before applying your edits to the document
   *
   * Note that if you make two edits at the same location with the same text,
   * it is not possible to mark only one of them as replace edit.
   *
   * It is ok to add to this list after registering it; any items in the list
   * at the time of a document change will be treated as replace edits.  Please
   * be sure to call the returned deregister function after you have waited for
   * your edits to be applied.
   * @param document The document containing the ranges
   * @param replaceEditList A list of edits to treat as replace edits; it is ok to add to this list after the fact
   * @returns A function that can be used to deregister the list
   */
  registerReplaceEditList(document2, replaceEditList) {
    const key = document2.uri.toString();
    const documentReplaceEditLists = getDefault(
      this.replaceEditLists,
      key,
      () => []
    );
    documentReplaceEditLists.push(replaceEditList);
    return () => {
      pull_default(documentReplaceEditLists, replaceEditList);
      if (documentReplaceEditLists.length === 0 && this.replaceEditLists.get(key) === documentReplaceEditLists) {
        this.replaceEditLists.delete(key);
      }
    };
  }
  *documentRangeInfoGenerator(document2) {
    const documentRangeInfoLists = this.rangeInfoLists.get(document2.uri.toString()) ?? [];
    for (const rangeInfoLists of documentRangeInfoLists) {
      for (const rangeInfo of rangeInfoLists) {
        yield rangeInfo;
      }
    }
  }
  listenForDocumentChanges() {
    this.disposables.push(
      ide().onDidChangeTextDocument((event) => {
        const documentReplaceEditLists = this.replaceEditLists.get(event.document.uri.toString()) ?? [];
        const extendedEvent = {
          ...event,
          contentChanges: event.contentChanges.map(
            (change) => isReplace(documentReplaceEditLists, change) ? {
              ...change,
              isReplace: true
            } : change
          )
        };
        updateRangeInfos(
          extendedEvent,
          this.documentRangeInfoGenerator(event.document)
        );
      }),
      ide().onDidCloseTextDocument((document2) => {
        const key = document2.uri.toString();
        this.rangeInfoLists.delete(key);
        this.replaceEditLists.delete(key);
      })
    );
  }
  dispose() {
    this.disposables.forEach((disposable) => disposable.dispose());
  }
};
function isReplace(documentReplaceEditLists, change) {
  for (const replaceEditLists of documentReplaceEditLists) {
    for (const replaceEdit of replaceEditLists) {
      if (replaceEdit.range.isRangeEqual(change.range) && replaceEdit.text === change.text) {
        return true;
      }
    }
  }
  return false;
}

// ../cursorless-engine/src/disabledComponents/DisabledCommandServerApi.ts
var DisabledCommandServerApi = class {
  constructor() {
    __publicField(this, "signals", {
      prePhrase: {
        getVersion() {
          return Promise.resolve(null);
        }
      }
    });
  }
  getFocusedElementType() {
    return Promise.resolve(void 0);
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledHatTokenMap.ts
var DisabledHatTokenMap = class {
  async allocateHats() {
  }
  async getReadableMap() {
    return {
      getEntries() {
        return [];
      },
      getToken() {
        throw new Error("Hat map is disabled");
      }
    };
  }
  dispose() {
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledLanguageDefinitions.ts
var DisabledLanguageDefinitions = class {
  onDidChangeDefinition(_listener) {
    return { dispose: () => {
    } };
  }
  loadLanguage(_languageId) {
    return Promise.resolve();
  }
  get(_languageId) {
    return void 0;
  }
  dispose() {
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledSnippets.ts
var DisabledSnippets = class {
  openNewSnippetFile(_snippetName, _directory) {
    throw new Error("Snippets are not implemented.");
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledTalonSpokenForms.ts
var DisabledTalonSpokenForms = class {
  getSpokenFormEntries() {
    throw new DisabledCustomSpokenFormsError();
  }
  onDidChange() {
    return { dispose: () => {
    } };
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledTreeSitter.ts
var DisabledTreeSitter = class {
  getTree(_document) {
    throw new Error("Tree sitter not provided");
  }
  loadLanguage(_languageId) {
    return Promise.resolve(false);
  }
  getNodeAtLocation(_document, _range) {
    throw new Error("Tree sitter not provided");
  }
  createQuery(_languageId, _source) {
    throw new Error("Tree sitter not provided");
  }
};

// ../cursorless-engine/src/spokenForms/CustomSpokenForms.ts
var CustomSpokenForms = class {
  constructor(talonSpokenForms) {
    this.talonSpokenForms = talonSpokenForms;
    __publicField(this, "disposable");
    __publicField(this, "notifier", new Notifier());
    /**
     * A promise that resolves when the custom spoken forms have been loaded.
     */
    __publicField(this, "customSpokenFormsInitialized");
    __publicField(this, "spokenFormMap_", { ...defaultSpokenFormMap });
    __publicField(this, "needsInitialTalonUpdate_");
    /**
     * Registers a callback to be run when the custom spoken forms change.
     * @param callback The callback to run when the scope ranges change
     * @returns A {@link Disposable} which will stop the callback from running
     */
    __publicField(this, "onDidChangeCustomSpokenForms", this.notifier.registerListener);
    this.disposable = talonSpokenForms.onDidChange(
      () => this.updateSpokenFormMaps()
    );
    this.customSpokenFormsInitialized = this.updateSpokenFormMaps();
  }
  get spokenFormMap() {
    return this.spokenFormMap_;
  }
  /**
   * If `true`, indicates they need to update their Talon files to get the
   * machinery used to share spoken forms from Talon to the VSCode extension.
   */
  get needsInitialTalonUpdate() {
    return this.needsInitialTalonUpdate_;
  }
  async updateSpokenFormMaps() {
    let allCustomEntries;
    this.needsInitialTalonUpdate_ = false;
    try {
      allCustomEntries = await this.talonSpokenForms.getSpokenFormEntries();
      if (allCustomEntries.length === 0) {
        throw new Error("Custom spoken forms list empty");
      }
    } catch (err2) {
      if (err2 instanceof NeedsInitialTalonUpdateError) {
        this.needsInitialTalonUpdate_ = true;
      } else if (err2 instanceof DisabledCustomSpokenFormsError) {
      } else {
        console.error("Error loading custom spoken forms", err2);
        const msg = err2.message.replace(/\.$/, "");
        void showError(
          ide().messages,
          "CustomSpokenForms.updateSpokenFormMaps",
          `Error loading custom spoken forms: ${msg}. Falling back to default spoken forms.`
        );
      }
      this.spokenFormMap_ = { ...defaultSpokenFormMap };
      this.notifier.notifyListeners();
      return;
    }
    for (const entryType of SUPPORTED_ENTRY_TYPES) {
      updateEntriesForType(
        this.spokenFormMap_,
        entryType,
        defaultSpokenFormInfoMap[entryType],
        Object.fromEntries(
          allCustomEntries.filter((entry) => entry.type === entryType).map(({ id: id2, spokenForms }) => [id2, spokenForms])
        )
      );
    }
    this.notifier.notifyListeners();
  }
  getCustomRegexScopeTypes() {
    return Object.keys(this.spokenFormMap_.customRegex).map((regex) => ({
      type: "customRegex",
      regex
    }));
  }
  dispose() {
    this.disposable.dispose();
  }
};
function updateEntriesForType(spokenFormMapToUpdate, key, defaultEntries, customEntries) {
  const ids = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(defaultEntries), ...Object.keys(customEntries)])
  );
  const obj = {};
  for (const id2 of ids) {
    const { defaultSpokenForms = [], isPrivate: isPrivate2 = false } = defaultEntries[id2] ?? {};
    const customSpokenForms = customEntries[id2];
    obj[id2] = customSpokenForms == null ? (
      // No entry for the given id. This either means that the user needs to
      // update Talon, or it's a private spoken form.
      {
        defaultSpokenForms,
        spokenForms: [],
        // If it's not a private spoken form, then it's a new scope type
        requiresTalonUpdate: !isPrivate2,
        isCustom: false,
        isPrivate: isPrivate2
      }
    ) : (
      // We have an entry for the given id
      {
        defaultSpokenForms,
        spokenForms: customSpokenForms,
        requiresTalonUpdate: false,
        isCustom: !isEqual_default(defaultSpokenForms, customSpokenForms),
        isPrivate: isPrivate2
      }
    );
  }
  spokenFormMapToUpdate[key] = obj;
}

// ../cursorless-engine/src/generateSpokenForm/NoSpokenFormError.ts
var NoSpokenFormError = class extends Error {
  constructor(reason, requiresTalonUpdate = false, isPrivate2 = false) {
    super(`No spoken form for: ${reason}`);
    this.reason = reason;
    this.requiresTalonUpdate = requiresTalonUpdate;
    this.isPrivate = isPrivate2;
  }
};

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/surroundingPairsDelimiters.ts
var surroundingPairsDelimiters = {
  curlyBrackets: ["{", "}"],
  angleBrackets: ["<", ">"],
  escapedDoubleQuotes: ['\\"', '\\"'],
  escapedSingleQuotes: ["\\'", "\\'"],
  escapedParentheses: ["\\(", "\\)"],
  escapedSquareBrackets: ["\\[", "\\]"],
  doubleQuotes: ['"', '"'],
  parentheses: ["(", ")"],
  backtickQuotes: ["`", "`"],
  squareBrackets: ["[", "]"],
  singleQuotes: ["'", "'"],
  tripleBacktickQuotes: ["```", "```"],
  tripleDoubleQuotes: ['"""', '"""'],
  tripleSingleQuotes: ["'''", "'''"],
  whitespace: [" ", " "],
  any: null,
  string: null,
  collectionBoundary: null
};

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/modifiers.ts
var surroundingPairDelimiterToName = new CompositeKeyMap((pair) => pair);
for (const [name2, pair] of Object.entries(surroundingPairsDelimiters)) {
  if (pair != null) {
    surroundingPairDelimiterToName.set(
      pair,
      name2
    );
  }
}
function surroundingPairDelimitersToSpokenForm(spokenFormMap, left, right) {
  const pairName = surroundingPairDelimiterToName.get([left, right]);
  if (pairName == null) {
    throw Error(`Unknown surrounding pair delimiters '${left} ${right}'`);
  }
  return spokenFormMap.pairedDelimiter[pairName];
}

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/snippets.ts
function insertionSnippetToSpokenForm(snippetDescription) {
  throw new NoSpokenFormError(`${snippetDescription.type} insertion snippet`);
}
function wrapperSnippetToSpokenForm(snippetDescription) {
  throw new NoSpokenFormError(`${snippetDescription.type} wrap with snippet`);
}

// ../cursorless-engine/src/generateSpokenForm/getRangeConnective.ts
function getRangeConnective(excludeAnchor, excludeActive, type2) {
  const prefix = type2 === "vertical" ? `${connectives.verticalRange} ` : "";
  if (excludeAnchor && excludeActive) {
    return prefix + connectives.rangeExclusive;
  }
  if (excludeAnchor) {
    throw new NoSpokenFormError("Range exclude anchor");
  }
  if (excludeActive) {
    return prefix + connectives.rangeExcludingEnd;
  }
  if (type2 === "vertical") {
    return connectives.verticalRange;
  }
  return connectives.rangeInclusive;
}

// ../cursorless-engine/src/generateSpokenForm/getSpokenFormComponentMap.ts
function getSpokenFormComponentMap(spokenFormMap) {
  return Object.fromEntries(
    Object.entries(spokenFormMap).map(([spokenFormType, map4]) => [
      spokenFormType,
      Object.fromEntries(
        Object.entries(map4).map(([id2, spokenForms]) => [
          id2,
          {
            type: "customizable",
            spokenForms,
            spokenFormType,
            id: id2
          }
        ])
      )
    ])
    // FIXME: Don't cast here; need to make our own mapValues with stronger typing
    // using tricks from our object.d.ts
  );
}

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/numbers.ts
var numbers = [
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen",
  "twenty",
  "twenty one",
  "twenty two",
  "twenty three",
  "twenty four",
  "twenty five",
  "twenty six",
  "twenty seven",
  "twenty eight",
  "twenty nine",
  "thirty",
  "thirty one",
  "thirty two",
  "thirty three",
  "thirty four",
  "thirty five",
  "thirty six",
  "thirty seven",
  "thirty eight",
  "thirty nine",
  "forty",
  "forty one",
  "forty two",
  "forty three",
  "forty four",
  "forty five",
  "forty six",
  "forty seven",
  "forty eight",
  "forty nine",
  "fifty",
  "fifty one",
  "fifty two",
  "fifty three",
  "fifty four",
  "fifty five",
  "fifty six",
  "fifty seven",
  "fifty eight",
  "fifty nine",
  "sixty",
  "sixty one",
  "sixty two",
  "sixty three",
  "sixty four",
  "sixty five",
  "sixty six",
  "sixty seven",
  "sixty eight",
  "sixty nine",
  "seventy",
  "seventy one",
  "seventy two",
  "seventy three",
  "seventy four",
  "seventy five",
  "seventy six",
  "seventy seven",
  "seventy eight",
  "seventy nine",
  "eighty",
  "eighty one",
  "eighty two",
  "eighty three",
  "eighty four",
  "eighty five",
  "eighty six",
  "eighty seven",
  "eighty eight",
  "eighty nine",
  "ninety",
  "ninety one",
  "ninety two",
  "ninety three",
  "ninety four",
  "ninety five",
  "ninety six",
  "ninety seven",
  "ninety eight",
  "ninety nine"
];
var ordinals = [
  "zeroth",
  "first",
  "second",
  "third",
  "fourth",
  "fifth",
  "sixth",
  "seventh",
  "eighth",
  "ninth",
  "tenth",
  "eleventh",
  "twelfth",
  "thirteenth",
  "fourteenth",
  "fifteenth",
  "sixteenth",
  "seventeenth",
  "eighteenth",
  "nineteenth",
  "twentieth"
];
function numberToSpokenForm(number4) {
  const result = numbers[number4];
  if (result == null) {
    throw Error(`Unknown number '${number4}'`);
  }
  return result;
}
function ordinalToSpokenForm(ordinal) {
  const result = ordinals[ordinal];
  if (result == null) {
    throw Error(`Unknown ordinal '${ordinal}'`);
  }
  return result;
}

// ../cursorless-engine/src/generateSpokenForm/primitiveTargetToSpokenForm.ts
var PrimitiveTargetSpokenFormGenerator = class {
  constructor(spokenFormMap) {
    this.spokenFormMap = spokenFormMap;
    this.handleModifier = this.handleModifier.bind(this);
  }
  handlePrimitiveTarget(target) {
    const components = [];
    if (target.modifiers != null) {
      components.push(target.modifiers.map(this.handleModifier));
    }
    if (target.mark != null) {
      components.push(this.handleMark(target.mark));
    }
    return components;
  }
  handleModifier(modifier) {
    switch (modifier.type) {
      case "fallback":
      case "modifyIfUntyped":
      case "preferredScope":
        throw new NoSpokenFormError(`Modifier '${modifier.type}'`);
      case "containingScope":
        if (modifier.ancestorIndex == null || modifier.ancestorIndex === 0) {
          return this.handleScopeType(modifier.scopeType);
        }
        return [
          new Array(modifier.ancestorIndex).fill(
            this.spokenFormMap.modifierExtra.ancestor
          ),
          this.handleScopeType(modifier.scopeType)
        ];
      case "everyScope":
        return [
          this.spokenFormMap.simpleModifier.everyScope,
          this.handleScopeType(modifier.scopeType)
        ];
      case "extendThroughStartOf":
      case "extendThroughEndOf": {
        const type2 = this.spokenFormMap.simpleModifier[modifier.type];
        return modifier.modifiers != null ? [type2, modifier.modifiers.map(this.handleModifier)] : [type2];
      }
      case "relativeScope":
        return modifier.offset === 0 ? this.handleRelativeScopeInclusive(modifier) : this.handleRelativeScopeExclusive(modifier);
      case "ordinalScope": {
        const scope = this.handleScopeType(modifier.scopeType);
        const isEvery = modifier.isEvery ? this.spokenFormMap.simpleModifier.everyScope : [];
        if (modifier.length === 1) {
          if (modifier.start === -1) {
            return [isEvery, this.spokenFormMap.modifierExtra.last, scope];
          }
          if (modifier.start === 0) {
            return [isEvery, this.spokenFormMap.modifierExtra.first, scope];
          }
          if (modifier.start < 0) {
            return [
              isEvery,
              ordinalToSpokenForm(Math.abs(modifier.start)),
              this.spokenFormMap.modifierExtra.last,
              scope
            ];
          }
          return [isEvery, ordinalToSpokenForm(modifier.start + 1), scope];
        }
        const number4 = numberToSpokenForm(modifier.length);
        if (modifier.start === 0) {
          return [
            isEvery,
            this.spokenFormMap.modifierExtra.first,
            number4,
            pluralize(scope)
          ];
        }
        if (modifier.start === -modifier.length) {
          return [
            isEvery,
            this.spokenFormMap.modifierExtra.last,
            number4,
            pluralize(scope)
          ];
        }
        throw new NoSpokenFormError(
          `'${modifier.type}' with count > 1 and offset away from start / end`
        );
      }
      case "range": {
        if (modifier.anchor.type === "ordinalScope" && modifier.active.type === "ordinalScope" && modifier.anchor.length === 1 && modifier.active.length === 1 && modifier.anchor.scopeType.type === modifier.active.scopeType.type) {
          const anchor = modifier.anchor.start === -1 ? this.spokenFormMap.modifierExtra.last : ordinalToSpokenForm(modifier.anchor.start + 1);
          const active = this.handleModifier(modifier.active);
          const connective = getRangeConnective(
            modifier.excludeAnchor,
            modifier.excludeActive
          );
          return [anchor, connective, active];
        }
        throw Error(`Modifier '${modifier.type}' is not fully implemented`);
      }
      default:
        return [this.spokenFormMap.simpleModifier[modifier.type]];
    }
  }
  handleRelativeScopeInclusive(modifier) {
    const scope = this.handleScopeType(modifier.scopeType);
    const isEvery = modifier.isEvery ? this.spokenFormMap.simpleModifier.everyScope : [];
    if (modifier.length === 1) {
      const direction2 = modifier.direction === "forward" ? connectives.forward : connectives.backward;
      return [isEvery, scope, direction2];
    }
    const length = numberToSpokenForm(modifier.length);
    const scopePlural = pluralize(scope);
    if (modifier.direction === "forward") {
      return [isEvery, length, scopePlural];
    }
    return [isEvery, length, scopePlural, connectives.backward];
  }
  handleRelativeScopeExclusive(modifier) {
    const scope = this.handleScopeType(modifier.scopeType);
    const direction2 = modifier.direction === "forward" ? connectives.next : connectives.previous;
    const isEvery = modifier.isEvery ? this.spokenFormMap.simpleModifier.everyScope : [];
    if (modifier.offset === 1) {
      const number4 = numberToSpokenForm(modifier.length);
      if (modifier.length === 1) {
        return [isEvery, direction2, scope];
      }
      const scopePlural = pluralize(scope);
      return [isEvery, direction2, number4, scopePlural];
    }
    if (modifier.length === 1) {
      const ordinal = ordinalToSpokenForm(modifier.offset);
      return [isEvery, ordinal, direction2, scope];
    }
    throw new NoSpokenFormError(
      `${modifier.type} modifier with offset > 1 and length > 1`
    );
  }
  handleScopeType(scopeType) {
    switch (scopeType.type) {
      case "oneOf":
      case "surroundingPairInterior":
        throw new NoSpokenFormError(`Scope type '${scopeType.type}'`);
      case "glyph":
        return [
          this.spokenFormMap.complexScopeTypeType.glyph,
          getSpokenFormStrict(
            this.spokenFormMap.grapheme,
            "grapheme",
            scopeType.character
          )
        ];
      case "surroundingPair": {
        return this.spokenFormMap.pairedDelimiter[scopeType.delimiter];
      }
      case "customRegex":
        return this.spokenFormMap.customRegex[scopeType.regex] ?? {
          type: "customizable",
          spokenForms: {
            spokenForms: [],
            isCustom: true,
            defaultSpokenForms: [],
            requiresTalonUpdate: false,
            isPrivate: false
          },
          spokenFormType: "customRegex",
          id: scopeType.regex
        };
      case "interior":
        return this.spokenFormMap.simpleModifier.interiorOnly;
      default:
        return this.spokenFormMap.simpleScopeTypeType[scopeType.type];
    }
  }
  handleMark(mark) {
    switch (mark.type) {
      case "decoratedSymbol": {
        const [color, shape] = mark.symbolColor.split("-");
        const components = [];
        if (color !== "default") {
          components.push(hatColorToSpokenForm(color));
        }
        if (shape != null) {
          components.push(hatShapeToSpokenForm(shape));
        }
        components.push(
          getSpokenFormStrict(
            this.spokenFormMap.grapheme,
            "grapheme",
            mark.character
          )
        );
        return components;
      }
      case "lineNumber": {
        return this.handleLineNumberMark(mark);
      }
      case "range": {
        if (mark.anchor.type === "lineNumber" && mark.active.type === "lineNumber") {
          const [typeAnchor, numberAnchor] = this.handleLineNumberMark(
            mark.anchor
          );
          const [typeActive, numberActive] = this.handleLineNumberMark(
            mark.active
          );
          if (typeAnchor === typeActive) {
            const connective = getRangeConnective(
              mark.excludeAnchor,
              mark.excludeActive
            );
            return [typeAnchor, numberAnchor, connective, numberActive];
          }
        }
        throw Error(`Mark '${mark.type}' is not fully implemented`);
      }
      case "explicit":
      case "keyboard":
      case "target":
        throw new NoSpokenFormError(`Mark '${mark.type}'`);
      default:
        return [marks[mark.type]];
    }
  }
  handleLineNumberMark(mark) {
    switch (mark.lineNumberType) {
      case "absolute":
        throw new NoSpokenFormError("Absolute line numbers");
      case "modulo100": {
        return [
          lineDirections.modulo100,
          numberToSpokenForm(mark.lineNumber + 1)
        ];
      }
      case "relative": {
        return [
          mark.lineNumber < 0 ? lineDirections.relativeUp : lineDirections.relativeDown,
          numberToSpokenForm(Math.abs(mark.lineNumber))
        ];
      }
    }
  }
};
function pluralize(name2) {
  if (typeof name2 === "string") {
    return pluralizeString(name2);
  }
  if (Array.isArray(name2)) {
    if (name2.length === 0) {
      return name2;
    }
    const last2 = name2[name2.length - 1];
    return [...name2.slice(0, -1), pluralize(last2)];
  }
  return {
    ...name2,
    spokenForms: {
      ...name2.spokenForms,
      spokenForms: name2.spokenForms.spokenForms.map(pluralizeString)
    }
  };
}
function pluralizeString(name2) {
  return `${name2}s`;
}
function getSpokenFormStrict(map4, typeName, key) {
  const spokenForm = map4[key];
  if (spokenForm == null) {
    throw new NoSpokenFormError(`${typeName} '${key}'`);
  }
  return spokenForm;
}

// ../cursorless-engine/src/generateSpokenForm/generateSpokenForm.ts
var SpokenFormGenerator = class {
  constructor(spokenFormMap) {
    __publicField(this, "primitiveGenerator");
    __publicField(this, "spokenFormMap");
    this.spokenFormMap = getSpokenFormComponentMap(spokenFormMap);
    this.primitiveGenerator = new PrimitiveTargetSpokenFormGenerator(
      this.spokenFormMap
    );
  }
  getSpokenFormForSingleTerm(type2, id2) {
    return this.componentsToSpokenForm(() => {
      const value = this.spokenFormMap[type2][id2];
      if (value == null) {
        throw new NoSpokenFormError(`${type2} with id ${id2}`);
      }
      return value;
    });
  }
  /**
   * Given a command, generates its spoken form.
   * @param command The command to generate a spoken form for
   * @returns The spoken form of the command
   */
  processCommand(command) {
    return this.componentsToSpokenForm(() => this.handleAction(command.action));
  }
  /**
   * Given a scope type, generates its spoken form.
   * @param scopeType The scope type to generate a spoken form for
   * @returns The spoken form of the scope type
   */
  processScopeType(scopeType) {
    return this.componentsToSpokenForm(() => [
      this.primitiveGenerator.handleScopeType(scopeType)
    ]);
  }
  /**
   * Given a function that returns a spoken form component, generates a spoken
   * form for that component by flattening the component and performing a
   * cartesian product over any elements that have multiple ways to be spoken.
   * Note that this spoken form object can correspond to multiple actual spoken
   * forms, consisting of a preferred spoken form and a list of alternative
   * spoken forms.
   *
   * Note that today, we arbitrarily choose the first spoken form as the
   * preferred spoken form, and the rest as alternative spoken forms.
   *
   * If the function throws a {@link NoSpokenFormError}, returns an error spoken
   * form object instead.
   *
   * @param getComponents A function that returns the components to generate a
   * spoken form for
   * @returns A spoken form for the given components
   */
  componentsToSpokenForm(getComponents) {
    try {
      return {
        type: "success",
        spokenForms: constructSpokenForms(getComponents())
      };
    } catch (e) {
      if (e instanceof NoSpokenFormError) {
        return {
          type: "error",
          reason: e.reason,
          requiresTalonUpdate: e.requiresTalonUpdate,
          isPrivate: e.isPrivate
        };
      }
      throw e;
    }
  }
  handleAction(action) {
    switch (action.name) {
      case "editNew":
      case "getText":
      case "replace":
      case "executeCommand":
      case "parsed":
      case "private.getTargets":
      case "private.setKeyboardTarget":
        throw new NoSpokenFormError(`Action '${action.name}'`);
      case "replaceWithTarget":
      case "moveToTarget":
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.source),
          this.handleDestination(action.destination)
        ];
      case "swapTargets":
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target1),
          connectives.swapConnective,
          this.handleTarget(action.target2)
        ];
      case "callAsFunction":
        if (action.argument.type === "implicit") {
          return [
            this.spokenFormMap.action[action.name],
            this.handleTarget(action.callee)
          ];
        }
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.callee),
          "on",
          this.handleTarget(action.argument)
        ];
      case "wrapWithPairedDelimiter":
      case "rewrapWithPairedDelimiter":
        return [
          surroundingPairDelimitersToSpokenForm(
            this.spokenFormMap,
            action.left,
            action.right
          ),
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      case "pasteFromClipboard":
        return [
          this.spokenFormMap.action[action.name],
          this.handleDestination(action.destination)
        ];
      case "insertSnippet":
        return [
          this.spokenFormMap.action[action.name],
          insertionSnippetToSpokenForm(action.snippetDescription),
          this.handleDestination(action.destination)
        ];
      case "generateSnippet":
        if (action.snippetName != null) {
          throw new NoSpokenFormError(`${action.name}.snippetName`);
        }
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      case "wrapWithSnippet":
        return [
          wrapperSnippetToSpokenForm(action.snippetDescription),
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      case "highlight": {
        if (action.highlightId != null) {
          throw new NoSpokenFormError(`${action.name}.highlightId`);
        }
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      }
      default: {
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      }
    }
  }
  handleTarget(target) {
    switch (target.type) {
      case "list":
        if (target.elements.length < 2) {
          throw new NoSpokenFormError("List target with < 2 elements");
        }
        return target.elements.map(
          (element, i2) => i2 === 0 ? this.handleTarget(element) : [connectives.listConnective, this.handleTarget(element)]
        );
      case "range": {
        const anchor = this.handleTarget(target.anchor);
        const active = this.handleTarget(target.active);
        const connective = getRangeConnective(
          target.excludeAnchor,
          target.excludeActive,
          target.rangeType
        );
        return [anchor, connective, active];
      }
      case "primitive":
        return this.primitiveGenerator.handlePrimitiveTarget(target);
      case "implicit":
        return [];
    }
  }
  handleDestination(destination) {
    switch (destination.type) {
      case "list":
        if (destination.destinations.length < 2) {
          throw new NoSpokenFormError("List destination with < 2 elements");
        }
        return destination.destinations.map(
          (destination2, i2) => i2 === 0 ? this.handleDestination(destination2) : [connectives.listConnective, this.handleDestination(destination2)]
        );
      case "primitive":
        return [
          this.handleInsertionMode(destination.insertionMode),
          this.handleTarget(destination.target)
        ];
      case "implicit":
        return [];
    }
  }
  handleInsertionMode(insertionMode2) {
    switch (insertionMode2) {
      case "to":
        return connectives.sourceDestinationConnective;
      case "before":
        return connectives.before;
      case "after":
        return connectives.after;
    }
  }
};
function constructSpokenForms(component) {
  if (typeof component === "string") {
    return [component];
  }
  if (Array.isArray(component)) {
    if (component.length === 0) {
      return [""];
    }
    return cartesianProduct(component.map(constructSpokenForms)).map(
      (words) => words.filter((word) => word.length !== 0).join(" ")
    );
  }
  if (component.spokenForms.spokenForms.length === 0) {
    const componentInfo = `${camelCaseToAllDown(
      component.spokenFormType
    )} with id ${component.id}`;
    let helpInfo;
    if (component.spokenForms.isPrivate) {
      helpInfo = "this is a private spoken form currently only for internal experimentation";
    } else if (component.spokenForms.requiresTalonUpdate) {
      helpInfo = `please update talon to the latest version (see ${DOCS_URL}/user/updating)`;
    } else {
      helpInfo = `please see ${DOCS_URL}/user/customization for more information`;
    }
    throw new NoSpokenFormError(
      `${componentInfo}; ${helpInfo}`,
      component.spokenForms.requiresTalonUpdate,
      component.spokenForms.isPrivate
    );
  }
  return component.spokenForms.spokenForms;
}
function cartesianProduct(arrays) {
  if (arrays.length === 0) {
    return [];
  }
  if (arrays.length === 1) {
    return arrays[0].map((element) => [element]);
  }
  const [first, ...rest] = arrays;
  const restCartesianProduct = cartesianProduct(rest);
  return first.flatMap(
    (element) => restCartesianProduct.map((restElement) => [element, ...restElement])
  );
}

// ../cursorless-engine/src/generateSpokenForm/CustomSpokenFormGeneratorImpl.ts
var CustomSpokenFormGeneratorImpl = class {
  constructor(talonSpokenForms) {
    __publicField(this, "customSpokenForms");
    __publicField(this, "spokenFormGenerator");
    __publicField(this, "disposables", []);
    /**
     * A promise that resolves when the custom spoken forms have been loaded.
     */
    __publicField(this, "customSpokenFormsInitialized");
    this.customSpokenForms = new CustomSpokenForms(talonSpokenForms);
    this.customSpokenFormsInitialized = this.customSpokenForms.customSpokenFormsInitialized;
    this.spokenFormGenerator = new SpokenFormGenerator(
      this.customSpokenForms.spokenFormMap
    );
    this.disposables = [
      this.customSpokenForms,
      this.customSpokenForms.onDidChangeCustomSpokenForms(() => {
        this.spokenFormGenerator = new SpokenFormGenerator(
          this.customSpokenForms.spokenFormMap
        );
      })
    ];
  }
  onDidChangeCustomSpokenForms(listener) {
    return this.customSpokenForms.onDidChangeCustomSpokenForms(listener);
  }
  commandToSpokenForm(command) {
    return this.spokenFormGenerator.processCommand(command);
  }
  scopeTypeToSpokenForm(scopeType) {
    return this.spokenFormGenerator.processScopeType(scopeType);
  }
  actionIdToSpokenForm(actionId) {
    return this.spokenFormGenerator.getSpokenFormForSingleTerm(
      "action",
      actionId
    );
  }
  graphemeToSpokenForm(grapheme) {
    return this.spokenFormGenerator.getSpokenFormForSingleTerm(
      "grapheme",
      grapheme
    );
  }
  getCustomRegexScopeTypes() {
    return this.customSpokenForms.getCustomRegexScopeTypes();
  }
  get needsInitialTalonUpdate() {
    return this.customSpokenForms.needsInitialTalonUpdate;
  }
  dispose() {
    this.disposables.forEach((disposable) => disposable.dispose());
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/compareTargetScopes.ts
function compareTargetScopes(direction2, position, { domain: a }, { domain: b }) {
  return direction2 === "forward" ? compareTargetScopesForward(position, a, b) : compareTargetScopesBackward(position, a, b);
}
function compareTargetScopesForward(position, a, b) {
  const aIsStartVisible = a.start.isAfterOrEqual(position);
  const bIsStartVisible = b.start.isAfterOrEqual(position);
  if (aIsStartVisible && bIsStartVisible) {
    const value2 = a.start.compareTo(b.start);
    return value2 === 0 ? a.end.compareTo(b.end) : value2;
  }
  if (!aIsStartVisible && !bIsStartVisible) {
    const value2 = a.end.compareTo(b.end);
    return value2 === 0 ? -a.start.compareTo(b.start) : value2;
  }
  if (!aIsStartVisible && bIsStartVisible) {
    const value2 = a.end.compareTo(b.start);
    return value2 !== 0 ? value2 : b.isEmpty ? 1 : -1;
  }
  const value = a.start.compareTo(b.end);
  return value !== 0 ? value : a.isEmpty ? -1 : 1;
}
function compareTargetScopesBackward(position, a, b) {
  const aIsEndVisible = a.end.isBeforeOrEqual(position);
  const bIsEndVisible = b.end.isBeforeOrEqual(position);
  if (aIsEndVisible && bIsEndVisible) {
    const value2 = -a.end.compareTo(b.end);
    return value2 === 0 ? -a.start.compareTo(b.start) : value2;
  }
  if (!aIsEndVisible && !bIsEndVisible) {
    const value2 = -a.start.compareTo(b.start);
    return value2 === 0 ? a.end.compareTo(b.end) : value2;
  }
  if (!aIsEndVisible && bIsEndVisible) {
    const value2 = -a.start.compareTo(b.end);
    return value2 !== 0 ? value2 : b.isEmpty ? 1 : -1;
  }
  const value = -a.end.compareTo(b.start);
  return value !== 0 ? value : a.isEmpty ? -1 : 1;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/shouldYieldScope.ts
function shouldYieldScope(initialPosition, currentPosition, direction2, requirements, previousScope, scope) {
  return checkRequirements(initialPosition, requirements, previousScope, scope) && // Note that we're using `currentPosition` instead of `initialPosition`
  // below, because we want to filter out scopes that are strictly contained
  // by previous scopes.  However, if we want to include descendant scopes,
  // then we do use the initial position
  (previousScope == null || compareTargetScopes(
    direction2,
    requirements.includeDescendantScopes ? initialPosition : currentPosition,
    previousScope,
    scope
  ) < 0);
}
function checkRequirements(position, requirements, previousScope, scope) {
  const {
    containment,
    distalPosition,
    allowAdjacentScopes,
    skipAncestorScopes
  } = requirements;
  const { domain: domain2 } = scope;
  switch (containment) {
    case "disallowed":
      if (domain2.contains(position)) {
        return false;
      }
      break;
    case "disallowedIfStrict":
      if (strictlyContains(domain2, position)) {
        return false;
      }
      break;
    case "required":
      if (!domain2.contains(position)) {
        return false;
      }
      break;
  }
  if (skipAncestorScopes && previousScope != null && domain2.contains(previousScope.domain)) {
    return false;
  }
  return partiallyContains(
    new Range(position, distalPosition),
    domain2,
    allowAdjacentScopes
  );
}
function partiallyContains(range1, range22, allowAdjacent) {
  const intersection2 = range1.intersection(range22);
  if (intersection2 == null) {
    return false;
  }
  return !intersection2.isEmpty || allowAdjacent || range22.isEmpty;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/BaseScopeHandler.ts
var DEFAULT_REQUIREMENTS = {
  containment: null,
  allowAdjacentScopes: false,
  skipAncestorScopes: false,
  includeDescendantScopes: false
};
var BaseScopeHandler = class {
  constructor() {
    __publicField(this, "includeAdjacentInEvery", false);
  }
  *generateScopes(editor, position, direction2, requirements = {}) {
    const hints = {
      ...DEFAULT_REQUIREMENTS,
      ...requirements,
      distalPosition: requirements.distalPosition ?? (direction2 === "forward" ? editor.document.range.end : editor.document.range.start)
    };
    let previousScope = void 0;
    let currentPosition = position;
    for (const scope of this.generateScopeCandidates(
      editor,
      position,
      direction2,
      hints
    )) {
      if (shouldYieldScope(
        position,
        currentPosition,
        direction2,
        hints,
        previousScope,
        scope
      )) {
        yield scope;
        previousScope = scope;
        currentPosition = direction2 === "forward" ? scope.domain.end : scope.domain.start;
      }
      if (this.canStopEarly(position, direction2, hints, previousScope, scope)) {
        return;
      }
    }
  }
  canStopEarly(position, direction2, requirements, previousScope, scope) {
    const { containment, distalPosition, skipAncestorScopes } = requirements;
    if (this.isHierarchical && !skipAncestorScopes) {
      return false;
    }
    const scopeToCheck = this.isHierarchical && skipAncestorScopes ? previousScope : scope;
    if (scopeToCheck == null) {
      return false;
    }
    if (containment === "required" && (direction2 === "forward" ? scopeToCheck.domain.end.isAfter(position) : scopeToCheck.domain.start.isBefore(position))) {
      return true;
    }
    if (direction2 === "forward" ? scopeToCheck.domain.end.isAfterOrEqual(distalPosition) : scopeToCheck.domain.start.isBeforeOrEqual(distalPosition)) {
      return true;
    }
    return false;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/NestedScopeHandler.ts
var NestedScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.scopeType = scopeType;
    this.languageId = languageId;
    __publicField(this, "isHierarchical", false);
    __publicField(this, "_searchScopeHandler");
  }
  /**
   * We expand to this scope type before looking for instances of the scope type
   * handled by this scope handler.  In most cases the iteration scope will
   * suffice, but in some cases you want them to diverge.  For example, you
   * might want the default iteration scope to be `"file"`, but you don't need
   * to expand to the file just to find instances of the given scope type.
   */
  get searchScopeType() {
    return this.iterationScopeType;
  }
  get searchScopeHandler() {
    if (this._searchScopeHandler == null) {
      this._searchScopeHandler = this.scopeHandlerFactory.create(
        this.searchScopeType,
        this.languageId
      );
    }
    return this._searchScopeHandler;
  }
  generateScopeCandidates(editor, position, direction2, hints) {
    const { containment, ...rest } = hints;
    const generator = this.searchScopeHandler.generateScopes(
      editor,
      position,
      direction2,
      // If containment is disallowed, we need to unset that for the search
      // scope, because the search scope could contain position but nested
      // scopes do not.
      {
        containment: containment === "required" ? "required" : void 0,
        ...rest
      }
    );
    return flatmap(
      generator,
      (searchScope) => this.generateScopesInSearchScope(direction2, searchScope)
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/LineScopeHandler.ts
var LineScopeHandler = class extends BaseScopeHandler {
  constructor(scopeType, _languageId) {
    super();
    this.scopeType = scopeType;
    __publicField(this, "iterationScopeType", {
      type: "paragraph"
    });
    __publicField(this, "isHierarchical", false);
    __publicField(this, "includeAdjacentInEvery", true);
  }
  *generateScopeCandidates(editor, position, direction2) {
    const useFullLine = this.scopeType.type === "fullLine";
    if (direction2 === "forward") {
      for (let i2 = position.line; i2 < editor.document.lineCount; i2++) {
        yield lineNumberToScope(editor, useFullLine, i2);
      }
    } else {
      for (let i2 = position.line; i2 >= 0; i2--) {
        yield lineNumberToScope(editor, useFullLine, i2);
      }
    }
  }
};
function lineNumberToScope(editor, useFullLine, lineNumber) {
  const line = editor.document.lineAt(lineNumber);
  return {
    editor,
    domain: line.range,
    getTargets: (isReversed) => [
      createLineTarget(editor, isReversed, line, useFullLine)
    ]
  };
}

// ../cursorless-engine/src/util/getMatchesInRange.ts
function generateMatchesInRange(regex, editor, range3, direction2) {
  const offset = editor.document.offsetAt(range3.start);
  const text = editor.document.getText(range3);
  const matchToRange = (match) => new Range(
    editor.document.positionAt(offset + match.index),
    editor.document.positionAt(offset + match.index + match[0].length)
  );
  regex.lastIndex = 0;
  return direction2 === "forward" ? imap(text.matchAll(regex), matchToRange) : Array.from(text.matchAll(regex), matchToRange).reverse();
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/IdentifierScopeHandler.ts
var IdentifierScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    __publicField(this, "scopeType", { type: "identifier" });
    __publicField(this, "iterationScopeType", { type: "line" });
    __publicField(this, "regex", getMatcher(this.languageId).identifierMatcher);
  }
  generateScopesInSearchScope(direction2, { editor, domain: domain2 }) {
    return imap(
      generateMatchesInRange(this.regex, editor, domain2, direction2),
      (range3) => ({
        editor,
        domain: range3,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange: range3,
            isReversed
          })
        ]
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/isPreferredOverHelper.ts
function isPreferredOverHelper(scopeA, scopeB, matchers3) {
  const textA = scopeA.editor.document.getText(scopeA.domain);
  const textB = scopeB.editor.document.getText(scopeB.domain);
  for (const matcher of matchers3) {
    const aMatchesRegex = testRegex(matcher, textA);
    const bMatchesRegex = testRegex(matcher, textB);
    if (aMatchesRegex && !bMatchesRegex) {
      return true;
    }
    if (bMatchesRegex && !aMatchesRegex) {
      return false;
    }
  }
  return void 0;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CharacterScopeHandler.ts
var SPLIT_REGEX = /\p{L}\p{M}*|[\p{N}\p{P}\p{S}\p{Z}\p{C}]/gu;
var PREFERRED_SYMBOLS_REGEX = /[$]/g;
var NONWHITESPACE_REGEX = /\p{L}\p{M}*|[\p{N}\p{P}\p{S}]/gu;
var CharacterScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    __publicField(this, "scopeType", { type: "character" });
    __publicField(this, "iterationScopeType", { type: "token" });
  }
  get searchScopeType() {
    return { type: "line" };
  }
  generateScopesInSearchScope(direction2, { editor, domain: domain2 }) {
    return imap(
      generateMatchesInRange(SPLIT_REGEX, editor, domain2, direction2),
      (range3) => ({
        editor,
        domain: range3,
        getTargets: (isReversed) => [
          new PlainTarget({
            editor,
            contentRange: range3,
            isReversed,
            textualType: "character"
          })
        ]
      })
    );
  }
  isPreferredOver(scopeA, scopeB) {
    const { identifierMatcher } = getMatcher(this.languageId);
    return isPreferredOverHelper(scopeA, scopeB, [
      identifierMatcher,
      PREFERRED_SYMBOLS_REGEX,
      NONWHITESPACE_REGEX
    ]);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/WordScopeHandler/WordScopeHandler.ts
var WordScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    __publicField(this, "scopeType", { type: "word" });
    __publicField(this, "iterationScopeType", { type: "identifier" });
    __publicField(this, "wordTokenizer", new WordTokenizer(this.languageId));
  }
  getScopesInSearchScope({
    editor,
    domain: domain2
  }) {
    const { document: document2 } = editor;
    const offset = document2.offsetAt(domain2.start);
    const matches = this.wordTokenizer.splitIdentifier(
      document2.getText(domain2)
    );
    const contentRanges = matches.map(
      (match) => new Range(
        document2.positionAt(offset + match.index),
        document2.positionAt(offset + match.index + match.text.length)
      )
    );
    return contentRanges.map((range3, i2) => ({
      editor,
      domain: range3,
      getTargets: (isReversed) => {
        const previousContentRange = i2 > 0 ? contentRanges[i2 - 1] : null;
        const nextContentRange = i2 + 1 < contentRanges.length ? contentRanges[i2 + 1] : null;
        return [
          constructTarget(
            isReversed,
            editor,
            previousContentRange,
            range3,
            nextContentRange
          )
        ];
      }
    }));
  }
  generateScopesInSearchScope(direction2, searchScope) {
    const scopes = this.getScopesInSearchScope(searchScope);
    if (direction2 === "backward") {
      scopes.reverse();
    }
    return scopes;
  }
};
function constructTarget(isReversed, editor, previousContentRange, contentRange, nextContentRange) {
  const leadingDelimiterRange = previousContentRange != null && contentRange.start.isAfter(previousContentRange.end) ? new Range(previousContentRange.end, contentRange.start) : void 0;
  const trailingDelimiterRange = nextContentRange != null && nextContentRange.start.isAfter(contentRange.end) ? new Range(contentRange.end, nextContentRange.start) : void 0;
  const isInDelimitedList = leadingDelimiterRange != null || trailingDelimiterRange != null;
  const insertionDelimiter = isInDelimitedList ? editor.document.getText(leadingDelimiterRange ?? trailingDelimiterRange) : "";
  return new SubTokenWordTarget({
    editor,
    isReversed,
    contentRange,
    insertionDelimiter,
    leadingDelimiterRange,
    trailingDelimiterRange
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TokenScopeHandler.ts
var PREFERRED_SYMBOLS_REGEX2 = /[$]/g;
var TokenScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    __publicField(this, "scopeType", { type: "token" });
    __publicField(this, "iterationScopeType", { type: "line" });
    __publicField(this, "regex", getMatcher(this.languageId).tokenMatcher);
  }
  generateScopesInSearchScope(direction2, { editor, domain: domain2 }) {
    return imap(
      generateMatchesInRange(this.regex, editor, domain2, direction2),
      (range3) => ({
        editor,
        domain: range3,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange: range3,
            isReversed
          })
        ]
      })
    );
  }
  isPreferredOver(scopeA, scopeB) {
    const { identifierMatcher } = getMatcher(this.languageId);
    return isPreferredOverHelper(scopeA, scopeB, [
      identifierMatcher,
      PREFERRED_SYMBOLS_REGEX2
    ]);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/DocumentScopeHandler.ts
var DocumentScopeHandler = class extends BaseScopeHandler {
  constructor(_scopeType, _languageId) {
    super();
    __publicField(this, "scopeType", { type: "document" });
    __publicField(this, "iterationScopeType", { type: "document" });
    __publicField(this, "isHierarchical", false);
  }
  *generateScopeCandidates(editor, _position, _direction) {
    const contentRange = editor.document.range;
    yield {
      editor,
      domain: contentRange,
      getTargets: (isReversed) => [
        new DocumentTarget({
          editor,
          isReversed,
          contentRange
        })
      ]
    };
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/util/getCollectionItemRemovalRange.ts
function getCollectionItemRemovalRange(isEveryScope, editor, contentRange, leadingDelimiterRange, trailingDelimiterRange) {
  if (isEveryScope) {
    return void 0;
  }
  if (leadingDelimiterRange != null && trailingDelimiterRange != null && getRangeLength(editor, leadingDelimiterRange) > getRangeLength(editor, trailingDelimiterRange)) {
    return contentRange.union(leadingDelimiterRange);
  }
  return void 0;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/util/isHintsEveryScope.ts
function isEveryScopeModifier(hints) {
  return hints.containment == null && hints.skipAncestorScopes;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/getQuerySearchRange.ts
function getQuerySearchRange(document2, position, direction2, {
  containment,
  distalPosition,
  allowAdjacentScopes
}) {
  const { start: start2, end } = getQuerySearchRangeCore(
    document2.offsetAt(position),
    document2.offsetAt(distalPosition),
    direction2,
    containment,
    allowAdjacentScopes
  );
  return {
    start: document2.positionAt(start2),
    end: document2.positionAt(end)
  };
}
function getQuerySearchRangeCore(offset, distalOffset, direction2, containment, allowAdjacentScopes) {
  const adjacentShift = allowAdjacentScopes ? 1 : 0;
  if (containment === "required") {
    return direction2 === "forward" ? {
      start: offset - adjacentShift,
      end: offset + 1
    } : {
      start: offset - 1,
      end: offset + adjacentShift
    };
  }
  const proximalShift = containment === "disallowed" ? 1 : -adjacentShift;
  return direction2 === "forward" ? {
    start: offset + proximalShift,
    end: distalOffset + adjacentShift
  } : {
    start: distalOffset - adjacentShift,
    end: offset - proximalShift
  };
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/mergeAdjacentBy.ts
function mergeAdjacentBy(input, isEqual2, merge3) {
  const result = [];
  let current2 = [];
  for (const elem of input) {
    if (current2.length === 0 || isEqual2(current2[current2.length - 1], elem)) {
      current2.push(elem);
    } else {
      result.push(merge3(current2));
      current2 = [elem];
    }
  }
  if (current2.length > 0) {
    result.push(merge3(current2));
  }
  return result;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/BaseTreeSitterScopeHandler.ts
var BaseTreeSitterScopeHandler = class extends BaseScopeHandler {
  constructor(query) {
    super();
    this.query = query;
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const { document: document2 } = editor;
    const isEveryScope = isEveryScopeModifier(hints);
    const { start: start2, end } = getQuerySearchRange(
      document2,
      position,
      direction2,
      hints
    );
    const scopes = this.query.matches(document2, start2, end).map((match) => this.matchToScope(editor, match, isEveryScope)).filter((scope) => scope != null).sort((a, b) => compareTargetScopes(direction2, position, a, b));
    yield* mergeAdjacentBy(
      scopes,
      (a, b) => a.domain.isRangeEqual(b.domain),
      (equivalentScopes) => {
        if (equivalentScopes.length === 1) {
          return equivalentScopes[0];
        }
        return {
          ...equivalentScopes[0],
          getTargets(isReversed) {
            const targets = uniqWith_default(
              equivalentScopes.flatMap((scope) => scope.getTargets(isReversed)),
              (a, b) => a.isEqual(b)
            );
            if (targets.length > 1 && !equivalentScopes.every((scope) => scope.allowMultiple)) {
              const message = "Please use #allow-multiple! predicate in your query to allow multiple matches for this scope type";
              void showError(
                ide().messages,
                "BaseTreeSitterScopeHandler.allow-multiple",
                message
              );
              if (ide().runMode === "test") {
                throw Error(message);
              }
            }
            return targets;
          }
        };
      }
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/captureUtils.ts
function getRelatedCapture(match, scopeTypeType, relationship, matchHasScopeType) {
  if (matchHasScopeType) {
    return findCaptureByName(
      match,
      `${scopeTypeType}.${relationship}`,
      `_.${relationship}`
    );
  }
  return findCaptureByName(match, `${scopeTypeType}.${relationship}`) ?? (findCaptureByName(match, scopeTypeType) != null ? findCaptureByName(match, `_.${relationship}`) : void 0);
}
function getRelatedRange(match, scopeTypeType, relationship, matchHasScopeType) {
  return getRelatedCapture(
    match,
    scopeTypeType,
    relationship,
    matchHasScopeType
  )?.range;
}
function findCaptureByName(match, ...names2) {
  return match.captures.find(
    (capture) => names2.some((name2) => capture.name === name2)
  );
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/TreeSitterIterationScopeHandler.ts
var TreeSitterIterationScopeHandler = class extends BaseTreeSitterScopeHandler {
  constructor(query, iterateeScopeType) {
    super(query);
    this.iterateeScopeType = iterateeScopeType;
    __publicField(this, "isHierarchical", true);
    // Doesn't correspond to any scope type
    __publicField(this, "scopeType");
  }
  // Doesn't have any iteration scope type itself; that would correspond to
  // something like "every every"
  get iterationScopeType() {
    throw Error("Not implemented");
  }
  matchToScope(editor, match, _isEveryScope) {
    const scopeTypeType = this.iterateeScopeType.type;
    const capture = getRelatedCapture(match, scopeTypeType, "iteration", false);
    if (capture == null) {
      return void 0;
    }
    const { range: contentRange, allowMultiple } = capture;
    if (contentRange.isEmpty) {
      return void 0;
    }
    const domain2 = getRelatedRange(match, scopeTypeType, "iteration.domain", false) ?? contentRange;
    return {
      editor,
      domain: domain2,
      allowMultiple,
      getTargets: (isReversed) => [
        new PlainTarget({
          editor,
          isReversed,
          contentRange
        })
      ]
    };
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/TreeSitterScopeHandler.ts
var TreeSitterScopeHandler = class extends BaseTreeSitterScopeHandler {
  constructor(query, scopeType) {
    super(query);
    this.scopeType = scopeType;
    __publicField(this, "isHierarchical", true);
  }
  // We just create a custom scope handler that doesn't necessarily correspond
  // to any well-defined scope type
  get iterationScopeType() {
    return {
      type: "custom",
      scopeHandler: new TreeSitterIterationScopeHandler(
        this.query,
        this.scopeType
      )
    };
  }
  matchToScope(editor, match, isEveryScope) {
    const scopeTypeType = this.scopeType.type;
    const capture = findCaptureByName(match, scopeTypeType);
    if (capture == null) {
      return void 0;
    }
    const { range: contentRange, allowMultiple, insertionDelimiter } = capture;
    const domain2 = getRelatedRange(match, scopeTypeType, "domain", true) ?? contentRange;
    const prefixRange = getRelatedRange(
      match,
      scopeTypeType,
      "prefix",
      true
    )?.with(void 0, contentRange.start);
    const leadingDelimiterRange = getRelatedRange(
      match,
      scopeTypeType,
      "leading",
      true
    )?.with(void 0, prefixRange?.start ?? contentRange.start);
    const trailingDelimiterRange = getRelatedRange(
      match,
      scopeTypeType,
      "trailing",
      true
    )?.with(contentRange.end);
    let removalRange = getRelatedRange(match, scopeTypeType, "removal", true);
    if (removalRange == null && (scopeTypeType === "collectionItem" || scopeTypeType === "argumentOrParameter")) {
      removalRange = getCollectionItemRemovalRange(
        isEveryScope,
        editor,
        contentRange,
        leadingDelimiterRange,
        trailingDelimiterRange
      );
    }
    return {
      editor,
      domain: domain2,
      allowMultiple,
      getTargets: (isReversed) => [
        new ScopeTypeTarget({
          scopeTypeType,
          editor,
          isReversed,
          contentRange,
          prefixRange,
          removalRange,
          leadingDelimiterRange,
          trailingDelimiterRange,
          insertionDelimiter
        })
      ]
    };
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/IteratorInfo.ts
function getInitialIteratorInfos(iterators) {
  return iterators.flatMap((iterator, i2) => {
    const { value, done } = iterator.next();
    return done ? [] : [
      {
        iterator,
        value,
        index: i2
      }
    ];
  });
}
function advanceIteratorsUntil(iteratorInfos, criterion) {
  return iteratorInfos.flatMap((iteratorInfo) => {
    const { iterator, index } = iteratorInfo;
    let { value } = iteratorInfo;
    let done = false;
    while (!done && !criterion(value)) {
      ({ value, done } = iterator.next());
    }
    if (done) {
      return [];
    }
    return [{ iterator, value, index }];
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SortedScopeHandler.ts
var SortedScopeHandler = class _SortedScopeHandler extends BaseScopeHandler {
  constructor(scopeHandlers, getIterationScopeHandler) {
    super();
    this.scopeHandlers = scopeHandlers;
    this.getIterationScopeHandler = getIterationScopeHandler;
    __publicField(this, "isHierarchical", true);
    __publicField(this, "scopeType");
    __publicField(this, "iterationScopeHandler");
    __publicField(this, "lastYieldedIndex");
  }
  static create(scopeHandlerFactory, scopeType, languageId) {
    const scopeHandlers = scopeType.scopeTypes.map(
      (scopeType2) => scopeHandlerFactory.maybeCreate(scopeType2, languageId)
    ).filter(
      (scopeHandler) => scopeHandler != null
    );
    if (scopeHandlers.length === 1) {
      return scopeHandlers[0];
    }
    return this.createFromScopeHandlers(
      scopeHandlerFactory,
      languageId,
      scopeHandlers
    );
  }
  static createFromScopeHandlers(scopeHandlerFactory, languageId, scopeHandlers) {
    const getIterationScopeHandler = () => new _SortedScopeHandler(
      scopeHandlers.map(
        (scopeHandler) => scopeHandlerFactory.create(
          scopeHandler.iterationScopeType,
          languageId
        )
      ),
      () => {
        throw new Error("Not implemented");
      }
    );
    return new _SortedScopeHandler(scopeHandlers, getIterationScopeHandler);
  }
  get iterationScopeType() {
    if (this.iterationScopeHandler == null) {
      this.iterationScopeHandler = this.getIterationScopeHandler();
    }
    return {
      type: "custom",
      scopeHandler: this.iterationScopeHandler
    };
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    if (this.iterationScopeHandler?.lastYieldedIndex != null) {
      const handlerIndex = this.iterationScopeHandler.lastYieldedIndex;
      const handler = this.scopeHandlers[handlerIndex];
      yield* handler.generateScopes(editor, position, direction2, hints);
      return;
    }
    const iterators = this.scopeHandlers.map(
      (scopeHandler) => scopeHandler.generateScopes(editor, position, direction2, hints)[Symbol.iterator]()
    );
    let iteratorInfos = getInitialIteratorInfos(iterators);
    while (iteratorInfos.length > 0) {
      iteratorInfos.sort(
        (a, b) => compareTargetScopes(direction2, position, a.value, b.value)
      );
      const iteratorInfo = iteratorInfos[0];
      const currentScope2 = iteratorInfo.value;
      this.lastYieldedIndex = iteratorInfo.index;
      yield currentScope2;
      iteratorInfos = advanceIteratorsUntil(
        iteratorInfos,
        (scope) => compareTargetScopes(direction2, position, currentScope2, scope) < 0
      );
    }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/ParagraphScopeHandler.ts
var ParagraphScopeHandler = class extends BaseScopeHandler {
  constructor(_scopeType, _languageId) {
    super();
    __publicField(this, "scopeType", { type: "paragraph" });
    __publicField(this, "iterationScopeType", { type: "document" });
    __publicField(this, "isHierarchical", false);
  }
  *generateScopeCandidates(editor, position, direction2) {
    const { document: document2 } = editor;
    const offset = direction2 === "forward" ? 1 : -1;
    const stop2 = direction2 === "forward" ? document2.lineCount : -1;
    let startLine = getStartLine(document2, position, direction2);
    let previousLine = editor.document.lineAt(position);
    for (let i2 = position.line + offset; i2 !== stop2; i2 += offset) {
      const currentLine = editor.document.lineAt(i2);
      if (currentLine.isEmptyOrWhitespace) {
        if (startLine != null) {
          yield createScope2(editor, startLine.range.union(previousLine.range));
          startLine = void 0;
        }
      } else if (startLine == null) {
        startLine = currentLine;
      }
      previousLine = currentLine;
    }
    if (startLine != null) {
      yield createScope2(editor, startLine.range.union(previousLine.range));
    }
  }
};
function getStartLine(document2, position, direction2) {
  const offset = direction2 === "forward" ? -1 : 1;
  const stop2 = direction2 === "forward" ? -1 : document2.lineCount;
  let startLine = document2.lineAt(position);
  if (startLine.isEmptyOrWhitespace) {
    return void 0;
  }
  for (let i2 = position.line + offset; i2 !== stop2; i2 += offset) {
    const line = document2.lineAt(i2);
    if (line.isEmptyOrWhitespace) {
      break;
    }
    startLine = line;
  }
  return startLine;
}
function createScope2(editor, domain2) {
  return {
    editor,
    domain: domain2,
    getTargets: (isReversed) => [
      new ParagraphTarget({
        editor,
        isReversed,
        contentRange: fitRangeToLineContent(editor, domain2)
      })
    ]
  };
}
function fitRangeToLineContent(editor, range3) {
  const startLine = editor.document.lineAt(range3.start);
  const endLine = editor.document.lineAt(range3.end);
  return new Range(
    startLine.rangeTrimmed?.start ?? startLine.range.start,
    endLine.rangeTrimmed?.end ?? endLine.range.end
  );
}

// ../sentence-parser/src/stringHelper.ts
function endsWithChar(word, c) {
  if (c.length > 1) {
    return c.indexOf(word.slice(-1)) > -1;
  }
  return word.slice(-1) === c;
}
function endsWith(word, end) {
  return word.slice(word.length - end.length) === end;
}

// ../sentence-parser/src/Match.ts
var abbreviations;
var englishAbbreviations = [
  "al",
  "adj",
  "assn",
  "Ave",
  "BSc",
  "MSc",
  "Cell",
  "Ch",
  "Co",
  "cc",
  "Corp",
  "Dem",
  "Dept",
  "ed",
  "eg",
  "Eq",
  "Eqs",
  "est",
  "est",
  "etc",
  "Ex",
  "ext",
  // + number?
  "Fig",
  "fig",
  "Figs",
  "figs",
  "i.e",
  "ie",
  "Inc",
  "inc",
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Sept",
  "Oct",
  "Nov",
  "Dec",
  "jr",
  "mi",
  "Miss",
  "Mrs",
  "Mr",
  "Ms",
  "Mol",
  "mt",
  "mts",
  "no",
  "Nos",
  "PhD",
  "MD",
  "BA",
  "MA",
  "MM",
  "pl",
  "pop",
  "pp",
  "Prof",
  "Dr",
  "pt",
  "Ref",
  "Refs",
  "Rep",
  "repr",
  "rev",
  "Sec",
  "Secs",
  "Sgt",
  "Col",
  "Gen",
  "Rep",
  "Sen",
  "Gov",
  "Lt",
  "Maj",
  "Capt",
  "St",
  "Sr",
  "sr",
  "Jr",
  "jr",
  "Rev",
  "Sun",
  "Mon",
  "Tu",
  "Tue",
  "Tues",
  "Wed",
  "Th",
  "Thu",
  "Thur",
  "Thurs",
  "Fri",
  "Sat",
  "trans",
  "Univ",
  "Viz",
  "Vol",
  "vs",
  "v"
];
function setAbbreviations(abbr) {
  if (abbr) {
    abbreviations = abbr;
  } else {
    abbreviations = englishAbbreviations;
  }
}
function isCapitalized(str2) {
  return /^[A-Z][a-z].*/.test(str2) || isNumber(str2);
}
function isSentenceStarter(str2) {
  return isCapitalized(str2) || /``|"|'/.test(str2.substring(0, 2));
}
function isCommonAbbreviation(str2) {
  const noSymbols = str2.replace(/[-'`~!@#$%^&*()_|+=?;:'",.<>{}[\]\\/]/gi, "");
  return ~abbreviations.indexOf(noSymbols);
}
function isTimeAbbreviation(word, next) {
  if (word === "a.m." || word === "p.m.") {
    const tmp = next.replace(/\W+/g, "").slice(-3).toLowerCase();
    if (tmp === "day") {
      return true;
    }
  }
  return false;
}
function isDottedAbbreviation(word) {
  const matches = word.replace(/[()[]{}]/g, "").match(/(.\.)*/);
  return matches && matches[0].length > 0;
}
function isCustomAbbreviation(str2) {
  if (str2.length <= 3) {
    return true;
  }
  return isCapitalized(str2);
}
function isNameAbbreviation(wordCount, words) {
  if (words.length > 0) {
    if (wordCount < 5 && words[0].length < 6 && isCapitalized(words[0])) {
      return true;
    }
    const capitalized = words.filter(function(str2) {
      return /[A-Z]/.test(str2.charAt(0));
    });
    return capitalized.length >= 3;
  }
  return false;
}
function isNumber(str2, dotPos) {
  if (dotPos) {
    str2 = str2.slice(dotPos - 1, dotPos + 2);
  }
  return !isNaN(str2);
}
function isPhoneNr(str2) {
  return str2.match(
    /^(?:(?:\+?1\s*(?:[.-]\s*)?)?(?:\(\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\s*\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\s*(?:[.-]\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\s*(?:[.-]\s*)?([0-9]{4})(?:\s*(?:#|x\.?|ext\.?|extension)\s*(\d+))?$/
  );
}
function isURL(str2) {
  return str2.match(
    /[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/
  );
}
function isConcatenated(word) {
  let i2;
  if ((i2 = word.indexOf(".")) > -1 || (i2 = word.indexOf("!")) > -1 || (i2 = word.indexOf("?")) > -1) {
    const c = word.charAt(i2 + 1);
    if (c.match(/[a-zA-Z].*/)) {
      return [word.slice(0, i2), word.slice(i2 + 1)];
    }
  }
  return false;
}
function isBoundaryChar(word) {
  return word === "." || word === "!" || word === "?";
}

// ../sentence-parser/src/sbd.ts
var newline_placeholder = " @~@ ";
var newline_placeholder_t = newline_placeholder.trim();
var whiteSpaceCheck = new RegExp("\\S", "");
var addNewLineBoundaries = new RegExp("\\n+|[-#=_+*]{4,}", "g");
var splitIntoWords = new RegExp("\\S+|\\n", "g");
var defaultOptions = {
  newlineBoundaries: false,
  preserveWhitespace: false,
  abbreviations: void 0
};
function getSentences(text, userOptions) {
  if (!text) {
    return [];
  }
  if (!whiteSpaceCheck.test(text)) {
    return [];
  }
  const options2 = {
    ...defaultOptions,
    ...userOptions
  };
  setAbbreviations(options2.abbreviations);
  if (options2.newlineBoundaries) {
    text = text.replace(addNewLineBoundaries, newline_placeholder);
  }
  let words;
  let tokens2;
  if (options2.preserveWhitespace) {
    tokens2 = text.split(/(<br\s*\/?>|\S+|\n+)/);
    words = tokens2.filter(function(token, ii) {
      return ii % 2;
    });
  } else {
    words = text.trim().match(splitIntoWords) ?? [];
  }
  let wordCount = 0;
  let index;
  let temp;
  let sentences = [];
  let current2 = [];
  if (!words || !words.length) {
    return [];
  }
  for (let i2 = 0, L = words.length; i2 < L; i2++) {
    wordCount++;
    current2.push(words[i2]);
    if (~words[i2].indexOf(",")) {
      wordCount = 0;
    }
    if (isBoundaryChar(words[i2]) || endsWithChar(words[i2], "?!") || words[i2] === newline_placeholder_t) {
      if (options2.newlineBoundaries && words[i2] === newline_placeholder_t) {
        current2.pop();
      }
      sentences.push(current2);
      wordCount = 0;
      current2 = [];
      continue;
    }
    if (endsWithChar(words[i2], '"') || endsWithChar(words[i2], "\u201D")) {
      words[i2] = words[i2].slice(0, -1);
    }
    if (endsWithChar(words[i2], ".")) {
      if (i2 + 1 < L) {
        if (words[i2].length === 2 && isNaN(words[i2].charAt(0))) {
          continue;
        }
        if (isCommonAbbreviation(words[i2])) {
          continue;
        }
        if (isSentenceStarter(words[i2 + 1])) {
          if (isTimeAbbreviation(words[i2], words[i2 + 1])) {
            continue;
          }
          if (isNameAbbreviation(wordCount, words.slice(i2, 6))) {
            continue;
          }
          if (isNumber(words[i2 + 1])) {
            if (isCustomAbbreviation(words[i2])) {
              continue;
            }
          }
        } else {
          if (endsWith(words[i2], "..")) {
            continue;
          }
          if (isDottedAbbreviation(words[i2])) {
            continue;
          }
          if (isNameAbbreviation(wordCount, words.slice(i2, 5))) {
            continue;
          }
        }
      }
      sentences.push(current2);
      current2 = [];
      wordCount = 0;
      continue;
    }
    if ((index = words[i2].indexOf(".")) > -1) {
      if (isNumber(words[i2], index)) {
        continue;
      }
      if (isDottedAbbreviation(words[i2])) {
        continue;
      }
      if (isURL(words[i2]) || isPhoneNr(words[i2])) {
        continue;
      }
    }
    if (temp = isConcatenated(words[i2])) {
      current2.pop();
      current2.push(temp[0]);
      sentences.push(current2);
      current2 = [];
      wordCount = 0;
      current2.push(temp[1]);
    }
  }
  if (current2.length) {
    sentences.push(current2);
  }
  sentences = sentences.filter(function(s) {
    return s.length > 0;
  });
  const result = sentences.slice(1).reduce(
    function(out2, sentence) {
      const lastSentence = out2[out2.length - 1];
      if (lastSentence.length === 1 && /^.{1,2}[.]$/.test(lastSentence[0])) {
        if (!/[.]/.test(sentence[0])) {
          out2.pop();
          out2.push(lastSentence.concat(sentence));
          return out2;
        }
      }
      out2.push(sentence);
      return out2;
    },
    [sentences[0]]
  );
  return result.map(function(sentence, ii) {
    if (options2.preserveWhitespace && !options2.newlineBoundaries) {
      let tokenCount = sentence.length * 2;
      if (ii === 0) {
        tokenCount += 1;
      }
      return tokens2.splice(0, tokenCount).join("");
    }
    return sentence.join(" ");
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SentenceScopeHandler/SentenceSegmenter.ts
var leadingOffsetRegex = /\S*\p{L}/u;
var skipPartRegex = /(\r?\n[^\p{L}]*\r?\n)|(?<=[.!?])(\s*\r?\n)/gu;
var options = {
  newlineBoundaries: false,
  preserveWhitespace: true
};
var SentenceSegmenter = class {
  *segment(text) {
    const sentences = getSentences(text, options);
    let index = 0;
    for (const sentence of sentences) {
      const parts2 = sentence.split(skipPartRegex).filter((p) => p != null);
      for (const part of parts2) {
        if (!skipPart(part)) {
          const segment = createSegment(part, index);
          if (segment != null) {
            yield segment;
          }
        }
        index += part.length;
      }
    }
  }
};
function createSegment(sentence, index) {
  const leadingOffsetMatch = matchRegex(leadingOffsetRegex, sentence);
  if (leadingOffsetMatch == null) {
    return void 0;
  }
  const leadingOffset = leadingOffsetMatch.index;
  if (leadingOffset !== 0) {
    index += leadingOffset;
    sentence = sentence.slice(leadingOffset);
  }
  return {
    text: sentence.trimEnd(),
    index
  };
}
function skipPart(text) {
  return testRegex(skipPartRegex, text);
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SentenceScopeHandler/SentenceScopeHandler.ts
var SentenceScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    __publicField(this, "scopeType", { type: "sentence" });
    __publicField(this, "iterationScopeType", { type: "paragraph" });
    __publicField(this, "segmenter", new SentenceSegmenter());
  }
  generateScopesInSearchScope(direction2, { editor, domain: domain2 }) {
    const offset = editor.document.offsetAt(domain2.start);
    const text = editor.document.getText(domain2);
    const sentenceToScope = (sentence) => {
      const contentRange = new Range(
        editor.document.positionAt(offset + sentence.index),
        editor.document.positionAt(
          offset + sentence.index + sentence.text.length
        )
      );
      return {
        editor,
        domain: contentRange,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange,
            isReversed
          })
        ]
      };
    };
    const sentences = this.segmenter.segment(text);
    return direction2 === "forward" ? imap(sentences, sentenceToScope) : Array.from(sentences, sentenceToScope).reverse();
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/RegexScopeHandler.ts
var RegexStageBase = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    __publicField(this, "iterationScopeType", { type: "line" });
  }
  generateScopesInSearchScope(direction2, { editor, domain: domain2 }) {
    return imap(
      generateMatchesInRange(this.regex, editor, domain2, direction2),
      (range3) => ({
        editor,
        domain: range3,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange: range3,
            isReversed
          })
        ]
      })
    );
  }
};
var NonWhitespaceSequenceScopeHandler = class extends RegexStageBase {
  constructor() {
    super(...arguments);
    __publicField(this, "regex", /\S+/g);
  }
};
var UrlScopeHandler = class extends RegexStageBase {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, scopeType, languageId);
    this.scopeType = scopeType;
    // taken from https://regexr.com/3e6m0
    __publicField(this, "regex", /(http(s)?:\/\/.)?(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/g);
  }
};
var CustomRegexScopeHandler = class extends RegexStageBase {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, scopeType, languageId);
    this.scopeType = scopeType;
  }
  get regex() {
    return new RegExp(this.scopeType.regex, this.scopeType.flags ?? "gu");
  }
};
var GlyphScopeHandler = class extends RegexStageBase {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, scopeType, languageId);
    this.scopeType = scopeType;
  }
  get regex() {
    return new RegExp(escapeRegExp_default(this.scopeType.character), "gui");
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/BoundedScopeHandler.ts
var BoundedBaseScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, languageId, targetScopeType) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.languageId = languageId;
    this.targetScopeType = targetScopeType;
    __publicField(this, "isHierarchical", true);
    __publicField(this, "targetScopeHandler");
    __publicField(this, "surroundingPairInteriorScopeHandler");
    this.targetScopeHandler = this.scopeHandlerFactory.create(
      this.targetScopeType,
      this.languageId
    );
    this.surroundingPairInteriorScopeHandler = this.scopeHandlerFactory.create(
      {
        type: "surroundingPairInterior",
        delimiter: "any"
      },
      this.languageId
    );
  }
  get iterationScopeType() {
    switch (this.targetScopeHandler.iterationScopeType.type) {
      case "custom":
      case "fallback":
      case "conditional":
        throw Error(
          `Iteration scope type can't be '${this.targetScopeHandler.iterationScopeType.type}' for BoundedBaseScopeHandler`
        );
    }
    return {
      type: "oneOf",
      scopeTypes: [
        this.targetScopeHandler.iterationScopeType,
        {
          type: "surroundingPairInterior",
          delimiter: "any"
        }
      ]
    };
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const targetScopes = this.targetScopeHandler.generateScopes(
      editor,
      position,
      direction2,
      {
        ...hints,
        // Don't skip containing paint since it might have non contained nested scopes.
        containment: hints.containment !== "disallowed" ? hints.containment : void 0
      }
    );
    const interiorScopes = Array.from(
      this.surroundingPairInteriorScopeHandler.generateScopes(
        editor,
        position,
        direction2,
        {
          ...hints,
          // For the every scope, we don't want to go outside of the surrounding pair
          containment: isEveryScopeModifier(hints) ? "required" : hints.containment
        }
      )
    );
    for (const targetScope of targetScopes) {
      const allScopes = [];
      for (const interiorScope of interiorScopes) {
        const domain2 = targetScope.domain.intersection(interiorScope.domain);
        if (domain2 != null && !domain2.isEmpty) {
          allScopes.push({
            editor,
            domain: domain2,
            getTargets: (isReversed) => {
              return [
                this.getTargets(
                  ensureSingleTarget2(targetScope, isReversed),
                  ensureSingleTarget2(interiorScope, isReversed)
                )
              ];
            }
          });
        }
      }
      allScopes.push(targetScope);
      allScopes.sort((a, b) => compareTargetScopes(direction2, position, a, b));
      yield* allScopes;
    }
  }
};
function ensureSingleTarget2(scope, isReversed) {
  const targets = scope.getTargets(isReversed);
  if (targets.length !== 1) {
    throw Error(`Expected one target but got ${targets.length}`);
  }
  return targets[0];
}
var BoundedNonWhitespaceSequenceScopeHandler = class extends BoundedBaseScopeHandler {
  constructor(scopeHandlerFactory, _scopeType, languageId) {
    super(scopeHandlerFactory, languageId, { type: "nonWhitespaceSequence" });
    __publicField(this, "scopeType", { type: "boundedNonWhitespaceSequence" });
  }
  getTargets(target, interior) {
    const contentRange = target.contentRange.intersection(
      interior.contentRange
    );
    if (contentRange == null || contentRange.isEmpty) {
      throw Error("Expected non empty intersection");
    }
    return new TokenTarget({
      editor: target.editor,
      isReversed: target.isReversed,
      contentRange
    });
  }
};
var BoundedParagraphScopeHandler = class extends BoundedBaseScopeHandler {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, languageId, { type: "paragraph" });
    __publicField(this, "scopeType", { type: "boundedParagraph" });
  }
  getTargets(target, interior) {
    if (!(target instanceof ParagraphTarget)) {
      throw Error("Expected ParagraphTarget");
    }
    return new BoundedParagraphTarget({
      editor: target.editor,
      isReversed: target.isReversed,
      paragraphTarget: target,
      containingInterior: interior
    });
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/ScopeHandlerCache.ts
var ScopeHandlerCache = class {
  constructor() {
    __publicField(this, "key", "");
    __publicField(this, "documentVersion", -1);
    __publicField(this, "documentUri", "");
    __publicField(this, "documentLanguageId", "");
    __publicField(this, "matches", []);
  }
  clear() {
    this.key = "";
    this.documentUri = "";
    this.documentVersion = -1;
    this.documentLanguageId = "";
    this.matches = [];
  }
  isValid(key, document2) {
    return this.key === key && this.documentVersion === document2.version && this.documentUri === document2.uri.toString() && this.documentLanguageId === document2.languageId;
  }
  update(key, document2, matches) {
    this.key = key;
    this.documentVersion = document2.version;
    this.documentUri = document2.uri.toString();
    this.documentLanguageId = document2.languageId;
    this.matches = matches;
  }
  get() {
    return this.matches;
  }
};
var scopeHandlerCache = new ScopeHandlerCache();

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/util/OneWayRangeFinder.ts
var OneWayRangeFinder = class {
  /**
   * @param items The items to search in. Must be sorted in document order.
   */
  constructor(items) {
    this.items = items;
    __publicField(this, "index", 0);
  }
  add(item) {
    this.items.push(item);
  }
  contains(searchItem) {
    return this.advance(searchItem);
  }
  getContaining(searchItem) {
    if (this.advance(searchItem)) {
      return this.items[this.index];
    }
    return void 0;
  }
  advance(searchItem) {
    while (this.index < this.items.length) {
      const range3 = this.items[this.index].range;
      if (range3.contains(searchItem)) {
        return true;
      }
      if (searchItem.end.isBeforeOrEqual(range3.start)) {
        return false;
      }
      this.index++;
    }
    return false;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/util/OneWayNestedRangeFinder.ts
var OneWayNestedRangeFinder = class {
  /**
   * @param items The items to search in. Must be sorted in document order.
   */
  constructor(items) {
    __publicField(this, "children");
    this.children = createNodes(items);
  }
  getSmallestContaining(separator2) {
    return this.children.getContaining(separator2)?.getSmallestContaining(separator2);
  }
};
function createNodes(items) {
  const results = [];
  const parents = [];
  for (const item of items) {
    const node = new RangeLookupTreeNode(item);
    while (parents.length > 0 && !parents[parents.length - 1].range.contains(item.range)) {
      parents.pop();
    }
    const parent = parents[parents.length - 1];
    if (parent != null) {
      parent.children.add(node);
    } else {
      results.push(node);
    }
    parents.push(node);
  }
  return new OneWayRangeFinder(results);
}
var RangeLookupTreeNode = class {
  constructor(item) {
    this.item = item;
    __publicField(this, "children");
    this.children = new OneWayRangeFinder([]);
  }
  get range() {
    return this.item.range;
  }
  getSmallestContaining(range3) {
    const child = this.children.getContaining(range3)?.getSmallestContaining(range3);
    return child ?? this.item;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/getSeparatorOccurrences.ts
var separator = ",";
var separatorRegex = new RegExp(separator, "g");
function getSeparatorOccurrences(document2) {
  const text = document2.getText();
  return matchAll(text, separatorRegex, (match) => {
    return new Range(
      document2.positionAt(match.index),
      document2.positionAt(match.index + match[0].length)
    );
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/collectionItemTextualIterationScopeHandler.ts
var collectionItemTextualIterationScopeHandler = {
  type: "fallback",
  scopeTypes: [
    {
      type: "conditional",
      scopeType: {
        type: "surroundingPairInterior",
        delimiter: "collectionBoundary"
      },
      predicate: (scope) => !scope.domain.isEmpty
    },
    {
      type: "conditional",
      scopeType: {
        type: "line"
      },
      predicate: (scope) => {
        const text = scope.editor.document.getText(scope.domain);
        return testRegex(separatorRegex, text);
      }
    }
  ]
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/createTargetScope.ts
function createTargetScope(isEveryScope, editor, iterationRange, contentRange, previousRange, nextRange) {
  const leadingDelimiterRange = previousRange != null ? new Range(previousRange.end, contentRange.start) : void 0;
  const trailingDelimiterRange = nextRange != null ? new Range(contentRange.end, nextRange.start) : void 0;
  const removalRange = getCollectionItemRemovalRange(
    isEveryScope,
    editor,
    contentRange,
    leadingDelimiterRange,
    trailingDelimiterRange
  );
  const insertionDelimiter = iterationRange.isSingleLine ? ", " : ",\n";
  return {
    editor,
    domain: contentRange,
    getTargets(isReversed) {
      return [
        new ScopeTypeTarget({
          scopeTypeType: "collectionItem",
          editor,
          isReversed,
          contentRange,
          insertionDelimiter,
          leadingDelimiterRange,
          trailingDelimiterRange,
          removalRange
        })
      ];
    }
  };
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/getInteriorRanges.ts
function getInteriorRanges(scopeHandlerFactory, languageId, editor, delimiter) {
  const scopeHandler = scopeHandlerFactory.create(
    {
      type: "surroundingPairInterior",
      delimiter
    },
    languageId
  );
  return Array.from(
    scopeHandler.generateScopes(editor, new Position(0, 0), "forward", {
      containment: void 0,
      skipAncestorScopes: false,
      includeDescendantScopes: true
    }),
    (scope) => ({ range: scope.domain })
  );
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/CollectionItemTextualScopeHandler.ts
var CollectionItemTextualScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.languageId = languageId;
    __publicField(this, "scopeType", { type: "collectionItem" });
    __publicField(this, "isHierarchical", true);
  }
  get iterationScopeType() {
    return collectionItemTextualIterationScopeHandler;
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const isEveryScope = isEveryScopeModifier(hints);
    const cacheKey = "CollectionItemTextualScopeHandler_" + isEveryScope;
    if (!scopeHandlerCache.isValid(cacheKey, editor.document)) {
      const scopes2 = this.getsScopes(editor, direction2, isEveryScope);
      scopeHandlerCache.update(cacheKey, editor.document, scopes2);
    }
    const scopes = scopeHandlerCache.get();
    scopes.sort((a, b) => compareTargetScopes(direction2, position, a, b));
    yield* scopes;
  }
  getsScopes(editor, direction2, isEveryScope) {
    const separatorRanges = getSeparatorOccurrences(editor.document);
    const interiorRanges = getInteriorRanges(
      this.scopeHandlerFactory,
      this.languageId,
      editor,
      "collectionBoundary"
    );
    const interiorRangeFinder = new OneWayNestedRangeFinder(interiorRanges);
    const stringRanges = getInteriorRanges(
      this.scopeHandlerFactory,
      this.languageId,
      editor,
      "string"
    );
    const stringRangeFinder = new OneWayRangeFinder(stringRanges);
    const scopes = [];
    const usedInteriors = /* @__PURE__ */ new Set();
    const iterationStatesStack = [];
    for (const separator2 of separatorRanges) {
      if (stringRangeFinder.contains(separator2)) {
        continue;
      }
      let currentIterationState;
      while (iterationStatesStack.length > 0) {
        const lastState = iterationStatesStack[iterationStatesStack.length - 1];
        if (lastState.iterationRange.contains(separator2)) {
          currentIterationState = lastState;
          break;
        }
        this.addScopes(scopes, lastState);
        iterationStatesStack.pop();
      }
      const containingInteriorRange = interiorRangeFinder.getSmallestContaining(separator2)?.range;
      const containingIterationRange = containingInteriorRange ?? editor.document.lineAt(separator2.start.line).range;
      if (currentIterationState != null && currentIterationState.iterationRange.isRangeEqual(
        containingIterationRange
      )) {
        currentIterationState.delimiters.push(separator2);
        continue;
      }
      if (containingInteriorRange != null) {
        usedInteriors.add(containingInteriorRange);
      }
      iterationStatesStack.push({
        editor,
        isEveryScope,
        iterationRange: containingIterationRange,
        delimiters: [separator2]
      });
    }
    for (const state of iterationStatesStack) {
      this.addScopes(scopes, state);
    }
    for (const interior of interiorRanges) {
      if (!usedInteriors.has(interior.range) && !interior.range.isEmpty) {
        const range3 = shrinkRangeToFitContent(editor, interior.range);
        if (!range3.isEmpty) {
          scopes.push(
            createTargetScope(isEveryScope, editor, interior.range, range3)
          );
        }
      }
    }
    return scopes;
  }
  addScopes(scopes, state) {
    const { editor, iterationRange, isEveryScope, delimiters } = state;
    if (delimiters.length === 0) {
      return;
    }
    const itemRanges = [];
    for (let i2 = 0; i2 < delimiters.length; ++i2) {
      const current2 = delimiters[i2];
      const previous = delimiters[i2 - 1]?.end ?? iterationRange.start;
      itemRanges.push(new Range(previous, current2.start));
    }
    const lastDelimiter = delimiters[delimiters.length - 1];
    itemRanges.push(new Range(lastDelimiter.end, iterationRange.end));
    const trimmedRanges = itemRanges.map(
      (range3) => shrinkRangeToFitContent(editor, range3)
    );
    for (let i2 = 0; i2 < trimmedRanges.length; ++i2) {
      if (i2 === trimmedRanges.length - 1 && editor.document.getText(trimmedRanges[i2]).trim() === "") {
        continue;
      }
      scopes.push(
        createTargetScope(
          isEveryScope,
          editor,
          iterationRange,
          trimmedRanges[i2],
          trimmedRanges[i2 - 1],
          trimmedRanges[i2 + 1]
        )
      );
    }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/CollectionItemScopeHandler.ts
var CollectionItemScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, languageDefinitions, languageId) {
    super();
    __publicField(this, "scopeType", { type: "collectionItem" });
    __publicField(this, "isHierarchical", true);
    __publicField(this, "scopeHandler");
    this.scopeHandler = (() => {
      const textualScopeHandler = new CollectionItemTextualScopeHandler(
        scopeHandlerFactory,
        languageId
      );
      const languageScopeHandler = languageDefinitions.get(languageId)?.getScopeHandler(this.scopeType);
      if (languageScopeHandler == null) {
        return textualScopeHandler;
      }
      return SortedScopeHandler.createFromScopeHandlers(
        scopeHandlerFactory,
        languageId,
        [languageScopeHandler, textualScopeHandler]
      );
    })();
  }
  get iterationScopeType() {
    return this.scopeHandler.iterationScopeType;
  }
  generateScopeCandidates(editor, position, direction2, hints) {
    return this.scopeHandler.generateScopes(editor, position, direction2, hints);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/ConditionalScopeHandler.ts
var ConditionalScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, conditionalScopeType, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.conditionalScopeType = conditionalScopeType;
    this.languageId = languageId;
    __publicField(this, "scopeType");
    __publicField(this, "isHierarchical", true);
  }
  get iterationScopeType() {
    throw new NoContainingScopeError(
      "Iteration scope for ConditionalScopeHandler"
    );
  }
  generateScopeCandidates(editor, position, direction2, hints) {
    const scopeHandler = this.scopeHandlerFactory.create(
      this.conditionalScopeType.scopeType,
      this.languageId
    );
    return ifilter(
      scopeHandler.generateScopes(editor, position, direction2, hints),
      this.conditionalScopeType.predicate
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/FallbackScopeHandler.ts
var FallbackScopeHandler = class _FallbackScopeHandler extends BaseScopeHandler {
  constructor(scopeHandlers) {
    super();
    this.scopeHandlers = scopeHandlers;
    __publicField(this, "scopeType");
    __publicField(this, "isHierarchical", true);
  }
  static create(scopeHandlerFactory, scopeType, languageId) {
    const scopeHandlers = scopeType.scopeTypes.map(
      (scopeType2) => scopeHandlerFactory.create(scopeType2, languageId)
    );
    return this.createFromScopeHandlers(scopeHandlers);
  }
  static createFromScopeHandlers(scopeHandlers) {
    return new _FallbackScopeHandler(scopeHandlers);
  }
  get iterationScopeType() {
    throw new NoContainingScopeError(
      "Iteration scope for FallbackScopeHandler"
    );
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    for (const scopeHandler of this.scopeHandlers) {
      yield* scopeHandler.generateScopes(editor, position, direction2, hints);
    }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/NotebookCellApiScopeHandler.ts
var NotebookCellApiScopeHandler = class extends BaseScopeHandler {
  constructor() {
    super();
    __publicField(this, "scopeType", { type: "notebookCell" });
    __publicField(this, "iterationScopeType", { type: "document" });
    __publicField(this, "isHierarchical", false);
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const cells = getNotebookCells(editor, position, direction2, hints);
    for (const cell of cells) {
      yield createTargetScope2(cell);
    }
  }
};
function getNotebookCells(editor, position, direction2, hints) {
  const nb = getNotebook(editor);
  if (nb == null) {
    return [];
  }
  const { notebook, cell } = nb;
  if (hints.containment === "required") {
    return [cell];
  }
  if (hints.containment === "disallowed" || hints.containment === "disallowedIfStrict") {
    return direction2 === "forward" ? notebook.cells.slice(cell.index + 1) : notebook.cells.slice(0, cell.index).reverse();
  }
  if (hints.distalPosition != null) {
    const searchRange = new Range(position, hints.distalPosition);
    if (searchRange.isRangeEqual(editor.document.range)) {
      return notebook.cells;
    }
  }
  return direction2 === "forward" ? notebook.cells.slice(cell.index) : notebook.cells.slice(0, cell.index + 1).reverse();
}
function getNotebook(editor) {
  const uri = editor.document.uri.toString();
  for (const notebook of ide().visibleNotebookEditors) {
    for (const cell of notebook.cells) {
      if (cell.document.uri.toString() === uri) {
        return { notebook, cell };
      }
    }
  }
  return void 0;
}
function createTargetScope2(cell) {
  const editor = getEditor(cell);
  const contentRange = editor.document.range;
  return {
    editor,
    domain: contentRange,
    getTargets: (isReversed) => [
      new NotebookCellTarget({
        editor,
        isReversed,
        contentRange
      })
    ]
  };
}
function getEditor(cell) {
  const uri = cell.document.uri.toString();
  for (const editor of ide().visibleTextEditors) {
    if (editor.document.uri.toString() === uri) {
      return editor;
    }
  }
  throw new Error("Editor not found notebook cell");
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/NotebookCellScopeHandler.ts
var NotebookCellScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, languageDefinitions, _scopeType, languageId) {
    super();
    __publicField(this, "scopeType", { type: "notebookCell" });
    __publicField(this, "isHierarchical", false);
    __publicField(this, "scopeHandler");
    this.scopeHandler = (() => {
      const apiScopeHandler = new NotebookCellApiScopeHandler();
      const languageScopeHandler = languageDefinitions.get(languageId)?.getScopeHandler(this.scopeType);
      if (languageScopeHandler == null) {
        return apiScopeHandler;
      }
      return SortedScopeHandler.createFromScopeHandlers(
        scopeHandlerFactory,
        languageId,
        [languageScopeHandler, apiScopeHandler]
      );
    })();
  }
  get iterationScopeType() {
    return this.scopeHandler.iterationScopeType;
  }
  generateScopeCandidates(editor, position, direction2, hints) {
    return this.scopeHandler.generateScopes(editor, position, direction2, hints);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/SurroundingPairInteriorScopeHandler.ts
var SurroundingPairInteriorScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.scopeType = scopeType;
    this.languageId = languageId;
    __publicField(this, "isHierarchical", true);
    __publicField(this, "surroundingPairScopeHandler");
    this.surroundingPairScopeHandler = this.scopeHandlerFactory.create(
      {
        type: "surroundingPair",
        delimiter: this.scopeType.delimiter,
        requireStrongContainment: true
      },
      this.languageId
    );
  }
  get iterationScopeType() {
    return this.surroundingPairScopeHandler.iterationScopeType;
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const scopes = this.surroundingPairScopeHandler.generateScopes(
      editor,
      position,
      direction2,
      hints
    );
    for (const scope of scopes) {
      yield {
        editor,
        domain: scope.domain,
        getTargets(isReversed) {
          return scope.getTargets(isReversed).flatMap((target) => target.getInterior());
        }
      };
    }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/createTargetScope.ts
function createTargetScope3(editor, { openingDelimiterRange, closingDelimiterRange }, requireStrongContainment) {
  const fullRange = openingDelimiterRange.union(closingDelimiterRange);
  const interiorRange = new Range(
    openingDelimiterRange.end,
    closingDelimiterRange.start
  );
  return {
    editor,
    domain: requireStrongContainment ? interiorRange : fullRange,
    getTargets: (isReversed) => [
      new SurroundingPairTarget({
        editor,
        isReversed,
        contentRange: fullRange,
        interiorRange,
        boundary: [openingDelimiterRange, closingDelimiterRange]
      })
    ]
  };
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/getDelimiterRegex.ts
function getDelimiterRegex(individualDelimiters) {
  const individualDelimiterDisjunct = uniq_default(
    individualDelimiters.map(({ text }) => text)
  ).map(escapeRegExp_default).join("|");
  return new RegExp(`(?<!\\\\)(${individualDelimiterDisjunct})`, "gu");
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/getDelimiterOccurrences.ts
function getDelimiterOccurrences(languageDefinition, document2, individualDelimiters) {
  if (individualDelimiters.length === 0) {
    return [];
  }
  const capturesMap = languageDefinition?.getCapturesMap(document2) ?? {};
  const disqualifyDelimiters = new OneWayRangeFinder(
    getSortedCaptures(capturesMap.disqualifyDelimiter)
  );
  const pairDelimiters = new OneWayRangeFinder(
    getSortedCaptures(capturesMap.pairDelimiter)
  );
  const textFragments = new OneWayNestedRangeFinder(
    getSortedCaptures(capturesMap.textFragment)
  );
  const delimiterTextToDelimiterInfoMap = Object.fromEntries(
    individualDelimiters.map((individualDelimiter) => [
      individualDelimiter.text,
      individualDelimiter
    ])
  );
  const regexMatches = matchAllIterator(
    document2.getText(),
    getDelimiterRegex(individualDelimiters)
  );
  const results = [];
  for (const match of regexMatches) {
    const text = match[0];
    const matchRange = new Range(
      document2.positionAt(match.index),
      document2.positionAt(match.index + text.length)
    );
    const disqualifiedDelimiter = ifNoErrors(
      disqualifyDelimiters.getContaining(matchRange)
    );
    if (disqualifiedDelimiter != null) {
      continue;
    }
    results.push({
      delimiterInfo: delimiterTextToDelimiterInfoMap[text],
      textFragmentRange: textFragments.getSmallestContaining(matchRange)?.range,
      range: ifNoErrors(pairDelimiters.getContaining(matchRange))?.range ?? matchRange
    });
  }
  return results;
}
function ifNoErrors(capture) {
  return capture != null && !capture.hasError() ? capture : void 0;
}
function getSortedCaptures(items) {
  if (items == null) {
    return [];
  }
  items.sort((a, b) => a.range.start.compareTo(b.range.start));
  return items;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/delimiterMaps.ts
var delimiterToText = Object.freeze({
  angleBrackets: [
    ["</", "<"],
    [">", "/>"]
  ],
  curlyBrackets: [["{", "${"], "}"],
  tripleBacktickQuotes: [[], []],
  tripleDoubleQuotes: [[], []],
  tripleSingleQuotes: [[], []],
  doubleQuotes: ['"', '"', { isSingleLine: true }],
  escapedDoubleQuotes: ['\\"', '\\"', { isSingleLine: true }],
  escapedParentheses: ["\\(", "\\)"],
  escapedSquareBrackets: ["\\[", "\\]"],
  escapedSingleQuotes: ["\\'", "\\'", { isSingleLine: true }],
  parentheses: [["(", "$("], ")"],
  backtickQuotes: ["`", "`"],
  singleQuotes: ["'", "'", { isSingleLine: true }],
  squareBrackets: ["[", "]"]
});
var delimiterToTextOverrides = {
  nix: {
    singleQuotes: ["''", "''"]
  },
  lua: {
    // FIXME: Add special double square brackets
    // see https://github.com/cursorless-dev/cursorless/pull/2012#issuecomment-1808214409
    // see also https://github.com/cursorless-dev/cursorless/issues/1812#issuecomment-1691493746
    doubleQuotes: [
      ['"', "[["],
      ['"', "]]"]
    ]
  },
  python: {
    tripleSingleQuotes: ["'''", "'''"],
    tripleDoubleQuotes: ['"""', '"""']
  },
  markdown: {
    tripleBacktickQuotes: ["```", "```"]
  },
  ruby: {
    tripleDoubleQuotes: ["%Q(", ")"]
  },
  csharp: {
    doubleQuotes: [
      ['@"', '"'],
      ['"', '"']
    ]
  }
};
var leftToRightMap = Object.fromEntries(
  Object.values(delimiterToText)
);
var complexDelimiterMap = {
  any: unsafeKeys(delimiterToText),
  string: [
    "tripleDoubleQuotes",
    "tripleSingleQuotes",
    "tripleBacktickQuotes",
    "doubleQuotes",
    "singleQuotes",
    "backtickQuotes"
  ],
  collectionBoundary: [
    "parentheses",
    "squareBrackets",
    "curlyBrackets",
    "angleBrackets"
  ]
};
function getSimpleDelimiterMap(languageId) {
  if (languageId != null && languageId in delimiterToTextOverrides) {
    return {
      ...delimiterToText,
      ...delimiterToTextOverrides[languageId]
    };
  }
  return delimiterToText;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/getIndividualDelimiters.ts
function getIndividualDelimiters(delimiter, languageId) {
  const delimiters = complexDelimiterMap[delimiter] ?? [delimiter];
  return getSimpleIndividualDelimiters(languageId, delimiters);
}
function getSimpleIndividualDelimiters(languageId, delimiters) {
  const delimiterToText2 = getSimpleDelimiterMap(languageId);
  return delimiters.flatMap((delimiterName) => {
    const [leftDelimiter, rightDelimiter, options2] = delimiterToText2[delimiterName];
    const { isSingleLine = false } = options2 ?? {};
    const leftDelimiters = isString(leftDelimiter) ? [leftDelimiter] : leftDelimiter;
    const rightDelimiters = isString(rightDelimiter) ? [rightDelimiter] : rightDelimiter;
    const allDelimiterTexts = uniq_default(concat_default(leftDelimiters, rightDelimiters));
    return allDelimiterTexts.map((text) => {
      const isLeft = leftDelimiters.includes(text);
      const isRight = rightDelimiters.includes(text);
      const side = (() => {
        if (isLeft && !isRight) {
          return "left";
        }
        if (!isLeft && isRight) {
          return "right";
        }
        return "unknown";
      })();
      return {
        text,
        side,
        delimiterName,
        isSingleLine
      };
    });
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/getSurroundingPairOccurrences.ts
function getSurroundingPairOccurrences(delimiterOccurrences) {
  const result = [];
  const openingDelimitersStack = [];
  for (const occurrence of delimiterOccurrences) {
    const {
      delimiterInfo: { delimiterName, side, isSingleLine },
      textFragmentRange,
      range: range3
    } = occurrence;
    if (side === "left") {
      openingDelimitersStack.push(occurrence);
    } else {
      const openingDelimiterIndex = findLastIndex_default(
        openingDelimitersStack,
        (o) => o.delimiterInfo.delimiterName === delimiterName && isSameTextFragment(o.textFragmentRange, textFragmentRange) && isValidLine(isSingleLine, o.range, range3)
      );
      if (openingDelimiterIndex === -1) {
        if (side === "unknown") {
          openingDelimitersStack.push(occurrence);
        }
        continue;
      }
      const openingDelimiter = openingDelimitersStack[openingDelimiterIndex];
      openingDelimitersStack.length = openingDelimiterIndex;
      result.push({
        delimiterName,
        openingDelimiterRange: openingDelimiter.range,
        closingDelimiterRange: range3
      });
    }
  }
  return result;
}
function isSameTextFragment(a, b) {
  if (a == null || b == null) {
    return a === b;
  }
  return a.isRangeEqual(b);
}
function isValidLine(isSingleLine, a, b) {
  return !isSingleLine || a.start.line === b.start.line;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/SurroundingPairScopeHandler.ts
var SurroundingPairScopeHandler = class extends BaseScopeHandler {
  constructor(languageDefinitions, scopeType, languageId) {
    super();
    this.languageDefinitions = languageDefinitions;
    this.scopeType = scopeType;
    this.languageId = languageId;
    __publicField(this, "iterationScopeType", {
      type: "conditional",
      scopeType: { type: "line" },
      predicate: (scope) => !scope.domain.isEmpty
    });
    __publicField(this, "isHierarchical", true);
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const cacheKey = "SurroundingPairScopeHandler_" + this.scopeType.delimiter;
    if (!scopeHandlerCache.isValid(cacheKey, editor.document)) {
      const delimiterOccurrences = getDelimiterOccurrences(
        this.languageDefinitions.get(this.languageId),
        editor.document,
        getIndividualDelimiters(this.scopeType.delimiter, this.languageId)
      );
      const surroundingPairs2 = getSurroundingPairOccurrences(delimiterOccurrences);
      scopeHandlerCache.update(cacheKey, editor.document, surroundingPairs2);
    }
    const surroundingPairs = scopeHandlerCache.get();
    const updatedSurroundingPairs = maybeApplyEmptyTargetHack(
      direction2,
      hints,
      position,
      surroundingPairs
    );
    yield* updatedSurroundingPairs.map(
      (pair) => createTargetScope3(
        editor,
        pair,
        this.scopeType.requireStrongContainment ?? false
      )
    ).sort((a, b) => compareTargetScopes(direction2, position, a, b));
  }
};
function maybeApplyEmptyTargetHack(direction2, hints, position, surroundingPairs) {
  if (direction2 === "forward" && hints.containment === "required" && hints.allowAdjacentScopes && hints.skipAncestorScopes) {
    return surroundingPairs.filter(
      (pair, i2) => !(pair.closingDelimiterRange.end.isEqual(position) && surroundingPairs[i2 + 1]?.closingDelimiterRange.start.isEqual(position))
    );
  }
  return surroundingPairs;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/InteriorScopeHandler.ts
var InteriorScopeHandler = class _InteriorScopeHandler extends BaseScopeHandler {
  constructor(scopeHandler) {
    super();
    this.scopeHandler = scopeHandler;
    __publicField(this, "scopeType", { type: "interior" });
    __publicField(this, "isHierarchical", true);
  }
  static maybeCreate(languageDefinitions, languageId) {
    const scopeHandler = languageDefinitions.get(languageId)?.getScopeHandler({ type: "interior" });
    if (scopeHandler == null) {
      return void 0;
    }
    return new _InteriorScopeHandler(scopeHandler);
  }
  get iterationScopeType() {
    throw new NoContainingScopeError(
      "Iteration scope for InteriorScopeHandler"
    );
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const scopes = this.scopeHandler.generateScopes(
      editor,
      position,
      direction2,
      hints
    );
    for (const scope of scopes) {
      yield createScope3(scope);
    }
  }
};
function createScope3(scope) {
  return {
    editor: scope.editor,
    domain: scope.domain,
    getTargets(isReversed) {
      return scope.getTargets(isReversed).map(createInteriorTarget);
    }
  };
}
function createInteriorTarget(target) {
  return new InteriorTarget({
    editor: target.editor,
    isReversed: target.isReversed,
    fullInteriorRange: target.contentRange
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/ScopeHandlerFactoryImpl.ts
var ScopeHandlerFactoryImpl = class {
  constructor(languageDefinitions) {
    this.languageDefinitions = languageDefinitions;
    this.maybeCreate = this.maybeCreate.bind(this);
    this.create = this.create.bind(this);
  }
  maybeCreate(scopeType, languageId) {
    switch (scopeType.type) {
      case "character":
        return new CharacterScopeHandler(this, scopeType, languageId);
      case "word":
        return new WordScopeHandler(this, scopeType, languageId);
      case "token":
        return new TokenScopeHandler(this, scopeType, languageId);
      case "identifier":
        return new IdentifierScopeHandler(this, scopeType, languageId);
      case "line":
      case "fullLine":
        return new LineScopeHandler({ type: scopeType.type }, languageId);
      case "sentence":
        return new SentenceScopeHandler(this, scopeType, languageId);
      case "paragraph":
        return new ParagraphScopeHandler(scopeType, languageId);
      case "boundedParagraph":
        return new BoundedParagraphScopeHandler(this, scopeType, languageId);
      case "document":
        return new DocumentScopeHandler(scopeType, languageId);
      case "nonWhitespaceSequence":
        return new NonWhitespaceSequenceScopeHandler(
          this,
          scopeType,
          languageId
        );
      case "boundedNonWhitespaceSequence":
        return new BoundedNonWhitespaceSequenceScopeHandler(
          this,
          scopeType,
          languageId
        );
      case "url":
        return new UrlScopeHandler(this, scopeType, languageId);
      case "customRegex":
        return new CustomRegexScopeHandler(this, scopeType, languageId);
      case "glyph":
        return new GlyphScopeHandler(this, scopeType, languageId);
      case "collectionItem":
        return new CollectionItemScopeHandler(
          this,
          this.languageDefinitions,
          languageId
        );
      case "surroundingPair":
        return new SurroundingPairScopeHandler(
          this.languageDefinitions,
          scopeType,
          languageId
        );
      case "surroundingPairInterior":
        return new SurroundingPairInteriorScopeHandler(
          this,
          scopeType,
          languageId
        );
      case "notebookCell":
        return new NotebookCellScopeHandler(
          this,
          this.languageDefinitions,
          scopeType,
          languageId
        );
      case "interior":
        return InteriorScopeHandler.maybeCreate(
          this.languageDefinitions,
          languageId
        );
      case "custom":
        return scopeType.scopeHandler;
      case "oneOf":
        return SortedScopeHandler.create(this, scopeType, languageId);
      case "fallback":
        return FallbackScopeHandler.create(this, scopeType, languageId);
      case "conditional":
        return new ConditionalScopeHandler(this, scopeType, languageId);
      default:
        if (pseudoScopes.has(scopeType.type)) {
          throw Error(`Unexpected scope type '${scopeType.type}'`);
        }
        return this.languageDefinitions.get(languageId)?.getScopeHandler(scopeType);
    }
  }
  create(scopeType, languageId) {
    const handler = this.maybeCreate(scopeType, languageId);
    if (handler == null) {
      throw new UnsupportedScopeError(scopeType.type);
    }
    return handler;
  }
};

// ../cursorless-engine/src/languages/TreeSitterQuery/checkCaptureStartEnd.ts
function checkCaptureStartEnd(captures, messages) {
  if (captures.length === 1) {
    return true;
  }
  let shownError = false;
  const lastStart = captures.filter(({ name: name2 }) => name2.endsWith(".start")).map(({ range: { end } }) => end).sort((a, b) => a.compareTo(b)).at(-1);
  const firstEnd = captures.filter(({ name: name2 }) => name2.endsWith(".end")).map(({ range: { start: start2 } }) => start2).sort((a, b) => a.compareTo(b)).at(0);
  if (lastStart != null && firstEnd != null) {
    if (lastStart.isAfter(firstEnd)) {
      void showError(
        messages,
        "TreeSitterQuery.checkCaptures.badOrder",
        `Start capture must be before end capture: ${captures.map((c) => c.name)}`
      );
      shownError = true;
    }
  }
  const startCount = captures.filter(
    ({ name: name2 }) => name2.endsWith(".start")
  ).length;
  const endCount = captures.filter(({ name: name2 }) => name2.endsWith(".end")).length;
  const regularCount = captures.length - startCount - endCount;
  if (regularCount > 0 && (startCount > 0 || endCount > 0)) {
    void showError(
      messages,
      "TreeSitterQuery.checkCaptures.mixRegularStartEnd",
      `Please do not mix regular captures and start/end captures: ${captures.map(
        ({ name: name2, range: range3 }) => name2 + " " + range3.toString()
      )}`
    );
    shownError = true;
  }
  if (regularCount > 1) {
    void showError(
      messages,
      "TreeSitterQuery.checkCaptures.duplicate",
      `A capture with the same name may only appear once in a single pattern: ${captures.map(
        ({ name: name2, range: range3 }) => name2 + " " + range3.toString()
      )}`
    );
    shownError = true;
  }
  return !shownError;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/getNodeRange.ts
function getNodeRange(node) {
  return new Range(
    node.startPosition.row,
    node.startPosition.column,
    node.endPosition.row,
    node.endPosition.column
  );
}

// ../cursorless-engine/src/languages/TreeSitterQuery/isContainedInErrorNode.ts
function isContainedInErrorNode(node) {
  if (node.hasError) {
    return true;
  }
  let ancestorNode = node.parent;
  while (ancestorNode != null) {
    if (ancestorNode.isError) {
      return true;
    }
    if (ancestorNode.hasError) {
      return false;
    }
    if (ancestorNode.previousSibling?.isError || ancestorNode.nextSibling?.isError) {
      return true;
    }
    ancestorNode = ancestorNode.parent;
  }
  return false;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/normalizeCaptureName.ts
function normalizeCaptureName(name2) {
  return name2.replace(/(\.(start|end))?(\.(startOf|endOf))?$/, "");
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default3,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone2,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError2,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int2,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json2,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map3,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null4,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set3,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union2,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default2,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null3,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone2,
  config: () => config,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize2,
  flattenError: () => flattenError,
  formatError: () => formatError2,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  process: () => process2,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name2, initializer3, params) {
  function init2(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name2)) {
      return;
    }
    inst._zod.traits.add(name2);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys2 = Object.keys(proto);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const k = keys2[i2];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name2 });
  function _(def) {
    var _a10;
    const inst = params?.Parent ? new Definition() : this;
    init2(inst, def);
    (_a10 = inst._zod).deferred ?? (_a10.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init2 });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name2);
    }
  });
  Object.defineProperty(_, "name", { value: name2 });
  return _;
}
var $brand = /* @__PURE__ */ Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name2) {
    super(`Encountered unidirectional transform during encode: ${name2}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert2,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone2,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend3,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject4,
  isPlainObject: () => isPlainObject2,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge2,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert2(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values2 = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values2;
}
function joinValues(array2, separator2 = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator2);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set4 = false;
  return {
    get value() {
      if (!set4) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start2 = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start2, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = /* @__PURE__ */ Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema3) {
  return mergeDefs(schema3._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys2 = Object.keys(promisesObj);
  const promises = keys2.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i2 = 0; i2 < keys2.length; i2++) {
      resolvedObj[keys2[i2]] = results[i2];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str2 = "";
  for (let i2 = 0; i2 < length; i2++) {
    str2 += chars[Math.floor(Math.random() * chars.length)];
  }
  return str2;
}
function esc(str2) {
  return JSON.stringify(str2);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject4(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject2(o) {
  if (isObject4(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject4(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject2(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str2) {
  return str2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema3, mask) {
  const currDef = schema3._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema3._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema3, def);
}
function omit(schema3, mask) {
  const currDef = schema3._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema3._zod.def, {
    get shape() {
      const newShape = { ...schema3._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema3, def);
}
function extend3(schema3, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema3._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema3._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema3._zod.def, {
    get shape() {
      const _shape = { ...schema3._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone2(schema3, def);
}
function safeExtend(schema3, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema3._zod.def, {
    get shape() {
      const _shape = { ...schema3._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone2(schema3, def);
}
function merge2(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone2(a, def);
}
function partial(Class2, schema3, mask) {
  const currDef = schema3._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema3._zod.def, {
    get shape() {
      const oldShape = schema3._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema3, def);
}
function required(Class2, schema3, mask) {
  const def = mergeDefs(schema3._zod.def, {
    get shape() {
      const oldShape = schema3._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone2(schema3, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i2 = startIndex; i2 < x.issues.length; i2++) {
    if (x.issues[i2]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a10;
    (_a10 = iss).path ?? (_a10.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args2) {
  const [iss, input, inst] = args2;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i2 = 0; i2 < binaryString.length; i2++) {
    bytes[i2] = binaryString.charCodeAt(i2);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    binaryString += String.fromCharCode(bytes[i2]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i2 = 0; i2 < cleanHex.length; i2 += 2) {
    bytes[i2 / 2] = Number.parseInt(cleanHex.slice(i2, i2 + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError2(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue2.path.length) {
          const el = issue2.path[i2];
          const terminal = i2 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError(error48, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error49, path = []) => {
    var _a10, _b;
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i2 = 0;
        while (i2 < fullpath.length) {
          const el = fullpath[i2];
          const terminal = i2 === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a10 = curr.properties)[el] ?? (_a10[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i2++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema3, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema3._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema3, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema3._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema3, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema3._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema3, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema3._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema3, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema3, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema3, value, _ctx) => {
  return _parse(_Err)(schema3, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema3, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema3, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema3, value, _ctx) => {
  return _parseAsync(_Err)(schema3, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema3, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema3, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema3, value, _ctx) => {
  return _safeParse(_Err)(schema3, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema3, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema3, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema3, value, _ctx) => {
  return _safeParseAsync(_Err)(schema3, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null2,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args2) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args2.precision === "number" ? args2.precision === -1 ? `${hhmm}` : args2.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args2.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args2) {
  return new RegExp(`^${timeSource(args2)}$`);
}
function datetime(args2) {
  const time3 = timeSource({ precision: args2.precision });
  const opts = ["Z"];
  if (args2.local)
    opts.push("");
  if (args2.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?$/;
var boolean = /^(?:true|false)$/i;
var _null2 = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a10;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a10 = inst._zod).onattach ?? (_a10.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a10;
    (_a10 = inst2._zod.bag).multipleOf ?? (_a10.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a10;
  $ZodCheck.init(inst, def);
  (_a10 = inst._zod.def).when ?? (_a10.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a10;
  $ZodCheck.init(inst, def);
  (_a10 = inst._zod.def).when ?? (_a10.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a10;
  $ZodCheck.init(inst, def);
  (_a10 = inst._zod.def).when ?? (_a10.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a10;
  $ZodCheck.init(inst, def);
  (_a10 = inst._zod.def).when ?? (_a10.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a10;
  $ZodCheck.init(inst, def);
  (_a10 = inst._zod.def).when ?? (_a10.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a10;
  $ZodCheck.init(inst, def);
  (_a10 = inst._zod.def).when ?? (_a10.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a10, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a10 = inst._zod).check ?? (_a10.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property2) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property2, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args2 = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args2;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args2 = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args2, lines.join("\n"));
  }
};

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a10;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a10 = inst._zod).deferred ?? (_a10.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts2 = payload.value.split("/");
    try {
      if (parts2.length !== 2)
        throw new Error();
      const [address, prefix] = parts2;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null2;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys2 = Object.keys(def.shape);
  for (const k of keys2) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys: keys2,
    keySet: new Set(keys2),
    numKeys: keys2.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject5 = isObject4;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject5(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id2 = ids[key];
      const k = esc(key);
      const schema3 = shape[key];
      const isOptionalOut = schema3?._zod?.optout === "optional";
      doc.write(`const ${id2} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id2}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id2}.issues.length) {
          payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject5 = isObject4;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject5(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map4 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values2 = o._zod.propValues?.[def.discriminator];
      if (!values2 || values2.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values2) {
        if (map4.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map4.set(v, o);
      }
    }
    return map4;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject4(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i2 = -1;
    for (const item of items) {
      i2++;
      if (i2 >= input.length) {
        if (i2 >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i2],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
      } else {
        handleTupleResult(result, payload, i2);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i2++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
        } else {
          handleTupleResult(result, payload, i2);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject2(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values2 = def.keyType._zod.values;
    if (values2) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values2) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values2 = getEnumValues(def.entries);
  const valuesSet = new Set(values2);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values2.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: values2,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values2 = new Set(def.values);
  inst._zod.values = values2;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values2.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction2 = ctx.direction || "forward";
    if (direction2 === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction2 = ctx.direction || "forward";
  if (direction2 === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start2 = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start2, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func2) => {
    if (typeof func2 !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args2) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args2) : args2;
      const result = Reflect.apply(func2, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func2) => {
    if (typeof func2 !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args2) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args2) : args2;
      const result = await Reflect.apply(func2, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args2) => {
    const F = inst.constructor;
    if (Array.isArray(args2[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args2[0],
          rest: args2[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args2[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count2, one, few, many) {
  const absCount = Math.abs(count2);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/bg.js
var error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/en.js
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/eo.js
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/he.js
var error16 = () => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
    // no unit
  };
  const typeEntry = (t) => t ? TypeNames[t] : void 0;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count2, one, many) {
  return Math.abs(count2) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
};
function hy_default() {
  return {
    localeError: error18()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/id.js
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error19()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/is.js
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error20()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/it.js
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error21()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ja.js
var error22 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error22()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ka.js
var error23 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default() {
  return {
    localeError: error23()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/km.js
var error24 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default() {
  return {
    localeError: error24()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ko.js
var error25 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error25()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last2 = abs % 10;
  const last22 = abs % 100;
  if (last22 >= 11 && last22 <= 19 || last2 === 0)
    return "many";
  if (last2 === 1)
    return "one";
  return "few";
}
var error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error26()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/mk.js
var error27 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error27()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ms.js
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error28()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/nl.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error29()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/no.js
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error30()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ota.js
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error31()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ps.js
var error32 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error32()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/pl.js
var error33 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error33()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/pt.js
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error34()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count2, one, few, many) {
  const absCount = Math.abs(count2);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error35()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/sl.js
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error36()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/sv.js
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error37()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ta.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error38()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/th.js
var error39 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error39()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/tr.js
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error40()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/uk.js
var error41 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default() {
  return {
    localeError: error41()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ur.js
var error42 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error42()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/uz.js
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
};
function uz_default() {
  return {
    localeError: error43()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/vi.js
var error44 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error44()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/zh-CN.js
var error45 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error45()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/zh-TW.js
var error46 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error46()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/yo.js
var error47 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default() {
  return {
    localeError: error47()
  };
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/registries.js
var _a;
var $output = /* @__PURE__ */ Symbol("ZodOutput");
var $input = /* @__PURE__ */ Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema3, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema3, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.set(meta3.id, schema3);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema3) {
    const meta3 = this._map.get(schema3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema3);
    return this;
  }
  get(schema3) {
    const p = schema3._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema3) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema3);
  }
  has(schema3) {
    return this._map.has(schema3);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null3(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property2, schema3, params) {
  return new $ZodCheckProperty({
    check: "property",
    property: property2,
    schema: schema3,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _union(Class2, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    inclusive: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class2, discriminator, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    discriminator,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
// @__NO_SIDE_EFFECTS__
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _enum(Class2, values2, params) {
  const entries = Array.isArray(values2) ? Object.fromEntries(values2.map((v) => [v, v])) : values2;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
// @__NO_SIDE_EFFECTS__
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _default2(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
// @__NO_SIDE_EFFECTS__
function _pipe(Class2, in_, out2) {
  return new Class2({
    type: "pipe",
    in: in_,
    out: out2
  });
}
// @__NO_SIDE_EFFECTS__
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class2, parts2, params) {
  return new Class2({
    type: "template_literal",
    parts: parts2,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
// @__NO_SIDE_EFFECTS__
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema3 = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema3;
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  const schema3 = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema3;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata2) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata2 });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema3, ctx, _params = { path: [], schemaPath: [] }) {
  var _a10;
  const def = schema3._zod.def;
  const seen = ctx.seen.get(schema3);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema3);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema3, result);
  const overrideSchema = schema3._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema3],
      path: _params.path
    };
    if (schema3._zod.processJSONSchema) {
      schema3._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema3, ctx, _json, params);
    }
    const parent = schema3._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema3);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema3)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a10 = result.schema).default ?? (_a10.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema3);
  return _result.schema;
}
function extractDefs(ctx, schema3) {
  const root2 = ctx.seen.get(schema3);
  if (!root2)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id2 = ctx.metadataRegistry.get(entry[0])?.id;
    if (id2) {
      const existing = idToSchema.get(id2);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id2}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id2, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id3) => id3);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id2 = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id2;
      return { defId: id2, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id2}` };
    }
    if (entry[1] === root2) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema4 = seen.schema;
    for (const key in schema4) {
      delete schema4[key];
    }
    schema4.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema3 === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema3 !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id2 = ctx.metadataRegistry.get(entry[0])?.id;
    if (id2) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize2(ctx, schema3) {
  const root2 = ctx.seen.get(schema3);
  if (!root2)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema4 = seen.def ?? seen.schema;
    const _cached = { ...schema4 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema4.allOf = schema4.allOf ?? [];
        schema4.allOf.push(refSchema);
      } else {
        Object.assign(schema4, refSchema);
      }
      Object.assign(schema4, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema4) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema4[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema4) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema4[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema4[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema4.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema4) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema4[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema4[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema4,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id2 = ctx.external.registry.get(schema3)?.id;
    if (!id2)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id2);
  }
  Object.assign(result, root2.def ?? root2.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema3["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema3, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema3, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema3, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema3, ctx);
  extractDefs(ctx, schema3);
  return finalize2(ctx, schema3);
};
var createStandardJSONSchemaMethod = (schema3, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema3, ctx);
  extractDefs(ctx, schema3);
  return finalize2(ctx, schema3);
};

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
var stringProcessor = (schema3, ctx, _json, _params) => {
  const json3 = _json;
  json3.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema3._zod.bag;
  if (typeof minimum === "number")
    json3.minLength = minimum;
  if (typeof maximum === "number")
    json3.maxLength = maximum;
  if (format) {
    json3.format = formatMap[format] ?? format;
    if (json3.format === "")
      delete json3.format;
    if (format === "time") {
      delete json3.format;
    }
  }
  if (contentEncoding)
    json3.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json3.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json3.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema3, ctx, _json, _params) => {
  const json3 = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema3._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json3.type = "integer";
  else
    json3.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.minimum = exclusiveMinimum;
      json3.exclusiveMinimum = true;
    } else {
      json3.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json3.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json3.minimum;
      else
        delete json3.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.maximum = exclusiveMaximum;
      json3.exclusiveMaximum = true;
    } else {
      json3.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json3.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json3.maximum;
      else
        delete json3.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json3.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json3, _params) => {
  json3.type = "boolean";
};
var bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
var symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
var nullProcessor = (_schema, ctx, json3, _params) => {
  if (ctx.target === "openapi-3.0") {
    json3.type = "string";
    json3.nullable = true;
    json3.enum = [null];
  } else {
    json3.type = "null";
  }
};
var undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
var voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
var neverProcessor = (_schema, _ctx, json3, _params) => {
  json3.not = {};
};
var anyProcessor = (_schema, _ctx, _json, _params) => {
};
var unknownProcessor = (_schema, _ctx, _json, _params) => {
};
var dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
var enumProcessor = (schema3, _ctx, json3, _params) => {
  const def = schema3._zod.def;
  const values2 = getEnumValues(def.entries);
  if (values2.every((v) => typeof v === "number"))
    json3.type = "number";
  if (values2.every((v) => typeof v === "string"))
    json3.type = "string";
  json3.enum = values2;
};
var literalProcessor = (schema3, ctx, json3, _params) => {
  const def = schema3._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === void 0) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {
      }
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {
  } else if (vals.length === 1) {
    const val = vals[0];
    json3.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.enum = [val];
    } else {
      json3.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json3.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json3.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json3.type = "boolean";
    if (vals.every((v) => v === null))
      json3.type = "null";
    json3.enum = vals;
  }
};
var nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
var templateLiteralProcessor = (schema3, _ctx, json3, _params) => {
  const _json = json3;
  const pattern = schema3._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
};
var fileProcessor = (schema3, _ctx, json3, _params) => {
  const _json = json3;
  const file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema3._zod.bag;
  if (minimum !== void 0)
    file2.minLength = minimum;
  if (maximum !== void 0)
    file2.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file2.contentMediaType = mime[0];
      Object.assign(_json, file2);
    } else {
      Object.assign(_json, file2);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file2);
  }
};
var successProcessor = (_schema, _ctx, json3, _params) => {
  json3.type = "boolean";
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
var setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema3, ctx, _json, params) => {
  const json3 = _json;
  const def = schema3._zod.def;
  const { minimum, maximum } = schema3._zod.bag;
  if (typeof minimum === "number")
    json3.minItems = minimum;
  if (typeof maximum === "number")
    json3.maxItems = maximum;
  json3.type = "array";
  json3.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema3, ctx, _json, params) => {
  const json3 = _json;
  const def = schema3._zod.def;
  json3.type = "object";
  json3.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json3.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === void 0;
    } else {
      return v.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json3.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json3.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json3.additionalProperties = false;
  } else if (def.catchall) {
    json3.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema3, ctx, json3, params) => {
  const def = schema3._zod.def;
  const isExclusive = def.inclusive === false;
  const options2 = def.options.map((x, i2) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i2]
  }));
  if (isExclusive) {
    json3.oneOf = options2;
  } else {
    json3.anyOf = options2;
  }
};
var intersectionProcessor = (schema3, ctx, json3, params) => {
  const def = schema3._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json3.allOf = allOf;
};
var tupleProcessor = (schema3, ctx, _json, params) => {
  const json3 = _json;
  const def = schema3._zod.def;
  json3.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i2) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i2]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json3.prefixItems = prefixItems;
    if (rest) {
      json3.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json3.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json3.items.anyOf.push(rest);
    }
    json3.minItems = prefixItems.length;
    if (!rest) {
      json3.maxItems = prefixItems.length;
    }
  } else {
    json3.items = prefixItems;
    if (rest) {
      json3.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema3._zod.bag;
  if (typeof minimum === "number")
    json3.minItems = minimum;
  if (typeof maximum === "number")
    json3.maxItems = maximum;
};
var recordProcessor = (schema3, ctx, _json, params) => {
  const json3 = _json;
  const def = schema3._zod.def;
  json3.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json3.patternProperties = {};
    for (const pattern of patterns) {
      json3.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json3.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json3.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json3.required = validKeyValues;
    }
  }
};
var nullableProcessor = (schema3, ctx, json3, params) => {
  const def = schema3._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json3.nullable = true;
  } else {
    json3.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema3, ctx, _json, params) => {
  const def = schema3._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema3, ctx, json3, params) => {
  const def = schema3._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  seen.ref = def.innerType;
  json3.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema3, ctx, json3, params) => {
  const def = schema3._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json3._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema3, ctx, json3, params) => {
  const def = schema3._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json3.default = catchValue;
};
var pipeProcessor = (schema3, ctx, _json, params) => {
  const def = schema3._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  seen.ref = innerType;
};
var readonlyProcessor = (schema3, ctx, json3, params) => {
  const def = schema3._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  seen.ref = def.innerType;
  json3.readOnly = true;
};
var promiseProcessor = (schema3, ctx, _json, params) => {
  const def = schema3._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  seen.ref = def.innerType;
};
var optionalProcessor = (schema3, ctx, _json, params) => {
  const def = schema3._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  seen.ref = def.innerType;
};
var lazyProcessor = (schema3, ctx, _json, params) => {
  const innerType = schema3._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema3);
  seen.ref = innerType;
};
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema3] = entry;
      process2(schema3, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema3] = entry;
      extractDefs(ctx2, schema3);
      schemas[key] = finalize2(ctx2, schema3);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize2(ctx, input);
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/json-schema-generator.js
var JSONSchemaGenerator = class {
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(schema3, _params = { path: [], schemaPath: [] }) {
    return process2(schema3, this.ctx, _params);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(schema3, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema3);
    const result = finalize2(this.ctx, schema3);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
};

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/schemas.js
var schemas_exports2 = {};
__export(schemas_exports2, {
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default3,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int2,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json2,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map3,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null4,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set3,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union2,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError2(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone2(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union2([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default3(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args2) => {
    if (args2.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args2[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => stringProcessor(inst, ctx, json3, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args2) => inst.check(_regex(...args2));
  inst.includes = (...args2) => inst.check(_includes(...args2));
  inst.startsWith = (...args2) => inst.check(_startsWith(...args2));
  inst.endsWith = (...args2) => inst.check(_endsWith(...args2));
  inst.min = (...args2) => inst.check(_minLength(...args2));
  inst.max = (...args2) => inst.check(_maxLength(...args2));
  inst.length = (...args2) => inst.check(_length(...args2));
  inst.nonempty = (...args2) => inst.check(_minLength(1, ...args2));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args2) => inst.check(_normalize(...args2));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => numberProcessor(inst, ctx, json3, params);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int2(params));
  inst.safe = (params) => inst.check(int2(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int2(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => booleanProcessor(inst, ctx, json3, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => bigintProcessor(inst, ctx, json3, params);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => symbolProcessor(inst, ctx, json3, params);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => undefinedProcessor(inst, ctx, json3, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nullProcessor(inst, ctx, json3, params);
});
function _null4(params) {
  return _null3(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => anyProcessor(inst, ctx, json3, params);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unknownProcessor(inst, ctx, json3, params);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => neverProcessor(inst, ctx, json3, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => voidProcessor(inst, ctx, json3, params);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => dateProcessor(inst, ctx, json3, params);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => arrayProcessor(inst, ctx, json3, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema3) {
  const shape = schema3._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => objectProcessor(inst, ctx, json3, params);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args2) => util_exports.partial(ZodOptional, inst, args2[0]);
  inst.required = (...args2) => util_exports.required(ZodNonOptional, inst, args2[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
  inst.options = def.options;
});
function union2(options2, params) {
  return new ZodUnion({
    type: "union",
    options: options2,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
  inst.options = def.options;
});
function xor(options2, params) {
  return new ZodXor({
    type: "union",
    options: options2,
    inclusive: false,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options2, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options: options2,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => intersectionProcessor(inst, ctx, json3, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => tupleProcessor(inst, ctx, json3, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => recordProcessor(inst, ctx, json3, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone2(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => mapProcessor(inst, ctx, json3, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args2) => inst.check(_minSize(...args2));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args2) => inst.check(_maxSize(...args2));
  inst.size = (...args2) => inst.check(_size(...args2));
});
function map3(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => setProcessor(inst, ctx, json3, params);
  inst.min = (...args2) => inst.check(_minSize(...args2));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args2) => inst.check(_maxSize(...args2));
  inst.size = (...args2) => inst.check(_size(...args2));
});
function set3(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => enumProcessor(inst, ctx, json3, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys2 = new Set(Object.keys(def.entries));
  inst.extract = (values2, params) => {
    const newEntries = {};
    for (const value of values2) {
      if (keys2.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values2, params) => {
    const newEntries = { ...def.entries };
    for (const value of values2) {
      if (keys2.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values2, params) {
  const entries = Array.isArray(values2) ? Object.fromEntries(values2.map((v) => [v, v])) : values2;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => literalProcessor(inst, ctx, json3, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => fileProcessor(inst, ctx, json3, params);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => transformProcessor(inst, ctx, json3, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nullableProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => defaultProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default3(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => prefaultProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nonoptionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => successProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => catchProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nanProcessor(inst, ctx, json3, params);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => pipeProcessor(inst, ctx, json3, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out2) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out: out2
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out2, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out: out2,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => readonlyProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => templateLiteralProcessor(inst, ctx, json3, params);
});
function templateLiteral(parts2, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts: parts2,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => lazyProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => promiseProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => functionProcessor(inst, ctx, json3, params);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => customProcessor(inst, ctx, json3, params);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
var stringbool = (...args2) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args2);
function json2(params) {
  const jsonSchema = lazy(() => {
    return union2([string2(params), number2(), boolean2(), _null4(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema3) {
  return pipe(transform(fn), schema3);
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map4) {
  config({
    customError: map4
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports2,
  ...checks_exports2,
  iso: iso_exports
};
var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  // Schema identification
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  // Core schema keywords
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  // Type
  "type",
  "enum",
  "const",
  // Composition
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  // Object
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  // Array
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  // String
  "minLength",
  "maxLength",
  "pattern",
  "format",
  // Number
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  // Already handled metadata
  "description",
  "default",
  // Content
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  // Unsupported (error-throwing)
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  // OpenAPI
  "nullable",
  "readOnly"
]);
function detectVersion(schema3, defaultTarget) {
  const $schema = schema3.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path = ref.slice(1).split("/").filter(Boolean);
  if (path.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    const key = path[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema3, ctx) {
  if (schema3.not !== void 0) {
    if (typeof schema3.not === "object" && Object.keys(schema3.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema3.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema3.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema3.if !== void 0 || schema3.then !== void 0 || schema3.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema3.dependentSchemas !== void 0 || schema3.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema3.$ref) {
    const refPath = schema3.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema3.enum !== void 0) {
    const enumValues = schema3.enum;
    if (ctx.version === "openapi-3.0" && schema3.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema3.const !== void 0) {
    return z.literal(schema3.const);
  }
  const type2 = schema3.type;
  if (Array.isArray(type2)) {
    const typeSchemas = type2.map((t) => {
      const typeSchema = { ...schema3, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type2) {
    return z.any();
  }
  let zodSchema;
  switch (type2) {
    case "string": {
      let stringSchema = z.string();
      if (schema3.format) {
        const format = schema3.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema3.minLength === "number") {
        stringSchema = stringSchema.min(schema3.minLength);
      }
      if (typeof schema3.maxLength === "number") {
        stringSchema = stringSchema.max(schema3.maxLength);
      }
      if (schema3.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema3.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type2 === "integer" ? z.number().int() : z.number();
      if (typeof schema3.minimum === "number") {
        numberSchema = numberSchema.min(schema3.minimum);
      }
      if (typeof schema3.maximum === "number") {
        numberSchema = numberSchema.max(schema3.maximum);
      }
      if (typeof schema3.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema3.exclusiveMinimum);
      } else if (schema3.exclusiveMinimum === true && typeof schema3.minimum === "number") {
        numberSchema = numberSchema.gt(schema3.minimum);
      }
      if (typeof schema3.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema3.exclusiveMaximum);
      } else if (schema3.exclusiveMaximum === true && typeof schema3.maximum === "number") {
        numberSchema = numberSchema.lt(schema3.maximum);
      }
      if (typeof schema3.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema3.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema3.properties || {};
      const requiredSet = new Set(schema3.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema3.propertyNames) {
        const keySchema = convertSchema(schema3.propertyNames, ctx);
        const valueSchema = schema3.additionalProperties && typeof schema3.additionalProperties === "object" ? convertSchema(schema3.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema3.patternProperties) {
        const patternProps = schema3.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i2 = 2; i2 < schemasToIntersect.length; i2++) {
            result = z.intersection(result, schemasToIntersect[i2]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema3.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema3.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema3.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema3.prefixItems;
      const items = schema3.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema3.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema3.minItems));
        }
        if (typeof schema3.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema3.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema3.additionalItems && typeof schema3.additionalItems === "object" ? convertSchema(schema3.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema3.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema3.minItems));
        }
        if (typeof schema3.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema3.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema3.minItems === "number") {
          arraySchema = arraySchema.min(schema3.minItems);
        }
        if (typeof schema3.maxItems === "number") {
          arraySchema = arraySchema.max(schema3.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type2}`);
  }
  if (schema3.description) {
    zodSchema = zodSchema.describe(schema3.description);
  }
  if (schema3.default !== void 0) {
    zodSchema = zodSchema.default(schema3.default);
  }
  return zodSchema;
}
function convertSchema(schema3, ctx) {
  if (typeof schema3 === "boolean") {
    return schema3 ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema3, ctx);
  const hasExplicitType = schema3.type || schema3.enum !== void 0 || schema3.const !== void 0;
  if (schema3.anyOf && Array.isArray(schema3.anyOf)) {
    const options2 = schema3.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options2);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema3.oneOf && Array.isArray(schema3.oneOf)) {
    const options2 = schema3.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options2);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema3.allOf && Array.isArray(schema3.allOf)) {
    if (schema3.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema3.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i2 = startIdx; i2 < schema3.allOf.length; i2++) {
        result = z.intersection(result, convertSchema(schema3.allOf[i2], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema3.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema3.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema3) {
      extraMeta[key] = schema3[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema3) {
      extraMeta[key] = schema3[key];
    }
  }
  for (const key of Object.keys(schema3)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema3[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema3, params) {
  if (typeof schema3 === "boolean") {
    return schema3 ? z.any() : z.never();
  }
  const version2 = detectVersion(schema3, params?.defaultTarget);
  const defs = schema3.$defs || schema3.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema3,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema3, ctx);
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// ../../node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/external.js
config(en_default());

// ../cursorless-engine/src/languages/TreeSitterQuery/getNode.ts
function getNode(capture) {
  if (capture.node == null) {
    throw Error(
      `Capture ${capture.name} has no node. The range of the capture has already been updated and no longer matches a specific node.`
    );
  }
  return capture.node;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/isEven.ts
function isEven(node, fieldName) {
  if (node.parent == null) {
    throw Error("Node has no parent");
  }
  const treeCursor = node.parent.walk();
  let hasNext = treeCursor.gotoFirstChild();
  let even = true;
  while (hasNext) {
    if (treeCursor.currentFieldName === fieldName) {
      if (treeCursor.currentNode.id === node.id) {
        return even;
      }
      even = !even;
    }
    hasNext = treeCursor.gotoNextSibling();
  }
  throw Error(`Node not found in parent for field: ${fieldName}`);
}

// ../cursorless-engine/src/languages/TreeSitterQuery/makeRangeFromPositions.ts
function makeRangeFromPositions(startPosition, endPosition) {
  return new Range(
    startPosition.row,
    startPosition.column,
    endPosition.row,
    endPosition.column
  );
}

// ../cursorless-engine/src/languages/TreeSitterQuery/operatorArgumentSchemaTypes.ts
var string4 = external_exports.object({ type: external_exports.literal("string"), value: external_exports.string() });
var q = {
  /**
   * Expect a capture, eg @foo.  The operator will receive the node referenced
   * by the capture
   */
  node: external_exports.object({ type: external_exports.literal("capture"), name: external_exports.string() }),
  /** Expect a string */
  string: string4,
  /** Expect an integer */
  integer: string4.transform((val, ctx) => {
    const parsedValue = stringToInteger(val.value);
    if (parsedValue == null) {
      ctx.addIssue({
        code: "custom",
        message: "Expected an integer"
      });
      return external_exports.NEVER;
    }
    return { type: "integer", value: parsedValue };
  }),
  /** Expect a boolean */
  boolean: string4.transform((val, ctx) => {
    if (val.value === "true") {
      return { type: "boolean", value: true };
    }
    if (val.value === "false") {
      return { type: "boolean", value: false };
    }
    ctx.addIssue({
      code: "custom",
      message: "Expected true or false"
    });
    return external_exports.NEVER;
  })
};

// ../cursorless-engine/src/languages/TreeSitterQuery/predicateToString.ts
function predicateToString(predicateDescriptor) {
  const operandList = predicateDescriptor.operands.map(operandToString).join(" ");
  return `(#${predicateDescriptor.operator} ${operandList})`;
}
function operandToString(value) {
  return value.type === "capture" ? `@${value.name}` : value.value;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/constructZodErrorMessages.ts
function constructZodErrorMessages(inputOperands, error48) {
  return error48.issues.filter(
    // If the user has supplied a capture instead of a string, or vice versa,
    // we'll get two issues instead of one; we prefer to show the more helpful
    // one.
    (issue2) => !(issue2.code === "invalid_type" && issue2.path.length === 2 && (issue2.path[1] === "name" || issue2.path[1] === "value"))
  ).map((issue2) => getErrorMessage(inputOperands, issue2));
}
function getErrorMessage(inputOperands, issue2) {
  if (issue2.path.length === 0) {
    if (issue2.code === "too_small") {
      return "Too few arguments";
    } else if (issue2.code === "too_big") {
      return "Too many arguments";
    }
    return issue2.message;
  }
  const argIndex = issue2.path[0];
  if (argIndex >= inputOperands.length) {
    return "Too few arguments";
  }
  let message = issue2.message;
  if (issue2.code === "invalid_value" && issue2.path[1] === "type") {
    message = issue2.values[0] === "capture" ? "Capture names must be prefixed with @" : "Expected string, but received capture";
  }
  const operandString = operandToString(inputOperands[argIndex]);
  return `Error on argument ${argIndex} (\`${operandString}\`): ${message}`;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/QueryPredicateOperator.ts
var QueryPredicateOperator = class {
  /**
   * Whether it is ok for a node argument to be missing.  If true, then the
   * operator will just accept the pattern if the given node is missing.  If
   * false, then the operator will throw an error if the node is missing.
   *
   * This is useful if we want to set some flag on a node, but only if it's
   * present.
   *
   * @returns A boolean indicating whether it is ok for a node argument to be
   * missing.
   */
  allowMissingNode() {
    return false;
  }
  /**
   * Given a list of operands, return a predicate function that can be used to
   * test whether a given match satisfies the predicate.
   *
   * @param inputOperands The operands to the operator, as returned directly
   * from tree-sitter when parse the query file.
   * @returns Either a predicate function, or a list of error messages if the operands
   * were invalid.
   */
  createPredicate(inputOperands) {
    const result = this.schema.safeParse(inputOperands);
    return result.success ? {
      success: true,
      predicate: (match) => {
        try {
          const acceptArgs = this.constructAcceptArgs(result.data, match);
          return this.run(...acceptArgs);
        } catch (err2) {
          if (err2 instanceof CaptureNotFoundError && this.allowMissingNode()) {
            return true;
          }
          throw err2;
        }
      }
    } : {
      success: false,
      errors: constructZodErrorMessages(inputOperands, result.error)
    };
  }
  /**
   * Given the output of the schema and a match, construct the arguments to pass
   * to the `accept` function.
   * @param rawOutput The output of the schema.
   * @param match The match to use to convert captures to nodes.
   * @returns The arguments to pass to the `accept` function.
   */
  constructAcceptArgs(rawOutput, match) {
    return rawOutput.map((operand) => {
      if (operand.type === "capture") {
        const capture = match.captures.find(
          (capture2) => capture2.name === operand.name
        );
        if (capture == null) {
          throw new CaptureNotFoundError(operand.name);
        }
        return capture;
      } else {
        return operand.value;
      }
    });
  }
};
var CaptureNotFoundError = class extends Error {
  constructor(operandName) {
    super(`Could not find capture ${operandName}`);
  }
};

// ../cursorless-engine/src/languages/TreeSitterQuery/setRange.ts
function setRange(capture, range3) {
  capture.range = range3;
  capture.node = void 0;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/queryPredicateOperators.ts
var Even = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "even?");
    __publicField(this, "schema", external_exports.tuple([q.node, q.string]));
  }
  run(capture, fieldName) {
    return isEven(getNode(capture), fieldName);
  }
};
var Odd = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "odd?");
    __publicField(this, "schema", external_exports.tuple([q.node, q.string]));
  }
  run(capture, fieldName) {
    return !isEven(getNode(capture), fieldName);
  }
};
var Text = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "text?");
    __publicField(this, "schema", external_exports.tuple([q.node, q.string]).rest(q.string));
  }
  run(capture, ...texts) {
    return texts.includes(getNode(capture).text);
  }
};
var Type2 = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "type?");
    __publicField(this, "schema", external_exports.tuple([q.node, q.string]).rest(q.string));
  }
  run(capture, ...types) {
    return types.includes(getNode(capture).type);
  }
};
var NotType = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "not-type?");
    __publicField(this, "schema", external_exports.tuple([q.node, q.string]).rest(q.string));
  }
  run(capture, ...types) {
    return !types.includes(getNode(capture).type);
  }
};
var NotParentType = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "not-parent-type?");
    __publicField(this, "schema", external_exports.tuple([q.node, q.string]).rest(q.string));
  }
  run(capture, ...types) {
    const node = getNode(capture);
    return node.parent == null || !types.includes(node.parent.type);
  }
};
var IsNthChild = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "is-nth-child?");
    __publicField(this, "schema", external_exports.tuple([q.node, q.integer]));
  }
  run(capture, n) {
    const node = getNode(capture);
    return node.parent?.children.findIndex((n2) => n2.id === node.id) === n;
  }
};
var HasMultipleChildrenOfType = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "has-multiple-children-of-type?");
    __publicField(this, "schema", external_exports.tuple([q.node, q.string]));
  }
  run(capture, type2) {
    const count2 = getNode(capture).children.filter(
      (n) => n.type === type2
    ).length;
    return count2 > 1;
  }
};
var ChildRange = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "child-range!");
    __publicField(this, "schema", external_exports.union([
      external_exports.tuple([q.node, q.integer]),
      external_exports.tuple([q.node, q.integer, q.integer]),
      external_exports.tuple([q.node, q.integer, q.integer, q.boolean]),
      external_exports.tuple([q.node, q.integer, q.integer, q.boolean, q.boolean])
    ]));
  }
  run(capture, startIndex, endIndex, excludeStart, excludeEnd) {
    const children = getNode(capture).children;
    startIndex = startIndex < 0 ? children.length + startIndex : startIndex;
    endIndex = endIndex == null ? -1 : endIndex;
    endIndex = endIndex < 0 ? children.length + endIndex : endIndex;
    const start2 = children[startIndex];
    const end = children[endIndex];
    setRange(
      capture,
      makeRangeFromPositions(
        excludeStart ? start2.endPosition : start2.startPosition,
        excludeEnd ? end.startPosition : end.endPosition
      )
    );
    return true;
  }
};
var CharacterRange = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "character-range!");
    __publicField(this, "schema", external_exports.union([
      external_exports.tuple([q.node, q.integer]),
      external_exports.tuple([q.node, q.integer, q.integer])
    ]));
  }
  run(capture, startOffset, endOffset) {
    setRange(
      capture,
      new Range(
        capture.range.start.translate(void 0, startOffset),
        capture.range.end.translate(void 0, endOffset ?? 0)
      )
    );
    return true;
  }
};
var ShrinkToMatch = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "shrink-to-match!");
    __publicField(this, "schema", external_exports.tuple([q.node, q.string]));
  }
  run(capture, pattern) {
    const { document: document2, range: range3 } = capture;
    const text = getNode(capture).text;
    const match = text.match(new RegExp(pattern, "ds"));
    if (match?.index == null) {
      throw Error(`No match for pattern '${pattern}'`);
    }
    const [startOffset, endOffset] = match.indices?.groups?.keep ?? match.indices[0];
    const baseOffset = document2.offsetAt(range3.start);
    setRange(
      capture,
      new Range(
        document2.positionAt(baseOffset + startOffset),
        document2.positionAt(baseOffset + endOffset)
      )
    );
    return true;
  }
};
var GrowToNamedSiblings = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "grow-to-named-siblings!");
    __publicField(this, "schema", external_exports.union([external_exports.tuple([q.node]), external_exports.tuple([q.node, q.string])]));
  }
  run(capture, notText) {
    const node = getNode(capture);
    if (node.parent == null) {
      throw Error("Node has no parent");
    }
    const { children } = node.parent;
    const nodeIndex = children.findIndex((n) => n.id === node.id);
    let endPosition;
    if (nodeIndex === -1) {
      throw Error("Node not found in parent");
    }
    for (let i2 = nodeIndex + 1; i2 < children.length; ++i2) {
      const child = children[i2];
      if (!child.isNamed) {
        break;
      }
      if (notText != null && notText === child.text) {
        break;
      }
      endPosition = child.endPosition;
    }
    if (endPosition != null) {
      setRange(
        capture,
        new Range(
          capture.range.start,
          new Position(endPosition.row, endPosition.column)
        )
      );
    }
    return true;
  }
};
var TrimEnd = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "trim-end!");
    __publicField(this, "schema", external_exports.tuple([q.node]).rest(q.node));
  }
  run(...captures) {
    for (const capture of captures) {
      const { document: document2, range: range3 } = capture;
      const text = getNode(capture).text;
      const whitespaceLength = text.length - text.trimEnd().length;
      if (whitespaceLength > 0) {
        setRange(
          capture,
          new Range(
            range3.start,
            adjustPosition(document2, range3.end, -whitespaceLength)
          )
        );
      }
    }
    return true;
  }
};
var DocumentRange = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "document-range!");
    __publicField(this, "schema", external_exports.tuple([q.node]).rest(q.node));
  }
  run(...captures) {
    for (const capture of captures) {
      setRange(capture, capture.document.range);
    }
    return true;
  }
};
var AllowMultiple = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "allow-multiple!");
    __publicField(this, "schema", external_exports.tuple([q.node]).rest(q.node));
  }
  allowMissingNode() {
    return true;
  }
  run(...captures) {
    for (const capture of captures) {
      capture.allowMultiple = true;
    }
    return true;
  }
};
var InsertionDelimiter = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "insertion-delimiter!");
    __publicField(this, "schema", external_exports.tuple([q.node, q.string]));
  }
  run(capture, insertionDelimiter) {
    capture.insertionDelimiter = insertionDelimiter;
    return true;
  }
};
var SingleOrMultilineDelimiter = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "single-or-multi-line-delimiter!");
    __publicField(this, "schema", external_exports.tuple([q.node, q.node, q.string, q.string]));
  }
  run(capture, conditionCapture, insertionDelimiterConsequence, insertionDelimiterAlternative) {
    capture.insertionDelimiter = conditionCapture.range.isSingleLine ? insertionDelimiterConsequence : insertionDelimiterAlternative;
    return true;
  }
};
var EmptySingleMultiDelimiter = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "empty-single-multi-delimiter!");
    __publicField(this, "schema", external_exports.tuple([q.node, q.node, q.string, q.string, q.string]));
  }
  run(capture, conditionCapture, insertionDelimiterEmpty, insertionDelimiterSingleLine, insertionDelimiterMultiline) {
    const isEmpty = !getNode(conditionCapture).children.some(
      (child) => child.isNamed
    );
    capture.insertionDelimiter = isEmpty ? insertionDelimiterEmpty : conditionCapture.range.isSingleLine ? insertionDelimiterSingleLine : insertionDelimiterMultiline;
    return true;
  }
};
var queryPredicateOperators = [
  new Even(),
  new Odd(),
  new Text(),
  new Type2(),
  new NotType(),
  new TrimEnd(),
  new DocumentRange(),
  new NotParentType(),
  new IsNthChild(),
  new ChildRange(),
  new CharacterRange(),
  new ShrinkToMatch(),
  new GrowToNamedSiblings(),
  new AllowMultiple(),
  new InsertionDelimiter(),
  new SingleOrMultilineDelimiter(),
  new EmptySingleMultiDelimiter(),
  new HasMultipleChildrenOfType()
];

// ../cursorless-engine/src/languages/TreeSitterQuery/parsePredicates.ts
function parsePredicates(predicateDescriptors) {
  const errors2 = [];
  const predicates = [];
  predicateDescriptors.forEach((patternPredicateDescriptors, patternIdx) => {
    const patternPredicates = [];
    patternPredicateDescriptors.forEach((predicateDescriptor, predicateIdx) => {
      const operator = queryPredicateOperators.find(
        ({ name: name2 }) => name2 === predicateDescriptor.operator
      );
      if (operator == null) {
        errors2.push({
          patternIdx,
          predicateIdx,
          error: `Unknown predicate operator "${predicateDescriptor.operator}"`
        });
        return;
      }
      const result = operator.createPredicate(predicateDescriptor.operands);
      if (!result.success) {
        errors2.push(
          ...result.errors.map((error48) => ({
            patternIdx,
            predicateIdx,
            error: error48
          }))
        );
        return;
      }
      patternPredicates.push(result.predicate);
    });
    predicates.push(patternPredicates);
  });
  return { errors: errors2, predicates };
}

// ../cursorless-engine/src/languages/TreeSitterQuery/parsePredicatesWithErrorHandling.ts
function parsePredicatesWithErrorHandling(languageId, query) {
  const { errors: errors2, predicates } = parsePredicates(query.predicates);
  if (errors2.length > 0) {
    for (const error48 of errors2) {
      const context = [
        `language ${languageId}`,
        `pattern ${error48.patternIdx}`,
        `predicate \`${predicateToString(
          query.predicates[error48.patternIdx][error48.predicateIdx]
        )}\``
      ].join(", ");
      void showError(
        ide().messages,
        "TreeSitterQuery.parsePredicates",
        `Error parsing predicate for ${context}: ${error48.error}`
      );
    }
    if (ide().runMode === "test") {
      throw new Error("Invalid predicates");
    }
  }
  return predicates;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/positionToPoint.ts
function positionToPoint(start2) {
  return { row: start2.line, column: start2.character };
}

// ../cursorless-engine/src/languages/TreeSitterQuery/rewriteStartOfEndOf.ts
function rewriteStartOfEndOf(captures) {
  return captures.map((capture) => ({
    ...capture,
    range: getStartOfEndOfRange(capture),
    name: getStartOfEndOfName(capture)
  }));
}
function getStartOfEndOfRange(capture) {
  if (capture.name.endsWith(".startOf")) {
    return capture.range.start.toEmptyRange();
  }
  if (capture.name.endsWith(".endOf")) {
    return capture.range.end.toEmptyRange();
  }
  return capture.range;
}
function getStartOfEndOfName(capture) {
  if (capture.name.endsWith(".startOf")) {
    return capture.name.slice(0, -8);
  }
  if (capture.name.endsWith(".endOf")) {
    return capture.name.slice(0, -6);
  }
  return capture.name;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/TreeSitterQueryCache.ts
var TreeSitterQueryCache = class {
  constructor() {
    __publicField(this, "documentVersion", -1);
    __publicField(this, "documentUri", "");
    __publicField(this, "documentLanguageId", "");
    __publicField(this, "startPosition");
    __publicField(this, "endPosition");
    __publicField(this, "matches", []);
  }
  clear() {
    this.documentUri = "";
    this.documentVersion = -1;
    this.documentLanguageId = "";
    this.startPosition = void 0;
    this.endPosition = void 0;
    this.matches = [];
  }
  isValid(document2, startPosition, endPosition) {
    return this.documentVersion === document2.version && this.documentUri === document2.uri.toString() && this.documentLanguageId === document2.languageId && positionsEqual(this.startPosition, startPosition) && positionsEqual(this.endPosition, endPosition);
  }
  update(document2, startPosition, endPosition, matches) {
    this.documentVersion = document2.version;
    this.documentUri = document2.uri.toString();
    this.documentLanguageId = document2.languageId;
    this.startPosition = startPosition;
    this.endPosition = endPosition;
    this.matches = matches;
  }
  get() {
    return this.matches;
  }
};
function positionsEqual(a, b) {
  if (a == null || b == null) {
    return a === b;
  }
  return a.isEqual(b);
}
var treeSitterQueryCache = new TreeSitterQueryCache();

// ../cursorless-engine/src/languages/TreeSitterQuery/TreeSitterQuery.ts
var TreeSitterQuery = class _TreeSitterQuery {
  constructor(treeSitter, query, patternPredicates) {
    this.treeSitter = treeSitter;
    this.query = query;
    this.patternPredicates = patternPredicates;
    __publicField(this, "shouldCheckCaptures");
    this.shouldCheckCaptures = ide().runMode !== "production";
  }
  static create(languageId, treeSitter, query) {
    const predicates = parsePredicatesWithErrorHandling(languageId, query);
    return new _TreeSitterQuery(treeSitter, query, predicates);
  }
  hasCapture(name2) {
    return this.query.captureNames.some(
      (n) => normalizeCaptureName(n) === name2
    );
  }
  matches(document2, start2, end) {
    if (!treeSitterQueryCache.isValid(document2, start2, end)) {
      const matches = this.getAllMatches(document2, start2, end);
      treeSitterQueryCache.update(document2, start2, end, matches);
    }
    return treeSitterQueryCache.get();
  }
  getAllMatches(document2, start2, end) {
    const matches = this.getTreeMatches(document2, start2, end);
    const results = [];
    for (const match of matches) {
      const mutableMatch = this.createMutableQueryMatch(document2, match);
      if (!this.runPredicates(mutableMatch)) {
        continue;
      }
      results.push(this.createQueryMatch(mutableMatch));
    }
    return results;
  }
  getTreeMatches(document2, start2, end) {
    const { rootNode } = this.treeSitter.getTree(document2);
    return this.query.matches(rootNode, {
      startPosition: start2 != null ? positionToPoint(start2) : void 0,
      endPosition: end != null ? positionToPoint(end) : void 0
    });
  }
  createMutableQueryMatch(document2, match) {
    return {
      patternIdx: match.patternIndex,
      captures: match.captures.map(({ name: name2, node }) => ({
        name: name2,
        node,
        document: document2,
        range: getNodeRange(node),
        insertionDelimiter: void 0,
        allowMultiple: false,
        hasError: () => isContainedInErrorNode(node)
      }))
    };
  }
  runPredicates(match) {
    for (const predicate of this.patternPredicates[match.patternIdx]) {
      if (!predicate(match)) {
        return false;
      }
    }
    return true;
  }
  createQueryMatch(match) {
    const result = [];
    const map4 = /* @__PURE__ */ new Map();
    for (const capture of match.captures) {
      const name2 = normalizeCaptureName(capture.name);
      const range3 = getStartOfEndOfRange(capture);
      const existing = map4.get(name2);
      if (existing == null) {
        const captures = [capture];
        const acc = {
          ...capture,
          name: name2,
          range: range3,
          hasError: () => captures.some((c) => c.hasError())
        };
        result.push(acc);
        map4.set(name2, { acc, captures });
      } else {
        existing.acc.range = existing.acc.range.union(range3);
        existing.acc.allowMultiple = existing.acc.allowMultiple || capture.allowMultiple;
        existing.acc.insertionDelimiter = existing.acc.insertionDelimiter ?? capture.insertionDelimiter;
        existing.captures.push(capture);
      }
    }
    if (this.shouldCheckCaptures) {
      this.checkCaptures(Array.from(map4.values()));
    }
    return { captures: result };
  }
  checkCaptures(matches) {
    for (const match of matches) {
      const capturesAreValid = checkCaptureStartEnd(
        rewriteStartOfEndOf(match.captures),
        ide().messages
      );
      if (!capturesAreValid && ide().runMode === "test") {
        throw new Error("Invalid captures");
      }
    }
  }
};

// ../cursorless-engine/src/languages/TreeSitterQuery/validateQueryCaptures.ts
var wildcard = "_";
var captureNames = [
  ...simpleScopeTypeTypes.filter((s) => !pseudoScopes.has(s)),
  wildcard,
  "interior"
];
var positionRelationships = ["prefix", "leading", "trailing"];
var positionSuffixes = [
  "startOf",
  "endOf",
  "start.startOf",
  "start.endOf",
  "end.startOf",
  "end.endOf"
];
var rangeRelationships = [
  "domain",
  "removal",
  "iteration",
  "iteration.domain"
];
var rangeSuffixes = [
  "start",
  "end",
  "start.startOf",
  "start.endOf",
  "end.startOf",
  "end.endOf"
];
var allowedCaptures = /* @__PURE__ */ new Set();
for (const captureName of captureNames) {
  if (captureName !== wildcard) {
    allowedCaptures.add(captureName);
    for (const suffix of rangeSuffixes) {
      allowedCaptures.add(`${captureName}.${suffix}`);
    }
  }
  for (const relationship of positionRelationships) {
    allowedCaptures.add(`${captureName}.${relationship}`);
    for (const suffix of positionSuffixes) {
      allowedCaptures.add(`${captureName}.${relationship}.${suffix}`);
    }
  }
  for (const relationship of rangeRelationships) {
    allowedCaptures.add(`${captureName}.${relationship}`);
    for (const suffix of rangeSuffixes) {
      allowedCaptures.add(`${captureName}.${relationship}.${suffix}`);
    }
  }
}
var capturePattern = /^(?!;;).*(?<!"\w*)@([\w.]*)/gm;
function validateQueryCaptures(file2, rawQuery) {
  const matches = rawQuery.matchAll(capturePattern);
  const errors2 = [];
  for (const match of matches) {
    const captureName = match[1];
    if (captureName.length > 1 && !captureName.includes(".") && captureName.startsWith("_")) {
      continue;
    }
    if (!allowedCaptures.has(captureName)) {
      const lineNumber = match.input.slice(0, match.index).split("\n").length;
      errors2.push(`${file2}(${lineNumber}) invalid capture '@${captureName}'.`);
    }
  }
  if (errors2.length === 0) {
    return;
  }
  const message = errors2.join("\n");
  void showError(
    ide().messages,
    "validateQueryCaptures.invalidCaptureName",
    message
  );
  if (ide().runMode === "test") {
    throw new Error(message);
  }
}

// ../cursorless-engine/src/languages/LanguageDefinition.ts
var LanguageDefinition = class _LanguageDefinition {
  constructor(query) {
    this.query = query;
  }
  /**
   * Construct a language definition for the given language id, if the language
   * has a new-style query definition, or return undefined if the language doesn't
   *
   * @param treeSitter The tree-sitter instance to use for parsing
   * @param languageId The language id for which to create a language definition
   * @returns A language definition for the given language id, or undefined if the given language
   * id doesn't have a new-style query definition
   */
  static async create(ide2, treeSitterQueryProvider, treeSitter, languageId) {
    const rawLanguageQueryString = await readQueryFileAndImports(
      ide2,
      treeSitterQueryProvider,
      `${languageId}.scm`
    );
    if (rawLanguageQueryString == null) {
      return void 0;
    }
    if (!await treeSitter.loadLanguage(languageId)) {
      return void 0;
    }
    const rawQuery = treeSitter.createQuery(languageId, rawLanguageQueryString);
    if (rawQuery == null) {
      throw Error(
        `Could not create Tree sitter query for language ${languageId}`
      );
    }
    const query = TreeSitterQuery.create(languageId, treeSitter, rawQuery);
    return new _LanguageDefinition(query);
  }
  /**
   * @param scopeType The scope type for which to get a scope handler
   * @returns A scope handler for the given scope type and language id, or
   * undefined if the given scope type is not supported by this language.
   */
  getScopeHandler(scopeType) {
    if (!this.query.hasCapture(scopeType.type)) {
      return void 0;
    }
    return new TreeSitterScopeHandler(this.query, scopeType);
  }
  /**
   * This is a low-level function that just returns a map of all captures in the
   * document. We use this in our surrounding pair code.
   *
   * @param document The document to search
   * @param captureName The name of a capture to search for
   * @returns A map of captures in the document
   */
  getCapturesMap(document2) {
    const matches = this.query.matches(document2);
    const result = {};
    for (const match of matches) {
      for (const capture of match.captures) {
        const name2 = capture.name;
        if (result[name2] == null) {
          result[name2] = [];
        }
        result[name2].push(capture);
      }
    }
    return result;
  }
};
async function readQueryFileAndImports(ide2, provider, languageQueryName) {
  const rawQueryStrings = {
    [languageQueryName]: null
  };
  const doValidation = ide2.runMode !== "production";
  while (Object.values(rawQueryStrings).some((v) => v == null)) {
    for (const [queryName, rawQueryString] of Object.entries(rawQueryStrings)) {
      if (rawQueryString != null) {
        continue;
      }
      let rawQuery = await provider.readQuery(queryName);
      if (rawQuery == null) {
        if (queryName === languageQueryName) {
          return void 0;
        }
        void showError(
          ide2.messages,
          "LanguageDefinition.readQueryFileAndImports.queryNotFound",
          `Could not find imported query file ${queryName}`
        );
        if (ide2.runMode === "test") {
          throw new Error("Invalid import statement");
        }
        rawQuery = "";
      }
      if (doValidation) {
        validateQueryCaptures(queryName, rawQuery);
      }
      rawQueryStrings[queryName] = rawQuery;
      matchAll(
        rawQuery,
        // Matches lines like:
        //
        // ;; import path/to/query.scm
        //
        // but is very lenient about whitespace and quotes, and also allows
        // include instead of import, so that we can throw a nice error message
        // if the developer uses the wrong syntax
        /^[^\S\r\n]*;;?[^\S\r\n]*(?:import|include)[^\S\r\n]+['"]?([\w|/\\.]+)['"]?[^\S\r\n]*$/gm,
        (match) => {
          const importName = match[1];
          if (doValidation) {
            validateImportSyntax(ide2, queryName, importName, match[0]);
          }
          rawQueryStrings[importName] = rawQueryStrings[importName] ?? null;
        }
      );
    }
  }
  return Object.values(rawQueryStrings).join("\n");
}
function validateImportSyntax(ide2, file2, importName, actual) {
  let isError = false;
  if (/[/\\]/g.test(importName)) {
    void showError(
      ide2.messages,
      "LanguageDefinition.readQueryFileAndImports.invalidImport",
      `Invalid import statement in ${file2}: "${actual}". Relative import paths not supported`
    );
    isError = true;
  }
  const canonicalSyntax = `;; import ${importName}`;
  if (actual !== canonicalSyntax) {
    void showError(
      ide2.messages,
      "LanguageDefinition.readQueryFileAndImports.malformedImport",
      `Malformed import statement in ${file2}: "${actual}". Import statements must be of the form "${canonicalSyntax}"`
    );
    isError = true;
  }
  if (isError && ide2.runMode === "test") {
    throw new Error("Invalid import statement");
  }
}

// ../cursorless-engine/src/languages/LanguageDefinitions.ts
var LANGUAGE_UNDEFINED = /* @__PURE__ */ Symbol("LANGUAGE_UNDEFINED");
var LanguageDefinitionsImpl = class _LanguageDefinitionsImpl {
  constructor(ide2, treeSitter, treeSitterQueryProvider) {
    this.ide = ide2;
    this.treeSitter = treeSitter;
    this.treeSitterQueryProvider = treeSitterQueryProvider;
    __publicField(this, "notifier", new Notifier());
    /**
     * Maps from language id to {@link LanguageDefinition} or
     * {@link LANGUAGE_UNDEFINED} if language doesn't have new-style definitions.
     * We use a sentinel value instead of undefined so that we can distinguish
     * between a situation where we haven't yet checked whether a language has a
     * new-style query definition and a situation where we've checked and found
     * that it doesn't.  The former case is represented by `undefined` (due to the
     * semantics of {@link Map.get}), while the latter is represented by the
     * sentinel value.
     */
    __publicField(this, "languageDefinitions", /* @__PURE__ */ new Map());
    __publicField(this, "disposables", []);
    __publicField(this, "onDidChangeDefinition", this.notifier.registerListener);
    const isTesting = ide2.runMode === "test";
    this.disposables.push(
      ide2.onDidOpenTextDocument((document2) => {
        if (isTesting) {
          treeSitterQueryCache.clear();
        }
        void this.loadLanguage(document2.languageId);
      }),
      ide2.onDidChangeVisibleTextEditors((editors) => {
        editors.forEach(
          ({ document: document2 }) => void this.loadLanguage(document2.languageId)
        );
      }),
      treeSitterQueryProvider.onChanges(() => this.reloadLanguageDefinitions())
    );
  }
  static async create(ide2, treeSitter, treeSitterQueryProvider) {
    const instance2 = new _LanguageDefinitionsImpl(
      ide2,
      treeSitter,
      treeSitterQueryProvider
    );
    await instance2.loadAllLanguages();
    return instance2;
  }
  async loadAllLanguages() {
    const languageIds = this.ide.visibleTextEditors.map(
      ({ document: document2 }) => document2.languageId
    );
    try {
      await Promise.all(
        languageIds.map((languageId) => this.loadLanguage(languageId))
      );
    } catch (err2) {
      void showError(
        this.ide.messages,
        "Failed to load language definitions",
        toString_default(err2)
      );
      if (this.ide.runMode === "test") {
        throw err2;
      }
    }
  }
  async loadLanguage(languageId) {
    if (this.languageDefinitions.has(languageId)) {
      return;
    }
    const definition = await LanguageDefinition.create(
      this.ide,
      this.treeSitterQueryProvider,
      this.treeSitter,
      languageId
    ) ?? LANGUAGE_UNDEFINED;
    this.languageDefinitions.set(languageId, definition);
  }
  async reloadLanguageDefinitions() {
    this.languageDefinitions.clear();
    await this.loadAllLanguages();
    treeSitterQueryCache.clear();
    this.notifier.notifyListeners();
  }
  get(languageId) {
    const definition = this.languageDefinitions.get(languageId);
    if (definition == null) {
      throw new Error(
        "Expected language definition entry is missing for languageId " + languageId
      );
    }
    return definition === LANGUAGE_UNDEFINED ? void 0 : definition;
  }
  dispose() {
    this.disposables.forEach((disposable) => disposable.dispose());
  }
};

// ../cursorless-engine/src/processTargets/modifiers/ConditionalModifierStages.ts
var ConditionalModifierBaseStage = class {
  constructor(modifierStageFactory, nestedModifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.nestedModifier = nestedModifier;
    __publicField(this, "nestedStage_");
    __publicField(this, "suppressErrors", false);
  }
  run(target, options2) {
    if (this.shouldModify(target)) {
      try {
        return this.nestedStage.run(target, options2).map((newTarget) => newTarget.withThatTarget(target));
      } catch (ex) {
        if (!this.suppressErrors) {
          throw ex;
        }
      }
    }
    return [target];
  }
  get nestedStage() {
    if (this.nestedStage_ == null) {
      this.nestedStage_ = this.modifierStageFactory.create(this.nestedModifier);
    }
    return this.nestedStage_;
  }
};
var ModifyIfUntypedStage = class extends ConditionalModifierBaseStage {
  constructor(modifierStageFactory, modifier) {
    super(modifierStageFactory, modifier.modifier);
  }
  shouldModify(target) {
    return !target.hasExplicitScopeType;
  }
};
var ModifyIfConditionStage = class extends ConditionalModifierBaseStage {
  constructor(modifierStageFactory, nestedModifier, modificationCondition) {
    super(modifierStageFactory, nestedModifier);
    this.modificationCondition = modificationCondition;
  }
  shouldModify(target) {
    return this.modificationCondition(target);
  }
};
var ModifyIfUntypedExplicitStage = class extends ConditionalModifierBaseStage {
  shouldModify(target) {
    return !target.hasExplicitScopeType && !target.isImplicit;
  }
};
var ContainingTokenIfUntypedEmptyStage = class extends ConditionalModifierBaseStage {
  constructor(modifierStageFactory) {
    super(modifierStageFactory, {
      type: "containingScope",
      scopeType: { type: "token" }
    });
    __publicField(this, "suppressErrors", true);
  }
  shouldModify(target) {
    return !target.hasExplicitScopeType && !target.hasExplicitRange && target.contentRange.isEmpty;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/BoundaryStage.ts
var ExcludeInteriorStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
    __publicField(this, "containingSurroundingPairIfNoBoundaryStage");
    this.containingSurroundingPairIfNoBoundaryStage = getContainingSurroundingPairIfNoBoundaryStage(this.modifierStageFactory);
  }
  run(target, options2) {
    return this.containingSurroundingPairIfNoBoundaryStage.run(target, options2).flatMap((target2) => target2.getBoundary());
  }
};
function getContainingSurroundingPairIfNoBoundaryStage(modifierStageFactory) {
  return new ModifyIfConditionStage(
    modifierStageFactory,
    {
      type: "containingScope",
      scopeType: { type: "surroundingPair", delimiter: "any" }
    },
    (target) => target.getBoundary() == null
  );
}

// ../cursorless-engine/src/processTargets/modifiers/ClassFunctionNameStage.ts
var ClassFunctionNameStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  static use(scopeType) {
    return scopeType.type === "className" || scopeType.type === "functionName";
  }
  run(target, options2) {
    const stage1 = this.modifierStageFactory.create({
      ...this.modifier,
      scopeType: {
        type: getScopeTypeType(this.modifier.scopeType)
      }
    });
    const stage2 = this.modifierStageFactory.create({
      type: "containingScope",
      scopeType: {
        type: "name"
      }
    });
    return stage1.run(target, options2).flatMap((t) => stage2.run(t, options2));
  }
};
function getScopeTypeType(scopeType) {
  if (scopeType.type === "className") {
    return "class";
  }
  if (scopeType.type === "functionName") {
    return "namedFunction";
  }
  throw new Error(`Unsupported scope type: ${scopeType.type}`);
}

// ../cursorless-engine/src/util/typeUtils.ts
function isSameType(a, b) {
  return Object.getPrototypeOf(a).constructor === Object.getPrototypeOf(b).constructor;
}

// ../cursorless-engine/src/processTargets/createContinuousRangeTarget.ts
function createContinuousRangeTarget(isReversed, startTarget, endTarget, includeStart, includeEnd) {
  if (startTarget.editor !== endTarget.editor) {
    throw Error("Continuous targets must be in the same editor");
  }
  if (includeStart && includeEnd && isSameType(startTarget, endTarget)) {
    const richTarget = startTarget.maybeCreateRichRangeTarget(
      isReversed,
      endTarget
    );
    if (richTarget != null) {
      return richTarget;
    }
  }
  if (startTarget.textualType === "line" && endTarget.textualType === "line") {
    return new LineTarget({
      editor: startTarget.editor,
      isReversed,
      contentRange: createContinuousLineRange(
        startTarget,
        endTarget,
        includeStart,
        includeEnd
      )
    });
  }
  return new UntypedTarget({
    editor: startTarget.editor,
    isReversed,
    hasExplicitRange: true,
    contentRange: createContinuousRange(
      startTarget,
      endTarget,
      includeStart,
      includeEnd
    ),
    textualType: includeStart && includeEnd && startTarget.textualType === "token" && endTarget.textualType === "token" ? "token" : "character"
  });
}

// ../cursorless-engine/src/processTargets/modifiers/constructScopeRangeTarget.ts
function constructScopeRangeTarget(isReversed, scope1, scope2) {
  if (scope1 === scope2) {
    return scope1.getTargets(isReversed);
  }
  const targets1 = scope1.getTargets(isReversed);
  const targets2 = scope2.getTargets(isReversed);
  if (targets1.length !== 1 || targets2.length !== 1) {
    throw Error("Scope range targets must be single-target");
  }
  const [target1] = targets1;
  const [target2] = targets2;
  const isScope2After = target2.contentRange.start.isAfterOrEqual(
    target1.contentRange.start
  );
  const [startTarget, endTarget] = isScope2After ? [target1, target2] : [target2, target1];
  return [
    createContinuousRangeTarget(isReversed, startTarget, endTarget, true, true)
  ];
}

// ../cursorless-engine/src/processTargets/modifiers/getPreferredScopeTouchingPosition.ts
function getPreferredScopeTouchingPosition(scopeHandler, editor, position, forceDirection) {
  const candidates = Array.from(
    scopeHandler.generateScopes(editor, position, "forward", {
      containment: "required",
      allowAdjacentScopes: true,
      skipAncestorScopes: true
    })
  );
  switch (candidates.length) {
    case 0:
      return void 0;
    case 1:
      return candidates[0];
    case 2: {
      const [backwardScope, forwardScope] = candidates;
      if (forceDirection === "forward") {
        return forwardScope;
      }
      if (forceDirection === "backward") {
        return backwardScope;
      }
      if (scopeHandler.isPreferredOver?.(backwardScope, forwardScope) ?? false) {
        return backwardScope;
      }
      return forwardScope;
    }
    default:
      throw new Error("Expected no more than 2 scope candidates");
  }
}

// ../cursorless-engine/src/processTargets/modifiers/getContainingScopeTarget.ts
function getContainingScopeTarget(target, scopeHandler, ancestorIndex = 0) {
  const {
    isReversed,
    editor,
    contentRange: { start: start2, end }
  } = target;
  if (end.isEqual(start2)) {
    let scope = getPreferredScopeTouchingPosition(scopeHandler, editor, start2);
    if (scope == null) {
      return void 0;
    }
    if (ancestorIndex > 0) {
      scope = expandFromPosition(
        scopeHandler,
        editor,
        scope.domain.end,
        "forward",
        ancestorIndex,
        true
      );
    }
    if (scope == null) {
      return void 0;
    }
    return scope.getTargets(isReversed);
  }
  const startScope = expandFromPosition(
    scopeHandler,
    editor,
    start2,
    "forward",
    ancestorIndex
  );
  if (startScope == null) {
    return void 0;
  }
  if (startScope.domain.contains(end)) {
    return startScope.getTargets(isReversed);
  }
  const endScope = expandFromPosition(
    scopeHandler,
    editor,
    end,
    "backward",
    ancestorIndex
  );
  if (endScope == null) {
    return void 0;
  }
  return constructScopeRangeTarget(isReversed, startScope, endScope);
}
function expandFromPosition(scopeHandler, editor, position, direction2, ancestorIndex, allowAdjacentScopes = false) {
  let nextAncestorIndex = 0;
  for (const scope of scopeHandler.generateScopes(editor, position, direction2, {
    containment: "required",
    allowAdjacentScopes
  })) {
    if (nextAncestorIndex === ancestorIndex) {
      return scope;
    }
    nextAncestorIndex += 1;
  }
  return void 0;
}

// ../cursorless-engine/src/processTargets/modifiers/ContainingScopeStage.ts
var ContainingScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target) {
    const { scopeType, ancestorIndex = 0 } = this.modifier;
    const scopeHandler = this.scopeHandlerFactory.create(
      scopeType,
      target.editor.document.languageId
    );
    const containingScopes = getContainingScopeTarget(
      target,
      scopeHandler,
      ancestorIndex
    );
    if (containingScopes == null) {
      throw new NoContainingScopeError(scopeType.type);
    }
    return containingScopes;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/EveryScopeStage.ts
var EveryScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const { scopeType } = this.modifier;
    const { editor, isReversed } = target;
    const scopeHandler = this.scopeHandlerFactory.create(
      scopeType,
      editor.document.languageId
    );
    let scopes;
    if (target.hasExplicitRange) {
      scopes = getScopesOverlappingRange(
        scopeHandler,
        editor,
        target.contentRange
      );
      if (scopes.length === 1 && scopes[0].domain.contains(target.contentRange) && !target.hasExplicitScopeType && !options2.multipleTargets) {
        scopes = void 0;
      }
    }
    if (scopes == null) {
      scopes = this.getDefaultIterationRange(
        scopeHandler,
        this.scopeHandlerFactory,
        target
      ).flatMap(
        (iterationRange) => getScopesOverlappingRange(scopeHandler, editor, iterationRange)
      );
    }
    if (scopes.length === 0) {
      throw new NoContainingScopeError(scopeType.type);
    }
    return scopes.flatMap((scope) => scope.getTargets(isReversed));
  }
  getDefaultIterationRange(scopeHandler, scopeHandlerFactory, target) {
    const iterationScopeHandler = scopeHandlerFactory.create(
      scopeHandler.iterationScopeType,
      target.editor.document.languageId
    );
    const iterationScopeTarget = getContainingScopeTarget(
      target,
      iterationScopeHandler
    );
    if (iterationScopeTarget == null) {
      throw new NoContainingScopeError(
        `iteration scope for ${scopeHandler.scopeType.type}`
      );
    }
    return iterationScopeTarget.map((target2) => target2.contentRange);
  }
};
function getScopesOverlappingRange(scopeHandler, editor, { start: start2, end }) {
  return Array.from(
    scopeHandler.generateScopes(editor, start2, "forward", {
      distalPosition: end,
      skipAncestorScopes: true,
      allowAdjacentScopes: scopeHandler.includeAdjacentInEvery
    })
  );
}

// ../cursorless-engine/src/processTargets/modifiers/FallbackStage.ts
var FallbackStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const stages = this.modifier.modifiers.map(
      this.modifierStageFactory.create
    );
    for (const stage of stages) {
      try {
        return stage.run(target, options2);
      } catch (_error) {
        continue;
      }
    }
    throw new Error("No modifier could be applied");
  }
};

// ../cursorless-engine/src/processTargets/modifiers/FilterStages.ts
var KeepContentFilterStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return target.contentText.trim() !== "" ? [target] : [];
  }
};
var KeepEmptyFilterStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return target.contentText.trim() === "" ? [target] : [];
  }
};

// ../cursorless-engine/src/processTargets/marks/ImplicitStage.ts
var ImplicitStage = class {
  run() {
    return getActiveSelections(ide()).map(
      (selection) => new ImplicitTarget({
        editor: selection.editor,
        isReversed: selection.selection.isReversed,
        contentRange: selection.selection
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/TargetPipelineRunner.ts
var TargetPipelineRunner = class {
  constructor(modifierStageFactory, markStageFactory) {
    this.modifierStageFactory = modifierStageFactory;
    this.markStageFactory = markStageFactory;
  }
  /**
   * Converts the abstract target descriptions provided by the user to a
   * concrete representation usable by actions. Conceptually, the input will be
   * something like "the function call argument containing the cursor" and the
   * output will be something like "line 3, characters 5 through 10".
   * @param target The abstract target representations provided by the user
   * @param actionFinalStages Modifier stages contributed by the action that
   * should run at the end of the modifier pipeline
   * @returns A list of lists of typed selections, one list per input target.
   * Each typed selection includes the selection, as well the uri of the
   * document containing it, and potentially rich context information such as
   * how to remove the target
   */
  run(target, {
    actionFinalStages = [],
    noAutomaticTokenExpansion = false,
    allowDuplicateTargets = false
  } = {}) {
    return new TargetPipeline(
      this.modifierStageFactory,
      this.markStageFactory,
      target,
      { actionFinalStages, noAutomaticTokenExpansion, allowDuplicateTargets }
    ).run();
  }
};
var TargetPipeline = class {
  constructor(modifierStageFactory, markStageFactory, target, opts) {
    this.modifierStageFactory = modifierStageFactory;
    this.markStageFactory = markStageFactory;
    this.target = target;
    this.opts = opts;
  }
  /**
   * Converts the abstract target descriptions provided by the user to a concrete
   * representation usable by actions. Conceptually, the input will be something
   * like "the function call argument containing the cursor" and the output will be something
   * like "line 3, characters 5 through 10".
   * @param context Captures the environment needed to convert the abstract target
   *    description given by the user to a concrete representation usable by
   *    actions
   * @param targets The abstract target representations provided by the user
   * @returns A list of lists of typed selections, one list per input target. Each
   * typed selection includes the selection, as well the uri of the document
   * containing it, and potentially rich context information such as how to remove
   * the target
   */
  run() {
    const targets = this.processTarget(this.target);
    return this.opts.allowDuplicateTargets ? targets : uniqTargets(targets);
  }
  processTarget(target) {
    switch (target.type) {
      case "list":
        return target.elements.flatMap(
          (element) => this.processTarget(element)
        );
      case "range":
        return this.processRangeTarget(target);
      case "primitive":
      case "implicit":
        return this.processPrimitiveTarget(target);
    }
  }
  processRangeTarget(targetDesc) {
    const anchorTargets = this.processPrimitiveTarget(targetDesc.anchor);
    const activeTargets = this.processPrimitiveTarget(targetDesc.active);
    return zip_default(anchorTargets, activeTargets).flatMap(
      ([anchorTarget, activeTarget]) => {
        if (anchorTarget == null || activeTarget == null) {
          throw new Error(
            "AnchorTargets and activeTargets lengths don't match"
          );
        }
        switch (targetDesc.rangeType) {
          case "continuous":
            return this.processContinuousRangeTarget(
              anchorTarget,
              activeTarget,
              targetDesc
            );
          case "vertical":
            return targetsToVerticalTarget(
              anchorTarget,
              activeTarget,
              targetDesc.excludeAnchor,
              targetDesc.excludeActive
            );
        }
      }
    );
  }
  processContinuousRangeTarget(anchorTarget, activeTarget, { excludeAnchor, excludeActive, exclusionScopeType }) {
    if (exclusionScopeType == null) {
      return [
        targetsToContinuousTarget(
          anchorTarget,
          activeTarget,
          excludeAnchor,
          excludeActive
        )
      ];
    }
    const isReversed = calcIsReversed(anchorTarget, activeTarget);
    return [
      targetsToContinuousTarget(
        excludeAnchor ? getExcludedScope(
          this.modifierStageFactory,
          anchorTarget,
          exclusionScopeType,
          isReversed ? "backward" : "forward"
        ) : anchorTarget,
        excludeActive ? getExcludedScope(
          this.modifierStageFactory,
          activeTarget,
          exclusionScopeType,
          isReversed ? "forward" : "backward"
        ) : activeTarget,
        false,
        false
      )
    ];
  }
  /**
   * This function implements the modifier pipeline that is at the core of Cursorless target processing.
   * It proceeds as follows:
   *
   * 1. It begins by getting the output from the {@link markStage} (eg "air", "this", etc).
   * This output is a list of zero or more targets.
   * 2. It then constructs a pipeline from the modifiers on the {@link targetDescriptor}
   * 3. It then runs each pipeline stage in turn, feeding the first stage with
   * the list of targets output from the {@link markStage}.  For each pipeline
   * stage, it passes the targets from the previous stage to the pipeline stage
   * one by one.  For each target, the stage will output a list of zero or more output
   * targets.  It then concatenates all of these lists into the list of targets
   * that will be passed to the next pipeline stage.  This process is similar to
   * the way that [jq](https://stedolan.github.io/jq/) processes its inputs.
   *
   * @param targetDescriptor The description of the target, consisting of a mark
   * and zero or more modifiers
   * @returns The output of running the modifier pipeline on the output from the mark
   */
  processPrimitiveTarget(targetDescriptor) {
    let markStage;
    let targetModifierStages;
    let automaticTokenExpansionBefore = false;
    if (targetDescriptor.type === "implicit") {
      markStage = new ImplicitStage();
      targetModifierStages = [];
    } else {
      markStage = this.markStageFactory.create(targetDescriptor.mark);
      targetModifierStages = getModifierStagesFromTargetModifiers(
        this.modifierStageFactory,
        targetDescriptor.modifiers
      );
      automaticTokenExpansionBefore = doAutomaticTokenExpansionBefore(targetDescriptor);
    }
    const markOutputTargets = markStage.run();
    const [preStages, postStages] = this.getPreAndPostStages(
      automaticTokenExpansionBefore
    );
    const modifierStages = [
      ...preStages,
      ...targetModifierStages,
      ...this.opts.actionFinalStages,
      ...postStages
    ];
    return processModifierStages(modifierStages, markOutputTargets);
  }
  getPreAndPostStages(automaticTokenExpansionBefore) {
    if (this.opts.noAutomaticTokenExpansion) {
      return [[], []];
    }
    const stage = new ContainingTokenIfUntypedEmptyStage(
      this.modifierStageFactory
    );
    if (automaticTokenExpansionBefore) {
      return [[stage], []];
    }
    return [[], [stage]];
  }
};
function doAutomaticTokenExpansionBefore(targetDescriptor) {
  return targetDescriptor.modifiers.length > 0 && targetDescriptor.modifiers.every(
    ({ type: type2 }) => type2 === "startOf" || type2 === "endOf"
  );
}
function getModifierStagesFromTargetModifiers(modifierStageFactory, targetModifiers) {
  return targetModifiers.map(modifierStageFactory.create).reverse();
}
function processModifierStages(modifierStages, targets) {
  const options2 = {
    multipleTargets: targets.length > 1
  };
  modifierStages.forEach((stage) => {
    targets = targets.flatMap((target) => stage.run(target, options2));
  });
  return targets;
}
function getExcludedScope(modifierStageFactory, target, scopeType, direction2) {
  const options2 = {
    multipleTargets: false
  };
  return modifierStageFactory.create({
    type: "relativeScope",
    scopeType,
    direction: direction2,
    length: 1,
    offset: 1
  }).run(target, options2)[0];
}
function calcIsReversed(anchor, active) {
  if (anchor.contentRange.start.isAfter(active.contentRange.start)) {
    return true;
  }
  if (anchor.contentRange.start.isBefore(active.contentRange.start)) {
    return false;
  }
  return anchor.contentRange.end.isAfter(active.contentRange.end);
}
function uniqTargets(array2) {
  return uniqWithHash(
    array2,
    (a, b) => a.isEqual(b),
    (a) => a.contentRange.concise()
  );
}
function ensureSingleEditor2(anchorTarget, activeTarget) {
  if (anchorTarget.editor !== activeTarget.editor) {
    throw new Error("Cannot form range between targets in different editors");
  }
}
function targetsToContinuousTarget(anchorTarget, activeTarget, excludeAnchor = false, excludeActive = false) {
  ensureSingleEditor2(anchorTarget, activeTarget);
  const isReversed = calcIsReversed(anchorTarget, activeTarget);
  const startTarget = isReversed ? activeTarget : anchorTarget;
  const endTarget = isReversed ? anchorTarget : activeTarget;
  const excludeStart = isReversed ? excludeActive : excludeAnchor;
  const excludeEnd = isReversed ? excludeAnchor : excludeActive;
  return createContinuousRangeTarget(
    isReversed,
    startTarget,
    endTarget,
    !excludeStart,
    !excludeEnd
  );
}
function targetsToVerticalTarget(anchorTarget, activeTarget, excludeAnchor, excludeActive) {
  ensureSingleEditor2(anchorTarget, activeTarget);
  const isReversed = calcIsReversed(anchorTarget, activeTarget);
  const delta = isReversed ? -1 : 1;
  const anchorPosition = isReversed ? anchorTarget.contentRange.start : anchorTarget.contentRange.end;
  const anchorLine = anchorPosition.line + (excludeAnchor ? delta : 0);
  const activePosition = isReversed ? activeTarget.contentRange.start : activeTarget.contentRange.end;
  const activeLine = activePosition.line - (excludeActive ? delta : 0);
  const results = [];
  for (let i2 = anchorLine; true; i2 += delta) {
    const contentRange = new Range(
      i2,
      anchorTarget.contentRange.start.character,
      i2,
      anchorTarget.contentRange.end.character
    );
    results.push(
      new PlainTarget({
        editor: anchorTarget.editor,
        isReversed: anchorTarget.isReversed,
        contentRange,
        insertionDelimiter: anchorTarget.insertionDelimiter
      })
    );
    if (i2 === activeLine) {
      return results;
    }
  }
}

// ../cursorless-engine/src/processTargets/modifiers/InteriorStage.ts
var InteriorOnlyStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const interior = target.getInterior();
    if (interior != null) {
      return interior;
    }
    if (target.hasExplicitScopeType) {
      const everyModifier = this.modifierStageFactory.create({
        type: "everyScope",
        scopeType: {
          type: "interior"
        }
      });
      try {
        return everyModifier.run(target, options2);
      } catch (e) {
        if (e instanceof UnsupportedScopeError) {
          throw new NoContainingScopeError("interior");
        }
        throw e;
      }
    }
    try {
      return this.modifierStageFactory.create({
        type: "containingScope",
        scopeType: compoundInteriorScopeType
      }).run(target, options2);
    } catch (e) {
      if (e instanceof NoContainingScopeError) {
        throw new NoContainingScopeError("interior");
      }
      throw e;
    }
  }
};
var compoundInteriorScopeType = {
  type: "oneOf",
  scopeTypes: [
    {
      type: "interior"
    },
    {
      type: "surroundingPairInterior",
      delimiter: "any"
    }
  ]
};

// ../cursorless-engine/src/processTargets/modifiers/HeadTailStage.ts
var HeadTailStage = class {
  constructor(modifierStageFactory, modifiers, isHead) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifiers = modifiers;
    this.isHead = isHead;
  }
  run(target) {
    const modifierStages = this.getModifierStages();
    const modifiedTargets = processModifierStages(modifierStages, [target]);
    return modifiedTargets.map((modifiedTarget) => {
      return new HeadTailTarget({
        editor: target.editor,
        isReversed: this.isHead,
        inputTarget: target,
        modifiedTarget,
        isHead: this.isHead
      });
    });
  }
  getModifierStages() {
    if (this.modifiers != null) {
      return getModifierStagesFromTargetModifiers(
        this.modifierStageFactory,
        this.modifiers
      );
    }
    return [new BoundedLineStage(this.modifierStageFactory)];
  }
};
var HeadStage = class extends HeadTailStage {
  constructor(modifierStageFactory, modifier) {
    super(modifierStageFactory, modifier.modifiers, true);
  }
};
var TailStage = class extends HeadTailStage {
  constructor(modifierStageFactory, modifier) {
    super(modifierStageFactory, modifier.modifiers, false);
  }
};
var BoundedLineStage = class {
  constructor(modifierStageFactory) {
    this.modifierStageFactory = modifierStageFactory;
  }
  run(target, options2) {
    const line = this.getContainingLine(target, options2);
    const interior = this.getContainingInterior(target, options2);
    const intersection2 = interior != null ? line.contentRange.intersection(interior.contentRange) : null;
    if (intersection2 == null || intersection2.isEmpty) {
      return [line];
    }
    return [
      new PlainTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: intersection2
      })
    ];
  }
  getContainingInterior(target, options2) {
    try {
      return this.modifierStageFactory.create({
        type: "containingScope",
        scopeType: compoundInteriorScopeType
      }).run(target, options2)[0];
    } catch (error48) {
      if (error48 instanceof NoContainingScopeError) {
        return void 0;
      }
      throw error48;
    }
  }
  getContainingLine(target, options2) {
    return this.modifierStageFactory.create({ type: "containingScope", scopeType: { type: "line" } }).run(target, options2)[0];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/listUtils.ts
var OutOfRangeError = class extends Error {
  constructor(scopeType, index) {
    const numberStr = index != null ? ` #${index + 1}` : "";
    super(`Scope '${scopeType.type}'${numberStr} is out of range`);
    this.name = "OutOfRangeError";
  }
};
function sliceStrict(scopeType, targets, startIndex, endIndex) {
  assertIndices(scopeType, targets, startIndex, endIndex);
  return targets.slice(startIndex, endIndex + 1);
}
function assertIndices(scopeType, targets, startIndex, endIndex) {
  if (startIndex < 0 || startIndex >= targets.length) {
    throw new OutOfRangeError(scopeType, startIndex);
  }
  if (endIndex < 0 || endIndex >= targets.length) {
    throw new OutOfRangeError(scopeType, endIndex);
  }
}

// ../cursorless-engine/src/processTargets/modifiers/InstanceStage.ts
var InstanceStage = class {
  constructor(modifierStageFactory, storedTargets, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.storedTargets = storedTargets;
    this.modifier = modifier;
  }
  static use(scopeType) {
    return scopeType.type === "instance";
  }
  run(inputTarget, options2) {
    const target = new ContainingTokenIfUntypedEmptyStage(
      this.modifierStageFactory
    ).run(inputTarget, options2)[0];
    switch (this.modifier.type) {
      case "everyScope":
        return this.handleEveryScope(target, options2);
      case "ordinalScope":
        return this.handleOrdinalScope(target, options2, this.modifier);
      case "relativeScope":
        return this.handleRelativeScope(target, options2, this.modifier);
      default:
        throw Error(`${this.modifier.type} instance scope not supported`);
    }
  }
  handleEveryScope(target, options2) {
    return Array.from(
      flatmap(
        this.getEveryRanges(target),
        ([editor, searchRange]) => this.getTargetIterable(target, options2, editor, searchRange, "forward")
      )
    );
  }
  handleOrdinalScope(target, options2, { start: start2, length, scopeType }) {
    return this.getEveryRanges(target).flatMap(
      ([editor, searchRange]) => takeFromOffset(
        scopeType,
        this.getTargetIterable(
          target,
          options2,
          editor,
          searchRange,
          start2 >= 0 ? "forward" : "backward"
        ),
        start2 >= 0 ? start2 : -(length + start2),
        length
      )
    );
  }
  handleRelativeScope(target, options2, { direction: direction2, offset, length, scopeType }) {
    const referenceTargets = this.storedTargets.get("instanceReference") ?? [
      target
    ];
    return referenceTargets.flatMap((referenceTarget) => {
      const { editor } = referenceTarget;
      const iterationRange = direction2 === "forward" ? new Range(
        offset === 0 ? referenceTarget.contentRange.start : referenceTarget.contentRange.end,
        editor.document.range.end
      ) : new Range(
        editor.document.range.start,
        offset === 0 ? referenceTarget.contentRange.end : referenceTarget.contentRange.start
      );
      return takeFromOffset(
        scopeType,
        this.getTargetIterable(
          target,
          options2,
          editor,
          iterationRange,
          direction2
        ),
        offset === 0 ? 0 : offset - 1,
        length
      );
    });
  }
  getEveryRanges({
    editor: targetEditor
  }) {
    return this.storedTargets.get("instanceReference")?.map(({ editor, contentRange }) => [editor, contentRange]) ?? [[targetEditor, targetEditor.document.range]];
  }
  getTargetIterable(target, options2, editor, searchRange, direction2) {
    const iterable = imap(
      generateMatchesInRange(
        new RegExp(escapeRegExp_default(target.contentText), "g"),
        editor,
        searchRange,
        direction2
      ),
      (range3) => new PlainTarget({
        contentRange: range3,
        editor,
        isReversed: false,
        textualType: "character"
      })
    );
    const filterScopeType = getFilterScopeType(target);
    if (filterScopeType != null) {
      const containingScopeModifier2 = this.modifierStageFactory.create({
        type: "containingScope",
        scopeType: filterScopeType
      });
      return ifilter(
        imap(iterable, (target2) => {
          try {
            const containingScope = containingScopeModifier2.run(
              target2,
              options2
            );
            if (containingScope.length === 1 && containingScope[0].contentRange.isRangeEqual(target2.contentRange)) {
              return containingScope[0];
            }
            return null;
          } catch (_err) {
            return null;
          }
        }),
        (target2) => target2 != null
      );
    }
    return iterable;
  }
};
function getFilterScopeType(target) {
  switch (target.textualType) {
    case "line":
    case "token":
    case "word":
      return { type: target.textualType };
    default:
      return null;
  }
}
function takeFromOffset(scopeType, iterable, offset, count2) {
  Array.from(itake(offset, iterable));
  const items = Array.from(itake(count2, iterable));
  if (items.length < count2) {
    throw new OutOfRangeError(scopeType, offset + count2 - 1);
  }
  return items;
}

// ../cursorless-engine/src/processTargets/modifiers/commonContainingScopeIfUntypedModifiers.ts
var containingLineIfUntypedModifier = {
  type: "modifyIfUntyped",
  modifier: {
    type: "containingScope",
    scopeType: { type: "line" }
  }
};
var containingTokenIfUntypedModifier = {
  type: "modifyIfUntyped",
  modifier: {
    type: "containingScope",
    scopeType: { type: "token" }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/LeadingTrailingStages.ts
var NoDelimiterError = class extends Error {
  constructor(type2) {
    super(`Target has no ${type2} delimiter.`);
    this.name = "NoDelimiterError";
  }
};
var LeadingStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    return this.modifierStageFactory.create(containingTokenIfUntypedModifier).run(target, options2).map((target2) => {
      const leading = target2.getLeadingDelimiterTarget();
      if (leading == null) {
        throw new NoDelimiterError("leading");
      }
      return leading;
    });
  }
};
var TrailingStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    return this.modifierStageFactory.create(containingTokenIfUntypedModifier).run(target, options2).map((target2) => {
      const trailing = target2.getTrailingDelimiterTarget();
      if (trailing == null) {
        throw new NoDelimiterError("trailing");
      }
      return trailing;
    });
  }
};

// ../cursorless-engine/src/processTargets/modifiers/targetSequenceUtils.ts
function createRangeTargetFromIndices(scopeType, isReversed, targets, startIndex, endIndex) {
  assertIndices(scopeType, targets, startIndex, endIndex);
  if (startIndex === endIndex) {
    return targets[startIndex];
  }
  return createContinuousRangeTarget(
    isReversed,
    targets[startIndex],
    targets[endIndex],
    true,
    true
  );
}
function getEveryScopeTargets(modifierStageFactory, target, options2, scopeType) {
  const containingStage = modifierStageFactory.create({
    type: "everyScope",
    scopeType
  });
  return containingStage.run(target, options2);
}

// ../cursorless-engine/src/processTargets/modifiers/OrdinalScopeStage.ts
var OrdinalScopeStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const targets = getEveryScopeTargets(
      this.modifierStageFactory,
      target,
      options2,
      this.modifier.scopeType
    );
    const startIndex = this.modifier.start + (this.modifier.start < 0 ? targets.length : 0);
    const endIndex = startIndex + this.modifier.length - 1;
    if (this.modifier.isEvery) {
      return sliceStrict(
        this.modifier.scopeType,
        targets,
        startIndex,
        endIndex
      );
    }
    return [
      createRangeTargetFromIndices(
        this.modifier.scopeType,
        target.isReversed,
        targets,
        startIndex,
        endIndex
      )
    ];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/PositionStage.ts
var PositionStage = class {
  run(target) {
    const parameters = {
      editor: target.editor,
      isReversed: target.isReversed,
      contentRange: this.getContentRange(target.contentRange)
    };
    return [
      target.isRaw ? new RawSelectionTarget(parameters) : new PlainTarget({ ...parameters, textualType: "character" })
    ];
  }
};
var StartOfStage = class extends PositionStage {
  getContentRange(contentRange) {
    return contentRange.start.toEmptyRange();
  }
};
var EndOfStage = class extends PositionStage {
  getContentRange(contentRange) {
    return contentRange.end.toEmptyRange();
  }
};

// ../cursorless-engine/src/processTargets/modifiers/PreferredScopeStage.ts
var PreferredScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target) {
    const { scopeType } = this.modifier;
    const containingScopeStage = new ContainingScopeStage(
      this.modifierStageFactory,
      this.scopeHandlerFactory,
      { type: "containingScope", scopeType }
    );
    try {
      return containingScopeStage.run(target);
    } catch (ex) {
      if (!(ex instanceof NoContainingScopeError)) {
        throw ex;
      }
    }
    const scopeHandler = this.scopeHandlerFactory.create(
      this.modifier.scopeType,
      target.editor.document.languageId
    );
    const closestTargets = getClosestScopeTargets(target, scopeHandler);
    if (closestTargets == null) {
      throw Error(`No scopes found for scope type: ${scopeType.type}`);
    }
    return closestTargets;
  }
};
function getClosestScopeTargets(target, scopeHandler) {
  const previousScopes = scopeHandler.generateScopes(
    target.editor,
    target.contentRange.start,
    "backward"
  );
  const nextScopes = scopeHandler.generateScopes(
    target.editor,
    target.contentRange.end,
    "forward"
  );
  const { active } = target.contentSelection;
  const previousScope = getClosestScope(previousScopes, active);
  const nextScope = getClosestScope(nextScopes, active);
  const preferredScope = previousScope.distance < nextScope.distance ? previousScope.scope : nextScope.scope;
  return preferredScope != null ? preferredScope.getTargets(target.isReversed) : void 0;
}
function getClosestScope(scopes, position) {
  let closestScope;
  let closestDistance = Infinity;
  for (const scope of scopes) {
    const distance = Math.min(
      distanceBetweenPositions(position, scope.domain.start),
      distanceBetweenPositions(position, scope.domain.end)
    );
    if (distance < closestDistance) {
      closestScope = scope;
      closestDistance = distance;
    } else {
      break;
    }
  }
  return { scope: closestScope, distance: closestDistance };
}
function distanceBetweenPositions(a, b) {
  return (
    // 10000 is arbitrary to always pick same-line occurrences first
    Math.abs(a.line - b.line) * 1e4 + Math.abs(a.character - b.character)
  );
}

// ../cursorless-engine/src/processTargets/modifiers/RangeModifierStage.ts
var RangeModifierStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const anchorStage = this.modifierStageFactory.create(this.modifier.anchor);
    const activeStage = this.modifierStageFactory.create(this.modifier.active);
    const anchorTargets = anchorStage.run(target, options2);
    const activeTargets = activeStage.run(target, options2);
    if (anchorTargets.length !== 1 || activeTargets.length !== 1) {
      throw new Error("Expected single anchor and active target");
    }
    return [
      targetsToContinuousTarget(
        anchorTargets[0],
        activeTargets[0],
        this.modifier.excludeAnchor,
        this.modifier.excludeActive
      )
    ];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/RawSelectionStage.ts
var RawSelectionStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return [
      new RawSelectionTarget({
        editor: target.editor,
        contentRange: target.contentRange,
        isReversed: target.isReversed
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/RelativeScopeStage.ts
var RelativeScopeStage = class {
  constructor(scopeHandlerFactory, modifier) {
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target) {
    const scopeHandler = this.scopeHandlerFactory.create(
      this.modifier.scopeType,
      target.editor.document.languageId
    );
    const scopes = Array.from(
      this.modifier.offset === 0 ? generateScopesInclusive(scopeHandler, target, this.modifier) : generateScopesExclusive(
        this.scopeHandlerFactory,
        scopeHandler,
        target,
        this.modifier
      )
    );
    if (scopes.length < this.modifier.length) {
      throw new OutOfRangeError(
        this.modifier.scopeType,
        this.modifier.offset + this.modifier.length - 1
      );
    }
    const { isReversed } = target;
    if (this.modifier.isEvery) {
      return scopes.flatMap((scope) => scope.getTargets(isReversed));
    }
    return constructScopeRangeTarget(
      isReversed,
      scopes[0],
      scopes[scopes.length - 1]
    );
  }
};
function generateScopesInclusive(scopeHandler, target, modifier) {
  const { editor, contentRange } = target;
  const { length: desiredScopeCount, direction: direction2 } = modifier;
  const initialRange = getPreferredScopeTouchingPosition(
    scopeHandler,
    editor,
    direction2 === "forward" ? contentRange.start : contentRange.end,
    direction2
  )?.domain;
  if (initialRange == null) {
    throw new NoContainingScopeError(modifier.scopeType.type);
  }
  return itake(
    desiredScopeCount,
    scopeHandler.generateScopes(
      editor,
      direction2 === "forward" ? initialRange.start : initialRange.end,
      direction2,
      {
        skipAncestorScopes: true
      }
    )
  );
}
function generateScopesExclusive(scopeHandlerFactory, scopeHandler, target, modifier) {
  const { editor, contentRange: inputRange } = target;
  const { length: desiredScopeCount, direction: direction2, offset } = modifier;
  const initialPosition = direction2 === "forward" ? inputRange.end : inputRange.start;
  const containment = inputRange.isEmpty ? "disallowed" : "disallowedIfStrict";
  let scopes = scopeHandler.generateScopes(editor, initialPosition, direction2, {
    containment,
    skipAncestorScopes: true
  });
  const interiorRanges = getExcludedInteriorRanges(
    scopeHandlerFactory,
    scopeHandler,
    editor,
    initialPosition,
    direction2
  );
  if (interiorRanges.length > 0) {
    scopes = ifilter(
      scopes,
      (s) => !interiorRanges.some((r) => r.contains(s.domain))
    );
  }
  return islice(scopes, offset - 1, offset + desiredScopeCount - 1);
}
function getExcludedInteriorRanges(scopeHandlerFactory, scopeHandler, editor, initialPosition, direction2) {
  const containingScopeTarget = getContainingScopeTarget2(
    scopeHandler,
    editor,
    initialPosition,
    direction2
  );
  if (containingScopeTarget == null) {
    return [];
  }
  const containingInteriorTargets = containingScopeTarget.getInterior();
  if (containingInteriorTargets != null) {
    return getFilteredInteriorRanges(
      containingInteriorTargets,
      initialPosition
    );
  }
  const interiorScopeHandler = scopeHandlerFactory.maybeCreate(
    { type: "interior" },
    editor.document.languageId
  );
  if (interiorScopeHandler == null) {
    return [];
  }
  const containingPositions = getPositions(
    containingScopeTarget.contentRange,
    direction2
  );
  const interiorScopes = interiorScopeHandler.generateScopes(
    editor,
    containingPositions.initial,
    direction2,
    {
      skipAncestorScopes: true,
      distalPosition: containingPositions.distal
    }
  );
  const interiorTargets = Array.from(interiorScopes).flatMap(
    (s) => s.getTargets(false)
  );
  if (interiorTargets.length > 0) {
    return getFilteredInteriorRanges(interiorTargets, initialPosition);
  }
  return [containingScopeTarget.contentRange];
}
function getPositions(range3, direction2) {
  return direction2 === "forward" ? { initial: range3.start, distal: range3.end } : { initial: range3.end, distal: range3.start };
}
function getFilteredInteriorRanges(interiorTargets, initialPosition) {
  return interiorTargets.map(
    (t) => t instanceof InteriorTarget ? t.fullInteriorRange : t.contentRange
  ).filter((r) => !r.contains(initialPosition));
}
function getContainingScopeTarget2(scopeHandler, editor, initialPosition, direction2) {
  const containingScope = find(
    scopeHandler.generateScopes(editor, initialPosition, direction2, {
      containment: "required",
      allowAdjacentScopes: true,
      skipAncestorScopes: true
    })
  );
  return containingScope?.getTargets(false)[0];
}

// ../cursorless-engine/src/processTargets/modifiers/VisibleStage.ts
var VisibleStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return target.editor.visibleRanges.map(
      (range3) => new PlainTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: range3
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/ModifierStageFactoryImpl.ts
var ModifierStageFactoryImpl = class {
  constructor(languageDefinitions, storedTargets, scopeHandlerFactory) {
    this.languageDefinitions = languageDefinitions;
    this.storedTargets = storedTargets;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.create = this.create.bind(this);
  }
  create(modifier) {
    switch (modifier.type) {
      case "startOf":
        return new StartOfStage();
      case "endOf":
        return new EndOfStage();
      case "extendThroughStartOf":
        return new HeadStage(this, modifier);
      case "extendThroughEndOf":
        return new TailStage(this, modifier);
      case "toRawSelection":
        return new RawSelectionStage(modifier);
      case "interiorOnly":
        return new InteriorOnlyStage(this, modifier);
      case "excludeInterior":
        return new ExcludeInteriorStage(this, modifier);
      case "leading":
        return new LeadingStage(this, modifier);
      case "trailing":
        return new TrailingStage(this, modifier);
      case "visible":
        return new VisibleStage(modifier);
      case "containingScope":
        if (ClassFunctionNameStage.use(modifier.scopeType)) {
          return new ClassFunctionNameStage(this, modifier);
        }
        return new ContainingScopeStage(
          this,
          this.scopeHandlerFactory,
          modifier
        );
      case "preferredScope":
        if (ClassFunctionNameStage.use(modifier.scopeType)) {
          return new ClassFunctionNameStage(this, modifier);
        }
        return new PreferredScopeStage(
          this,
          this.scopeHandlerFactory,
          modifier
        );
      case "everyScope":
        if (InstanceStage.use(modifier.scopeType)) {
          return new InstanceStage(this, this.storedTargets, modifier);
        }
        if (ClassFunctionNameStage.use(modifier.scopeType)) {
          return new ClassFunctionNameStage(this, modifier);
        }
        return new EveryScopeStage(this, this.scopeHandlerFactory, modifier);
      case "ordinalScope":
        if (InstanceStage.use(modifier.scopeType)) {
          return new InstanceStage(this, this.storedTargets, modifier);
        }
        if (ClassFunctionNameStage.use(modifier.scopeType)) {
          return new ClassFunctionNameStage(this, modifier);
        }
        return new OrdinalScopeStage(this, modifier);
      case "relativeScope":
        if (InstanceStage.use(modifier.scopeType)) {
          return new InstanceStage(this, this.storedTargets, modifier);
        }
        if (ClassFunctionNameStage.use(modifier.scopeType)) {
          return new ClassFunctionNameStage(this, modifier);
        }
        return new RelativeScopeStage(this.scopeHandlerFactory, modifier);
      case "keepContentFilter":
        return new KeepContentFilterStage(modifier);
      case "keepEmptyFilter":
        return new KeepEmptyFilterStage(modifier);
      case "fallback":
        return new FallbackStage(this, modifier);
      case "modifyIfUntyped":
        return new ModifyIfUntypedStage(this, modifier);
      case "range":
        return new RangeModifierStage(this, modifier);
      case "inferPreviousMark":
        throw Error(
          `Unexpected modifier '${modifier.type}'; it should have been removed during inference`
        );
      default: {
        const _exhaustiveCheck = modifier;
        const { type: type2 } = modifier;
        throw new Error(`Unknown modifier: ${type2}`);
      }
    }
  }
};

// ../cursorless-engine/src/util/performDocumentEdits.ts
async function performDocumentEdits(rangeUpdater, editor, edits) {
  const deregister = rangeUpdater.registerReplaceEditList(
    editor.document,
    edits.filter((edit) => edit.isReplace)
  );
  try {
    return await editor.edit(edits);
  } finally {
    deregister();
  }
}

// ../cursorless-engine/src/core/updateSelections/updateSelections.ts
async function performEditsAndUpdateSelections({
  rangeUpdater,
  editor,
  selections,
  preserveCursorSelections: preserveEditorSelections,
  ...rest
}) {
  const keys2 = unsafeKeys(selections);
  const selectionInfos = keys2.map((key) => {
    const selectionValue = selections[key];
    const selectionsWithBehavior = getSelectionsWithBehavior(selectionValue);
    return getFullSelectionInfos(
      editor.document,
      selectionsWithBehavior.selections,
      selectionsWithBehavior.behavior
    );
  });
  if (!preserveEditorSelections) {
    selectionInfos.push(
      getFullSelectionInfos(
        editor.document,
        editor.selections,
        1 /* closedClosed */
      )
    );
  }
  const updatedSelectionsMatrix = await (() => {
    if ("edits" in rest) {
      return performEditsAndUpdateFullSelectionInfos(
        rangeUpdater,
        editor,
        rest.edits,
        selectionInfos
      );
    }
    return callFunctionAndUpdateFullSelectionInfos(
      rangeUpdater,
      rest.callback,
      editor.document,
      selectionInfos
    );
  })();
  if (!preserveEditorSelections) {
    await editor.setSelections(updatedSelectionsMatrix.pop());
  }
  const result = Object.fromEntries(
    keys2.map((key, index) => [key, updatedSelectionsMatrix[index]])
  );
  return result;
}
function getFullSelectionInfos(document2, selections, rangeBehavior) {
  return selections.map(
    (selection) => getSelectionInfoInternal(
      document2,
      selection,
      selection instanceof Selection ? !selection.isReversed : true,
      rangeBehavior
    )
  );
}
function getSelectionsWithBehavior(selections) {
  if ("selections" in selections) {
    return selections;
  }
  return {
    selections,
    behavior: 1 /* closedClosed */
  };
}
function getSelectionInfoInternal(document2, range3, isForward, rangeBehavior) {
  return {
    range: range3,
    isForward,
    expansionBehavior: {
      start: {
        type: rangeBehavior === 1 /* closedClosed */ || rangeBehavior === 3 /* closedOpen */ ? "closed" : "open"
      },
      end: {
        type: rangeBehavior === 1 /* closedClosed */ || rangeBehavior === 2 /* openClosed */ ? "closed" : "open"
      }
    },
    offsets: {
      start: document2.offsetAt(range3.start),
      end: document2.offsetAt(range3.end)
    },
    text: document2.getText(range3)
  };
}
function selectionInfosToSelections(selectionInfoMatrix) {
  return selectionInfoMatrix.map(
    (selectionInfos) => selectionInfos.map(
      ({ range: { start: start2, end }, isForward }) => isForward ? new Selection(start2, end) : new Selection(end, start2)
    )
  );
}
async function callFunctionAndUpdateFullSelectionInfos(rangeUpdater, func2, document2, originalSelectionInfos) {
  const unsubscribe = rangeUpdater.registerRangeInfoList(
    document2,
    flatten_default(originalSelectionInfos)
  );
  try {
    await func2();
    return selectionInfosToSelections(originalSelectionInfos);
  } finally {
    unsubscribe();
  }
}
async function performEditsAndUpdateFullSelectionInfos(rangeUpdater, editor, edits, originalSelectionInfos) {
  const func2 = async () => {
    const wereEditsApplied = await performDocumentEdits(
      rangeUpdater,
      editor,
      edits
    );
    if (!wereEditsApplied) {
      throw new Error("Could not apply edits");
    }
  };
  return await callFunctionAndUpdateFullSelectionInfos(
    rangeUpdater,
    func2,
    editor.document,
    originalSelectionInfos
  );
}

// ../cursorless-engine/src/actions/BreakLine.ts
var BreakLine = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const thatSelections = flatten_default(
      await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
        const contentRanges = targets2.map(({ contentRange }) => contentRange);
        const edits = getEdits(editor, contentRanges);
        const editableEditor = ide().getEditableTextEditor(editor);
        const { contentRanges: updatedRanges } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: editableEditor,
          edits,
          selections: {
            contentRanges
          }
        });
        return zip_default(targets2, updatedRanges).map(([target, range3]) => ({
          editor: target.editor,
          selection: range3.toSelection(target.isReversed)
        }));
      })
    );
    return { thatSelections };
  }
};
function getEdits(editor, contentRanges) {
  const { document: document2 } = editor;
  const edits = [];
  for (const range3 of contentRanges) {
    const position = range3.start;
    const line = document2.lineAt(position);
    const indentation = line.text.slice(
      0,
      line.rangeTrimmed?.start?.character ?? line.range.start.character
    );
    const characterTrailingWhitespace = line.text.slice(0, position.character).search(/\s+$/);
    const replacementRange = characterTrailingWhitespace > -1 ? new Range(
      new Position(line.lineNumber, characterTrailingWhitespace),
      position
    ) : position.toEmptyRange();
    edits.push({
      range: replacementRange,
      text: "\n" + indentation,
      isReplace: !replacementRange.isEmpty
    });
  }
  return edits;
}

// ../cursorless-engine/src/util/unifyRanges.ts
function unifyRemovalTargets(targets) {
  if (targets.length < 2) {
    return targets;
  }
  return groupTargetsForEachEditor(targets).flatMap(([_editor, targets2]) => {
    if (targets2.length < 2) {
      return targets2;
    }
    let results = [...targets2];
    results.sort(
      (a, b) => a.contentRange.start.compareTo(b.contentRange.start)
    );
    let run2 = true;
    while (run2) {
      [results, run2] = unifyTargetsOnePass(results);
    }
    return results;
  });
}
function unifyTargetsOnePass(targets) {
  if (targets.length < 2) {
    return [targets, false];
  }
  const results = [];
  let currentGroup = [];
  targets.forEach((target) => {
    if (currentGroup.length && !intersects(currentGroup[currentGroup.length - 1], target)) {
      results.push(mergeTargets(currentGroup));
      currentGroup = [target];
    } else {
      currentGroup.push(target);
    }
  });
  results.push(mergeTargets(currentGroup));
  return [results, results.length !== targets.length];
}
function mergeTargets(targets) {
  if (targets.length === 1) {
    return targets[0];
  }
  const first = targets[0];
  const last2 = targets[targets.length - 1];
  return targetsToContinuousTarget(first, last2);
}
function intersects(targetA, targetB) {
  return targetA.getRemovalRange().intersection(targetB.getRemovalRange()) != null;
}

// ../cursorless-engine/src/actions/BringMoveSwap.ts
var BringMoveSwap = class {
  constructor(rangeUpdater, type2) {
    this.rangeUpdater = rangeUpdater;
    this.type = type2;
  }
  async decorateTargets(sources, destinations) {
    await Promise.all([
      flashTargets(
        ide(),
        sources,
        this.decoration.sourceStyle,
        this.decoration.getSourceRangeCallback
      ),
      flashTargets(ide(), destinations, this.decoration.destinationStyle)
    ]);
  }
  getEditsBringMove(sources, destinations) {
    const usedSources = [];
    const results = [];
    const shouldJoinSources = sources.length !== destinations.length && destinations.length === 1;
    sources.forEach((source, i2) => {
      let destination = destinations[i2];
      let destinationEdit;
      if ((source == null || destination == null) && !shouldJoinSources) {
        throw new Error("Targets must have same number of args");
      }
      if (destination != null) {
        let text;
        if (shouldJoinSources) {
          text = sources.map((source2, i3) => {
            const text2 = source2.contentText;
            const delimiter = (destination.isRaw ? null : destination.insertionDelimiter) ?? (source2.isRaw ? null : source2.insertionDelimiter);
            return i3 > 0 && delimiter != null ? delimiter + text2 : text2;
          }).join("");
        } else {
          text = source.contentText;
        }
        destinationEdit = {
          edit: destination.constructChangeEdit(text),
          editor: destination.editor,
          originalTarget: destination.target,
          isSource: false
        };
        results.push(destinationEdit);
      } else {
        destination = destinations[0];
      }
      if (!usedSources.includes(source)) {
        if (this.type !== "move" || destinationEdit == null || destinationEdit.editor.id !== source.editor.id || !destinationEdit.edit.range.contains(source.contentRange)) {
          usedSources.push(source);
        }
        if (this.type === "bring") {
          results.push({
            edit: source.toDestination("to").constructChangeEdit(destination.target.contentText),
            editor: source.editor,
            originalTarget: source,
            isSource: true
          });
        }
      }
    });
    if (this.type === "move") {
      unifyRemovalTargets(usedSources).forEach((source) => {
        results.push({
          edit: source.constructRemovalEdit(),
          editor: source.editor,
          originalTarget: source,
          isSource: true
        });
      });
    }
    return results;
  }
  async performEditsAndComputeThatMark(edits) {
    return flatten_default(
      await runForEachEditor(
        edits,
        (edit) => edit.editor,
        async (editor, edits2) => {
          const filteredEdits = this.type !== "bring" ? edits2 : edits2.filter(({ isSource }) => !isSource);
          const sourceEdits = this.type === "swap" ? [] : edits2.filter(({ isSource }) => isSource);
          const destinationEdits = this.type === "swap" ? edits2 : edits2.filter(({ isSource }) => !isSource);
          const sourceEditRanges = sourceEdits.map(({ edit }) => edit.range);
          const destinationEditRanges = destinationEdits.map(
            ({ edit }) => edit.range
          );
          const editableEditor = ide().getEditableTextEditor(editor);
          const {
            sourceEditRanges: updatedSourceEditRanges,
            destinationEditRanges: updatedDestinationEditRanges
          } = await performEditsAndUpdateSelections({
            rangeUpdater: this.rangeUpdater,
            editor: editableEditor,
            edits: filteredEdits.map(({ edit }) => edit),
            selections: {
              // Sources should be closedClosed, because they should be logically
              // the same as the original source.
              sourceEditRanges,
              // Destinations should be openOpen, because they should grow to contain
              // the new text.
              destinationEditRanges: {
                selections: destinationEditRanges,
                behavior: 0 /* openOpen */
              }
            }
          });
          const marks2 = [
            ...this.getMarks(sourceEdits, updatedSourceEditRanges),
            ...this.getMarks(destinationEdits, updatedDestinationEditRanges)
          ];
          marks2.sort(
            (a, b) => edits2.findIndex((e) => e.originalTarget === a.target) - edits2.findIndex((e) => e.originalTarget === b.target)
          );
          return marks2;
        }
      )
    );
  }
  getMarks(edits, ranges) {
    return edits.map((edit, index) => {
      const originalRange = ranges[index];
      const range3 = edit.edit.updateRange(originalRange);
      const target = edit.originalTarget;
      return {
        editor: edit.editor,
        selection: range3.toSelection(target.isReversed),
        isSource: edit.isSource,
        target
      };
    });
  }
  async decorateThatMark(thatMark) {
    const getRange = (target) => {
      return toGeneralizedRange(
        target,
        thatMark.find((t) => t.target === target).selection
      );
    };
    return Promise.all([
      flashTargets(
        ide(),
        thatMark.filter(({ isSource }) => isSource).map(({ target }) => target),
        this.decoration.sourceStyle,
        getRange
      ),
      flashTargets(
        ide(),
        thatMark.filter(({ isSource }) => !isSource).map(({ target }) => target),
        this.decoration.destinationStyle,
        getRange
      )
    ]);
  }
  calculateMarksBringMove(markEntries) {
    return {
      thatMark: markEntries.filter(({ isSource }) => !isSource),
      sourceMark: markEntries.filter(({ isSource }) => isSource)
    };
  }
};
function broadcastSource(sources, destinations) {
  if (sources.length === 1) {
    return Array(destinations.length).fill(sources[0]);
  }
  return sources;
}
var Bring = class extends BringMoveSwap {
  constructor(rangeUpdater) {
    super(rangeUpdater, "bring");
    __publicField(this, "decoration", {
      sourceStyle: "referenced" /* referenced */,
      destinationStyle: "pendingModification0" /* pendingModification0 */
    });
    this.run = this.run.bind(this);
  }
  async run(sources, destinations) {
    sources = broadcastSource(sources, destinations);
    await this.decorateTargets(
      sources,
      destinations.map((d) => d.target)
    );
    const edits = this.getEditsBringMove(sources, destinations);
    const markEntries = await this.performEditsAndComputeThatMark(edits);
    const { thatMark, sourceMark } = this.calculateMarksBringMove(markEntries);
    await this.decorateThatMark(thatMark);
    return { thatSelections: thatMark, sourceSelections: sourceMark };
  }
};
var Move = class extends BringMoveSwap {
  constructor(rangeUpdater) {
    super(rangeUpdater, "move");
    __publicField(this, "decoration", {
      sourceStyle: "pendingDelete" /* pendingDelete */,
      destinationStyle: "pendingModification0" /* pendingModification0 */,
      getSourceRangeCallback: getRemovalHighlightRange
    });
    this.run = this.run.bind(this);
  }
  async run(sources, destinations) {
    sources = broadcastSource(sources, destinations);
    await this.decorateTargets(
      sources,
      destinations.map((d) => d.target)
    );
    const edits = this.getEditsBringMove(sources, destinations);
    const markEntries = await this.performEditsAndComputeThatMark(edits);
    const { thatMark, sourceMark } = this.calculateMarksBringMove(markEntries);
    await this.decorateThatMark(thatMark);
    return { thatSelections: thatMark, sourceSelections: sourceMark };
  }
};
var Swap = class extends BringMoveSwap {
  constructor(rangeUpdater) {
    super(rangeUpdater, "swap");
    __publicField(this, "decoration", {
      sourceStyle: "pendingModification1" /* pendingModification1 */,
      destinationStyle: "pendingModification0" /* pendingModification0 */
    });
    this.run = this.run.bind(this);
  }
  async run(targets1, targets2) {
    await this.decorateTargets(targets1, targets2);
    const edits = this.getEditsSwap(targets1, targets2);
    const markEntries = await this.performEditsAndComputeThatMark(edits);
    await this.decorateThatMark(markEntries);
    return { thatSelections: markEntries, sourceSelections: [] };
  }
  getEditsSwap(targets1, targets2) {
    const results = [];
    targets1.forEach((target1, i2) => {
      const target2 = targets2[i2];
      if (target1 == null || target2 == null) {
        throw new Error("Targets must have same number of args");
      }
      results.push({
        edit: target2.toDestination("to").constructChangeEdit(target1.contentText),
        editor: target2.editor,
        originalTarget: target2,
        isSource: false
      });
      results.push({
        edit: target1.toDestination("to").constructChangeEdit(target2.contentText),
        editor: target1.editor,
        originalTarget: target1,
        isSource: true
      });
    });
    return results;
  }
};
function getRemovalHighlightRange(target) {
  return target.getRemovalHighlightRange();
}

// ../cursorless-engine/src/actions/Call.ts
var Call = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(callees, args2) {
    ensureSingleTarget(callees);
    const { returnValue: texts } = await this.actions.getText.run(callees, {
      showDecorations: false
    });
    const { thatSelections: thatMark } = await this.actions.wrapWithPairedDelimiter.run(args2, texts[0] + "(", ")");
    return { thatSelections: thatMark };
  }
};

// ../cursorless-engine/src/actions/Clear.ts
var Clear = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const editor = ensureSingleEditor(targets);
    const plainTargets = targets.map(
      (target) => new PlainTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: target.contentRange
      })
    );
    const { thatTargets } = await this.actions.remove.run(plainTargets);
    if (thatTargets != null) {
      await ide().getEditableTextEditor(editor).setSelections(
        thatTargets.map(({ contentSelection }) => contentSelection),
        { focusEditor: true }
      );
    }
    return { thatTargets };
  }
};

// ../cursorless-engine/src/core/commandRunner/selectionToStoredTarget.ts
var selectionToStoredTarget = (selection) => new UntypedTarget({
  editor: selection.editor,
  isReversed: selection.selection.isReversed,
  contentRange: selection.selection,
  hasExplicitRange: true
});

// ../cursorless-engine/src/actions/CallbackAction.ts
var CallbackAction = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets, options2) {
    if (options2.showDecorations) {
      await flashTargets(ide(), targets, "referenced" /* referenced */);
    }
    if (options2.ensureSingleEditor) {
      ensureSingleEditor(targets);
    }
    if (options2.ensureSingleTarget) {
      ensureSingleTarget(targets);
    }
    const originalEditor = ide().activeEditableTextEditor;
    const runOnTargets = options2.setSelection ? runOnTargetsForEachEditorSequentially : runOnTargetsForEachEditor;
    const thatTargets = flatten_default(
      await runOnTargets(
        targets,
        (editor, targets2) => this.runForEditor(options2, editor, targets2)
      )
    );
    if (options2.setSelection && options2.restoreSelection && originalEditor != null && !originalEditor.isActive) {
      await originalEditor.focus();
    }
    return { thatTargets };
  }
  async runForEditor(options2, editor, targets) {
    const editableEditor = ide().getEditableTextEditor(editor);
    const originalSelections = editor.selections;
    const originalEditorVersion = editor.document.version;
    const targetSelections = targets.map((target) => target.contentSelection);
    if (options2.setSelection) {
      await editableEditor.setSelections(targetSelections, {
        focusEditor: true,
        revealRange: false
      });
    }
    const {
      originalSelections: updatedOriginalSelections,
      targetSelections: updatedTargetSelections
    } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: editableEditor,
      callback: () => options2.callback(editableEditor, targets),
      preserveCursorSelections: true,
      selections: {
        originalSelections,
        targetSelections
      }
    });
    if (options2.setSelection && options2.restoreSelection) {
      await editableEditor.setSelections(updatedOriginalSelections);
    }
    return editor.document.version === originalEditorVersion ? targets : updatedTargetSelections.map(
      (selection) => selectionToStoredTarget({
        editor,
        selection
      })
    );
  }
};

// ../cursorless-engine/src/actions/SimpleIdeCommandActions.ts
var SimpleIdeCommandAction = class {
  constructor(rangeUpdater) {
    __publicField(this, "callbackAction");
    __publicField(this, "ensureSingleEditor", false);
    __publicField(this, "ensureSingleTarget", false);
    __publicField(this, "restoreSelection", true);
    __publicField(this, "showDecorations", true);
    this.callbackAction = new CallbackAction(rangeUpdater);
    this.run = this.run.bind(this);
  }
  async run(targets, { showDecorations } = {}) {
    const capabilities = ide().capabilities.commands[this.command];
    if (capabilities == null) {
      throw Error(`Action ${this.command} is not supported by your ide`);
    }
    const { acceptsLocation } = capabilities;
    return this.callbackAction.run(targets, {
      callback: (editor, targets2) => callback(
        editor,
        acceptsLocation ? targets2.map((t) => t.contentRange) : void 0,
        this.command
      ),
      setSelection: !acceptsLocation,
      ensureSingleEditor: this.ensureSingleEditor,
      ensureSingleTarget: this.ensureSingleTarget,
      restoreSelection: this.restoreSelection,
      showDecorations: showDecorations ?? this.showDecorations
    });
  }
};
var CopyToClipboardSimple = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "clipboardCopy");
    __publicField(this, "ensureSingleEditor", true);
  }
};
var ToggleLineComment = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "toggleLineComment");
  }
};
var IndentLineSimpleAction = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "indentLine");
  }
};
var OutdentLineSimpleAction = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "outdentLine");
  }
};
var Fold = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "fold");
  }
};
var Unfold = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "unfold");
  }
};
var Rename = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "rename");
    __publicField(this, "ensureSingleTarget", true);
  }
};
var ShowReferences = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "showReferences");
    __publicField(this, "ensureSingleTarget", true);
  }
};
var ShowQuickFix = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "quickFix");
    __publicField(this, "ensureSingleTarget", true);
  }
};
var RevealDefinition = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "revealDefinition");
    __publicField(this, "ensureSingleTarget", true);
    __publicField(this, "restoreSelection", false);
  }
};
var RevealTypeDefinition = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "revealTypeDefinition");
    __publicField(this, "ensureSingleTarget", true);
    __publicField(this, "restoreSelection", false);
  }
};
var ShowHover = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "showHover");
    __publicField(this, "ensureSingleTarget", true);
    __publicField(this, "restoreSelection", false);
  }
};
var ShowDebugHover = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "showDebugHover");
    __publicField(this, "ensureSingleTarget", true);
    __publicField(this, "restoreSelection", false);
  }
};
var ExtractVariable = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "extractVariable");
    __publicField(this, "ensureSingleTarget", true);
    __publicField(this, "restoreSelection", false);
  }
};
var GitAccept = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "gitAccept");
    __publicField(this, "ensureSingleTarget", true);
  }
};
var GitRevert = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "gitRevert");
    __publicField(this, "ensureSingleTarget", true);
  }
};
var GitStage = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "gitStage");
    __publicField(this, "ensureSingleTarget", true);
  }
};
var GitUnstage = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    __publicField(this, "command", "gitUnstage");
    __publicField(this, "ensureSingleTarget", true);
  }
};
function callback(editor, ranges, command) {
  switch (command) {
    // Multi target actions
    case "toggleLineComment":
      return editor.toggleLineComment(ranges);
    case "indentLine":
      return editor.indentLine(ranges);
    case "outdentLine":
      return editor.outdentLine(ranges);
    case "clipboardCopy":
      return editor.clipboardCopy(ranges);
    case "fold":
      return editor.fold(ranges);
    case "unfold":
      return editor.unfold(ranges);
    case "insertLineAfter":
      return editor.insertLineAfter(ranges);
    // Single target actions
    case "rename":
      return editor.rename(ranges?.[0]);
    case "showReferences":
      return editor.showReferences(ranges?.[0]);
    case "quickFix":
      return editor.quickFix(ranges?.[0]);
    case "revealDefinition":
      return editor.revealDefinition(ranges?.[0]);
    case "revealTypeDefinition":
      return editor.revealTypeDefinition(ranges?.[0]);
    case "showHover":
      return editor.showHover(ranges?.[0]);
    case "showDebugHover":
      return editor.showDebugHover(ranges?.[0]);
    case "extractVariable":
      return editor.extractVariable(ranges?.[0]);
    case "gitAccept":
      return editor.gitAccept(ranges?.[0]);
    case "gitRevert":
      return editor.gitRevert(ranges?.[0]);
    case "gitStage":
      return editor.gitStage(ranges?.[0]);
    case "gitUnstage":
      return editor.gitUnstage(ranges?.[0]);
    // Unsupported as simple action
    case "highlight":
      throw Error("Highlight command not supported as simple action");
  }
}

// ../cursorless-engine/src/actions/CopyToClipboard.ts
var CopyToClipboard = class {
  constructor(actions, rangeUpdater) {
    this.actions = actions;
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets, options2 = { showDecorations: true }) {
    if (ide().capabilities.commands.clipboardCopy != null) {
      const simpleAction = new CopyToClipboardSimple(this.rangeUpdater);
      return simpleAction.run(targets, options2);
    }
    if (options2.showDecorations) {
      await flashTargets(ide(), targets, "referenced" /* referenced */);
    }
    const text = targets.map((t) => t.contentText).join("\n");
    await ide().clipboard.writeText(text);
    return { thatTargets: targets };
  }
};

// ../cursorless-engine/src/actions/CutToClipboard.ts
var CutToClipboard = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await ide().flashRanges(targets.flatMap(getFlashDescriptors));
    const options2 = { showDecorations: false };
    await this.actions.copyToClipboard.run(targets, options2);
    const { thatTargets } = await this.actions.remove.run(targets, options2);
    return { thatTargets };
  }
};
function getFlashDescriptors(target) {
  const { editor, contentRange } = target;
  const removalHighlightRange = target.getRemovalHighlightRange();
  const flashDescriptors = [
    {
      editor,
      range: toCharacterRange(contentRange),
      style: "referenced" /* referenced */
    }
  ];
  if (removalHighlightRange.type === "line") {
    flashDescriptors.push({
      editor,
      range: removalHighlightRange,
      style: "pendingDelete" /* pendingDelete */
    });
  } else {
    flashDescriptors.push(
      ...getOutsideOverflow(contentRange, removalHighlightRange).map(
        (overflow) => ({
          editor,
          range: toCharacterRange(overflow),
          style: "pendingDelete" /* pendingDelete */
        })
      )
    );
  }
  return flashDescriptors;
}
function getOutsideOverflow(insideRange, outsideRange) {
  const { start: insideStart, end: insideEnd } = insideRange;
  const { start: outsideStart, end: outsideEnd } = outsideRange;
  const result = [];
  if (outsideStart.isBefore(insideStart)) {
    result.push(new Range(outsideStart, insideStart));
  }
  if (outsideEnd.isAfter(insideEnd)) {
    result.push(new Range(insideEnd, outsideEnd));
  }
  return result;
}

// ../cursorless-engine/src/actions/Deselect.ts
var Deselect = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
      const newSelections = editor.selections.filter(
        (selection) => !targets2.some((target) => {
          const intersection2 = target.contentRange.intersection(selection);
          return intersection2 && (!intersection2.isEmpty || selection.isEmpty);
        })
      );
      if (newSelections.length === 0) {
        throw new SelectionRequiredError();
      }
      await ide().getEditableTextEditor(editor).setSelections(newSelections);
    });
    return {
      thatTargets: targets
    };
  }
};
var SelectionRequiredError = class extends Error {
  constructor() {
    super("Can't deselect every selection. At least one is required");
    this.name = "SelectionRequiredError";
  }
};

// ../cursorless-engine/src/actions/EditNew/runEditTargets.ts
async function runEditTargets(rangeUpdater, editor, state, useAllDestinations) {
  const destinations = state.destinations.map((destination, index) => {
    if (useAllDestinations || state.actionTypes[index] === "edit") {
      return {
        destination,
        index
      };
    }
  }).filter((destination) => !!destination);
  if (destinations.length === 0) {
    return state;
  }
  const edits = destinations.map(
    (destination) => destination.destination.constructChangeEdit("")
  );
  const cursorInfos = state.cursorRanges.map((range3, index) => ({ range: range3, index })).filter(({ range: range3 }) => range3 != null);
  const cursorIndices = cursorInfos.map(({ index }) => index);
  const cursorRanges = cursorInfos.map(({ range: range3 }) => range3);
  const editRanges = edits.map((edit) => edit.range);
  const {
    thatRanges: updatedThatRanges,
    cursorRanges: updatedCursorRanges,
    editRanges: updatedEditRanges
  } = await performEditsAndUpdateSelections({
    rangeUpdater,
    editor,
    edits,
    preserveCursorSelections: true,
    selections: {
      thatRanges: state.thatRanges,
      cursorRanges,
      editRanges: {
        selections: editRanges,
        behavior: 0 /* openOpen */
      }
    }
  });
  const finalCursorRanges = [...state.cursorRanges];
  zip_default(cursorIndices, updatedCursorRanges).forEach(([index, range3]) => {
    finalCursorRanges[index] = range3;
  });
  destinations.forEach((delimiterTarget, index) => {
    const edit = edits[index];
    const range3 = edit.updateRange(updatedEditRanges[index]);
    finalCursorRanges[delimiterTarget.index] = range3;
  });
  return {
    destinations: state.destinations,
    actionTypes: state.actionTypes,
    thatRanges: updatedThatRanges,
    cursorRanges: finalCursorRanges
  };
}

// ../cursorless-engine/src/actions/EditNew/runInsertLineAfterTargets.ts
async function runInsertLineAfterTargets({ acceptsLocation }, rangeUpdater, editor, state) {
  const destinations = state.destinations.map((destination, index) => {
    const actionType = state.actionTypes[index];
    if (actionType === "insertLineAfter") {
      return {
        destination,
        index
      };
    }
  }).filter((destination) => !!destination);
  if (destinations.length === 0) {
    return state;
  }
  const contentRanges = destinations.map(
    ({ destination }) => destination.contentRange
  );
  const targetRanges = state.destinations.map(
    ({ contentRange }) => contentRange
  );
  const callback2 = async () => {
    if (acceptsLocation) {
      await editor.insertLineAfter(contentRanges);
    } else {
      await editor.setSelections(
        contentRanges.map((range3) => range3.toSelection(false))
      );
      await editor.focus();
      await editor.insertLineAfter();
    }
  };
  const { targetRanges: updatedTargetRanges, thatRanges: updatedThatRanges } = await performEditsAndUpdateSelections({
    rangeUpdater,
    editor,
    callback: callback2,
    preserveCursorSelections: true,
    selections: {
      targetRanges,
      thatRanges: state.thatRanges
    }
  });
  const cursorRanges = [...state.cursorRanges];
  destinations.forEach((commandTarget, index) => {
    cursorRanges[commandTarget.index] = editor.selections[index];
  });
  return {
    destinations: state.destinations.map(
      (destination, index) => destination.withTarget(
        destination.target.withContentRange(updatedTargetRanges[index])
      )
    ),
    actionTypes: state.actionTypes,
    thatRanges: updatedThatRanges,
    cursorRanges
  };
}

// ../cursorless-engine/src/actions/EditNew/runNotebookCellTargets.ts
async function runEditNewNotebookCellTargets(actions, destinations) {
  const destination = ensureSingleTarget(destinations);
  const editor = ide().getEditableTextEditor(destination.editor);
  const isAbove = destination.insertionMode === "before";
  if (destination.insertionMode === "to") {
    throw Error(
      `Unsupported insertion mode '${destination.insertionMode}' for notebook cell`
    );
  }
  await actions.setSelection.run([destination.target]);
  if (isAbove) {
    await editor.editNewNotebookCellAbove();
  } else {
    await editor.editNewNotebookCellBelow();
  }
  const thatMark = createThatMark([destination.target.thatTarget]);
  return { thatSelections: thatMark };
}

// ../cursorless-engine/src/actions/EditNew/EditNew.ts
var EditNew = class {
  constructor(rangeUpdater, actions) {
    this.rangeUpdater = rangeUpdater;
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(destinations) {
    if (destinations.some(({ target }) => target.isNotebookCell)) {
      return runEditNewNotebookCellTargets(this.actions, destinations);
    }
    const editableEditor = ide().getEditableTextEditor(
      ensureSingleEditor(destinations)
    );
    let state = {
      destinations,
      actionTypes: destinations.map((d) => d.getEditNewActionType()),
      thatRanges: destinations.map(
        ({ target }) => target.thatTarget.contentRange
      ),
      cursorRanges: new Array(destinations.length).fill(
        void 0
      )
    };
    const insertLineAfterCapability = ide().capabilities.commands.insertLineAfter;
    const useInsertLineAfter = insertLineAfterCapability != null;
    if (useInsertLineAfter) {
      state = await runInsertLineAfterTargets(
        insertLineAfterCapability,
        this.rangeUpdater,
        editableEditor,
        state
      );
    }
    state = await runEditTargets(
      this.rangeUpdater,
      editableEditor,
      state,
      !useInsertLineAfter
    );
    const newSelections = state.destinations.map((destination, index) => {
      const cursorRange = state.cursorRanges[index];
      if (cursorRange == null) {
        throw Error("Cursor range is undefined for destination");
      }
      return cursorRange.toSelection(destination.target.isReversed);
    });
    await editableEditor.setSelections(newSelections, { focusEditor: true });
    return {
      thatSelections: createThatMark(
        state.destinations.map((d) => d.target),
        state.thatRanges
      )
    };
  }
};

// ../cursorless-engine/src/actions/EditNewLineAction.ts
var EditNewLineAction = class {
  constructor(actions, modifierStageFactory) {
    this.actions = actions;
    this.modifierStageFactory = modifierStageFactory;
    this.run = this.run.bind(this);
  }
  getFinalStages() {
    return [this.modifierStageFactory.create(containingLineIfUntypedModifier)];
  }
  run(targets) {
    return this.actions.editNew.run(
      targets.map((target) => target.toDestination(this.insertionMode))
    );
  }
};
var EditNewBefore = class extends EditNewLineAction {
  constructor() {
    super(...arguments);
    __publicField(this, "insertionMode", "before");
  }
};
var EditNewAfter = class extends EditNewLineAction {
  constructor() {
    super(...arguments);
    __publicField(this, "insertionMode", "after");
  }
};

// ../cursorless-engine/src/actions/ExecuteCommand.ts
var ExecuteCommand = class {
  constructor(rangeUpdater) {
    __publicField(this, "callbackAction");
    this.callbackAction = new CallbackAction(rangeUpdater);
    this.run = this.run.bind(this);
  }
  async run(targets, commandId, {
    commandArgs,
    ensureSingleEditor: ensureSingleEditor3,
    ensureSingleTarget: ensureSingleTarget3,
    restoreSelection,
    showDecorations
  } = {}) {
    const args2 = commandArgs ?? [];
    return this.callbackAction.run(targets, {
      callback: () => ide().executeCommand(commandId, ...args2),
      setSelection: true,
      ensureSingleEditor: ensureSingleEditor3 ?? false,
      ensureSingleTarget: ensureSingleTarget3 ?? false,
      restoreSelection: restoreSelection ?? true,
      showDecorations: showDecorations ?? true
    });
  }
};

// ../cursorless-engine/src/actions/Find.ts
var Find = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    ensureSingleTarget(targets);
    const { returnValue, thatTargets } = await this.actions.getText.run(targets);
    const [text] = returnValue;
    let query;
    if (text.length > 200) {
      query = text.substring(0, 200);
      void showWarning(
        ide().messages,
        "truncatedSearchText",
        "Search text is longer than 200 characters; truncating"
      );
    } else {
      query = text;
    }
    await this.find(query);
    return { thatTargets };
  }
};
var FindInDocument = class extends Find {
  find(query) {
    return ide().findInDocument(query);
  }
};
var FindInWorkspace = class extends Find {
  find(query) {
    return ide().findInWorkspace(query);
  }
};

// ../cursorless-engine/src/actions/FlashTargets.ts
var FlashTargets = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await flashTargets(ide(), targets, "referenced" /* referenced */);
    return { thatTargets: targets };
  }
};

// ../cursorless-engine/src/actions/FollowLink.ts
var FollowLink = class {
  constructor(options2) {
    this.options = options2;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const target = ensureSingleTarget(targets);
    await flashTargets(ide(), targets, "referenced" /* referenced */);
    await ide().getEditableTextEditor(target.editor).openLink(target.contentRange, this.options);
    return {
      thatSelections: createThatMark(targets)
    };
  }
};

// ../../node_modules/.pnpm/talon-snippets@1.3.0/node_modules/talon-snippets/lib/esm/parser.js
function parseSnippetFile(content) {
  const documentContents = content.split(/^---$/m);
  const file2 = { snippets: [] };
  for (const text of documentContents) {
    const match = text.match(/^-$/m);
    const contextText = match != null ? text.slice(0, match.index) : text;
    const bodyText = match != null ? text.slice(match.index + match[0].length) : null;
    const body2 = bodyText ? parseBody(bodyText) : null;
    let context = parseContext(contextText);
    if (body2 != null) {
      if (context == null) {
        context = { variables: [] };
      }
      const { variables, ...rest } = context;
      file2.snippets.push({ ...rest, body: body2, variables });
    } else if (context != null) {
      if (file2.header != null || file2.snippets.length !== 0) {
        throw Error("Header snippet must be first in file");
      }
      file2.header = context;
    }
  }
  return file2;
}
function parseContext(text) {
  const document2 = { variables: [] };
  const pairs2 = parseContextPairs(text);
  if (Object.keys(pairs2).length === 0) {
    return void 0;
  }
  const variables = {};
  for (const [key, value] of Object.entries(pairs2)) {
    switch (key) {
      case "name":
        document2.name = value;
        break;
      case "description":
        document2.description = value;
        break;
      case "phrase":
        document2.phrases = parseVectorValue(value);
        break;
      case "insertionScope":
        document2.insertionScopes = parseVectorValue(value);
        break;
      case "language":
        document2.languages = parseVectorValue(value);
        break;
      default:
        if (!key.startsWith("$")) {
          throw Error(`Invalid key '${key}'`);
        }
        variables[key] = value;
    }
  }
  document2.variables = parseVariables(variables);
  return document2;
}
function parseContextPairs(text) {
  const lines = text.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
  const pairs2 = {};
  for (const line of lines) {
    const parts2 = line.split(":");
    if (parts2.length !== 2) {
      throw Error(`Invalid line '${line}'`);
    }
    const key = parts2[0].trim();
    const value = parts2[1].trim();
    if (key.length === 0 || value.length === 0) {
      throw Error(`Invalid line '${line}'`);
    }
    if (pairs2[key] != null) {
      throw Error(`Duplicate key '${key}' in '${text}'`);
    }
    pairs2[key] = value;
  }
  return pairs2;
}
function parseVariables(variables) {
  const variablesMap = {};
  const getVariable = (name2) => {
    if (variablesMap[name2] == null) {
      variablesMap[name2] = { name: name2 };
    }
    return variablesMap[name2];
  };
  for (const [key, value] of Object.entries(variables)) {
    const parts2 = key.split(".");
    if (parts2.length !== 2) {
      throw Error(`Invalid variable key '${key}'`);
    }
    const name2 = parts2[0].slice(1);
    const field = parts2[1];
    switch (field) {
      case "insertionFormatter":
        getVariable(name2).insertionFormatters = parseVectorValue(value);
        break;
      case "wrapperPhrase":
        getVariable(name2).wrapperPhrases = parseVectorValue(value);
        break;
      case "wrapperScope":
        getVariable(name2).wrapperScope = value;
        break;
      default:
        throw Error(`Invalid variable key '${key}'`);
    }
  }
  return Object.values(variablesMap);
}
function parseBody(text) {
  const matchLeading = text.match(/^[ \t]*\S/m);
  if (matchLeading?.index == null) {
    return void 0;
  }
  return text.slice(matchLeading.index).trimEnd().split(/\r?\n/).map((l) => l.trimEnd());
}
function parseVectorValue(value) {
  return value.split("|").map((v) => v.trim());
}

// ../../node_modules/.pnpm/talon-snippets@1.3.0/node_modules/talon-snippets/lib/esm/serializer.js
function serializeSnippetFile(snippetFile) {
  const documents = [];
  if (snippetFile.header != null) {
    documents.push(getDocumentText(snippetFile.header));
  }
  documents.push(...snippetFile.snippets.map(getDocumentText));
  const result = documents.filter(Boolean).join("\n---\n\n");
  return result ? result + "\n---\n" : "";
}
function getDocumentText(document2) {
  const parts2 = [
    getOptionalPairString("name", document2.name),
    getOptionalPairString("description", document2.description),
    getOptionalPairString("language", document2.languages),
    getOptionalPairString("phrase", document2.phrases),
    getOptionalPairString("insertionScope", document2.insertionScopes)
  ].filter(Boolean);
  if (document2.variables.length > 0) {
    if (parts2.length > 0) {
      parts2.push("");
    }
    parts2.push(...getSortedVariables(document2.variables));
  }
  if ("body" in document2) {
    parts2.push("-", ...document2.body);
  }
  return parts2.join("\n");
}
function getSortedVariables(variables) {
  const result = [...variables];
  result.sort(compareVariables);
  return result.flatMap((variable) => [
    getOptionalPairString(`$${variable.name}.insertionFormatter`, variable.insertionFormatters),
    getOptionalPairString(`$${variable.name}.wrapperPhrase`, variable.wrapperPhrases),
    getOptionalPairString(`$${variable.name}.wrapperScope`, variable.wrapperScope)
  ]).filter(Boolean);
}
function getOptionalPairString(key, value) {
  if (value == null) {
    return "";
  }
  if (Array.isArray(value)) {
    return `${key}: ${value.join(" | ")}`;
  }
  return `${key}: ${value}`;
}
function compareVariables(a, b) {
  if (a.name === "0") {
    return 1;
  }
  if (b.name === "0") {
    return -1;
  }
  return a.name.localeCompare(b.name);
}

// ../cursorless-engine/src/actions/GenerateSnippet/constructSnippetBody.ts
function constructSnippetBody(text, linePrefix) {
  const outputLines = [];
  let currentTabCount = 0;
  let currentIndentationString = null;
  const [firstLine, ...remainingLines] = text.split(/\r?\n/);
  const lines = [
    {
      text: linePrefix + firstLine,
      startIndex: linePrefix.length
    },
    ...remainingLines.map((line) => ({ text: line, startIndex: 0 }))
  ];
  lines.forEach(({ text: text2, startIndex }) => {
    const newIndentationString = text2.match(/^\s*/)?.[0] ?? "";
    const firstNonWhitespaceCharacterIndex = newIndentationString.length;
    if (currentIndentationString != null) {
      if (newIndentationString.length > currentIndentationString.length) {
        currentTabCount++;
      } else if (newIndentationString.length < currentIndentationString.length) {
        currentTabCount--;
      }
    }
    currentIndentationString = newIndentationString;
    const lineContentStart = Math.max(
      firstNonWhitespaceCharacterIndex,
      startIndex
    );
    const snippetIndentationString = repeat_default("	", currentTabCount);
    const lineContent = text2.slice(lineContentStart);
    outputLines.push(snippetIndentationString + lineContent);
  });
  return outputLines;
}

// ../cursorless-engine/src/actions/GenerateSnippet/editText.ts
function editText(text, edits) {
  const sortedEdits = sortBy_default(edits, (edit) => edit.offsets.start);
  let output = "";
  let currentOffset = 0;
  for (const edit of sortedEdits) {
    output += text.slice(currentOffset, edit.offsets.start) + edit.text;
    currentOffset = edit.offsets.end;
  }
  output += text.slice(currentOffset);
  return output;
}

// ../cursorless-engine/src/actions/GenerateSnippet/GenerateSnippet.ts
var GenerateSnippet = class {
  constructor(snippets) {
    this.snippets = snippets;
    this.run = this.run.bind(this);
  }
  async run(targets, directory, snippetName) {
    if (directory == null) {
      throw new Error(
        "Directory argument is required for GenerateSnippet action. Please update Cursorless Talon"
      );
    }
    const target = ensureSingleTarget(targets);
    const editor = target.editor;
    void flashTargets(ide(), targets, "referenced" /* referenced */);
    if (snippetName == null) {
      snippetName = await ide().showInputBox({
        prompt: "Name of snippet",
        placeHolder: "helloWorld"
      });
      if (!snippetName) {
        return {};
      }
    }
    const baseOffset = editor.document.offsetAt(target.contentRange.start);
    const selections = getsSnippetSelections(editor, target.contentRange);
    const variables = selections.map(
      (selection, index) => ({
        offsets: {
          start: editor.document.offsetAt(selection.start) - baseOffset,
          end: editor.document.offsetAt(selection.end) - baseOffset
        },
        name: index === selections.length - 1 ? "0" : `${index + 1}`
      })
    );
    const linePrefix = editor.document.getText(
      new Range(
        target.contentRange.start.with(void 0, 0),
        target.contentRange.start
      )
    );
    const originalText = editor.document.getText(target.contentRange);
    const snippetBodyText = editText(originalText, [
      ...matchAll(originalText, /\$|\\/g, (match) => ({
        offsets: {
          start: match.index,
          end: match.index + match[0].length
        },
        text: `\\${match[0]}`
      })),
      ...variables.map(({ offsets, name: name2 }) => ({
        offsets,
        text: `$${name2}`
      }))
    ]);
    const snippetLines = constructSnippetBody(snippetBodyText, linePrefix);
    let editableEditor;
    let snippetFile = { snippets: [] };
    if (ide().runMode === "test") {
      editableEditor = ide().getEditableTextEditor(editor);
    } else {
      editableEditor = ide().getEditableTextEditor(
        await this.snippets.openNewSnippetFile(snippetName, directory)
      );
      snippetFile = parseSnippetFile(editableEditor.document.getText());
    }
    await editableEditor.setSelections([
      editableEditor.document.range.toSelection(false)
    ]);
    let currentPlaceholderIndex = 1;
    const { header } = snippetFile;
    const phrases = snippetFile.header?.phrases != null ? void 0 : [`${PLACEHOLDER}${currentPlaceholderIndex++}`];
    const createVariable = (variable) => {
      const hasPhrase = header?.variables?.some(
        (v) => v.name === variable.name && v.wrapperPhrases != null
      );
      return {
        name: variable.name,
        wrapperPhrases: hasPhrase ? void 0 : [`${PLACEHOLDER}${currentPlaceholderIndex++}`]
      };
    };
    const snippet2 = {
      name: header?.name === snippetName ? void 0 : snippetName,
      phrases,
      languages: getSnippetLanguages(editor, header),
      body: snippetLines,
      variables: variables.map(createVariable)
    };
    snippetFile.snippets.push(snippet2);
    const metaSnippetText = serializeSnippetFile(snippetFile).replace(/\$/g, "\\$").replaceAll(PLACEHOLDER, "$");
    await editableEditor.insertSnippet(metaSnippetText);
    return {
      thatSelections: targets.map(({ editor: editor2, contentSelection }) => ({
        editor: editor2,
        selection: contentSelection
      }))
    };
  }
};
function getSnippetLanguages(editor, header) {
  if (header?.languages?.includes(editor.document.languageId)) {
    return void 0;
  }
  return [editor.document.languageId];
}
function getsSnippetSelections(editor, range3) {
  const selections = editor.selections.filter(
    (selection) => range3.contains(selection)
  );
  selections.sort((a, b) => a.start.compareTo(b.start));
  return selections;
}
var PLACEHOLDER = "PLACEHOLDER_VFA77zcbLD6wXNmfMAay";

// ../cursorless-engine/src/actions/GetTargets.ts
var GetTargets = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets) {
    return {
      returnValue: targets.map(({ contentRange }) => ({
        contentRange
      })),
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/GetText.ts
var GetText = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets, {
    showDecorations = true,
    ensureSingleTarget: doEnsureSingleTarget = false
  } = {}) {
    if (showDecorations) {
      await flashTargets(ide(), targets, "referenced" /* referenced */);
    }
    if (doEnsureSingleTarget) {
      ensureSingleTarget(targets);
    }
    return {
      returnValue: targets.map((target) => target.contentText),
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/Highlight.ts
var Highlight = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets, highlightId) {
    if (ide().capabilities.commands["highlight"] == null) {
      throw Error(`The highlight action is not supported by your ide`);
    }
    if (targets.length === 0) {
      await Promise.all(
        ide().visibleTextEditors.map(
          (editor) => ide().setHighlightRanges(highlightId, editor, [])
        )
      );
    } else {
      await runOnTargetsForEachEditor(
        targets,
        (editor, targets2) => ide().setHighlightRanges(
          highlightId,
          editor,
          targets2.map(
            (target) => toGeneralizedRange(target, target.contentRange)
          )
        )
      );
    }
    return {
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/IndentLine.ts
var IndentLineBase = class {
  constructor(rangeUpdater, isIndent) {
    this.rangeUpdater = rangeUpdater;
    this.isIndent = isIndent;
    this.run = this.run.bind(this);
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(targets) {
    if (this.hasCapability()) {
      return this.runSimpleCommandAction(targets);
    }
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const thatTargets = flatten_default(
      await runOnTargetsForEachEditor(targets, this.runForEditor)
    );
    return { thatTargets };
  }
  hasCapability() {
    return this.isIndent ? ide().capabilities.commands.indentLine != null : ide().capabilities.commands.outdentLine != null;
  }
  runSimpleCommandAction(targets) {
    const action = this.isIndent ? new IndentLineSimpleAction(this.rangeUpdater) : new OutdentLineSimpleAction(this.rangeUpdater);
    return action.run(targets);
  }
  async runForEditor(editor, targets) {
    const edits = this.isIndent ? getIndentEdits(editor, targets) : getOutdentEdits(editor, targets);
    const { targetSelections: updatedTargetSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: ide().getEditableTextEditor(editor),
      edits,
      selections: {
        targetSelections: targets.map(
          ({ contentSelection }) => contentSelection
        )
      }
    });
    return zip_default(targets, updatedTargetSelections).map(
      ([target, range3]) => selectionToStoredTarget({
        editor,
        selection: range3.toSelection(target.isReversed)
      })
    );
  }
};
var IndentLine = class extends IndentLineBase {
  constructor(rangeUpdater) {
    super(rangeUpdater, true);
  }
};
var OutdentLine = class extends IndentLineBase {
  constructor(rangeUpdater) {
    super(rangeUpdater, false);
  }
};
function getIndentEdits(editor, targets) {
  const { document: document2 } = editor;
  const lineNumbers = getLineNumbers(targets);
  const indent = getIndent(editor);
  return lineNumbers.map((lineNumber) => {
    const line = document2.lineAt(lineNumber);
    return {
      range: line.range.start.toEmptyRange(),
      text: indent
    };
  });
}
function getOutdentEdits(editor, targets) {
  const { document: document2 } = editor;
  const lineNumbers = getLineNumbers(targets);
  const regex = getRegex(editor);
  return lineNumbers.map((lineNumber) => {
    const line = document2.lineAt(lineNumber);
    const match = line.text.match(regex);
    const { start: start2 } = line.range;
    const end = start2.translate(void 0, match?.[0].length);
    return {
      range: new Range(start2, end),
      text: ""
    };
  });
}
function getLineNumbers(targets) {
  const lineNumbers = /* @__PURE__ */ new Set();
  for (const target of targets) {
    const { start: start2, end } = target.contentRange;
    for (let i2 = start2.line; i2 <= end.line; ++i2) {
      lineNumbers.add(i2);
    }
  }
  return [...lineNumbers];
}
function getIndent(editor) {
  if (editor.options.insertSpaces) {
    const tabSize = getTabSize(editor);
    return " ".repeat(tabSize);
  }
  return "	";
}
function getRegex(editor) {
  if (editor.options.insertSpaces) {
    const tabSize = getTabSize(editor);
    return new RegExp(`^[ ]{1,${tabSize}}`);
  }
  return /^\t/;
}
function getTabSize(editor) {
  return typeof editor.options.tabSize === "number" ? editor.options.tabSize : 4;
}

// ../cursorless-engine/src/actions/InsertCopy.ts
var InsertCopy = class {
  constructor(rangeUpdater, modifierStageFactory, isBefore) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.isBefore = isBefore;
    __publicField(this, "getFinalStages", () => [
      this.modifierStageFactory.create(containingLineIfUntypedModifier)
    ]);
    this.run = this.run.bind(this);
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(targets) {
    const results = flatten_default(
      await runOnTargetsForEachEditor(targets, this.runForEditor)
    );
    await ide().flashRanges(
      results.flatMap(
        (result) => result.thatMark.map((that) => ({
          editor: that.editor,
          range: toCharacterRange(that.selection),
          style: "justAdded" /* justAdded */
        }))
      )
    );
    return {
      sourceSelections: results.flatMap(({ sourceMark }) => sourceMark),
      thatSelections: results.flatMap(({ thatMark }) => thatMark)
    };
  }
  async runForEditor(editor, targets) {
    const position = this.isBefore ? "after" : "before";
    const edits = targets.flatMap(
      (target) => target.toDestination(position).constructChangeEdit(target.contentText)
    );
    const contentSelections = targets.map(
      ({ contentSelection }) => contentSelection
    );
    const editRanges = edits.map(({ range: range3 }) => range3);
    const editableEditor = ide().getEditableTextEditor(editor);
    const {
      contentSelections: updatedContentSelections,
      editRanges: updatedEditRanges
    } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: editableEditor,
      edits,
      selections: {
        contentSelections,
        editRanges: {
          selections: editRanges,
          behavior: 0 /* openOpen */
        }
      }
    });
    const insertionRanges = zip_default(edits, updatedEditRanges).map(
      ([edit, range3]) => edit.updateRange(range3)
    );
    const primarySelection = editor.selections[0];
    if (updatedContentSelections.some(
      (selection) => selection.intersection(primarySelection) != null
    )) {
      await editableEditor.revealRange(primarySelection);
    }
    return {
      sourceMark: createThatMark(targets, insertionRanges),
      thatMark: createThatMark(targets, updatedContentSelections)
    };
  }
};
var CopyContentBefore = class extends InsertCopy {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory, true);
  }
};
var CopyContentAfter = class extends InsertCopy {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory, false);
  }
};

// ../cursorless-engine/src/actions/InsertEmptyLines.ts
var InsertEmptyLines = class {
  constructor(rangeUpdater, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.run = this.run.bind(this);
  }
  getFinalStages() {
    return [this.modifierStageFactory.create(containingLineIfUntypedModifier)];
  }
  async run(targets) {
    const results = await runOnTargetsForEachEditor(
      targets,
      async (editor, targets2) => {
        const edits = this.getEdits(targets2);
        const contentSelections = targets2.map(
          (target) => target.thatTarget.contentSelection
        );
        const {
          contentSelections: updatedThatSelections,
          editRanges: updatedEditRanges
        } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits,
          selections: {
            contentSelections,
            editRanges: {
              selections: edits.map((edit) => edit.range),
              behavior: 0 /* openOpen */
            }
          }
        });
        return {
          thatMark: updatedThatSelections.map((selection) => ({
            editor,
            selection
          })),
          flashRanges: zipStrict(edits, updatedEditRanges).map(
            ([edit, editRange]) => ({
              editor,
              // Exclude the new line delimiter from the range for line edits
              range: edit.isLine ? edit.updateRange(editRange) : editRange,
              isLine: edit.isLine
            })
          )
        };
      }
    );
    await ide().flashRanges(
      results.flatMap(
        (result) => result.flashRanges.map(({ editor, range: range3, isLine }) => ({
          editor,
          range: isLine ? toLineRange(range3) : toCharacterRange(range3),
          style: "justAdded" /* justAdded */
        }))
      )
    );
    const thatMark = results.flatMap((result) => result.thatMark);
    return { thatSelections: thatMark };
  }
};
var InsertEmptyLinesAround = class extends InsertEmptyLines {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory);
  }
  getEdits(targets) {
    return targets.flatMap((target) => [
      constructChangeEdit(target, "before"),
      constructChangeEdit(target, "after")
    ]);
  }
};
var InsertEmptyLineAbove = class extends InsertEmptyLines {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory);
  }
  getEdits(targets) {
    return targets.map((target) => constructChangeEdit(target, "before"));
  }
};
var InsertEmptyLineBelow = class extends InsertEmptyLines {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory);
  }
  getEdits(targets) {
    return targets.map((target) => constructChangeEdit(target, "after"));
  }
};
function constructChangeEdit(target, insertionMode2) {
  return {
    ...target.toDestination(insertionMode2).constructChangeEdit("", true),
    isLine: target.textualType === "line"
  };
}

// ../cursorless-engine/src/core/getPreferredSnippet.ts
function getPreferredSnippet(snippetDescription, languageId) {
  if (snippetDescription.type === "named") {
    throw new NamedSnippetsDeprecationError();
  }
  if (snippetDescription.type === "custom") {
    return snippetDescription;
  }
  const preferredSnippet = tryToFindPreferredSnippet(
    snippetDescription.snippets,
    languageId,
    snippetDescription.fallbackLanguage
  );
  if (preferredSnippet == null) {
    const languages = getUniqueLanguagesString(snippetDescription.snippets);
    throw new Error(
      `No snippet available for language '${languageId}'. Available languages: ${languages}`
    );
  }
  return preferredSnippet;
}
function getUniqueLanguagesString(snippets) {
  const languages = new Set(
    snippets.flatMap((snippet2) => snippet2.languages ?? [])
  );
  return Array.from(languages).sort().join(", ");
}
function tryToFindPreferredSnippet(snippetDescriptions, languageId, fallbackLanguage) {
  let snippet2 = findSnippetWithFewestLanguages(
    snippetDescriptions.filter((snippetDescription) => {
      return snippetDescription.languages?.includes(languageId);
    })
  );
  if (snippet2 == null && fallbackLanguage != null) {
    snippet2 = findSnippetWithFewestLanguages(
      snippetDescriptions.filter((snippetDescription) => {
        return snippetDescription.languages?.includes(fallbackLanguage);
      })
    );
  }
  if (snippet2 == null) {
    snippet2 = snippetDescriptions.find((snippetDescription) => {
      return snippetDescription.languages == null;
    });
  }
  return snippet2;
}
function findSnippetWithFewestLanguages(snippets) {
  if (snippets.length === 0) {
    return void 0;
  }
  return snippets.reduce((prev, curr) => {
    if (prev.languages == null || curr.languages == null) {
      throw Error(
        "Snippet must have languages defined to find the one with the fewest languages"
      );
    }
    return curr.languages.length < prev.languages.length ? curr : prev;
  });
}

// ../cursorless-engine/src/snippets/vendor/vscodeSnippet/snippetParser.ts
var _Scanner = class _Scanner {
  constructor() {
    __publicField(this, "value", "");
    __publicField(this, "pos", 0);
  }
  static isDigitCharacter(ch) {
    return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;
  }
  static isVariableCharacter(ch) {
    return ch === 95 /* Underline */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 65 /* A */ && ch <= 90 /* Z */;
  }
  text(value) {
    this.value = value;
    this.pos = 0;
  }
  tokenText(token) {
    return this.value.substr(token.pos, token.len);
  }
  next() {
    if (this.pos >= this.value.length) {
      return { type: 14 /* EOF */, pos: this.pos, len: 0 };
    }
    let pos = this.pos;
    let len = 0;
    let ch = this.value.charCodeAt(pos);
    let type2;
    type2 = _Scanner._table[ch];
    if (typeof type2 === "number") {
      this.pos += 1;
      return { type: type2, pos, len: 1 };
    }
    if (_Scanner.isDigitCharacter(ch)) {
      type2 = 8 /* Int */;
      do {
        len += 1;
        ch = this.value.charCodeAt(pos + len);
      } while (_Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type: type2, pos, len };
    }
    if (_Scanner.isVariableCharacter(ch)) {
      type2 = 9 /* VariableName */;
      do {
        ch = this.value.charCodeAt(pos + ++len);
      } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type: type2, pos, len };
    }
    type2 = 10 /* Format */;
    do {
      len += 1;
      ch = this.value.charCodeAt(pos + len);
    } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
    this.pos += len;
    return { type: type2, pos, len };
  }
};
__publicField(_Scanner, "_table", {
  [36 /* DollarSign */]: 0 /* Dollar */,
  [58 /* Colon */]: 1 /* Colon */,
  [44 /* Comma */]: 2 /* Comma */,
  [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,
  [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,
  [92 /* Backslash */]: 5 /* Backslash */,
  [47 /* Slash */]: 6 /* Forwardslash */,
  [124 /* Pipe */]: 7 /* Pipe */,
  [43 /* Plus */]: 11 /* Plus */,
  [45 /* Dash */]: 12 /* Dash */,
  [63 /* QuestionMark */]: 13 /* QuestionMark */
});
var Scanner = _Scanner;
var Marker = class {
  constructor() {
    __publicField(this, "_markerBrand");
    __publicField(this, "parent");
    __publicField(this, "_children", []);
  }
  appendChild(child) {
    if (child instanceof Text2 && this._children[this._children.length - 1] instanceof Text2) {
      this._children[this._children.length - 1].value += child.value;
    } else {
      child.parent = this;
      this._children.push(child);
    }
    return this;
  }
  replace(child, others) {
    const { parent } = child;
    const idx = parent.children.indexOf(child);
    const newChildren = parent.children.slice(0);
    newChildren.splice(idx, 1, ...others);
    parent._children = newChildren;
    (function _fixParent(children, parent2) {
      for (const child2 of children) {
        child2.parent = parent2;
        _fixParent(child2.children, child2);
      }
    })(others, parent);
  }
  get children() {
    return this._children;
  }
  get snippet() {
    let candidate = this;
    while (true) {
      if (!candidate) {
        return void 0;
      }
      if (candidate instanceof TextmateSnippet) {
        return candidate;
      }
      candidate = candidate.parent;
    }
  }
  toString() {
    return this.children.reduce((prev, cur) => prev + cur.toString(), "");
  }
  len() {
    return 0;
  }
};
var Text2 = class _Text extends Marker {
  constructor(value) {
    super();
    this.value = value;
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  toString() {
    return this.value;
  }
  toTextmateString() {
    return _Text.escape(this.value);
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new _Text(this.value);
  }
};
var TransformableMarker = class extends Marker {
  constructor() {
    super(...arguments);
    __publicField(this, "transform");
  }
};
var Placeholder = class _Placeholder extends TransformableMarker {
  constructor(index) {
    super();
    this.index = index;
  }
  static compareByIndex(a, b) {
    if (a.index === b.index) {
      return 0;
    } else if (a.isFinalTabstop) {
      return 1;
    } else if (b.isFinalTabstop) {
      return -1;
    } else if (a.index < b.index) {
      return -1;
    } else if (a.index > b.index) {
      return 1;
    } else {
      return 0;
    }
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
  }
  toTextmateString() {
    let transformString = "";
    if (this.transform) {
      transformString = this.transform.toTextmateString();
    }
    if (this.children.length === 0 && !this.transform) {
      return `$${this.index}`;
    } else if (this.children.length === 0) {
      return `\${${this.index}${transformString}}`;
    } else if (this.choice) {
      return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
    } else {
      return `\${${this.index}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
    }
  }
  clone() {
    let ret = new _Placeholder(this.index);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var Choice = class _Choice extends Marker {
  constructor() {
    super(...arguments);
    __publicField(this, "options", []);
  }
  appendChild(marker) {
    if (marker instanceof Text2) {
      marker.parent = this;
      this.options.push(marker);
    }
    return this;
  }
  toString() {
    return this.options[0].value;
  }
  toTextmateString() {
    return this.options.map((option) => option.value.replace(/\||,|\\/g, "\\$&")).join(",");
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    let ret = new _Choice();
    this.options.forEach(ret.appendChild, ret);
    return ret;
  }
};
var Transform = class _Transform extends Marker {
  constructor() {
    super(...arguments);
    __publicField(this, "regexp", new RegExp(""));
  }
  resolve(value) {
    const _this = this;
    let didMatch = false;
    let ret = value.replace(this.regexp, function() {
      didMatch = true;
      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
      ret = this._replace([]);
    }
    return ret;
  }
  _replace(groups) {
    let ret = "";
    for (const marker of this._children) {
      if (marker instanceof FormatString) {
        let value = groups[marker.index] || "";
        value = marker.resolve(value);
        ret += value;
      } else {
        ret += marker.toString();
      }
    }
    return ret;
  }
  toString() {
    return "";
  }
  toTextmateString() {
    return `/${this.regexp.source}/${this.children.map((c) => c.toTextmateString())}/${(this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")}`;
  }
  clone() {
    let ret = new _Transform();
    ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var FormatString = class _FormatString extends Marker {
  constructor(index, shorthandName, ifValue, elseValue) {
    super();
    this.index = index;
    this.shorthandName = shorthandName;
    this.ifValue = ifValue;
    this.elseValue = elseValue;
  }
  resolve(value) {
    if (this.shorthandName === "upcase") {
      return !value ? "" : value.toLocaleUpperCase();
    } else if (this.shorthandName === "downcase") {
      return !value ? "" : value.toLocaleLowerCase();
    } else if (this.shorthandName === "capitalize") {
      return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
    } else if (this.shorthandName === "pascalcase") {
      return !value ? "" : this._toPascalCase(value);
    } else if (this.shorthandName === "camelcase") {
      return !value ? "" : this._toCamelCase(value);
    } else if (Boolean(value) && typeof this.ifValue === "string") {
      return this.ifValue;
    } else if (!Boolean(value) && typeof this.elseValue === "string") {
      return this.elseValue;
    } else {
      return value || "";
    }
  }
  _toPascalCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word) => {
      return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
    }).join("");
  }
  _toCamelCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word, index) => {
      if (index === 0) {
        return word.toLowerCase();
      } else {
        return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
      }
    }).join("");
  }
  toTextmateString() {
    let value = "${";
    value += this.index;
    if (this.shorthandName) {
      value += `:/${this.shorthandName}`;
    } else if (this.ifValue && this.elseValue) {
      value += `:?${this.ifValue}:${this.elseValue}`;
    } else if (this.ifValue) {
      value += `:+${this.ifValue}`;
    } else if (this.elseValue) {
      value += `:-${this.elseValue}`;
    }
    value += "}";
    return value;
  }
  clone() {
    let ret = new _FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
    return ret;
  }
};
var Variable = class _Variable extends TransformableMarker {
  constructor(name2) {
    super();
    this.name = name2;
  }
  resolve(resolver) {
    let value = resolver.resolve(this);
    if (this.transform) {
      value = this.transform.resolve(value || "");
    }
    if (value !== void 0) {
      this._children = [new Text2(value)];
      return true;
    }
    return false;
  }
  toTextmateString() {
    let transformString = "";
    if (this.transform) {
      transformString = this.transform.toTextmateString();
    }
    if (this.children.length === 0) {
      return `\${${this.name}${transformString}}`;
    } else {
      return `\${${this.name}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
    }
  }
  clone() {
    const ret = new _Variable(this.name);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var TextmateSnippet = class _TextmateSnippet extends Marker {
  constructor() {
    super(...arguments);
    __publicField(this, "_placeholders");
  }
  get placeholderInfo() {
    if (!this._placeholders) {
      let all = [];
      let last2;
      this.walk(function(candidate) {
        if (candidate instanceof Placeholder) {
          all.push(candidate);
          last2 = !last2 || last2.index < candidate.index ? candidate : last2;
        }
        return true;
      });
      this._placeholders = { all, last: last2 };
    }
    return this._placeholders;
  }
  get placeholders() {
    const { all } = this.placeholderInfo;
    return all;
  }
  offset(marker) {
    let pos = 0;
    let found = false;
    this.walk((candidate) => {
      if (candidate === marker) {
        found = true;
        return false;
      }
      pos += candidate.len();
      return true;
    });
    if (!found) {
      return -1;
    }
    return pos;
  }
  fullLen(marker) {
    let ret = 0;
    walk([marker], (marker2) => {
      ret += marker2.len();
      return true;
    });
    return ret;
  }
  enclosingPlaceholders(placeholder) {
    let ret = [];
    let { parent } = placeholder;
    while (parent) {
      if (parent instanceof Placeholder) {
        ret.push(parent);
      }
      parent = parent.parent;
    }
    return ret;
  }
  resolveVariables(resolver) {
    this.walk((candidate) => {
      if (candidate instanceof Variable) {
        if (candidate.resolve(resolver)) {
          this._placeholders = void 0;
        }
      }
      return true;
    });
    return this;
  }
  appendChild(child) {
    this._placeholders = void 0;
    return super.appendChild(child);
  }
  replace(child, others) {
    this._placeholders = void 0;
    return super.replace(child, others);
  }
  toTextmateString() {
    return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), "");
  }
  clone() {
    let ret = new _TextmateSnippet();
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
  walk(visitor) {
    walk(this.children, visitor);
  }
};
var SnippetParser = class {
  constructor() {
    __publicField(this, "_scanner", new Scanner());
    __publicField(this, "_token", { type: 14 /* EOF */, pos: 0, len: 0 });
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(template) {
    return /\${?CLIPBOARD/.test(template);
  }
  text(value) {
    return this.parse(value).toString();
  }
  parse(value, insertFinalTabstop, enforceFinalTabstop) {
    this._scanner.text(value);
    this._token = this._scanner.next();
    const snippet2 = new TextmateSnippet();
    while (this._parse(snippet2)) {
    }
    const placeholderDefaultValues = /* @__PURE__ */ new Map();
    const incompletePlaceholders = [];
    let placeholderCount = 0;
    snippet2.walk((marker) => {
      if (marker instanceof Placeholder) {
        placeholderCount += 1;
        if (marker.isFinalTabstop) {
          placeholderDefaultValues.set(0, void 0);
        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
          placeholderDefaultValues.set(marker.index, marker.children);
        } else {
          incompletePlaceholders.push(marker);
        }
      }
      return true;
    });
    for (const placeholder of incompletePlaceholders) {
      const defaultValues = placeholderDefaultValues.get(placeholder.index);
      if (defaultValues) {
        const clone3 = new Placeholder(placeholder.index);
        clone3.transform = placeholder.transform;
        for (const child of defaultValues) {
          clone3.appendChild(child.clone());
        }
        snippet2.replace(placeholder, [clone3]);
      }
    }
    if (!enforceFinalTabstop) {
      enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;
    }
    if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {
      snippet2.appendChild(new Placeholder(0));
    }
    return snippet2;
  }
  _accept(type2, value) {
    if (type2 === void 0 || this._token.type === type2) {
      let ret = !value ? true : this._scanner.tokenText(this._token);
      this._token = this._scanner.next();
      return ret;
    }
    return false;
  }
  _backTo(token) {
    this._scanner.pos = token.pos + token.len;
    this._token = token;
    return false;
  }
  _until(type2) {
    const start2 = this._token;
    while (this._token.type !== type2) {
      if (this._token.type === 14 /* EOF */) {
        return false;
      } else if (this._token.type === 5 /* Backslash */) {
        const nextToken = this._scanner.next();
        if (nextToken.type !== 0 /* Dollar */ && nextToken.type !== 4 /* CurlyClose */ && nextToken.type !== 5 /* Backslash */) {
          return false;
        }
      }
      this._token = this._scanner.next();
    }
    const value = this._scanner.value.substring(start2.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    this._token = this._scanner.next();
    return value;
  }
  _parse(marker) {
    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
  }
  // \$, \\, \} -> just text
  _parseEscaped(marker) {
    let value;
    if (value = this._accept(5 /* Backslash */, true)) {
      value = this._accept(0 /* Dollar */, true) || this._accept(4 /* CurlyClose */, true) || this._accept(5 /* Backslash */, true) || value;
      marker.appendChild(new Text2(value));
      return true;
    }
    return false;
  }
  // $foo -> variable, $1 -> tabstop
  _parseTabstopOrVariableName(parent) {
    let value;
    const token = this._token;
    const match = this._accept(0 /* Dollar */) && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));
    if (!match) {
      return this._backTo(token);
    }
    parent.appendChild(
      /^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value)
    );
    return true;
  }
  // ${1:<children>}, ${1} -> placeholder
  _parseComplexPlaceholder(parent) {
    let index;
    const token = this._token;
    const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (index = this._accept(8 /* Int */, true));
    if (!match) {
      return this._backTo(token);
    }
    const placeholder = new Placeholder(Number(index));
    if (this._accept(1 /* Colon */)) {
      while (true) {
        if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(placeholder);
          return true;
        }
        if (this._parse(placeholder)) {
          continue;
        }
        parent.appendChild(new Text2("${" + index + ":"));
        placeholder.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {
      const choice = new Choice();
      while (true) {
        if (this._parseChoiceElement(choice)) {
          if (this._accept(2 /* Comma */)) {
            continue;
          }
          if (this._accept(7 /* Pipe */)) {
            placeholder.appendChild(choice);
            if (this._accept(4 /* CurlyClose */)) {
              parent.appendChild(placeholder);
              return true;
            }
          }
        }
        this._backTo(token);
        return false;
      }
    } else if (this._accept(6 /* Forwardslash */)) {
      if (this._parseTransform(placeholder)) {
        parent.appendChild(placeholder);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4 /* CurlyClose */)) {
      parent.appendChild(placeholder);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseChoiceElement(parent) {
    const token = this._token;
    const values2 = [];
    while (true) {
      if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {
        break;
      }
      let value;
      if (value = this._accept(5 /* Backslash */, true)) {
        value = this._accept(2 /* Comma */, true) || this._accept(7 /* Pipe */, true) || this._accept(5 /* Backslash */, true) || value;
      } else {
        value = this._accept(void 0, true);
      }
      if (!value) {
        this._backTo(token);
        return false;
      }
      values2.push(value);
    }
    if (values2.length === 0) {
      this._backTo(token);
      return false;
    }
    parent.appendChild(new Text2(values2.join("")));
    return true;
  }
  // ${foo:<children>}, ${foo} -> variable
  _parseComplexVariable(parent) {
    let name2;
    const token = this._token;
    const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (name2 = this._accept(9 /* VariableName */, true));
    if (!match) {
      return this._backTo(token);
    }
    const variable = new Variable(name2);
    if (this._accept(1 /* Colon */)) {
      while (true) {
        if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(variable);
          return true;
        }
        if (this._parse(variable)) {
          continue;
        }
        parent.appendChild(new Text2("${" + name2 + ":"));
        variable.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (this._accept(6 /* Forwardslash */)) {
      if (this._parseTransform(variable)) {
        parent.appendChild(variable);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4 /* CurlyClose */)) {
      parent.appendChild(variable);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseTransform(parent) {
    let transform2 = new Transform();
    let regexValue = "";
    let regexOptions = "";
    while (true) {
      if (this._accept(6 /* Forwardslash */)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5 /* Backslash */, true)) {
        escaped = this._accept(6 /* Forwardslash */, true) || escaped;
        regexValue += escaped;
        continue;
      }
      if (this._token.type !== 14 /* EOF */) {
        regexValue += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(6 /* Forwardslash */)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5 /* Backslash */, true)) {
        escaped = this._accept(5 /* Backslash */, true) || this._accept(6 /* Forwardslash */, true) || escaped;
        transform2.appendChild(new Text2(escaped));
        continue;
      }
      if (this._parseFormatString(transform2) || this._parseAnything(transform2)) {
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(4 /* CurlyClose */)) {
        break;
      }
      if (this._token.type !== 14 /* EOF */) {
        regexOptions += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    try {
      transform2.regexp = new RegExp(regexValue, regexOptions);
    } catch (e) {
      return false;
    }
    parent.transform = transform2;
    return true;
  }
  _parseFormatString(parent) {
    const token = this._token;
    if (!this._accept(0 /* Dollar */)) {
      return false;
    }
    let complex = false;
    if (this._accept(3 /* CurlyOpen */)) {
      complex = true;
    }
    let index = this._accept(8 /* Int */, true);
    if (!index) {
      this._backTo(token);
      return false;
    } else if (!complex) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (this._accept(4 /* CurlyClose */)) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (!this._accept(1 /* Colon */)) {
      this._backTo(token);
      return false;
    }
    if (this._accept(6 /* Forwardslash */)) {
      let shorthand = this._accept(9 /* VariableName */, true);
      if (!shorthand || !this._accept(4 /* CurlyClose */)) {
        this._backTo(token);
        return false;
      } else {
        parent.appendChild(new FormatString(Number(index), shorthand));
        return true;
      }
    } else if (this._accept(11 /* Plus */)) {
      let ifValue = this._until(4 /* CurlyClose */);
      if (ifValue) {
        parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
        return true;
      }
    } else if (this._accept(12 /* Dash */)) {
      let elseValue = this._until(4 /* CurlyClose */);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    } else if (this._accept(13 /* QuestionMark */)) {
      let ifValue = this._until(1 /* Colon */);
      if (ifValue) {
        let elseValue = this._until(4 /* CurlyClose */);
        if (elseValue) {
          parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
          return true;
        }
      }
    } else {
      let elseValue = this._until(4 /* CurlyClose */);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    }
    this._backTo(token);
    return false;
  }
  _parseAnything(marker) {
    if (this._token.type !== 14 /* EOF */) {
      marker.appendChild(new Text2(this._scanner.tokenText(this._token)));
      this._accept(void 0);
      return true;
    }
    return false;
  }
};

// ../cursorless-engine/src/snippets/vendor/vscodeSnippet/snippetVariables.ts
var KnownSnippetVariableNames = Object.freeze({
  "CURRENT_YEAR": true,
  "CURRENT_YEAR_SHORT": true,
  "CURRENT_MONTH": true,
  "CURRENT_DATE": true,
  "CURRENT_HOUR": true,
  "CURRENT_MINUTE": true,
  "CURRENT_SECOND": true,
  "CURRENT_DAY_NAME": true,
  "CURRENT_DAY_NAME_SHORT": true,
  "CURRENT_MONTH_NAME": true,
  "CURRENT_MONTH_NAME_SHORT": true,
  "CURRENT_SECONDS_UNIX": true,
  "SELECTION": true,
  "CLIPBOARD": true,
  "TM_SELECTED_TEXT": true,
  "TM_CURRENT_LINE": true,
  "TM_CURRENT_WORD": true,
  "TM_LINE_INDEX": true,
  "TM_LINE_NUMBER": true,
  "TM_FILENAME": true,
  "TM_FILENAME_BASE": true,
  "TM_DIRECTORY": true,
  "TM_FILEPATH": true,
  "RELATIVE_FILEPATH": true,
  "BLOCK_COMMENT_START": true,
  "BLOCK_COMMENT_END": true,
  "LINE_COMMENT": true,
  "WORKSPACE_NAME": true,
  "WORKSPACE_FOLDER": true,
  "RANDOM": true,
  "RANDOM_HEX": true,
  "UUID": true
});

// ../cursorless-engine/src/snippets/transformSnippetVariables.ts
function transformSnippetVariables(parsedSnippet, placeholderName, substitutions) {
  let nextPlaceholderIndex = getMaxPlaceholderIndex(parsedSnippet) + 1;
  const placeholderIndexMap = {};
  parsedSnippet.walk((candidate) => {
    if (candidate instanceof Variable) {
      if (candidate.name === placeholderName) {
        candidate.name = "TM_SELECTED_TEXT";
      } else if (substitutions != null && Object.prototype.hasOwnProperty.call(substitutions, candidate.name)) {
        candidate.parent.replace(candidate, [
          new Text2(substitutions[candidate.name])
        ]);
      } else if (!KnownSnippetVariableNames[candidate.name]) {
        let placeholderIndex;
        if (candidate.name in placeholderIndexMap) {
          placeholderIndex = placeholderIndexMap[candidate.name];
        } else {
          placeholderIndex = nextPlaceholderIndex++;
          placeholderIndexMap[candidate.name] = placeholderIndex;
        }
        const placeholder = new Placeholder(placeholderIndex);
        candidate.children.forEach((child) => placeholder.appendChild(child));
        candidate.parent.replace(candidate, [placeholder]);
      }
    } else if (candidate instanceof Placeholder) {
      if (candidate.index.toString() === placeholderName) {
        candidate.parent.replace(candidate, [new Variable("TM_SELECTED_TEXT")]);
      } else if (substitutions != null && Object.prototype.hasOwnProperty.call(substitutions, candidate.index)) {
        candidate.parent.replace(candidate, [
          new Text2(substitutions[candidate.index])
        ]);
      }
    }
    return true;
  });
}
function getMaxPlaceholderIndex(parsedSnippet) {
  let placeholderIndex = 0;
  parsedSnippet.walk((candidate) => {
    if (candidate instanceof Placeholder) {
      placeholderIndex = Math.max(placeholderIndex, candidate.index);
    }
    return true;
  });
  return placeholderIndex;
}

// ../cursorless-engine/src/actions/InsertSnippet.ts
var InsertSnippet = class {
  constructor(rangeUpdater, actions, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.actions = actions;
    this.modifierStageFactory = modifierStageFactory;
    __publicField(this, "snippetParser", new SnippetParser());
    this.run = this.run.bind(this);
  }
  getFinalStages(destinations, snippetDescription) {
    const editor = ensureSingleEditor(destinations);
    const snippet2 = getPreferredSnippet(
      snippetDescription,
      editor.document.languageId
    );
    const defaultScopeTypes = snippet2.scopeTypes ?? [];
    return defaultScopeTypes.length === 0 ? [] : [
      new ModifyIfUntypedExplicitStage(this.modifierStageFactory, {
        type: "fallback",
        modifiers: defaultScopeTypes.map((scopeType) => ({
          type: "containingScope",
          scopeType
        }))
      })
    ];
  }
  async run(destinations, snippetDescription) {
    if (snippetDescription.type === "named") {
      throw new NamedSnippetsDeprecationError();
    }
    const editor = ide().getEditableTextEditor(
      ensureSingleEditor(destinations)
    );
    const snippet2 = getPreferredSnippet(
      snippetDescription,
      editor.document.languageId
    );
    const parsedSnippet = this.snippetParser.parse(snippet2.body);
    const substitutions = snippet2.substitutions ?? snippetDescription.substitutions;
    transformSnippetVariables(parsedSnippet, null, substitutions);
    const snippetString = parsedSnippet.toTextmateString();
    await this.actions.editNew.run(destinations);
    const { editorSelections: updatedThatSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      callback: () => editor.insertSnippet(snippetString),
      preserveCursorSelections: true,
      selections: {
        editorSelections: {
          selections: editor.selections,
          behavior: 0 /* openOpen */
        }
      }
    });
    return {
      thatSelections: updatedThatSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
};

// ../cursorless-engine/src/actions/JoinLines.ts
var JoinLines = class {
  constructor(rangeUpdater, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.run = this.run.bind(this);
  }
  getFinalStages() {
    return [this.modifierStageFactory.create(containingLineIfUntypedModifier)];
  }
  async run(targets) {
    await flashTargets(
      ide(),
      targets.map(({ thatTarget }) => thatTarget),
      "pendingModification0" /* pendingModification0 */
    );
    const thatSelections = flatten_default(
      await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
        const { thatRanges: updatedThatRanges } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits: getEdits2(editor, targets2),
          selections: {
            thatRanges: targets2.map(({ contentRange }) => contentRange)
          }
        });
        return zipStrict(targets2, updatedThatRanges).map(([target, range3]) => ({
          editor,
          selection: range3.toSelection(target.isReversed)
        }));
      })
    );
    return { thatSelections };
  }
};
function getEdits2(editor, targets) {
  const edits = [];
  for (const target of targets) {
    const targetsEdits = target.textualType === "token" ? getTokenTargetEdits(target) : getLineTargetEdits(target);
    edits.push(...targetsEdits);
  }
  return edits;
}
function getTokenTargetEdits(target) {
  const { editor, contentRange } = target;
  const regex = getMatcher(editor.document.languageId).tokenMatcher;
  const matches = generateMatchesInRange(
    regex,
    editor,
    contentRange,
    "forward"
  );
  return Array.from(pairwise(matches)).map(
    ([range1, range22]) => ({
      range: new Range(range1.end, range22.start),
      text: "",
      isReplace: true
    })
  );
}
function getLineTargetEdits(target) {
  const { document: document2 } = target.editor;
  const range3 = target.contentRange;
  const startLine = range3.start.line;
  const endLine = range3.isSingleLine ? Math.min(startLine + 1, document2.lineCount - 1) : range3.end.line;
  const lines = map(
    range2(startLine, endLine + 1),
    (i2) => document2.lineAt(i2)
  );
  return Array.from(pairwise(lines)).map(
    ([line1, line2]) => ({
      range: new Range(
        line1.rangeTrimmed?.end ?? line1.range.end,
        line2.rangeTrimmed?.start ?? line2.range.start
      ),
      text: line2.isEmptyOrWhitespace ? "" : " ",
      isReplace: true
    })
  );
}

// ../cursorless-engine/src/actions/PasteFromClipboardUsingCommand.ts
var PasteFromClipboardUsingCommand = class {
  constructor(rangeUpdater, actions) {
    this.rangeUpdater = rangeUpdater;
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(destinations) {
    const editor = ide().getEditableTextEditor(
      ensureSingleEditor(destinations)
    );
    const originalEditor = ide().activeEditableTextEditor;
    const callbackEdit = async () => {
      await this.actions.editNew.run(destinations);
    };
    const { cursorSelections: originalCursorSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      preserveCursorSelections: true,
      callback: callbackEdit,
      selections: {
        cursorSelections: editor.selections
      }
    });
    const {
      originalCursorSelections: updatedCursorSelections,
      editorSelections: updatedTargetSelections
    } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      callback: () => editor.clipboardPaste(),
      selections: {
        originalCursorSelections,
        editorSelections: {
          selections: editor.selections,
          behavior: 0 /* openOpen */
        }
      }
    });
    await editor.setSelections(updatedCursorSelections);
    if (originalEditor != null && !originalEditor.isActive) {
      await originalEditor.focus();
    }
    await ide().flashRanges(
      updatedTargetSelections.map((selection) => ({
        editor,
        range: toCharacterRange(selection),
        style: "justAdded" /* justAdded */
      }))
    );
    return {
      thatSelections: updatedTargetSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
};

// ../cursorless-engine/src/actions/PasteFromClipboardDirectly.ts
var PasteFromClipboardDirectly = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(destinations) {
    const text = await ide().clipboard.readText();
    const textLines = text.split(/\r?\n/g);
    const destinationsWithText = destinations.length === textLines.length ? zipStrict(destinations, textLines).map(([destination, text2]) => ({
      destination,
      text: text2
    })) : destinations.map((destination) => ({ destination, text }));
    const thatSelections = flatten_default(
      await runForEachEditor(
        destinationsWithText,
        ({ destination }) => destination.editor,
        this.runForEditor
      )
    );
    return { thatSelections };
  }
  async runForEditor(editor, destinationsWithText) {
    const edits = destinationsWithText.map(
      ({ destination, text }) => destination.constructChangeEdit(text)
    );
    const { editSelections: updatedEditSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: ide().getEditableTextEditor(editor),
      edits,
      selections: {
        editSelections: {
          selections: edits.map(({ range: range3 }) => range3),
          behavior: 0 /* openOpen */
        }
      }
    });
    const thatTargetSelections = zipStrict(edits, updatedEditSelections).map(
      ([edit, selection]) => edit.updateRange(selection).toSelection(selection.isReversed)
    );
    await ide().flashRanges(
      thatTargetSelections.map((selection) => ({
        editor,
        range: toCharacterRange(selection),
        style: "justAdded" /* justAdded */
      }))
    );
    return thatTargetSelections.map((selection) => ({
      editor,
      selection
    }));
  }
};

// ../cursorless-engine/src/actions/PasteFromClipboard.ts
var PasteFromClipboard = class {
  constructor(rangeUpdater, actions) {
    __publicField(this, "runner");
    this.run = this.run.bind(this);
    this.runner = ide().capabilities.commands.clipboardPaste != null ? new PasteFromClipboardUsingCommand(rangeUpdater, actions) : new PasteFromClipboardDirectly(rangeUpdater);
  }
  run(destinations) {
    return this.runner.run(destinations);
  }
};

// ../cursorless-engine/src/actions/Remove.ts
var Delete = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(targets, { showDecorations = true } = {}) {
    targets = unifyRemovalTargets(targets);
    if (showDecorations) {
      await flashTargets(
        ide(),
        targets,
        "pendingDelete" /* pendingDelete */,
        (target) => target.getRemovalHighlightRange()
      );
    }
    const thatTargets = flatten_default(
      await runOnTargetsForEachEditor(targets, this.runForEditor)
    );
    return { thatTargets };
  }
  async runForEditor(editor, targets) {
    const edits = targets.map((target) => target.constructRemovalEdit());
    const editableEditor = ide().getEditableTextEditor(editor);
    const { editRanges: updatedEditRanges } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: editableEditor,
      edits,
      selections: {
        editRanges: edits.map(({ range: range3 }) => range3)
      }
    });
    return zip_default(targets, updatedEditRanges).map(
      ([target, range3]) => new RawSelectionTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: range3
      })
    );
  }
};

// ../cursorless-engine/src/actions/Replace.ts
var Replace = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  getTexts(destinations, replaceWith) {
    if (Array.isArray(replaceWith)) {
      if (replaceWith.length === 1) {
        return Array(destinations.length).fill(replaceWith[0]);
      }
      return replaceWith;
    }
    const numbers2 = [];
    for (let i2 = 0; i2 < destinations.length; ++i2) {
      numbers2[i2] = (replaceWith.start + i2).toString();
    }
    return numbers2;
  }
  async run(destinations, replaceWith) {
    await flashTargets(
      ide(),
      destinations.map((d) => d.target),
      "pendingModification0" /* pendingModification0 */
    );
    const texts = this.getTexts(destinations, replaceWith);
    if (destinations.length !== texts.length) {
      throw new Error("Targets and texts must have same length");
    }
    const edits = zip_default(destinations, texts).map(([destination, text]) => ({
      editor: destination.editor,
      target: destination.target,
      edit: destination.constructChangeEdit(text)
    }));
    const sourceTargets = [];
    const thatSelections = [];
    await runForEachEditor(
      edits,
      (edit) => edit.editor,
      async (editor, editWrappers) => {
        const edits2 = editWrappers.map(({ edit }) => edit);
        const {
          contentSelections: updatedContentSelections,
          editRanges: updatedEditRanges
        } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits: edits2,
          selections: {
            contentSelections: editWrappers.map(
              ({ target }) => target.contentSelection
            ),
            editRanges: {
              selections: edits2.map(({ range: range3 }) => range3),
              behavior: 0 /* openOpen */
            }
          }
        });
        for (const [wrapper, selection] of zip_default(
          editWrappers,
          updatedContentSelections
        )) {
          sourceTargets.push(wrapper.target.withContentRange(selection));
        }
        for (const [wrapper, range3] of zip_default(editWrappers, updatedEditRanges)) {
          thatSelections.push({
            editor,
            selection: wrapper.edit.updateRange(range3).toSelection(false)
          });
        }
      }
    );
    return { sourceTargets, thatSelections };
  }
};

// ../cursorless-engine/src/actions/Rewrap.ts
var Rewrap = class {
  constructor(rangeUpdater, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    __publicField(this, "getFinalStages", () => [
      getContainingSurroundingPairIfNoBoundaryStage(this.modifierStageFactory)
    ]);
    this.run = this.run.bind(this);
  }
  async run(targets, left, right) {
    const boundaryTargets = targets.flatMap((target) => {
      const boundary = target.getBoundary();
      if (boundary.length !== 2) {
        throw Error("Target must have an opening and closing delimiter");
      }
      return boundary;
    });
    await flashTargets(ide(), boundaryTargets, "pendingModification0" /* pendingModification0 */);
    const results = await runOnTargetsForEachEditor(
      boundaryTargets,
      async (editor, boundaryTargets2) => {
        const edits = boundaryTargets2.map((target, i2) => ({
          editor,
          range: target.contentRange,
          text: i2 % 2 === 0 ? left : right
        }));
        const {
          sourceRanges: updatedSourceRanges,
          thatRanges: updatedThatRanges
        } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits,
          selections: {
            sourceRanges: targets.map(
              (target) => target.thatTarget.contentRange
            ),
            thatRanges: targets.map((target) => target.contentRange)
          }
        });
        return {
          sourceMark: createThatMark(targets, updatedSourceRanges),
          thatMark: createThatMark(targets, updatedThatRanges)
        };
      }
    );
    return {
      sourceSelections: results.flatMap(({ sourceMark }) => sourceMark),
      thatSelections: results.flatMap(({ thatMark }) => thatMark)
    };
  }
};

// ../cursorless-engine/src/actions/Scroll.ts
var Scroll = class {
  constructor(at) {
    this.at = at;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const selectionGroups = groupBy(targets, (t) => t.editor);
    const lines = Array.from(selectionGroups, ([editor, targets2]) => {
      return { lineNumber: getLineNumber(targets2, this.at), editor };
    });
    const originalEditor = ide().activeEditableTextEditor;
    for (const lineWithEditor of lines) {
      await ide().getEditableTextEditor(lineWithEditor.editor).revealLine(lineWithEditor.lineNumber, this.at);
    }
    if (originalEditor != null && !originalEditor.isActive) {
      await originalEditor.focus();
    }
    const decorationTargets = targets.filter((target) => {
      const visibleRanges = target.editor.visibleRanges;
      const startLine = visibleRanges[0].start.line;
      const endLine = visibleRanges[visibleRanges.length - 1].end.line;
      return target.contentRange.start.line > startLine || target.contentRange.end.line < endLine || target.contentRange.start.line === startLine && target.contentRange.end.line === endLine;
    });
    await ide().flashRanges(
      decorationTargets.map((target) => ({
        editor: target.editor,
        range: toLineRange(target.contentRange),
        style: "referenced" /* referenced */
      }))
    );
    return {
      thatTargets: targets
    };
  }
};
var ScrollToTop = class extends Scroll {
  constructor() {
    super("top" /* top */);
  }
};
var ScrollToCenter = class extends Scroll {
  constructor() {
    super("center" /* center */);
  }
};
var ScrollToBottom = class extends Scroll {
  constructor() {
    super("bottom" /* bottom */);
  }
};
function getLineNumber(targets, at) {
  let startLine = Number.MAX_SAFE_INTEGER;
  let endLine = 0;
  targets.forEach((target) => {
    startLine = Math.min(startLine, target.contentRange.start.line);
    endLine = Math.max(endLine, target.contentRange.end.line);
  });
  if (at === "top" /* top */) {
    return startLine;
  }
  if (at === "bottom" /* bottom */) {
    return endLine;
  }
  return Math.floor((startLine + endLine) / 2);
}

// ../cursorless-engine/src/actions/SetSelection.ts
var SetSelectionBase = class {
  constructor(selectionMode, rangeMode) {
    this.selectionMode = selectionMode;
    this.rangeMode = rangeMode;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const editor = ensureSingleEditor(targets);
    const targetSelections = this.getSelections(targets);
    const selections = this.selectionMode === "add" ? editor.selections.concat(targetSelections) : targetSelections;
    const highlightWord = this.selectionMode === "set" && selections.length === 1 && selections[0].isEmpty;
    await ide().getEditableTextEditor(editor).setSelections(selections, { focusEditor: true, highlightWord });
    return {
      thatTargets: targets
    };
  }
  getSelections(targets) {
    switch (this.rangeMode) {
      case "content":
        return targets.map((target) => target.contentSelection);
      case "before":
        return targets.map(
          (target) => new Selection(target.contentRange.start, target.contentRange.start)
        );
      case "after":
        return targets.map(
          (target) => new Selection(target.contentRange.end, target.contentRange.end)
        );
    }
  }
};
var SetSelection = class extends SetSelectionBase {
  constructor() {
    super("set", "content");
  }
};
var SetSelectionBefore = class extends SetSelectionBase {
  constructor() {
    super("set", "before");
  }
};
var SetSelectionAfter = class extends SetSelectionBase {
  constructor() {
    super("set", "after");
  }
};
var AddSelection = class extends SetSelectionBase {
  constructor() {
    super("add", "content");
  }
};
var AddSelectionBefore = class extends SetSelectionBase {
  constructor() {
    super("add", "before");
  }
};
var AddSelectionAfter = class extends SetSelectionBase {
  constructor() {
    super("add", "after");
  }
};

// ../cursorless-engine/src/actions/SetSpecialTarget.ts
var SetSpecialTarget = class {
  constructor(key) {
    this.key = key;
    __publicField(this, "noAutomaticTokenExpansion", true);
    this.run = this.run.bind(this);
  }
  async run(targets) {
    return {
      thatTargets: targets,
      [`${this.key}Targets`]: targets
    };
  }
};

// ../cursorless-engine/src/actions/ShowParseTree.ts
var ShowParseTree = class {
  constructor(treeSitter) {
    this.treeSitter = treeSitter;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await flashTargets(ide(), targets, "referenced" /* referenced */);
    const results = ["# Cursorless parse tree"];
    for (const target of targets) {
      const { editor, contentRange } = target;
      const tree = this.treeSitter.getTree(editor.document);
      results.push(parseTree(editor.document, tree, contentRange));
    }
    void ide().openUntitledTextDocument({
      language: "markdown",
      content: results.join("\n\n")
    });
    return { thatTargets: targets };
  }
};
function parseTree(document2, tree, contentRange) {
  const resultPlayground = [];
  const resultQuery = [];
  parseCursor(resultPlayground, resultQuery, contentRange, tree.walk(), 0);
  return [
    `## ${document2.filename} [${contentRange}]
`,
    `\`\`\`${document2.languageId}`,
    document2.getText(contentRange),
    "```",
    "",
    "```scm",
    ...resultQuery,
    "```",
    "",
    "```js",
    ...resultPlayground,
    "```",
    ""
  ].join("\n");
}
function parseCursor(resultPlayground, resultQuery, contentRange, cursor, numIndents) {
  while (true) {
    const nodeRange = new Range(
      cursor.startPosition.row,
      cursor.startPosition.column,
      cursor.endPosition.row,
      cursor.endPosition.column
    );
    if (contentRange.intersection(nodeRange) != null) {
      const indentation = "  ".repeat(numIndents);
      const fieldName = getFieldName(cursor);
      const prefix = indentation + fieldName;
      if (cursor.nodeIsNamed) {
        resultPlayground.push(`${prefix}${cursor.nodeType} [${nodeRange}]`);
        resultQuery.push(`${prefix}(${cursor.nodeType}`);
        if (cursor.gotoFirstChild()) {
          parseCursor(
            resultPlayground,
            resultQuery,
            contentRange,
            cursor,
            numIndents + 1
          );
          cursor.gotoParent();
          resultQuery.push(`${indentation})`);
        } else {
          resultQuery[resultQuery.length - 1] += ")";
        }
      } else {
        const type2 = `"${cursor.nodeType}"`;
        resultPlayground.push(`${prefix}${type2} [${nodeRange}]`);
        resultQuery.push(`${prefix}${type2}`);
      }
    }
    if (!cursor.gotoNextSibling()) {
      return;
    }
  }
}
function getFieldName(cursor) {
  const field = cursor.currentFieldName;
  return field != null ? `${field}: ` : "";
}

// ../cursorless-engine/src/actions/Sort.ts
var SortBase = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    if (targets.length < 2) {
      void showWarning(
        ide().messages,
        "tooFewTargets",
        'This action works on multiple targets, e.g. "sort every line block" instead of "sort block".'
      );
    }
    const sortedTargets = targets.slice().sort((a, b) => a.contentRange.start.compareTo(b.contentRange.start));
    const { returnValue: unsortedTexts } = await this.actions.getText.run(
      sortedTargets,
      {
        showDecorations: false
      }
    );
    const sortedTexts = this.sortTexts(unsortedTexts);
    const { thatSelections } = await this.actions.replace.run(
      sortedTargets.map((target) => target.toDestination("to")),
      sortedTexts
    );
    return { thatSelections };
  }
};
var Sort = class extends SortBase {
  sortTexts(texts) {
    return texts.sort(
      (a, b) => a.localeCompare(b, void 0, {
        numeric: true,
        caseFirst: "upper"
      })
    );
  }
};
var Reverse = class extends SortBase {
  sortTexts(texts) {
    return texts.reverse();
  }
};
var Random = class extends SortBase {
  sortTexts(texts) {
    return shuffle_default(texts);
  }
};

// ../cursorless-engine/src/actions/ToggleBreakpoint.ts
var ToggleBreakpoint = class {
  constructor(modifierStageFactory) {
    this.modifierStageFactory = modifierStageFactory;
    __publicField(this, "getFinalStages", () => [
      this.modifierStageFactory.create(containingLineIfUntypedModifier)
    ]);
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const thatTargets = targets.map(({ thatTarget }) => thatTarget);
    await flashTargets(ide(), thatTargets, "referenced" /* referenced */);
    await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
      const generalizedRanges = targets2.map(
        (target) => toGeneralizedRange(target, target.contentRange)
      );
      await ide().getEditableTextEditor(editor).toggleBreakpoint(generalizedRanges);
    });
    return {
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/Wrap.ts
var Wrap = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets, left, right) {
    const results = await runOnTargetsForEachEditor(
      targets,
      async (editor, targets2) => {
        const boundaries = targets2.map((target) => ({
          start: new Selection(
            target.contentRange.start,
            target.contentRange.start
          ),
          end: new Selection(target.contentRange.end, target.contentRange.end)
        }));
        const edits = boundaries.flatMap(({ start: start2, end }) => [
          {
            text: left,
            range: start2
          },
          {
            text: right,
            range: end,
            isReplace: true
          }
        ]);
        const contentSelections = targets2.map(
          (target) => target.contentSelection
        );
        const {
          boundariesStartSelections: delimiterStartSelections,
          boundariesEndSelections: delimiterEndSelections,
          sourceSelections: sourceMarkSelections,
          thatSelections: thatMarkSelections
        } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits,
          selections: {
            boundariesStartSelections: {
              selections: boundaries.map(({ start: start2 }) => start2),
              behavior: 2 /* openClosed */
            },
            boundariesEndSelections: {
              selections: boundaries.map(({ end }) => end),
              behavior: 3 /* closedOpen */
            },
            sourceSelections: {
              selections: contentSelections,
              behavior: 1 /* closedClosed */
            },
            thatSelections: {
              selections: contentSelections,
              behavior: 0 /* openOpen */
            }
          }
        });
        const delimiterSelections = [
          ...delimiterStartSelections,
          ...delimiterEndSelections
        ];
        await ide().flashRanges(
          delimiterSelections.map((selection) => ({
            editor,
            range: toCharacterRange(selection),
            style: "justAdded" /* justAdded */
          }))
        );
        return {
          sourceMark: sourceMarkSelections.map((selection) => ({
            editor,
            selection
          })),
          thatMark: thatMarkSelections.map((selection) => ({
            editor,
            selection
          }))
        };
      }
    );
    return {
      sourceSelections: results.flatMap(({ sourceMark }) => sourceMark),
      thatSelections: results.flatMap(({ thatMark }) => thatMark)
    };
  }
};

// ../cursorless-engine/src/actions/WrapWithSnippet.ts
var WrapWithSnippet = class {
  constructor(rangeUpdater, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    __publicField(this, "snippetParser", new SnippetParser());
    this.run = this.run.bind(this);
  }
  getFinalStages(targets, snippetDescription) {
    const editor = ensureSingleEditor(targets);
    const snippet2 = getPreferredSnippet(
      snippetDescription,
      editor.document.languageId
    );
    if (snippet2.scopeType == null) {
      return [];
    }
    return [
      new ModifyIfUntypedStage(this.modifierStageFactory, {
        type: "modifyIfUntyped",
        modifier: {
          type: "containingScope",
          scopeType: snippet2.scopeType
        }
      })
    ];
  }
  async run(targets, snippetDescription) {
    const editor = ide().getEditableTextEditor(ensureSingleEditor(targets));
    const snippet2 = getPreferredSnippet(
      snippetDescription,
      editor.document.languageId
    );
    const parsedSnippet = this.snippetParser.parse(snippet2.body);
    transformSnippetVariables(parsedSnippet, snippet2.variableName);
    const snippetString = parsedSnippet.toTextmateString();
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const targetSelections = targets.map((target) => target.contentSelection);
    const { targetSelections: updatedTargetSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      callback: () => editor.insertSnippet(snippetString, targetSelections),
      preserveCursorSelections: true,
      selections: {
        targetSelections
      }
    });
    return {
      thatSelections: updatedTargetSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
};

// ../cursorless-engine/src/actions/incrementDecrement.ts
var REGEX = /-?[\d_]+(\.[\d_]+)?/g;
var IncrementDecrement = class {
  constructor(actions, isIncrement) {
    this.actions = actions;
    this.isIncrement = isIncrement;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const thatSelections = [];
    await runForEachEditor(
      targets,
      (target) => target.editor,
      async (editor, targets2) => {
        const selections = await this.runOnEditor(editor, targets2);
        thatSelections.push(...selections);
      }
    );
    return { thatSelections };
  }
  async runOnEditor(editor, targets) {
    const { document: document2 } = editor;
    const destinations = [];
    const replaceWith = [];
    for (const target of targets) {
      const offset = document2.offsetAt(target.contentRange.start);
      const text = target.contentText;
      const matches = matchText(text, REGEX);
      for (const match of matches) {
        destinations.push(createDestination(editor, offset, match));
        replaceWith.push(updateNumber(this.isIncrement, match.text));
      }
    }
    const { thatSelections } = await this.actions.replace.run(
      destinations,
      replaceWith
    );
    return thatSelections;
  }
};
var Increment = class extends IncrementDecrement {
  constructor(actions) {
    super(actions, true);
  }
};
var Decrement = class extends IncrementDecrement {
  constructor(actions) {
    super(actions, false);
  }
};
function createDestination(editor, offset, match) {
  const target = new PlainTarget({
    editor,
    isReversed: false,
    contentRange: new Range(
      editor.document.positionAt(offset + match.index),
      editor.document.positionAt(offset + match.index + match.text.length)
    )
  });
  return target.toDestination("to");
}
function updateNumber(isIncrement, text) {
  return text.includes(".") ? updateFloat(isIncrement, text) : updateInteger(isIncrement, text);
}
function updateInteger(isIncrement, text) {
  const textWithoutUnderscores = text.replaceAll("_", "");
  const original = parseInt(textWithoutUnderscores);
  const diff = 1;
  const value = original + (isIncrement ? diff : -diff);
  return formatNumber(value, text, textWithoutUnderscores);
}
function updateFloat(isIncrement, text) {
  const textWithoutUnderscores = text.replaceAll("_", "");
  const original = parseFloat(textWithoutUnderscores);
  const isPercentage2 = Math.abs(original) <= 1;
  const diff = isPercentage2 ? 0.1 : 1;
  const updated = original + (isIncrement ? diff : -diff);
  const value = parseFloat(updated.toPrecision(15)) / 1;
  const decimalPlaces = textWithoutUnderscores.split(".")[1]?.length;
  return formatNumber(value, text, textWithoutUnderscores, decimalPlaces);
}
function formatNumber(value, text, textWithoutUnderscores, decimalPlaces) {
  const result = (() => {
    if (hasLeadingZeros(textWithoutUnderscores)) {
      return formatNumberWithLeadingZeros(
        value,
        textWithoutUnderscores,
        decimalPlaces
      );
    }
    return decimalPlaces != null ? value.toFixed(decimalPlaces) : value.toString();
  })();
  return formatNumberWithUnderscores(text, textWithoutUnderscores, result);
}
function formatNumberWithLeadingZeros(value, text, decimalPlaces) {
  const sign = value < 0 ? "-" : "";
  const absValue = Math.abs(value);
  const integerPartLength = getIntegerPartLength(text);
  const integerPart = Math.floor(absValue).toString().padStart(integerPartLength, "0");
  if (decimalPlaces != null) {
    const fractionPart = (absValue - Math.floor(absValue)).toFixed(decimalPlaces).slice(2);
    return `${sign}${integerPart}.${fractionPart}`;
  }
  return `${sign}${integerPart}`;
}
function formatNumberWithUnderscores(original, originalWithoutUnderscores, updated) {
  const underscoreMatches = Array.from(original.matchAll(/_/g));
  if (underscoreMatches.length === 0) {
    return updated;
  }
  let resultWithUnderscores = updated;
  const offset = getIntegerAndSignPartLength(updated) - getIntegerAndSignPartLength(originalWithoutUnderscores);
  for (const match of underscoreMatches) {
    const index = match.index + offset;
    if (index < resultWithUnderscores.length) {
      resultWithUnderscores = resultWithUnderscores.slice(0, index) + "_" + resultWithUnderscores.slice(index);
    }
  }
  return resultWithUnderscores;
}
function hasLeadingZeros(text) {
  return /^-?0\d/.test(text);
}
function getIntegerPartLength(text) {
  return /^-?(\d+)/.exec(text)[1].length;
}
function getIntegerAndSignPartLength(text) {
  return /^-?\d+/.exec(text)[0].length;
}

// ../cursorless-engine/src/actions/Actions.ts
var Actions = class {
  constructor(treeSitter, snippets, rangeUpdater, modifierStageFactory) {
    __publicField(this, "addSelection");
    __publicField(this, "addSelectionBefore");
    __publicField(this, "addSelectionAfter");
    __publicField(this, "callAsFunction");
    __publicField(this, "clearAndSetSelection");
    __publicField(this, "copyToClipboard");
    __publicField(this, "cutToClipboard");
    __publicField(this, "decrement");
    __publicField(this, "deselect");
    __publicField(this, "editNew");
    __publicField(this, "editNewLineAfter");
    __publicField(this, "editNewLineBefore");
    __publicField(this, "executeCommand");
    __publicField(this, "extractVariable");
    __publicField(this, "findInDocument");
    __publicField(this, "findInWorkspace");
    __publicField(this, "flashTargets");
    __publicField(this, "foldRegion");
    __publicField(this, "followLink");
    __publicField(this, "followLinkAside");
    __publicField(this, "generateSnippet");
    __publicField(this, "getText");
    __publicField(this, "gitAccept");
    __publicField(this, "gitRevert");
    __publicField(this, "gitStage");
    __publicField(this, "gitUnstage");
    __publicField(this, "highlight");
    __publicField(this, "increment");
    __publicField(this, "indentLine");
    __publicField(this, "insertCopyAfter");
    __publicField(this, "insertCopyBefore");
    __publicField(this, "insertEmptyLineAfter");
    __publicField(this, "insertEmptyLineBefore");
    __publicField(this, "insertEmptyLinesAround");
    __publicField(this, "insertSnippet");
    __publicField(this, "joinLines");
    __publicField(this, "breakLine");
    __publicField(this, "moveToTarget");
    __publicField(this, "outdentLine");
    __publicField(this, "pasteFromClipboard");
    __publicField(this, "randomizeTargets");
    __publicField(this, "remove");
    __publicField(this, "rename");
    __publicField(this, "replace");
    __publicField(this, "replaceWithTarget");
    __publicField(this, "revealDefinition");
    __publicField(this, "revealTypeDefinition");
    __publicField(this, "reverseTargets");
    __publicField(this, "rewrapWithPairedDelimiter");
    __publicField(this, "scrollToBottom");
    __publicField(this, "scrollToCenter");
    __publicField(this, "scrollToTop");
    __publicField(this, "setSelection");
    __publicField(this, "setSelectionAfter");
    __publicField(this, "setSelectionBefore");
    __publicField(this, "showDebugHover");
    __publicField(this, "showHover");
    __publicField(this, "showQuickFix");
    __publicField(this, "showReferences");
    __publicField(this, "sortTargets");
    __publicField(this, "swapTargets");
    __publicField(this, "toggleLineBreakpoint");
    __publicField(this, "toggleLineComment");
    __publicField(this, "unfoldRegion");
    __publicField(this, "wrapWithPairedDelimiter");
    __publicField(this, "wrapWithSnippet");
    __publicField(this, "experimental.setInstanceReference");
    __publicField(this, "private.showParseTree");
    __publicField(this, "private.getTargets");
    __publicField(this, "private.setKeyboardTarget");
    this.addSelection = new AddSelection();
    this.addSelectionBefore = new AddSelectionBefore();
    this.addSelectionAfter = new AddSelectionAfter();
    this.callAsFunction = new Call(this);
    this.clearAndSetSelection = new Clear(this);
    this.copyToClipboard = new CopyToClipboard(this, rangeUpdater);
    this.cutToClipboard = new CutToClipboard(this);
    this.decrement = new Decrement(this);
    this.deselect = new Deselect();
    this.editNew = new EditNew(rangeUpdater, this);
    this.editNewLineAfter = new EditNewAfter(this, modifierStageFactory);
    this.editNewLineBefore = new EditNewBefore(this, modifierStageFactory);
    this.executeCommand = new ExecuteCommand(rangeUpdater);
    this.extractVariable = new ExtractVariable(rangeUpdater);
    this.findInDocument = new FindInDocument(this);
    this.findInWorkspace = new FindInWorkspace(this);
    this.flashTargets = new FlashTargets();
    this.foldRegion = new Fold(rangeUpdater);
    this.followLink = new FollowLink({ openAside: false });
    this.followLinkAside = new FollowLink({ openAside: true });
    this.generateSnippet = new GenerateSnippet(snippets);
    this.getText = new GetText();
    this.gitAccept = new GitAccept(rangeUpdater);
    this.gitRevert = new GitRevert(rangeUpdater);
    this.gitStage = new GitStage(rangeUpdater);
    this.gitUnstage = new GitUnstage(rangeUpdater);
    this.highlight = new Highlight();
    this.increment = new Increment(this);
    this.indentLine = new IndentLine(rangeUpdater);
    this.insertCopyAfter = new CopyContentAfter(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertCopyBefore = new CopyContentBefore(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertEmptyLineAfter = new InsertEmptyLineBelow(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertEmptyLineBefore = new InsertEmptyLineAbove(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertEmptyLinesAround = new InsertEmptyLinesAround(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertSnippet = new InsertSnippet(
      rangeUpdater,
      this,
      modifierStageFactory
    );
    this.joinLines = new JoinLines(rangeUpdater, modifierStageFactory);
    this.breakLine = new BreakLine(rangeUpdater);
    this.moveToTarget = new Move(rangeUpdater);
    this.outdentLine = new OutdentLine(rangeUpdater);
    this.pasteFromClipboard = new PasteFromClipboard(rangeUpdater, this);
    this.randomizeTargets = new Random(this);
    this.remove = new Delete(rangeUpdater);
    this.rename = new Rename(rangeUpdater);
    this.replace = new Replace(rangeUpdater);
    this.replaceWithTarget = new Bring(rangeUpdater);
    this.revealDefinition = new RevealDefinition(rangeUpdater);
    this.revealTypeDefinition = new RevealTypeDefinition(rangeUpdater);
    this.reverseTargets = new Reverse(this);
    this.rewrapWithPairedDelimiter = new Rewrap(
      rangeUpdater,
      modifierStageFactory
    );
    this.scrollToBottom = new ScrollToBottom();
    this.scrollToCenter = new ScrollToCenter();
    this.scrollToTop = new ScrollToTop();
    this.setSelection = new SetSelection();
    this.setSelectionAfter = new SetSelectionAfter();
    this.setSelectionBefore = new SetSelectionBefore();
    this.showDebugHover = new ShowDebugHover(rangeUpdater);
    this.showHover = new ShowHover(rangeUpdater);
    this.showQuickFix = new ShowQuickFix(rangeUpdater);
    this.showReferences = new ShowReferences(rangeUpdater);
    this.sortTargets = new Sort(this);
    this.swapTargets = new Swap(rangeUpdater);
    this.toggleLineBreakpoint = new ToggleBreakpoint(modifierStageFactory);
    this.toggleLineComment = new ToggleLineComment(rangeUpdater);
    this.unfoldRegion = new Unfold(rangeUpdater);
    this.wrapWithPairedDelimiter = new Wrap(rangeUpdater);
    this.wrapWithSnippet = new WrapWithSnippet(
      rangeUpdater,
      modifierStageFactory
    );
    this["experimental.setInstanceReference"] = new SetSpecialTarget(
      "instanceReference"
    );
    this["private.showParseTree"] = new ShowParseTree(treeSitter);
    this["private.getTargets"] = new GetTargets();
    this["private.setKeyboardTarget"] = new SetSpecialTarget("keyboard");
  }
};

// ../cursorless-engine/src/core/getCommandFallback.ts
async function getCommandFallback(commandServerApi, runAction, command) {
  const focusedElementType = await commandServerApi.getFocusedElementType();
  if (focusedElementType == null || focusedElementType === "textEditor") {
    return null;
  }
  const action = command.action;
  switch (action.name) {
    case "replace":
      return destinationIsSelection(action.destination) && Array.isArray(action.replaceWith) ? {
        action: "insert",
        modifiers: getModifiersFromDestination(action.destination),
        text: action.replaceWith.join("\n")
      } : null;
    case "replaceWithTarget":
      if (destinationIsSelection(action.destination)) {
        return {
          action: "insert",
          modifiers: getModifiersFromDestination(action.destination),
          text: await getText(runAction, action.source)
        };
      }
      return null;
    case "moveToTarget":
      if (destinationIsSelection(action.destination)) {
        const text = await getText(runAction, action.source);
        await remove(runAction, action.source);
        return {
          action: "insert",
          modifiers: getModifiersFromDestination(action.destination),
          text
        };
      }
      return null;
    case "callAsFunction":
      if (targetIsSelection(action.argument)) {
        return {
          action: action.name,
          modifiers: getModifiersFromTarget(action.argument),
          callee: await getText(runAction, action.callee)
        };
      }
      return null;
    case "wrapWithPairedDelimiter":
    case "rewrapWithPairedDelimiter":
      return targetIsSelection(action.target) ? {
        action: action.name,
        modifiers: getModifiersFromTarget(action.target),
        left: action.left,
        right: action.right
      } : null;
    case "pasteFromClipboard":
      return destinationIsSelection(action.destination) ? {
        action: action.name,
        modifiers: getModifiersFromDestination(action.destination)
      } : null;
    case "swapTargets":
    case "editNew":
    case "insertSnippet":
    case "generateSnippet":
    case "wrapWithSnippet":
    case "parsed":
      return null;
    default:
      return targetIsSelection(action.target) ? {
        action: action.name,
        modifiers: getModifiersFromTarget(action.target)
      } : null;
  }
}
function destinationIsSelection(destination) {
  if (destination.type === "implicit") {
    return true;
  }
  if (destination.type === "primitive") {
    return destination.insertionMode === "to" && targetIsSelection(destination.target);
  }
  return false;
}
function targetIsSelection(target) {
  if (target.type === "implicit") {
    return true;
  }
  if (target.type === "primitive") {
    return target.mark == null || target.mark.type === "cursor";
  }
  return false;
}
function getModifiersFromDestination(destination) {
  if (destination.type === "primitive") {
    return getModifiersFromTarget(destination.target);
  }
  return [];
}
function getModifiersFromTarget(target) {
  if (target.type === "primitive") {
    if (target.modifiers != null && target.modifiers.length > 0) {
      return target.modifiers;
    }
  }
  return [];
}
async function getText(runAction, target) {
  const response = await runAction({ name: "getText", target });
  const texts = response.returnValue;
  return texts.join("\n");
}
async function remove(runAction, target) {
  await runAction({ name: "remove", target });
}

// ../cursorless-engine/src/core/handleHoistedModifiers.ts
function handleHoistedModifiers(targetDescriptor, isAnchorMarkImplicit) {
  const { anchor, rangeType, active } = targetDescriptor;
  if (anchor.type !== "primitive" || rangeType !== "continuous") {
    return targetDescriptor;
  }
  const indexedModifiers = anchor.modifiers.map((v, i2) => [v, i2]);
  for (const [modifier, idx] of indexedModifiers.reverse()) {
    for (const hoistedModifierType of hoistedModifierTypes) {
      const acceptanceInfo = hoistedModifierType.accept(modifier);
      if (acceptanceInfo.accepted) {
        const [hoistedModifiers, unhoistedModifiers] = [
          anchor.modifiers.slice(0, idx + 1),
          anchor.modifiers.slice(idx + 1)
        ];
        let pipelineInputDescriptor = {
          ...targetDescriptor,
          anchor: (
            // If they say "every line past bat", the anchor is implicit, even though
            // it comes across the wire as a primitive target due to the "every line",
            // which we've now removed
            unhoistedModifiers.length === 0 && isAnchorMarkImplicit ? { type: "implicit" } : {
              type: "primitive",
              mark: anchor.mark,
              modifiers: unhoistedModifiers
            }
          ),
          // Remove the hoisted modifier (and everything before it) from the
          // active if it ended up there from inference
          active: produce(active, (draft) => {
            draft.modifiers = draft.modifiers.slice(
              findLastIndex_default(
                draft.modifiers,
                (modifier2) => hoistedModifierType.accept(modifier2).accepted
              ) + 1
            );
          })
        };
        pipelineInputDescriptor = acceptanceInfo.transformTarget?.(pipelineInputDescriptor) ?? pipelineInputDescriptor;
        return {
          type: "primitive",
          mark: {
            type: "target",
            target: pipelineInputDescriptor
          },
          modifiers: hoistedModifiers
        };
      }
    }
  }
  return targetDescriptor;
}
var hoistedModifierTypes = [
  // "every" ranges, eg "every line air past bat"
  {
    accept(modifier) {
      return modifier.type === "everyScope" && modifier.scopeType.type !== "instance" ? {
        accepted: true,
        transformTarget(target) {
          return {
            ...target,
            exclusionScopeType: modifier.scopeType
          };
        }
      } : { accepted: false };
    }
  },
  // "instance" modifiers treat the range as the instance to search for, eg
  // "every instance air past bat" searches for instances of the text of the
  // range "air past bat".
  {
    accept(modifier) {
      return {
        accepted: (modifier.type === "everyScope" || modifier.type === "relativeScope" || modifier.type === "ordinalScope") && modifier.scopeType.type === "instance"
      };
    }
  }
];

// ../cursorless-engine/src/core/inferFullTargetDescriptor.ts
function inferFullTargetDescriptor(target, previousTargets) {
  switch (target.type) {
    case "list":
      return inferListTarget(target, previousTargets);
    case "range":
      return inferRangeTargetWithHoist(target, previousTargets);
    case "primitive":
      return inferPrimitiveTarget(target, previousTargets);
    case "implicit":
      return target;
  }
}
function inferListTarget(target, previousTargets) {
  return {
    ...target,
    elements: target.elements.map((element, index) => {
      const elementPreviousTargets = previousTargets.concat(
        target.elements.slice(0, index)
      );
      switch (element.type) {
        case "range":
          return inferRangeTargetWithHoist(element, elementPreviousTargets);
        case "primitive":
          return inferPrimitiveTarget(element, elementPreviousTargets);
      }
    })
  };
}
function inferRangeTargetWithHoist(target, previousTargets) {
  const fullTarget = inferRangeTarget(target, previousTargets);
  const isAnchorMarkImplicit = target.anchor.type === "implicit" || target.anchor.mark == null;
  return handleHoistedModifiers(fullTarget, isAnchorMarkImplicit);
}
function inferRangeTarget(target, previousTargets) {
  return {
    type: "range",
    rangeType: target.rangeType ?? "continuous",
    excludeAnchor: target.excludeAnchor ?? false,
    excludeActive: target.excludeActive ?? false,
    anchor: target.anchor.type === "implicit" ? target.anchor : inferPrimitiveTarget(target.anchor, previousTargets),
    active: inferPrimitiveTarget(
      target.active,
      previousTargets.concat(target.anchor)
    )
  };
}
function inferPrimitiveTarget(target, previousTargets) {
  const mark = handleTargetMark(
    target.mark ?? (shouldInferPreviousMark(target) ? getPreviousMark(previousTargets) : null) ?? {
      type: "cursor"
    }
  );
  const modifiers = getPreservedModifiers(target) ?? getPreviousPreservedModifiers(previousTargets) ?? getPreviousLineNumberMarkModifiers(previousTargets) ?? [];
  return {
    type: target.type,
    mark,
    modifiers
  };
}
function shouldInferPreviousMark(target) {
  return target.modifiers?.some((m) => m.type === "inferPreviousMark") ?? false;
}
function getPreservedModifiers(target) {
  const preservedModifiers = target.modifiers?.filter(
    (modifier) => modifier.type !== "inferPreviousMark"
  ) ?? [];
  return preservedModifiers.length !== 0 ? preservedModifiers : void 0;
}
function getLineNumberMarkModifiers(target) {
  if (isLineNumberMark(target)) {
    return [
      {
        type: "containingScope",
        scopeType: {
          type: "line"
        }
      }
    ];
  }
  return void 0;
}
function isLineNumberMark(target) {
  const isLineNumber = (mark) => mark?.type === "lineNumber";
  if (isLineNumber(target.mark)) {
    return true;
  }
  if (target.mark?.type === "range") {
    return isLineNumber(target.mark.anchor) && isLineNumber(target.mark.active);
  }
  return false;
}
function getPreviousMark(previousTargets) {
  return getPreviousTargetAttribute(
    previousTargets,
    (target) => target.mark
  );
}
function getPreviousPreservedModifiers(previousTargets) {
  return getPreviousTargetAttribute(previousTargets, getPreservedModifiers);
}
function getPreviousLineNumberMarkModifiers(previousTargets) {
  return getPreviousTargetAttribute(
    previousTargets,
    getLineNumberMarkModifiers
  );
}
function getPreviousTargetAttribute(previousTargets, getAttribute) {
  for (let i2 = previousTargets.length - 1; i2 > -1; --i2) {
    const target = previousTargets[i2];
    switch (target.type) {
      case "primitive": {
        const attributeValue = getAttribute(target);
        if (attributeValue != null) {
          return attributeValue;
        }
        break;
      }
      case "range": {
        const attributeValue = getPreviousTargetAttribute(
          [target.anchor],
          getAttribute
        );
        if (attributeValue != null) {
          return attributeValue;
        }
        break;
      }
      case "list": {
        const attributeValue = getPreviousTargetAttribute(
          target.elements,
          getAttribute
        );
        if (attributeValue != null) {
          return attributeValue;
        }
        break;
      }
    }
  }
  return void 0;
}
function handleTargetMark(mark) {
  switch (mark.type) {
    case "range":
      return {
        ...mark,
        anchor: handleTargetMark(mark.anchor),
        active: handleTargetMark(mark.active)
      };
    case "target":
      return {
        type: "target",
        target: inferFullTargetDescriptor(mark.target, [])
      };
    default:
      return mark;
  }
}

// ../cursorless-engine/src/core/commandRunner/CommandRunnerImpl.ts
var CommandRunnerImpl = class {
  constructor(commandServerApi, debug, storedTargets, pipelineRunner, actions) {
    this.commandServerApi = commandServerApi;
    this.debug = debug;
    this.storedTargets = storedTargets;
    this.pipelineRunner = pipelineRunner;
    this.actions = actions;
    __publicField(this, "inferenceContext");
    __publicField(this, "finalStages", []);
    __publicField(this, "noAutomaticTokenExpansion");
    __publicField(this, "allowDuplicateTargets");
    this.runAction = this.runAction.bind(this);
    this.inferenceContext = new InferenceContext(this.debug);
  }
  /**
   * Runs a Cursorless command. We proceed as follows:
   *
   * 1. Perform inference on targets to fill in details left out using things
   *    like previous targets. For example we would automatically infer that
   *    `"take funk air and bat"` is equivalent to `"take funk air and funk
   *    bat"`. See {@link inferFullTargetDescriptors} for details of how this is done.
   * 2. Call {@link processTargets} to map each abstract {@link Target} object
   *    to a concrete list of {@link Target} objects.
   * 3. Run the requested action on the given selections. The mapping from
   *    action id (eg `remove`) to implementation is defined in {@link Actions}.
   *    To understand how actions work, see some examples, such as `"take"`
   *    {@link SetSelection} and `"chuck"` {@link Delete}. See
   * 4. Update `source` and `that` marks, if they have been returned from the
   *    action, and returns the desired return value indicated by the action, if
   *    it has one.
   */
  async run(command) {
    if (clientSupportsFallback(command)) {
      const fallback = await getCommandFallback(
        this.commandServerApi,
        this.runAction,
        command
      );
      if (fallback != null) {
        return { fallback };
      }
    }
    const {
      returnValue,
      thatSelections: newThatSelections,
      thatTargets: newThatTargets,
      sourceSelections: newSourceSelections,
      sourceTargets: newSourceTargets,
      instanceReferenceTargets: newInstanceReferenceTargets,
      keyboardTargets: newKeyboardTargets
    } = await this.runAction(command.action);
    this.storedTargets.set(
      "that",
      constructStoredTarget(newThatTargets, newThatSelections)
    );
    this.storedTargets.set(
      "source",
      constructStoredTarget(newSourceTargets, newSourceSelections)
    );
    this.storedTargets.set("instanceReference", newInstanceReferenceTargets);
    this.storedTargets.set("keyboard", newKeyboardTargets, { history: true });
    return { returnValue };
  }
  runAction(actionDescriptor) {
    this.inferenceContext.reset();
    this.finalStages = [];
    switch (actionDescriptor.name) {
      case "replaceWithTarget":
        this.allowDuplicateTargets = true;
        return this.actions.replaceWithTarget.run(
          this.getTargets(actionDescriptor.source),
          this.getDestinations(actionDescriptor.destination)
        );
      case "moveToTarget":
        return this.actions.moveToTarget.run(
          this.getTargets(actionDescriptor.source),
          this.getDestinations(actionDescriptor.destination)
        );
      case "swapTargets":
        return this.actions.swapTargets.run(
          this.getTargets(actionDescriptor.target1),
          this.getTargets(actionDescriptor.target2)
        );
      case "callAsFunction":
        return this.actions.callAsFunction.run(
          this.getTargets(actionDescriptor.callee),
          this.getTargets(actionDescriptor.argument)
        );
      case "wrapWithPairedDelimiter":
        return this.actions.wrapWithPairedDelimiter.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.left,
          actionDescriptor.right
        );
      case "rewrapWithPairedDelimiter":
        this.finalStages = this.actions.rewrapWithPairedDelimiter.getFinalStages();
        return this.actions.rewrapWithPairedDelimiter.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.left,
          actionDescriptor.right
        );
      case "pasteFromClipboard":
        return this.actions.pasteFromClipboard.run(
          this.getDestinations(actionDescriptor.destination)
        );
      case "executeCommand":
        return this.actions.executeCommand.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.commandId,
          actionDescriptor.options
        );
      case "replace":
        return this.actions.replace.run(
          this.getDestinations(actionDescriptor.destination),
          actionDescriptor.replaceWith
        );
      case "highlight":
        return this.actions.highlight.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.highlightId
        );
      case "generateSnippet":
        return this.actions.generateSnippet.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.directory,
          actionDescriptor.snippetName
        );
      case "insertSnippet":
        this.finalStages = this.actions.insertSnippet.getFinalStages(
          this.getDestinations(actionDescriptor.destination),
          actionDescriptor.snippetDescription
        );
        return this.actions.insertSnippet.run(
          this.getDestinations(actionDescriptor.destination),
          actionDescriptor.snippetDescription
        );
      case "wrapWithSnippet":
        this.finalStages = this.actions.wrapWithSnippet.getFinalStages(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.snippetDescription
        );
        return this.actions.wrapWithSnippet.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.snippetDescription
        );
      case "editNew":
        return this.actions.editNew.run(
          this.getDestinations(actionDescriptor.destination)
        );
      case "getText":
        return this.actions.getText.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.options
        );
      case "parsed":
        return this.runAction(
          parseAndFillOutAction(
            actionDescriptor.content,
            actionDescriptor.arguments
          )
        );
      default: {
        const action = this.actions[actionDescriptor.name];
        if (action == null) {
          throw new Error(`Unknown action: ${actionDescriptor.name}`);
        }
        this.finalStages = action.getFinalStages?.() ?? [];
        this.noAutomaticTokenExpansion = action.noAutomaticTokenExpansion ?? false;
        return action.run(this.getTargets(actionDescriptor.target));
      }
    }
  }
  getTargets(partialTargetsDescriptor) {
    const targetDescriptor = this.inferenceContext.run(
      partialTargetsDescriptor
    );
    return this.pipelineRunner.run(targetDescriptor, {
      actionFinalStages: this.finalStages,
      noAutomaticTokenExpansion: this.noAutomaticTokenExpansion,
      allowDuplicateTargets: this.allowDuplicateTargets
    });
  }
  getDestinations(destinationDescriptor) {
    switch (destinationDescriptor.type) {
      case "list":
        return destinationDescriptor.destinations.flatMap(
          (destination) => this.getDestinations(destination)
        );
      case "primitive":
        return this.getTargets(destinationDescriptor.target).map(
          (target) => target.toDestination(destinationDescriptor.insertionMode)
        );
      case "implicit":
        return this.getTargets({ type: "implicit" }).map(
          (target) => target.toDestination("to")
        );
    }
  }
};
var InferenceContext = class {
  constructor(debug) {
    this.debug = debug;
    __publicField(this, "previousTargets", []);
  }
  run(target) {
    const ret = inferFullTargetDescriptor(target, this.previousTargets);
    if (this.debug.active) {
      this.debug.log("Full target:");
      this.debug.log(JSON.stringify(ret, null, 2));
    }
    this.previousTargets.push(target);
    return ret;
  }
  reset() {
    this.previousTargets = [];
  }
};
function constructStoredTarget(targets, selections) {
  if (targets != null && selections != null) {
    throw Error(
      "Actions may only return full targets or selections for that mark"
    );
  }
  if (selections != null) {
    return selections.map(selectionToStoredTarget);
  } else {
    return targets;
  }
}

// ../cursorless-engine/src/processTargets/marks/DecoratedSymbolStage.ts
var DecoratedSymbolStage = class {
  constructor(readableHatMap, mark) {
    this.readableHatMap = readableHatMap;
    this.mark = mark;
  }
  run() {
    const token = this.readableHatMap.getToken(
      this.mark.symbolColor,
      this.mark.character
    );
    if (token == null) {
      throw new Error(
        `Couldn't find mark ${this.mark.symbolColor} '${this.mark.character}'`
      );
    }
    return [
      new UntypedTarget({
        editor: token.editor,
        contentRange: token.range,
        isReversed: false,
        hasExplicitRange: false
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/marks/ExplicitMarkStage.ts
var ExplicitMarkStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    const {
      editorId,
      range: { start: start2, end }
    } = this.mark;
    const editor = ide().visibleTextEditors.find((e) => e.id === editorId);
    if (editor == null) {
      throw new Error(`Couldn't find editor '${editorId}'`);
    }
    const contentRange = new Range(
      start2.line,
      start2.character,
      end.line,
      end.character
    );
    return [
      new UntypedTarget({
        editor,
        contentRange,
        isReversed: false,
        hasExplicitRange: false
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/marks/LineNumberStage.ts
var LineNumberStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    const editor = ide().activeTextEditor;
    if (editor == null) {
      return [];
    }
    const lineNumber = getLineNumber2(
      editor,
      this.mark.lineNumberType,
      this.mark.lineNumber
    );
    const line = editor.document.lineAt(lineNumber);
    return [createLineTarget(editor, false, line)];
  }
};
var getLineNumber2 = (editor, lineNumberType, lineNumber) => {
  switch (lineNumberType) {
    case "absolute":
      return lineNumber;
    case "relative":
      return editor.selections[0].active.line + lineNumber;
    case "modulo100": {
      const stepSize = 100;
      const startLine = editor.visibleRanges[0].start.line;
      const endLine = editor.visibleRanges[editor.visibleRanges.length - 1].end.line;
      const base = Math.floor(startLine / stepSize) * stepSize;
      const visibleLines = [];
      const invisibleLines = [];
      let currentLineNumber = base + lineNumber;
      while (currentLineNumber <= endLine) {
        if (currentLineNumber >= startLine) {
          const visible = editor.visibleRanges.find(
            (r) => currentLineNumber >= r.start.line && currentLineNumber <= r.end.line
          );
          if (visible) {
            visibleLines.push(currentLineNumber);
          } else {
            invisibleLines.push(currentLineNumber);
          }
        }
        currentLineNumber += stepSize;
      }
      if (visibleLines.length === 1) {
        return visibleLines[0];
      }
      if (visibleLines.length + invisibleLines.length > 1) {
        throw new Error("Multiple lines matching");
      }
      if (invisibleLines.length === 1) {
        return invisibleLines[0];
      }
      throw new Error("Line is not in viewport");
    }
  }
};

// ../cursorless-engine/src/processTargets/marks/NothingStage.ts
var NothingStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    return [];
  }
};

// ../cursorless-engine/src/processTargets/marks/RangeMarkStage.ts
var RangeMarkStage = class {
  constructor(markStageFactory, mark) {
    this.markStageFactory = markStageFactory;
    this.mark = mark;
  }
  run() {
    const anchorStage = this.markStageFactory.create(this.mark.anchor);
    const activeStage = this.markStageFactory.create(this.mark.active);
    const anchorTargets = anchorStage.run();
    const activeTargets = activeStage.run();
    if (anchorTargets.length !== 1 || activeTargets.length !== 1) {
      throw new Error("Expected single anchor and active target");
    }
    return [
      targetsToContinuousTarget(
        anchorTargets[0],
        activeTargets[0],
        this.mark.excludeAnchor,
        this.mark.excludeActive
      )
    ];
  }
};

// ../cursorless-engine/src/processTargets/marks/StoredTargetStage.ts
var StoredTargetStage = class {
  constructor(storedTargets, key) {
    this.storedTargets = storedTargets;
    this.key = key;
  }
  run() {
    const targets = this.storedTargets.get(this.key);
    if (targets == null || targets.length === 0) {
      throw Error(`No available ${this.key} marks`);
    }
    return targets;
  }
};

// ../cursorless-engine/src/processTargets/marks/TargetMarkStage.ts
var TargetMarkStage = class {
  constructor(targetPipelineRunner, mark) {
    this.targetPipelineRunner = targetPipelineRunner;
    this.mark = mark;
  }
  run() {
    return this.targetPipelineRunner.run(this.mark.target);
  }
};

// ../cursorless-engine/src/processTargets/MarkStageFactoryImpl.ts
var MarkStageFactoryImpl = class {
  constructor(readableHatMap, storedTargets) {
    this.readableHatMap = readableHatMap;
    this.storedTargets = storedTargets;
    __publicField(this, "targetPipelineRunner");
    this.create = this.create.bind(this);
  }
  setPipelineRunner(targetPipelineRunner) {
    this.targetPipelineRunner = targetPipelineRunner;
  }
  create(mark) {
    switch (mark.type) {
      case "cursor":
        return new CursorStage();
      case "that":
      case "source":
      case "keyboard":
        return new StoredTargetStage(this.storedTargets, mark.type);
      case "decoratedSymbol":
        return new DecoratedSymbolStage(this.readableHatMap, mark);
      case "lineNumber":
        return new LineNumberStage(mark);
      case "range":
        return new RangeMarkStage(this, mark);
      case "nothing":
        return new NothingStage(mark);
      case "target":
        return new TargetMarkStage(this.targetPipelineRunner, mark);
      case "explicit":
        return new ExplicitMarkStage(mark);
      default: {
        const _exhaustiveCheck = mark;
        const { type: type2 } = mark;
        throw new Error(`Unknown mark: ${type2}`);
      }
    }
  }
};

// ../cursorless-engine/src/runCommand.ts
async function runCommand(treeSitter, commandServerApi, debug, hatTokenMap, snippets, storedTargets, languageDefinitions, rangeUpdater, commandRunnerDecorators, command) {
  if (debug.active) {
    debug.log(`command:`);
    debug.log(JSON.stringify(command, null, 2));
  }
  const commandComplete = canonicalizeAndValidateCommand(command);
  const readableHatMap = await hatTokenMap.getReadableMap(
    commandComplete.usePrePhraseSnapshot
  );
  let commandRunner = createCommandRunner(
    treeSitter,
    commandServerApi,
    languageDefinitions,
    debug,
    storedTargets,
    readableHatMap,
    snippets,
    rangeUpdater
  );
  for (const decorator of commandRunnerDecorators) {
    commandRunner = decorator.wrapCommandRunner(readableHatMap, commandRunner);
  }
  const response = await commandRunner.run(commandComplete);
  return await unwrapLegacyCommandResponse(command, response);
}
async function unwrapLegacyCommandResponse(command, response) {
  if (clientSupportsFallback(command)) {
    return response;
  }
  if ("returnValue" in response) {
    return response.returnValue;
  }
  return void 0;
}
function createCommandRunner(treeSitter, commandServerApi, languageDefinitions, debug, storedTargets, readableHatMap, snippets, rangeUpdater) {
  const modifierStageFactory = new ModifierStageFactoryImpl(
    languageDefinitions,
    storedTargets,
    new ScopeHandlerFactoryImpl(languageDefinitions)
  );
  const markStageFactory = new MarkStageFactoryImpl(
    readableHatMap,
    storedTargets
  );
  const targetPipelineRunner = new TargetPipelineRunner(
    modifierStageFactory,
    markStageFactory
  );
  markStageFactory.setPipelineRunner(targetPipelineRunner);
  return new CommandRunnerImpl(
    commandServerApi,
    debug,
    storedTargets,
    targetPipelineRunner,
    new Actions(treeSitter, snippets, rangeUpdater, modifierStageFactory)
  );
}

// ../cursorless-engine/src/scopeProviders/scopeTypeToString.ts
function scopeTypeToString(scopeType) {
  if (isSimpleScopeType(scopeType)) {
    return camelCaseToAllDown(scopeType.type).replace(".", " ");
  }
  if (scopeType.type === "surroundingPair") {
    return `Matching pair of ${camelCaseToAllDown(scopeType.delimiter)}`;
  }
  if (scopeType.type === "customRegex") {
    return `Regex \`${scopeType.regex}\``;
  }
  return "Unknown scope type";
}

// ../cursorless-engine/src/scopeProviders/ScopeInfoProvider.ts
var ScopeInfoProvider = class {
  constructor(customSpokenFormGenerator) {
    this.customSpokenFormGenerator = customSpokenFormGenerator;
    __publicField(this, "disposable");
    __publicField(this, "listeners", []);
    __publicField(this, "scopeInfos");
    this.disposable = customSpokenFormGenerator.onDidChangeCustomSpokenForms(
      () => this.onChange()
    );
    this.onDidChangeScopeInfo = this.onDidChangeScopeInfo.bind(this);
    this.getScopeTypeInfo = this.getScopeTypeInfo.bind(this);
    this.updateScopeTypeInfos();
  }
  /**
   * Registers a callback to be run when the scope info changes.  The callback
   * will be run immediately once with the current scope info.
   *
   * Includes information about the available scopes, including their custom
   * spoken forms, if available. Note that even custom regex scopes will be
   * available, as reported to the engine by Talon.
   * @param callback The callback to run when the scope support changes
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeScopeInfo(callback2) {
    callback2(this.getScopeTypeInfos());
    this.listeners.push(callback2);
    return {
      dispose: () => {
        pull_default(this.listeners, callback2);
      }
    };
  }
  async onChange() {
    this.updateScopeTypeInfos();
    this.listeners.slice().forEach((listener) => listener(this.scopeInfos));
  }
  updateScopeTypeInfos() {
    const scopeTypes = [
      ...simpleScopeTypeTypes.filter((scopeTypeType) => !pseudoScopes.has(scopeTypeType)).map((scopeTypeType) => ({
        type: scopeTypeType
      })),
      ...surroundingPairNames.map(
        (surroundingPairName) => ({
          type: "surroundingPair",
          delimiter: surroundingPairName
        })
      ),
      ...this.customSpokenFormGenerator.getCustomRegexScopeTypes()
    ];
    this.scopeInfos = scopeTypes.map(
      (scopeType) => this.getScopeTypeInfo(scopeType)
    );
  }
  getScopeTypeInfos() {
    return this.scopeInfos;
  }
  getScopeTypeInfo(scopeType) {
    return {
      scopeType,
      spokenForm: this.customSpokenFormGenerator.scopeTypeToSpokenForm(scopeType),
      humanReadableName: scopeTypeToString(scopeType),
      isLanguageSpecific: isLanguageSpecific(scopeType)
    };
  }
  dispose() {
    this.disposable.dispose();
  }
};
function isLanguageSpecific(scopeType) {
  switch (scopeType.type) {
    case "string":
    case "argumentOrParameter":
    case "argumentList":
    case "anonymousFunction":
    case "attribute":
    case "branch":
    case "class":
    case "className":
    case "collectionItem":
    case "collectionKey":
    case "command":
    case "comment":
    case "private.fieldAccess":
    case "functionCall":
    case "functionCallee":
    case "functionName":
    case "ifStatement":
    case "instance":
    case "interior":
    case "list":
    case "map":
    case "name":
    case "namedFunction":
    case "regularExpression":
    case "statement":
    case "type":
    case "value":
    case "condition":
    case "section":
    case "sectionLevelOne":
    case "sectionLevelTwo":
    case "sectionLevelThree":
    case "sectionLevelFour":
    case "sectionLevelFive":
    case "sectionLevelSix":
    case "selector":
    case "unit":
    case "xmlBothTags":
    case "xmlElement":
    case "xmlEndTag":
    case "xmlStartTag":
    case "part":
    case "chapter":
    case "subSection":
    case "subSubSection":
    case "namedParagraph":
    case "subParagraph":
    case "environment":
    case "textFragment":
    case "disqualifyDelimiter":
    case "pairDelimiter":
      return true;
    case "character":
    case "word":
    case "token":
    case "identifier":
    case "line":
    case "fullLine":
    case "sentence":
    case "paragraph":
    case "boundedParagraph":
    case "document":
    case "nonWhitespaceSequence":
    case "boundedNonWhitespaceSequence":
    case "url":
    case "notebookCell":
    case "surroundingPair":
    case "surroundingPairInterior":
    case "customRegex":
    case "glyph":
      return false;
    case "oneOf":
      throw Error(
        `Can't decide whether scope type ${JSON.stringify(
          scopeType,
          void 0,
          3
        )} is language-specific`
      );
  }
}

// ../cursorless-engine/src/scopeProviders/getIterationRange.ts
function getIterationRange(editor, scopeHandler, visibleOnly) {
  if (!visibleOnly) {
    return editor.document.range;
  }
  let visibleRange = editor.visibleRanges.reduce(
    (acc, range3) => acc.union(range3)
  );
  visibleRange = editor.document.range.intersection(
    visibleRange.with(
      visibleRange.start.translate(-10),
      visibleRange.end.translate(10)
    )
  );
  const expandedStart = last_default(
    Array.from(
      scopeHandler.generateScopes(editor, visibleRange.start, "forward", {
        containment: "required"
      })
    )
  )?.domain ?? visibleRange;
  const expandedEnd = last_default(
    Array.from(
      scopeHandler.generateScopes(editor, visibleRange.end, "forward", {
        containment: "required"
      })
    )
  )?.domain ?? visibleRange;
  return expandedStart.union(expandedEnd);
}

// ../cursorless-engine/src/scopeProviders/getTargetRanges.ts
function getTargetRanges(target) {
  return {
    contentRange: target.contentRange,
    removalRange: target.getRemovalRange(),
    removalHighlightRange: target.getRemovalHighlightRange(),
    leadingDelimiter: getOptionalTarget(target.getLeadingDelimiterTarget()),
    trailingDelimiter: getOptionalTarget(target.getTrailingDelimiterTarget()),
    interior: target.getInterior()?.map(getTargetRanges),
    boundary: target.getBoundary()?.map(getTargetRanges),
    insertionDelimiter: target.insertionDelimiter
  };
}
function getOptionalTarget(target) {
  return target != null ? getTargetRanges(target) : void 0;
}

// ../cursorless-engine/src/scopeProviders/getIterationScopeRanges.ts
function getIterationScopeRanges(editor, iterationScopeHandler, everyStage, iterationRange, includeIterationNestedTargets) {
  const options2 = {
    multipleTargets: true
  };
  return map(
    iterationScopeHandler.generateScopes(
      editor,
      iterationRange.start,
      "forward",
      {
        includeDescendantScopes: true,
        distalPosition: iterationRange.end
      }
    ),
    (scope) => {
      return {
        domain: scope.domain,
        ranges: scope.getTargets(false).map((target) => ({
          range: target.contentRange,
          targets: includeIterationNestedTargets ? getEveryScopeLenient(everyStage, target, options2).map(
            getTargetRanges
          ) : void 0
        }))
      };
    }
  );
}
function getEveryScopeLenient(everyStage, target, options2) {
  try {
    return everyStage.run(target, options2);
  } catch (err2) {
    if (err2.name === "NoContainingScopeError") {
      return [];
    }
    throw err2;
  }
}

// ../cursorless-engine/src/scopeProviders/getScopeRanges.ts
function getScopeRanges(editor, scopeHandler, iterationRange) {
  return map(
    scopeHandler.generateScopes(editor, iterationRange.start, "forward", {
      includeDescendantScopes: true,
      distalPosition: iterationRange.end
    }),
    (scope) => ({
      domain: scope.domain,
      targets: scope.getTargets(false).map(getTargetRanges)
    })
  );
}

// ../cursorless-engine/src/scopeProviders/ScopeRangeProvider.ts
var ScopeRangeProvider = class {
  constructor(scopeHandlerFactory, modifierStageFactory) {
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifierStageFactory = modifierStageFactory;
    this.provideScopeRanges = this.provideScopeRanges.bind(this);
    this.provideScopeRangesForRange = this.provideScopeRangesForRange.bind(this);
    this.provideIterationScopeRanges = this.provideIterationScopeRanges.bind(this);
  }
  provideScopeRanges(editor, { scopeType, visibleOnly }) {
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      editor.document.languageId
    );
    if (scopeHandler == null) {
      return [];
    }
    return getScopeRanges(
      editor,
      scopeHandler,
      getIterationRange(editor, scopeHandler, visibleOnly)
    );
  }
  provideScopeRangesForRange(editor, scopeType, range3) {
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      editor.document.languageId
    );
    if (scopeHandler == null) {
      return [];
    }
    if (range3.isEmpty) {
      const offset = editor.document.offsetAt(range3.start);
      range3 = new Range(
        editor.document.positionAt(offset - 1),
        editor.document.positionAt(offset + 1)
      );
    }
    return getScopeRanges(editor, scopeHandler, range3);
  }
  provideIterationScopeRanges(editor, { scopeType, visibleOnly, includeNestedTargets }) {
    const { languageId } = editor.document;
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      languageId
    );
    if (scopeHandler == null) {
      return [];
    }
    const iterationScopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeHandler.iterationScopeType,
      languageId
    );
    if (iterationScopeHandler == null) {
      return [];
    }
    return getIterationScopeRanges(
      editor,
      iterationScopeHandler,
      this.modifierStageFactory.create({
        type: "everyScope",
        scopeType
      }),
      getIterationRange(editor, scopeHandler, visibleOnly),
      includeNestedTargets
    );
  }
};

// ../cursorless-engine/src/scopeProviders/ScopeRangeWatcher.ts
var ScopeRangeWatcher = class {
  constructor(languageDefinitions, scopeRangeProvider) {
    this.scopeRangeProvider = scopeRangeProvider;
    __publicField(this, "disposables", []);
    __publicField(this, "listeners", []);
    this.onChange = this.onChange.bind(this);
    this.onDidChangeScopeRanges = this.onDidChangeScopeRanges.bind(this);
    this.onDidChangeIterationScopeRanges = this.onDidChangeIterationScopeRanges.bind(this);
    const debouncer = new DecorationDebouncer(
      ide().configuration,
      () => this.onChange()
    );
    this.disposables.push(
      // An Event which fires when the array of visible editors has changed.
      ide().onDidChangeVisibleTextEditors(debouncer.run),
      // An event that fires when a text document opens
      ide().onDidOpenTextDocument(debouncer.run),
      // An Event that fires when a text document closes
      ide().onDidCloseTextDocument(debouncer.run),
      // An event that is emitted when a text document is changed. This usually
      // happens when the contents changes but also when other things like the
      // dirty-state changes.
      ide().onDidChangeTextDocument(debouncer.run),
      ide().onDidChangeTextEditorVisibleRanges(debouncer.run),
      languageDefinitions.onDidChangeDefinition(this.onChange),
      debouncer
    );
  }
  /**
   * Registers a callback to be run when the scope ranges change for any visible
   * editor.  The callback will be run immediately once for each visible editor
   * with the current scope ranges.
   * @param callback The callback to run when the scope ranges change
   * @param config The configuration for the scope ranges
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeScopeRanges(callback2, config2) {
    const fn = () => {
      ide().visibleTextEditors.forEach((editor) => {
        let scopeRanges;
        try {
          scopeRanges = this.scopeRangeProvider.provideScopeRanges(
            editor,
            config2
          );
        } catch (err2) {
          void showError(
            ide().messages,
            "ScopeRangeWatcher.provide",
            err2.message
          );
          scopeRanges = [];
          if (ide().runMode === "test") {
            throw err2;
          }
        }
        callback2(editor, scopeRanges);
      });
    };
    this.listeners.push(fn);
    fn();
    return {
      dispose: () => {
        pull_default(this.listeners, fn);
      }
    };
  }
  /**
   * Registers a callback to be run when the iteration scope ranges change for
   * any visible editor.  The callback will be run immediately once for each
   * visible editor with the current iteration scope ranges.
   * @param callback The callback to run when the scope ranges change
   * @param config The configuration for the scope ranges
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeIterationScopeRanges(callback2, config2) {
    const fn = () => {
      ide().visibleTextEditors.forEach((editor) => {
        callback2(
          editor,
          this.scopeRangeProvider.provideIterationScopeRanges(editor, config2)
        );
      });
    };
    this.listeners.push(fn);
    fn();
    return {
      dispose: () => {
        pull_default(this.listeners, fn);
      }
    };
  }
  onChange() {
    this.listeners.slice().forEach((listener) => listener());
  }
  dispose() {
    this.disposables.forEach(({ dispose }) => {
      try {
        dispose();
      } catch (_e) {
      }
    });
  }
};

// ../cursorless-engine/src/scopeProviders/ScopeSupportChecker.ts
var ScopeSupportChecker = class {
  constructor(scopeHandlerFactory) {
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.getScopeSupport = this.getScopeSupport.bind(this);
    this.getIterationScopeSupport = this.getIterationScopeSupport.bind(this);
  }
  /**
   * Determine the level of support for {@link scopeType} in {@link editor}, as
   * determined by its language id.
   * @param editor The editor to check
   * @param scopeType The scope type to check
   * @returns The level of support for {@link scopeType} in {@link editor}
   */
  getScopeSupport(editor, scopeType) {
    const { languageId } = editor.document;
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      languageId
    );
    if (scopeHandler == null) {
      return 2 /* unsupported */;
    }
    return editorContainsScope(editor, scopeHandler) ? 0 /* supportedAndPresentInEditor */ : 1 /* supportedButNotPresentInEditor */;
  }
  /**
   * Determine the level of support for the iteration scope of {@link scopeType}
   * in {@link editor}, as determined by its language id.
   * @param editor The editor to check
   * @param scopeType The scope type to check
   * @returns The level of support for the iteration scope of {@link scopeType}
   * in {@link editor}
   */
  getIterationScopeSupport(editor, scopeType) {
    const { languageId } = editor.document;
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      languageId
    );
    if (scopeHandler == null) {
      return 2 /* unsupported */;
    }
    const iterationScopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeHandler.iterationScopeType,
      languageId
    );
    if (iterationScopeHandler == null) {
      return 2 /* unsupported */;
    }
    return editorContainsScope(editor, iterationScopeHandler) ? 0 /* supportedAndPresentInEditor */ : 1 /* supportedButNotPresentInEditor */;
  }
};
function editorContainsScope(editor, scopeHandler) {
  return !isEmptyIterable(
    scopeHandler.generateScopes(editor, new Position(0, 0), "forward")
  );
}

// ../cursorless-engine/src/scopeProviders/ScopeSupportWatcher.ts
var ScopeSupportWatcher = class {
  constructor(languageDefinitions, scopeSupportChecker, scopeInfoProvider) {
    this.scopeSupportChecker = scopeSupportChecker;
    this.scopeInfoProvider = scopeInfoProvider;
    __publicField(this, "disposable");
    __publicField(this, "listeners", []);
    this.onChange = this.onChange.bind(this);
    this.onDidChangeScopeSupport = this.onDidChangeScopeSupport.bind(this);
    const debouncer = new DecorationDebouncer(
      ide().configuration,
      () => this.onChange()
    );
    this.disposable = disposableFrom(
      // An event that fires when a text document opens
      ide().onDidOpenTextDocument(debouncer.run),
      // An Event that fires when a text document closes
      ide().onDidCloseTextDocument(debouncer.run),
      // An Event which fires when the active editor has changed. Note that the event also fires when the active editor changes to undefined.
      ide().onDidChangeActiveTextEditor(debouncer.run),
      // An event that is emitted when a text document is changed. This usually
      // happens when the contents changes but also when other things like the
      // dirty-state changes.
      ide().onDidChangeTextDocument(debouncer.run),
      languageDefinitions.onDidChangeDefinition(debouncer.run),
      this.scopeInfoProvider.onDidChangeScopeInfo(this.onChange),
      debouncer
    );
  }
  /**
   * Registers a callback to be run when the scope support changes for the active
   * editor.  The callback will be run immediately once with the current support
   * levels for the active editor.
   *
   * Note that this watcher could be expensive, because it runs all the scope
   * handlers for the active editor every time the content of the active editor
   * changes. If you only need info about the available scopes, including their
   * spoken forms, you should use {@link onDidChangeScopeInfo} instead.
   * @param callback The callback to run when the scope support changes
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeScopeSupport(callback2) {
    callback2(this.getSupportLevels());
    this.listeners.push(callback2);
    return {
      dispose: () => {
        pull_default(this.listeners, callback2);
      }
    };
  }
  onChange() {
    if (this.listeners.length === 0) {
      return;
    }
    const supportLevels = this.getSupportLevels();
    this.listeners.slice().forEach((listener) => listener(supportLevels));
  }
  getSupportLevels() {
    const activeTextEditor = ide().activeTextEditor;
    const getScopeTypeSupport = activeTextEditor == null ? () => 2 /* unsupported */ : (scopeType) => this.scopeSupportChecker.getScopeSupport(
      activeTextEditor,
      scopeType
    );
    const getIterationScopeTypeSupport = activeTextEditor == null ? () => 2 /* unsupported */ : (scopeType) => this.scopeSupportChecker.getIterationScopeSupport(
      activeTextEditor,
      scopeType
    );
    const scopeTypeInfos = this.scopeInfoProvider.getScopeTypeInfos();
    return scopeTypeInfos.map((scopeTypeInfo) => ({
      ...scopeTypeInfo,
      support: getScopeTypeSupport(scopeTypeInfo.scopeType),
      iterationScopeSupport: getIterationScopeTypeSupport(
        scopeTypeInfo.scopeType
      )
    }));
  }
  dispose() {
    this.disposable.dispose();
  }
};

// ../cursorless-engine/src/cursorlessEngine.ts
async function createCursorlessEngine({
  ide: ide2,
  hats,
  treeSitterQueryProvider,
  treeSitter = new DisabledTreeSitter(),
  commandServerApi = new DisabledCommandServerApi(),
  talonSpokenForms = new DisabledTalonSpokenForms(),
  snippets = new DisabledSnippets()
}) {
  injectIde(ide2);
  const debug = new Debug(ide2);
  const rangeUpdater = new RangeUpdater();
  const storedTargets = new StoredTargetMap();
  const keyboardTargetUpdater = new KeyboardTargetUpdater(ide2, storedTargets);
  const customSpokenFormGenerator = new CustomSpokenFormGeneratorImpl(
    talonSpokenForms
  );
  const hatTokenMap = hats != null ? new HatTokenMapImpl(rangeUpdater, debug, hats, commandServerApi) : new DisabledHatTokenMap();
  void hatTokenMap.allocateHats();
  const languageDefinitions = treeSitterQueryProvider ? await LanguageDefinitionsImpl.create(
    ide2,
    treeSitter,
    treeSitterQueryProvider
  ) : new DisabledLanguageDefinitions();
  ide2.disposeOnExit(
    rangeUpdater,
    languageDefinitions,
    hatTokenMap,
    debug,
    keyboardTargetUpdater,
    customSpokenFormGenerator
  );
  const commandRunnerDecorators = [];
  let previousCommand = void 0;
  const runCommandClosure = (command) => {
    previousCommand = command;
    return runCommand(
      treeSitter,
      commandServerApi,
      debug,
      hatTokenMap,
      snippets,
      storedTargets,
      languageDefinitions,
      rangeUpdater,
      commandRunnerDecorators,
      command
    );
  };
  return {
    commandApi: {
      runCommand(command) {
        return runCommandClosure(command);
      },
      runCommandSafe(...args2) {
        return runCommandClosure(ensureCommandShape(args2));
      },
      repeatPreviousCommand() {
        if (previousCommand == null) {
          throw new Error("No previous command");
        }
        return runCommandClosure(previousCommand);
      }
    },
    scopeProvider: createScopeProvider(
      ide2,
      languageDefinitions,
      storedTargets,
      customSpokenFormGenerator
    ),
    customSpokenFormGenerator,
    storedTargets,
    hatTokenMap,
    injectIde,
    addCommandRunnerDecorator: (decorator) => {
      commandRunnerDecorators.push(decorator);
    }
  };
}
function createScopeProvider(ide2, languageDefinitions, storedTargets, customSpokenFormGenerator) {
  const scopeHandlerFactory = new ScopeHandlerFactoryImpl(languageDefinitions);
  const rangeProvider = new ScopeRangeProvider(
    scopeHandlerFactory,
    new ModifierStageFactoryImpl(
      languageDefinitions,
      storedTargets,
      scopeHandlerFactory
    )
  );
  const rangeWatcher = new ScopeRangeWatcher(
    languageDefinitions,
    rangeProvider
  );
  const supportChecker = new ScopeSupportChecker(scopeHandlerFactory);
  const infoProvider = new ScopeInfoProvider(customSpokenFormGenerator);
  const supportWatcher = new ScopeSupportWatcher(
    languageDefinitions,
    supportChecker,
    infoProvider
  );
  ide2.disposeOnExit(rangeWatcher, infoProvider, supportWatcher);
  return {
    provideScopeRanges: rangeProvider.provideScopeRanges,
    provideScopeRangesForRange: rangeProvider.provideScopeRangesForRange,
    provideIterationScopeRanges: rangeProvider.provideIterationScopeRanges,
    onDidChangeScopeRanges: rangeWatcher.onDidChangeScopeRanges,
    onDidChangeIterationScopeRanges: rangeWatcher.onDidChangeIterationScopeRanges,
    getScopeSupport: supportChecker.getScopeSupport,
    getIterationScopeSupport: supportChecker.getIterationScopeSupport,
    onDidChangeScopeSupport: supportWatcher.onDidChangeScopeSupport,
    getScopeInfo: infoProvider.getScopeTypeInfo,
    onDidChangeScopeInfo: infoProvider.onDidChangeScopeInfo
  };
}

// ../cursorless-engine/src/util/grammarHelpers.ts
var ArgPosition = class {
  constructor(position) {
    this.position = position;
  }
};
var argPositions = {
  $0: new ArgPosition(0),
  $1: new ArgPosition(1),
  $2: new ArgPosition(2)
};

// ../../node_modules/.pnpm/web-tree-sitter@0.25.6/node_modules/web-tree-sitter/tree-sitter.js
var __defProp2 = Object.defineProperty;
var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
var SIZE_OF_SHORT = 2;
var SIZE_OF_INT = 4;
var SIZE_OF_CURSOR = 4 * SIZE_OF_INT;
var SIZE_OF_NODE = 5 * SIZE_OF_INT;
var SIZE_OF_POINT = 2 * SIZE_OF_INT;
var SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT;
var ZERO_POINT = { row: 0, column: 0 };
var INTERNAL = /* @__PURE__ */ Symbol("INTERNAL");
function assertInternal(x) {
  if (x !== INTERNAL) throw new Error("Illegal constructor");
}
__name(assertInternal, "assertInternal");
function isPoint(point) {
  return !!point && typeof point.row === "number" && typeof point.column === "number";
}
__name(isPoint, "isPoint");
function setModule(module2) {
  C = module2;
}
__name(setModule, "setModule");
var C;
var _a2;
var LookaheadIterator = (_a2 = class {
  /** @internal */
  constructor(internal, address, language) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "language");
    assertInternal(internal);
    this[0] = address;
    this.language = language;
  }
  /** Get the current symbol of the lookahead iterator. */
  get currentTypeId() {
    return C._ts_lookahead_iterator_current_symbol(this[0]);
  }
  /** Get the current symbol name of the lookahead iterator. */
  get currentType() {
    return this.language.types[this.currentTypeId] || "ERROR";
  }
  /** Delete the lookahead iterator, freeing its resources. */
  delete() {
    C._ts_lookahead_iterator_delete(this[0]);
    this[0] = 0;
  }
  /**
   * Reset the lookahead iterator.
   *
   * This returns `true` if the language was set successfully and `false`
   * otherwise.
   */
  reset(language, stateId) {
    if (C._ts_lookahead_iterator_reset(this[0], language[0], stateId)) {
      this.language = language;
      return true;
    }
    return false;
  }
  /**
   * Reset the lookahead iterator to another state.
   *
   * This returns `true` if the iterator was reset to the given state and
   * `false` otherwise.
   */
  resetState(stateId) {
    return Boolean(C._ts_lookahead_iterator_reset_state(this[0], stateId));
  }
  /**
   * Returns an iterator that iterates over the symbols of the lookahead iterator.
   *
   * The iterator will yield the current symbol name as a string for each step
   * until there are no more symbols to iterate over.
   */
  [Symbol.iterator]() {
    return {
      next: /* @__PURE__ */ __name(() => {
        if (C._ts_lookahead_iterator_next(this[0])) {
          return { done: false, value: this.currentType };
        }
        return { done: true, value: "" };
      }, "next")
    };
  }
}, __name(_a2, "LookaheadIterator"), _a2);
function getText2(tree, startIndex, endIndex, startPosition) {
  const length = endIndex - startIndex;
  let result = tree.textCallback(startIndex, startPosition);
  if (result) {
    startIndex += result.length;
    while (startIndex < endIndex) {
      const string5 = tree.textCallback(startIndex, startPosition);
      if (string5 && string5.length > 0) {
        startIndex += string5.length;
        result += string5;
      } else {
        break;
      }
    }
    if (startIndex > endIndex) {
      result = result.slice(0, length);
    }
  }
  return result ?? "";
}
__name(getText2, "getText");
var _a3;
var Tree = (_a3 = class {
  /** @internal */
  constructor(internal, address, language, textCallback) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "textCallback");
    /** The language that was used to parse the syntax tree. */
    __publicField(this, "language");
    assertInternal(internal);
    this[0] = address;
    this.language = language;
    this.textCallback = textCallback;
  }
  /** Create a shallow copy of the syntax tree. This is very fast. */
  copy() {
    const address = C._ts_tree_copy(this[0]);
    return new _a3(INTERNAL, address, this.language, this.textCallback);
  }
  /** Delete the syntax tree, freeing its resources. */
  delete() {
    C._ts_tree_delete(this[0]);
    this[0] = 0;
  }
  /** Get the root node of the syntax tree. */
  get rootNode() {
    C._ts_tree_root_node_wasm(this[0]);
    return unmarshalNode(this);
  }
  /**
   * Get the root node of the syntax tree, but with its position shifted
   * forward by the given offset.
   */
  rootNodeWithOffset(offsetBytes, offsetExtent) {
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, offsetBytes, "i32");
    marshalPoint(address + SIZE_OF_INT, offsetExtent);
    C._ts_tree_root_node_with_offset_wasm(this[0]);
    return unmarshalNode(this);
  }
  /**
   * Edit the syntax tree to keep it in sync with source code that has been
   * edited.
   *
   * You must describe the edit both in terms of byte offsets and in terms of
   * row/column coordinates.
   */
  edit(edit) {
    marshalEdit(edit);
    C._ts_tree_edit_wasm(this[0]);
  }
  /** Create a new {@link TreeCursor} starting from the root of the tree. */
  walk() {
    return this.rootNode.walk();
  }
  /**
   * Compare this old edited syntax tree to a new syntax tree representing
   * the same document, returning a sequence of ranges whose syntactic
   * structure has changed.
   *
   * For this to work correctly, this syntax tree must have been edited such
   * that its ranges match up to the new tree. Generally, you'll want to
   * call this method right after calling one of the [`Parser::parse`]
   * functions. Call it on the old tree that was passed to parse, and
   * pass the new tree that was returned from `parse`.
   */
  getChangedRanges(other) {
    if (!(other instanceof _a3)) {
      throw new TypeError("Argument must be a Tree");
    }
    C._ts_tree_get_changed_ranges_wasm(this[0], other[0]);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = unmarshalRange(address);
        address += SIZE_OF_RANGE;
      }
      C._free(buffer);
    }
    return result;
  }
  /** Get the included ranges that were used to parse the syntax tree. */
  getIncludedRanges() {
    C._ts_tree_included_ranges_wasm(this[0]);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = unmarshalRange(address);
        address += SIZE_OF_RANGE;
      }
      C._free(buffer);
    }
    return result;
  }
}, __name(_a3, "Tree"), _a3);
var _a4;
var TreeCursor = (_a4 = class {
  /** @internal */
  constructor(internal, tree) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, 1, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, 2, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, 3, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "tree");
    assertInternal(internal);
    this.tree = tree;
    unmarshalTreeCursor(this);
  }
  /** Creates a deep copy of the tree cursor. This allocates new memory. */
  copy() {
    const copy = new _a4(INTERNAL, this.tree);
    C._ts_tree_cursor_copy_wasm(this.tree[0]);
    unmarshalTreeCursor(copy);
    return copy;
  }
  /** Delete the tree cursor, freeing its resources. */
  delete() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_delete_wasm(this.tree[0]);
    this[0] = this[1] = this[2] = 0;
  }
  /** Get the tree cursor's current {@link Node}. */
  get currentNode() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_current_node_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get the numerical field id of this tree cursor's current node.
   *
   * See also {@link TreeCursor#currentFieldName}.
   */
  get currentFieldId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);
  }
  /** Get the field name of this tree cursor's current node. */
  get currentFieldName() {
    return this.tree.language.fields[this.currentFieldId];
  }
  /**
   * Get the depth of the cursor's current node relative to the original
   * node that the cursor was constructed with.
   */
  get currentDepth() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_depth_wasm(this.tree[0]);
  }
  /**
   * Get the index of the cursor's current node out of all of the
   * descendants of the original node that the cursor was constructed with.
   */
  get currentDescendantIndex() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_descendant_index_wasm(this.tree[0]);
  }
  /** Get the type of the cursor's current node. */
  get nodeType() {
    return this.tree.language.types[this.nodeTypeId] || "ERROR";
  }
  /** Get the type id of the cursor's current node. */
  get nodeTypeId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);
  }
  /** Get the state id of the cursor's current node. */
  get nodeStateId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_state_id_wasm(this.tree[0]);
  }
  /** Get the id of the cursor's current node. */
  get nodeId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);
  }
  /**
   * Check if the cursor's current node is *named*.
   *
   * Named nodes correspond to named rules in the grammar, whereas
   * *anonymous* nodes correspond to string literals in the grammar.
   */
  get nodeIsNamed() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if the cursor's current node is *missing*.
   *
   * Missing nodes are inserted by the parser in order to recover from
   * certain kinds of syntax errors.
   */
  get nodeIsMissing() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;
  }
  /** Get the string content of the cursor's current node. */
  get nodeText() {
    marshalTreeCursor(this);
    const startIndex = C._ts_tree_cursor_start_index_wasm(this.tree[0]);
    const endIndex = C._ts_tree_cursor_end_index_wasm(this.tree[0]);
    C._ts_tree_cursor_start_position_wasm(this.tree[0]);
    const startPosition = unmarshalPoint(TRANSFER_BUFFER);
    return getText2(this.tree, startIndex, endIndex, startPosition);
  }
  /** Get the start position of the cursor's current node. */
  get startPosition() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_start_position_wasm(this.tree[0]);
    return unmarshalPoint(TRANSFER_BUFFER);
  }
  /** Get the end position of the cursor's current node. */
  get endPosition() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_end_position_wasm(this.tree[0]);
    return unmarshalPoint(TRANSFER_BUFFER);
  }
  /** Get the start index of the cursor's current node. */
  get startIndex() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_start_index_wasm(this.tree[0]);
  }
  /** Get the end index of the cursor's current node. */
  get endIndex() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_end_index_wasm(this.tree[0]);
  }
  /**
   * Move this cursor to the first child of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there were no children.
   */
  gotoFirstChild() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the last child of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there were no children.
   *
   * Note that this function may be slower than
   * {@link TreeCursor#gotoFirstChild} because it needs to
   * iterate through all the children to compute the child's position.
   */
  gotoLastChild() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_last_child_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the parent of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there was no parent node (the cursor was already on the
   * root node).
   *
   * Note that the node the cursor was constructed with is considered the root
   * of the cursor, and the cursor cannot walk outside this node.
   */
  gotoParent() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the next sibling of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there was no next sibling node.
   *
   * Note that the node the cursor was constructed with is considered the root
   * of the cursor, and the cursor cannot walk outside this node.
   */
  gotoNextSibling() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the previous sibling of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there was no previous sibling node.
   *
   * Note that this function may be slower than
   * {@link TreeCursor#gotoNextSibling} due to how node
   * positions are stored. In the worst case, this will need to iterate
   * through all the children up to the previous sibling node to recalculate
   * its position. Also note that the node the cursor was constructed with is
   * considered the root of the cursor, and the cursor cannot walk outside this node.
   */
  gotoPreviousSibling() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_previous_sibling_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move the cursor to the node that is the nth descendant of
   * the original node that the cursor was constructed with, where
   * zero represents the original node itself.
   */
  gotoDescendant(goalDescendantIndex) {
    marshalTreeCursor(this);
    C._ts_tree_cursor_goto_descendant_wasm(this.tree[0], goalDescendantIndex);
    unmarshalTreeCursor(this);
  }
  /**
   * Move this cursor to the first child of its current node that contains or
   * starts after the given byte offset.
   *
   * This returns `true` if the cursor successfully moved to a child node, and returns
   * `false` if no such child was found.
   */
  gotoFirstChildForIndex(goalIndex) {
    marshalTreeCursor(this);
    C.setValue(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalIndex, "i32");
    const result = C._ts_tree_cursor_goto_first_child_for_index_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the first child of its current node that contains or
   * starts after the given byte offset.
   *
   * This returns the index of the child node if one was found, and returns
   * `null` if no such child was found.
   */
  gotoFirstChildForPosition(goalPosition) {
    marshalTreeCursor(this);
    marshalPoint(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalPosition);
    const result = C._ts_tree_cursor_goto_first_child_for_position_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Re-initialize this tree cursor to start at the original node that the
   * cursor was constructed with.
   */
  reset(node) {
    marshalNode(node);
    marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE);
    C._ts_tree_cursor_reset_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
  }
  /**
   * Re-initialize a tree cursor to the same position as another cursor.
   *
   * Unlike {@link TreeCursor#reset}, this will not lose parent
   * information and allows reusing already created cursors.
   */
  resetTo(cursor) {
    marshalTreeCursor(this, TRANSFER_BUFFER);
    marshalTreeCursor(cursor, TRANSFER_BUFFER + SIZE_OF_CURSOR);
    C._ts_tree_cursor_reset_to_wasm(this.tree[0], cursor.tree[0]);
    unmarshalTreeCursor(this);
  }
}, __name(_a4, "TreeCursor"), _a4);
var _a5;
var Node = (_a5 = class {
  /** @internal */
  constructor(internal, {
    id: id2,
    tree,
    startIndex,
    startPosition,
    other
  }) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "_children");
    /** @internal */
    __publicField(this, "_namedChildren");
    /**
     * The numeric id for this node that is unique.
     *
     * Within a given syntax tree, no two nodes have the same id. However:
     *
     * * If a new tree is created based on an older tree, and a node from the old tree is reused in
     *   the process, then that node will have the same id in both trees.
     *
     * * A node not marked as having changes does not guarantee it was reused.
     *
     * * If a node is marked as having changed in the old tree, it will not be reused.
     */
    __publicField(this, "id");
    /** The byte index where this node starts. */
    __publicField(this, "startIndex");
    /** The position where this node starts. */
    __publicField(this, "startPosition");
    /** The tree that this node belongs to. */
    __publicField(this, "tree");
    assertInternal(internal);
    this[0] = other;
    this.id = id2;
    this.tree = tree;
    this.startIndex = startIndex;
    this.startPosition = startPosition;
  }
  /** Get this node's type as a numerical id. */
  get typeId() {
    marshalNode(this);
    return C._ts_node_symbol_wasm(this.tree[0]);
  }
  /**
   * Get the node's type as a numerical id as it appears in the grammar,
   * ignoring aliases.
   */
  get grammarId() {
    marshalNode(this);
    return C._ts_node_grammar_symbol_wasm(this.tree[0]);
  }
  /** Get this node's type as a string. */
  get type() {
    return this.tree.language.types[this.typeId] || "ERROR";
  }
  /**
   * Get this node's symbol name as it appears in the grammar, ignoring
   * aliases as a string.
   */
  get grammarType() {
    return this.tree.language.types[this.grammarId] || "ERROR";
  }
  /**
   * Check if this node is *named*.
   *
   * Named nodes correspond to named rules in the grammar, whereas
   * *anonymous* nodes correspond to string literals in the grammar.
   */
  get isNamed() {
    marshalNode(this);
    return C._ts_node_is_named_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node is *extra*.
   *
   * Extra nodes represent things like comments, which are not required
   * by the grammar, but can appear anywhere.
   */
  get isExtra() {
    marshalNode(this);
    return C._ts_node_is_extra_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node represents a syntax error.
   *
   * Syntax errors represent parts of the code that could not be incorporated
   * into a valid syntax tree.
   */
  get isError() {
    marshalNode(this);
    return C._ts_node_is_error_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node is *missing*.
   *
   * Missing nodes are inserted by the parser in order to recover from
   * certain kinds of syntax errors.
   */
  get isMissing() {
    marshalNode(this);
    return C._ts_node_is_missing_wasm(this.tree[0]) === 1;
  }
  /** Check if this node has been edited. */
  get hasChanges() {
    marshalNode(this);
    return C._ts_node_has_changes_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node represents a syntax error or contains any syntax
   * errors anywhere within it.
   */
  get hasError() {
    marshalNode(this);
    return C._ts_node_has_error_wasm(this.tree[0]) === 1;
  }
  /** Get the byte index where this node ends. */
  get endIndex() {
    marshalNode(this);
    return C._ts_node_end_index_wasm(this.tree[0]);
  }
  /** Get the position where this node ends. */
  get endPosition() {
    marshalNode(this);
    C._ts_node_end_point_wasm(this.tree[0]);
    return unmarshalPoint(TRANSFER_BUFFER);
  }
  /** Get the string content of this node. */
  get text() {
    return getText2(this.tree, this.startIndex, this.endIndex, this.startPosition);
  }
  /** Get this node's parse state. */
  get parseState() {
    marshalNode(this);
    return C._ts_node_parse_state_wasm(this.tree[0]);
  }
  /** Get the parse state after this node. */
  get nextParseState() {
    marshalNode(this);
    return C._ts_node_next_parse_state_wasm(this.tree[0]);
  }
  /** Check if this node is equal to another node. */
  equals(other) {
    return this.tree === other.tree && this.id === other.id;
  }
  /**
   * Get the node's child at the given index, where zero represents the first child.
   *
   * This method is fairly fast, but its cost is technically log(n), so if
   * you might be iterating over a long list of children, you should use
   * {@link Node#children} instead.
   */
  child(index) {
    marshalNode(this);
    C._ts_node_child_wasm(this.tree[0], index);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's *named* child at the given index.
   *
   * See also {@link Node#isNamed}.
   * This method is fairly fast, but its cost is technically log(n), so if
   * you might be iterating over a long list of children, you should use
   * {@link Node#namedChildren} instead.
   */
  namedChild(index) {
    marshalNode(this);
    C._ts_node_named_child_wasm(this.tree[0], index);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's child with the given numerical field id.
   *
   * See also {@link Node#childForFieldName}. You can
   * convert a field name to an id using {@link Language#fieldIdForName}.
   */
  childForFieldId(fieldId) {
    marshalNode(this);
    C._ts_node_child_by_field_id_wasm(this.tree[0], fieldId);
    return unmarshalNode(this.tree);
  }
  /**
   * Get the first child with the given field name.
   *
   * If multiple children may have the same field name, access them using
   * {@link Node#childrenForFieldName}.
   */
  childForFieldName(fieldName) {
    const fieldId = this.tree.language.fields.indexOf(fieldName);
    if (fieldId !== -1) return this.childForFieldId(fieldId);
    return null;
  }
  /** Get the field name of this node's child at the given index. */
  fieldNameForChild(index) {
    marshalNode(this);
    const address = C._ts_node_field_name_for_child_wasm(this.tree[0], index);
    if (!address) return null;
    return C.AsciiToString(address);
  }
  /** Get the field name of this node's named child at the given index. */
  fieldNameForNamedChild(index) {
    marshalNode(this);
    const address = C._ts_node_field_name_for_named_child_wasm(this.tree[0], index);
    if (!address) return null;
    return C.AsciiToString(address);
  }
  /**
   * Get an array of this node's children with a given field name.
   *
   * See also {@link Node#children}.
   */
  childrenForFieldName(fieldName) {
    const fieldId = this.tree.language.fields.indexOf(fieldName);
    if (fieldId !== -1 && fieldId !== 0) return this.childrenForFieldId(fieldId);
    return [];
  }
  /**
    * Get an array of this node's children with a given field id.
    *
    * See also {@link Node#childrenForFieldName}.
    */
  childrenForFieldId(fieldId) {
    marshalNode(this);
    C._ts_node_children_by_field_id_wasm(this.tree[0], fieldId);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = unmarshalNode(this.tree, address);
        address += SIZE_OF_NODE;
      }
      C._free(buffer);
    }
    return result;
  }
  /** Get the node's first child that contains or starts after the given byte offset. */
  firstChildForIndex(index) {
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, index, "i32");
    C._ts_node_first_child_for_byte_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the node's first named child that contains or starts after the given byte offset. */
  firstNamedChildForIndex(index) {
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, index, "i32");
    C._ts_node_first_named_child_for_byte_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get this node's number of children. */
  get childCount() {
    marshalNode(this);
    return C._ts_node_child_count_wasm(this.tree[0]);
  }
  /**
   * Get this node's number of *named* children.
   *
   * See also {@link Node#isNamed}.
   */
  get namedChildCount() {
    marshalNode(this);
    return C._ts_node_named_child_count_wasm(this.tree[0]);
  }
  /** Get this node's first child. */
  get firstChild() {
    return this.child(0);
  }
  /**
   * Get this node's first named child.
   *
   * See also {@link Node#isNamed}.
   */
  get firstNamedChild() {
    return this.namedChild(0);
  }
  /** Get this node's last child. */
  get lastChild() {
    return this.child(this.childCount - 1);
  }
  /**
   * Get this node's last named child.
   *
   * See also {@link Node#isNamed}.
   */
  get lastNamedChild() {
    return this.namedChild(this.namedChildCount - 1);
  }
  /**
   * Iterate over this node's children.
   *
   * If you're walking the tree recursively, you may want to use the
   * {@link TreeCursor} APIs directly instead.
   */
  get children() {
    if (!this._children) {
      marshalNode(this);
      C._ts_node_children_wasm(this.tree[0]);
      const count2 = C.getValue(TRANSFER_BUFFER, "i32");
      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
      this._children = new Array(count2);
      if (count2 > 0) {
        let address = buffer;
        for (let i2 = 0; i2 < count2; i2++) {
          this._children[i2] = unmarshalNode(this.tree, address);
          address += SIZE_OF_NODE;
        }
        C._free(buffer);
      }
    }
    return this._children;
  }
  /**
   * Iterate over this node's named children.
   *
   * See also {@link Node#children}.
   */
  get namedChildren() {
    if (!this._namedChildren) {
      marshalNode(this);
      C._ts_node_named_children_wasm(this.tree[0]);
      const count2 = C.getValue(TRANSFER_BUFFER, "i32");
      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
      this._namedChildren = new Array(count2);
      if (count2 > 0) {
        let address = buffer;
        for (let i2 = 0; i2 < count2; i2++) {
          this._namedChildren[i2] = unmarshalNode(this.tree, address);
          address += SIZE_OF_NODE;
        }
        C._free(buffer);
      }
    }
    return this._namedChildren;
  }
  /**
   * Get the descendants of this node that are the given type, or in the given types array.
   *
   * The types array should contain node type strings, which can be retrieved from {@link Language#types}.
   *
   * Additionally, a `startPosition` and `endPosition` can be passed in to restrict the search to a byte range.
   */
  descendantsOfType(types, startPosition = ZERO_POINT, endPosition = ZERO_POINT) {
    if (!Array.isArray(types)) types = [types];
    const symbols2 = [];
    const typesBySymbol = this.tree.language.types;
    for (const node_type of types) {
      if (node_type == "ERROR") {
        symbols2.push(65535);
      }
    }
    for (let i2 = 0, n = typesBySymbol.length; i2 < n; i2++) {
      if (types.includes(typesBySymbol[i2])) {
        symbols2.push(i2);
      }
    }
    const symbolsAddress = C._malloc(SIZE_OF_INT * symbols2.length);
    for (let i2 = 0, n = symbols2.length; i2 < n; i2++) {
      C.setValue(symbolsAddress + i2 * SIZE_OF_INT, symbols2[i2], "i32");
    }
    marshalNode(this);
    C._ts_node_descendants_of_type_wasm(
      this.tree[0],
      symbolsAddress,
      symbols2.length,
      startPosition.row,
      startPosition.column,
      endPosition.row,
      endPosition.column
    );
    const descendantCount = C.getValue(TRANSFER_BUFFER, "i32");
    const descendantAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(descendantCount);
    if (descendantCount > 0) {
      let address = descendantAddress;
      for (let i2 = 0; i2 < descendantCount; i2++) {
        result[i2] = unmarshalNode(this.tree, address);
        address += SIZE_OF_NODE;
      }
    }
    C._free(descendantAddress);
    C._free(symbolsAddress);
    return result;
  }
  /** Get this node's next sibling. */
  get nextSibling() {
    marshalNode(this);
    C._ts_node_next_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get this node's previous sibling. */
  get previousSibling() {
    marshalNode(this);
    C._ts_node_prev_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's next *named* sibling.
   *
   * See also {@link Node#isNamed}.
   */
  get nextNamedSibling() {
    marshalNode(this);
    C._ts_node_next_named_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's previous *named* sibling.
   *
   * See also {@link Node#isNamed}.
   */
  get previousNamedSibling() {
    marshalNode(this);
    C._ts_node_prev_named_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the node's number of descendants, including one for the node itself. */
  get descendantCount() {
    marshalNode(this);
    return C._ts_node_descendant_count_wasm(this.tree[0]);
  }
  /**
   * Get this node's immediate parent.
   * Prefer {@link Node#childWithDescendant} for iterating over this node's ancestors.
   */
  get parent() {
    marshalNode(this);
    C._ts_node_parent_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get the node that contains `descendant`.
   *
   * Note that this can return `descendant` itself.
   */
  childWithDescendant(descendant) {
    marshalNode(this);
    marshalNode(descendant, 1);
    C._ts_node_child_with_descendant_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest node within this node that spans the given byte range. */
  descendantForIndex(start2, end = start2) {
    if (typeof start2 !== "number" || typeof end !== "number") {
      throw new Error("Arguments must be numbers");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, start2, "i32");
    C.setValue(address + SIZE_OF_INT, end, "i32");
    C._ts_node_descendant_for_index_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest named node within this node that spans the given byte range. */
  namedDescendantForIndex(start2, end = start2) {
    if (typeof start2 !== "number" || typeof end !== "number") {
      throw new Error("Arguments must be numbers");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, start2, "i32");
    C.setValue(address + SIZE_OF_INT, end, "i32");
    C._ts_node_named_descendant_for_index_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest node within this node that spans the given point range. */
  descendantForPosition(start2, end = start2) {
    if (!isPoint(start2) || !isPoint(end)) {
      throw new Error("Arguments must be {row, column} objects");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    marshalPoint(address, start2);
    marshalPoint(address + SIZE_OF_POINT, end);
    C._ts_node_descendant_for_position_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest named node within this node that spans the given point range. */
  namedDescendantForPosition(start2, end = start2) {
    if (!isPoint(start2) || !isPoint(end)) {
      throw new Error("Arguments must be {row, column} objects");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    marshalPoint(address, start2);
    marshalPoint(address + SIZE_OF_POINT, end);
    C._ts_node_named_descendant_for_position_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Create a new {@link TreeCursor} starting from this node.
   *
   * Note that the given node is considered the root of the cursor,
   * and the cursor cannot walk outside this node.
   */
  walk() {
    marshalNode(this);
    C._ts_tree_cursor_new_wasm(this.tree[0]);
    return new TreeCursor(INTERNAL, this.tree);
  }
  /**
   * Edit this node to keep it in-sync with source code that has been edited.
   *
   * This function is only rarely needed. When you edit a syntax tree with
   * the {@link Tree#edit} method, all of the nodes that you retrieve from
   * the tree afterward will already reflect the edit. You only need to
   * use {@link Node#edit} when you have a specific {@link Node} instance that
   * you want to keep and continue to use after an edit.
   */
  edit(edit) {
    if (this.startIndex >= edit.oldEndIndex) {
      this.startIndex = edit.newEndIndex + (this.startIndex - edit.oldEndIndex);
      let subbedPointRow;
      let subbedPointColumn;
      if (this.startPosition.row > edit.oldEndPosition.row) {
        subbedPointRow = this.startPosition.row - edit.oldEndPosition.row;
        subbedPointColumn = this.startPosition.column;
      } else {
        subbedPointRow = 0;
        subbedPointColumn = this.startPosition.column;
        if (this.startPosition.column >= edit.oldEndPosition.column) {
          subbedPointColumn = this.startPosition.column - edit.oldEndPosition.column;
        }
      }
      if (subbedPointRow > 0) {
        this.startPosition.row += subbedPointRow;
        this.startPosition.column = subbedPointColumn;
      } else {
        this.startPosition.column += subbedPointColumn;
      }
    } else if (this.startIndex > edit.startIndex) {
      this.startIndex = edit.newEndIndex;
      this.startPosition.row = edit.newEndPosition.row;
      this.startPosition.column = edit.newEndPosition.column;
    }
  }
  /** Get the S-expression representation of this node. */
  toString() {
    marshalNode(this);
    const address = C._ts_node_to_string_wasm(this.tree[0]);
    const result = C.AsciiToString(address);
    C._free(address);
    return result;
  }
}, __name(_a5, "Node"), _a5);
function unmarshalCaptures(query, tree, address, patternIndex, result) {
  for (let i2 = 0, n = result.length; i2 < n; i2++) {
    const captureIndex = C.getValue(address, "i32");
    address += SIZE_OF_INT;
    const node = unmarshalNode(tree, address);
    address += SIZE_OF_NODE;
    result[i2] = { patternIndex, name: query.captureNames[captureIndex], node };
  }
  return address;
}
__name(unmarshalCaptures, "unmarshalCaptures");
function marshalNode(node, index = 0) {
  let address = TRANSFER_BUFFER + index * SIZE_OF_NODE;
  C.setValue(address, node.id, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node.startIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node.startPosition.row, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node.startPosition.column, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node[0], "i32");
}
__name(marshalNode, "marshalNode");
function unmarshalNode(tree, address = TRANSFER_BUFFER) {
  const id2 = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  if (id2 === 0) return null;
  const index = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  const row = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  const column = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  const other = C.getValue(address, "i32");
  const result = new Node(INTERNAL, {
    id: id2,
    tree,
    startIndex: index,
    startPosition: { row, column },
    other
  });
  return result;
}
__name(unmarshalNode, "unmarshalNode");
function marshalTreeCursor(cursor, address = TRANSFER_BUFFER) {
  C.setValue(address + 0 * SIZE_OF_INT, cursor[0], "i32");
  C.setValue(address + 1 * SIZE_OF_INT, cursor[1], "i32");
  C.setValue(address + 2 * SIZE_OF_INT, cursor[2], "i32");
  C.setValue(address + 3 * SIZE_OF_INT, cursor[3], "i32");
}
__name(marshalTreeCursor, "marshalTreeCursor");
function unmarshalTreeCursor(cursor) {
  cursor[0] = C.getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, "i32");
  cursor[1] = C.getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, "i32");
  cursor[2] = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
  cursor[3] = C.getValue(TRANSFER_BUFFER + 3 * SIZE_OF_INT, "i32");
}
__name(unmarshalTreeCursor, "unmarshalTreeCursor");
function marshalPoint(address, point) {
  C.setValue(address, point.row, "i32");
  C.setValue(address + SIZE_OF_INT, point.column, "i32");
}
__name(marshalPoint, "marshalPoint");
function unmarshalPoint(address) {
  const result = {
    row: C.getValue(address, "i32") >>> 0,
    column: C.getValue(address + SIZE_OF_INT, "i32") >>> 0
  };
  return result;
}
__name(unmarshalPoint, "unmarshalPoint");
function marshalRange(address, range3) {
  marshalPoint(address, range3.startPosition);
  address += SIZE_OF_POINT;
  marshalPoint(address, range3.endPosition);
  address += SIZE_OF_POINT;
  C.setValue(address, range3.startIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, range3.endIndex, "i32");
  address += SIZE_OF_INT;
}
__name(marshalRange, "marshalRange");
function unmarshalRange(address) {
  const result = {};
  result.startPosition = unmarshalPoint(address);
  address += SIZE_OF_POINT;
  result.endPosition = unmarshalPoint(address);
  address += SIZE_OF_POINT;
  result.startIndex = C.getValue(address, "i32") >>> 0;
  address += SIZE_OF_INT;
  result.endIndex = C.getValue(address, "i32") >>> 0;
  return result;
}
__name(unmarshalRange, "unmarshalRange");
function marshalEdit(edit, address = TRANSFER_BUFFER) {
  marshalPoint(address, edit.startPosition);
  address += SIZE_OF_POINT;
  marshalPoint(address, edit.oldEndPosition);
  address += SIZE_OF_POINT;
  marshalPoint(address, edit.newEndPosition);
  address += SIZE_OF_POINT;
  C.setValue(address, edit.startIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, edit.oldEndIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, edit.newEndIndex, "i32");
  address += SIZE_OF_INT;
}
__name(marshalEdit, "marshalEdit");
function unmarshalLanguageMetadata(address) {
  const result = {};
  result.major_version = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  result.minor_version = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  result.field_count = C.getValue(address, "i32");
  return result;
}
__name(unmarshalLanguageMetadata, "unmarshalLanguageMetadata");
var PREDICATE_STEP_TYPE_CAPTURE = 1;
var PREDICATE_STEP_TYPE_STRING = 2;
var QUERY_WORD_REGEX = /[\w-]+/g;
var CaptureQuantifier = {
  Zero: 0,
  ZeroOrOne: 1,
  ZeroOrMore: 2,
  One: 3,
  OneOrMore: 4
};
var isCaptureStep = /* @__PURE__ */ __name((step) => step.type === "capture", "isCaptureStep");
var isStringStep = /* @__PURE__ */ __name((step) => step.type === "string", "isStringStep");
var QueryErrorKind = {
  Syntax: 1,
  NodeName: 2,
  FieldName: 3,
  CaptureName: 4,
  PatternStructure: 5
};
var _a6;
var QueryError = (_a6 = class extends Error {
  constructor(kind, info2, index, length) {
    super(_a6.formatMessage(kind, info2));
    this.kind = kind;
    this.info = info2;
    this.index = index;
    this.length = length;
    this.name = "QueryError";
  }
  /** Formats an error message based on the error kind and info */
  static formatMessage(kind, info2) {
    switch (kind) {
      case QueryErrorKind.NodeName:
        return `Bad node name '${info2.word}'`;
      case QueryErrorKind.FieldName:
        return `Bad field name '${info2.word}'`;
      case QueryErrorKind.CaptureName:
        return `Bad capture name @${info2.word}`;
      case QueryErrorKind.PatternStructure:
        return `Bad pattern structure at offset ${info2.suffix}`;
      case QueryErrorKind.Syntax:
        return `Bad syntax at offset ${info2.suffix}`;
    }
  }
}, __name(_a6, "QueryError"), _a6);
function parseAnyPredicate(steps, index, operator, textPredicates) {
  if (steps.length !== 3) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected 2, got ${steps.length - 1}`
    );
  }
  if (!isCaptureStep(steps[1])) {
    throw new Error(
      `First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}"`
    );
  }
  const isPositive = operator === "eq?" || operator === "any-eq?";
  const matchAll2 = !operator.startsWith("any-");
  if (isCaptureStep(steps[2])) {
    const captureName1 = steps[1].name;
    const captureName2 = steps[2].name;
    textPredicates[index].push((captures) => {
      const nodes1 = [];
      const nodes2 = [];
      for (const c of captures) {
        if (c.name === captureName1) nodes1.push(c.node);
        if (c.name === captureName2) nodes2.push(c.node);
      }
      const compare = /* @__PURE__ */ __name((n1, n2, positive) => {
        return positive ? n1.text === n2.text : n1.text !== n2.text;
      }, "compare");
      return matchAll2 ? nodes1.every((n1) => nodes2.some((n2) => compare(n1, n2, isPositive))) : nodes1.some((n1) => nodes2.some((n2) => compare(n1, n2, isPositive)));
    });
  } else {
    const captureName = steps[1].name;
    const stringValue = steps[2].value;
    const matches = /* @__PURE__ */ __name((n) => n.text === stringValue, "matches");
    const doesNotMatch = /* @__PURE__ */ __name((n) => n.text !== stringValue, "doesNotMatch");
    textPredicates[index].push((captures) => {
      const nodes = [];
      for (const c of captures) {
        if (c.name === captureName) nodes.push(c.node);
      }
      const test = isPositive ? matches : doesNotMatch;
      return matchAll2 ? nodes.every(test) : nodes.some(test);
    });
  }
}
__name(parseAnyPredicate, "parseAnyPredicate");
function parseMatchPredicate(steps, index, operator, textPredicates) {
  if (steps.length !== 3) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected 2, got ${steps.length - 1}.`
    );
  }
  if (steps[1].type !== "capture") {
    throw new Error(
      `First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}".`
    );
  }
  if (steps[2].type !== "string") {
    throw new Error(
      `Second argument of \`#${operator}\` predicate must be a string. Got @${steps[2].name}.`
    );
  }
  const isPositive = operator === "match?" || operator === "any-match?";
  const matchAll2 = !operator.startsWith("any-");
  const captureName = steps[1].name;
  const regex = new RegExp(steps[2].value);
  textPredicates[index].push((captures) => {
    const nodes = [];
    for (const c of captures) {
      if (c.name === captureName) nodes.push(c.node.text);
    }
    const test = /* @__PURE__ */ __name((text, positive) => {
      return positive ? regex.test(text) : !regex.test(text);
    }, "test");
    if (nodes.length === 0) return !isPositive;
    return matchAll2 ? nodes.every((text) => test(text, isPositive)) : nodes.some((text) => test(text, isPositive));
  });
}
__name(parseMatchPredicate, "parseMatchPredicate");
function parseAnyOfPredicate(steps, index, operator, textPredicates) {
  if (steps.length < 2) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected at least 1. Got ${steps.length - 1}.`
    );
  }
  if (steps[1].type !== "capture") {
    throw new Error(
      `First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}".`
    );
  }
  const isPositive = operator === "any-of?";
  const captureName = steps[1].name;
  const stringSteps = steps.slice(2);
  if (!stringSteps.every(isStringStep)) {
    throw new Error(
      `Arguments to \`#${operator}\` predicate must be strings.".`
    );
  }
  const values2 = stringSteps.map((s) => s.value);
  textPredicates[index].push((captures) => {
    const nodes = [];
    for (const c of captures) {
      if (c.name === captureName) nodes.push(c.node.text);
    }
    if (nodes.length === 0) return !isPositive;
    return nodes.every((text) => values2.includes(text)) === isPositive;
  });
}
__name(parseAnyOfPredicate, "parseAnyOfPredicate");
function parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties) {
  if (steps.length < 2 || steps.length > 3) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`
    );
  }
  if (!steps.every(isStringStep)) {
    throw new Error(
      `Arguments to \`#${operator}\` predicate must be strings.".`
    );
  }
  const properties = operator === "is?" ? assertedProperties : refutedProperties;
  if (!properties[index]) properties[index] = {};
  properties[index][steps[1].value] = steps[2]?.value ?? null;
}
__name(parseIsPredicate, "parseIsPredicate");
function parseSetDirective(steps, index, setProperties) {
  if (steps.length < 2 || steps.length > 3) {
    throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`);
  }
  if (!steps.every(isStringStep)) {
    throw new Error(`Arguments to \`#set!\` predicate must be strings.".`);
  }
  if (!setProperties[index]) setProperties[index] = {};
  setProperties[index][steps[1].value] = steps[2]?.value ?? null;
}
__name(parseSetDirective, "parseSetDirective");
function parsePattern(index, stepType, stepValueId, captureNames2, stringValues, steps, textPredicates, predicates, setProperties, assertedProperties, refutedProperties) {
  if (stepType === PREDICATE_STEP_TYPE_CAPTURE) {
    const name2 = captureNames2[stepValueId];
    steps.push({ type: "capture", name: name2 });
  } else if (stepType === PREDICATE_STEP_TYPE_STRING) {
    steps.push({ type: "string", value: stringValues[stepValueId] });
  } else if (steps.length > 0) {
    if (steps[0].type !== "string") {
      throw new Error("Predicates must begin with a literal value");
    }
    const operator = steps[0].value;
    switch (operator) {
      case "any-not-eq?":
      case "not-eq?":
      case "any-eq?":
      case "eq?":
        parseAnyPredicate(steps, index, operator, textPredicates);
        break;
      case "any-not-match?":
      case "not-match?":
      case "any-match?":
      case "match?":
        parseMatchPredicate(steps, index, operator, textPredicates);
        break;
      case "not-any-of?":
      case "any-of?":
        parseAnyOfPredicate(steps, index, operator, textPredicates);
        break;
      case "is?":
      case "is-not?":
        parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties);
        break;
      case "set!":
        parseSetDirective(steps, index, setProperties);
        break;
      default:
        predicates[index].push({ operator, operands: steps.slice(1) });
    }
    steps.length = 0;
  }
}
__name(parsePattern, "parsePattern");
var _a7;
var Query = (_a7 = class {
  /**
   * Create a new query from a string containing one or more S-expression
   * patterns.
   *
   * The query is associated with a particular language, and can only be run
   * on syntax nodes parsed with that language. References to Queries can be
   * shared between multiple threads.
   *
   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}
   */
  constructor(language, source) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "exceededMatchLimit");
    /** @internal */
    __publicField(this, "textPredicates");
    /** The names of the captures used in the query. */
    __publicField(this, "captureNames");
    /** The quantifiers of the captures used in the query. */
    __publicField(this, "captureQuantifiers");
    /**
     * The other user-defined predicates associated with the given index.
     *
     * This includes predicates with operators other than:
     * - `match?`
     * - `eq?` and `not-eq?`
     * - `any-of?` and `not-any-of?`
     * - `is?` and `is-not?`
     * - `set!`
     */
    __publicField(this, "predicates");
    /** The properties for predicates with the operator `set!`. */
    __publicField(this, "setProperties");
    /** The properties for predicates with the operator `is?`. */
    __publicField(this, "assertedProperties");
    /** The properties for predicates with the operator `is-not?`. */
    __publicField(this, "refutedProperties");
    /** The maximum number of in-progress matches for this cursor. */
    __publicField(this, "matchLimit");
    const sourceLength = C.lengthBytesUTF8(source);
    const sourceAddress = C._malloc(sourceLength + 1);
    C.stringToUTF8(source, sourceAddress, sourceLength + 1);
    const address = C._ts_query_new(
      language[0],
      sourceAddress,
      sourceLength,
      TRANSFER_BUFFER,
      TRANSFER_BUFFER + SIZE_OF_INT
    );
    if (!address) {
      const errorId = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
      const errorByte = C.getValue(TRANSFER_BUFFER, "i32");
      const errorIndex = C.UTF8ToString(sourceAddress, errorByte).length;
      const suffix = source.slice(errorIndex, errorIndex + 100).split("\n")[0];
      const word = suffix.match(QUERY_WORD_REGEX)?.[0] ?? "";
      C._free(sourceAddress);
      switch (errorId) {
        case QueryErrorKind.Syntax:
          throw new QueryError(QueryErrorKind.Syntax, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);
        case QueryErrorKind.NodeName:
          throw new QueryError(errorId, { word }, errorIndex, word.length);
        case QueryErrorKind.FieldName:
          throw new QueryError(errorId, { word }, errorIndex, word.length);
        case QueryErrorKind.CaptureName:
          throw new QueryError(errorId, { word }, errorIndex, word.length);
        case QueryErrorKind.PatternStructure:
          throw new QueryError(errorId, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);
      }
    }
    const stringCount = C._ts_query_string_count(address);
    const captureCount = C._ts_query_capture_count(address);
    const patternCount = C._ts_query_pattern_count(address);
    const captureNames2 = new Array(captureCount);
    const captureQuantifiers = new Array(patternCount);
    const stringValues = new Array(stringCount);
    for (let i2 = 0; i2 < captureCount; i2++) {
      const nameAddress = C._ts_query_capture_name_for_id(
        address,
        i2,
        TRANSFER_BUFFER
      );
      const nameLength = C.getValue(TRANSFER_BUFFER, "i32");
      captureNames2[i2] = C.UTF8ToString(nameAddress, nameLength);
    }
    for (let i2 = 0; i2 < patternCount; i2++) {
      const captureQuantifiersArray = new Array(captureCount);
      for (let j = 0; j < captureCount; j++) {
        const quantifier = C._ts_query_capture_quantifier_for_id(address, i2, j);
        captureQuantifiersArray[j] = quantifier;
      }
      captureQuantifiers[i2] = captureQuantifiersArray;
    }
    for (let i2 = 0; i2 < stringCount; i2++) {
      const valueAddress = C._ts_query_string_value_for_id(
        address,
        i2,
        TRANSFER_BUFFER
      );
      const nameLength = C.getValue(TRANSFER_BUFFER, "i32");
      stringValues[i2] = C.UTF8ToString(valueAddress, nameLength);
    }
    const setProperties = new Array(patternCount);
    const assertedProperties = new Array(patternCount);
    const refutedProperties = new Array(patternCount);
    const predicates = new Array(patternCount);
    const textPredicates = new Array(patternCount);
    for (let i2 = 0; i2 < patternCount; i2++) {
      const predicatesAddress = C._ts_query_predicates_for_pattern(address, i2, TRANSFER_BUFFER);
      const stepCount = C.getValue(TRANSFER_BUFFER, "i32");
      predicates[i2] = [];
      textPredicates[i2] = [];
      const steps = new Array();
      let stepAddress = predicatesAddress;
      for (let j = 0; j < stepCount; j++) {
        const stepType = C.getValue(stepAddress, "i32");
        stepAddress += SIZE_OF_INT;
        const stepValueId = C.getValue(stepAddress, "i32");
        stepAddress += SIZE_OF_INT;
        parsePattern(
          i2,
          stepType,
          stepValueId,
          captureNames2,
          stringValues,
          steps,
          textPredicates,
          predicates,
          setProperties,
          assertedProperties,
          refutedProperties
        );
      }
      Object.freeze(textPredicates[i2]);
      Object.freeze(predicates[i2]);
      Object.freeze(setProperties[i2]);
      Object.freeze(assertedProperties[i2]);
      Object.freeze(refutedProperties[i2]);
    }
    C._free(sourceAddress);
    this[0] = address;
    this.captureNames = captureNames2;
    this.captureQuantifiers = captureQuantifiers;
    this.textPredicates = textPredicates;
    this.predicates = predicates;
    this.setProperties = setProperties;
    this.assertedProperties = assertedProperties;
    this.refutedProperties = refutedProperties;
    this.exceededMatchLimit = false;
  }
  /** Delete the query, freeing its resources. */
  delete() {
    C._ts_query_delete(this[0]);
    this[0] = 0;
  }
  /**
   * Iterate over all of the matches in the order that they were found.
   *
   * Each match contains the index of the pattern that matched, and a list of
   * captures. Because multiple patterns can match the same set of nodes,
   * one match may contain captures that appear *before* some of the
   * captures from a previous match.
   *
   * @param {Node} node - The node to execute the query on.
   *
   * @param {QueryOptions} options - Options for query execution.
   */
  matches(node, options2 = {}) {
    const startPosition = options2.startPosition ?? ZERO_POINT;
    const endPosition = options2.endPosition ?? ZERO_POINT;
    const startIndex = options2.startIndex ?? 0;
    const endIndex = options2.endIndex ?? 0;
    const matchLimit = options2.matchLimit ?? 4294967295;
    const maxStartDepth = options2.maxStartDepth ?? 4294967295;
    const timeoutMicros = options2.timeoutMicros ?? 0;
    const progressCallback = options2.progressCallback;
    if (typeof matchLimit !== "number") {
      throw new Error("Arguments must be numbers");
    }
    this.matchLimit = matchLimit;
    if (endIndex !== 0 && startIndex > endIndex) {
      throw new Error("`startIndex` cannot be greater than `endIndex`");
    }
    if (endPosition !== ZERO_POINT && (startPosition.row > endPosition.row || startPosition.row === endPosition.row && startPosition.column > endPosition.column)) {
      throw new Error("`startPosition` cannot be greater than `endPosition`");
    }
    if (progressCallback) {
      C.currentQueryProgressCallback = progressCallback;
    }
    marshalNode(node);
    C._ts_query_matches_wasm(
      this[0],
      node.tree[0],
      startPosition.row,
      startPosition.column,
      endPosition.row,
      endPosition.column,
      startIndex,
      endIndex,
      matchLimit,
      maxStartDepth,
      timeoutMicros
    );
    const rawCount = C.getValue(TRANSFER_BUFFER, "i32");
    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
    const result = new Array(rawCount);
    this.exceededMatchLimit = Boolean(didExceedMatchLimit);
    let filteredCount = 0;
    let address = startAddress;
    for (let i2 = 0; i2 < rawCount; i2++) {
      const patternIndex = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captureCount = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captures = new Array(captureCount);
      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);
      if (this.textPredicates[patternIndex].every((p) => p(captures))) {
        result[filteredCount] = { pattern: patternIndex, patternIndex, captures };
        const setProperties = this.setProperties[patternIndex];
        result[filteredCount].setProperties = setProperties;
        const assertedProperties = this.assertedProperties[patternIndex];
        result[filteredCount].assertedProperties = assertedProperties;
        const refutedProperties = this.refutedProperties[patternIndex];
        result[filteredCount].refutedProperties = refutedProperties;
        filteredCount++;
      }
    }
    result.length = filteredCount;
    C._free(startAddress);
    C.currentQueryProgressCallback = null;
    return result;
  }
  /**
   * Iterate over all of the individual captures in the order that they
   * appear.
   *
   * This is useful if you don't care about which pattern matched, and just
   * want a single, ordered sequence of captures.
   *
   * @param {Node} node - The node to execute the query on.
   *
   * @param {QueryOptions} options - Options for query execution.
   */
  captures(node, options2 = {}) {
    const startPosition = options2.startPosition ?? ZERO_POINT;
    const endPosition = options2.endPosition ?? ZERO_POINT;
    const startIndex = options2.startIndex ?? 0;
    const endIndex = options2.endIndex ?? 0;
    const matchLimit = options2.matchLimit ?? 4294967295;
    const maxStartDepth = options2.maxStartDepth ?? 4294967295;
    const timeoutMicros = options2.timeoutMicros ?? 0;
    const progressCallback = options2.progressCallback;
    if (typeof matchLimit !== "number") {
      throw new Error("Arguments must be numbers");
    }
    this.matchLimit = matchLimit;
    if (endIndex !== 0 && startIndex > endIndex) {
      throw new Error("`startIndex` cannot be greater than `endIndex`");
    }
    if (endPosition !== ZERO_POINT && (startPosition.row > endPosition.row || startPosition.row === endPosition.row && startPosition.column > endPosition.column)) {
      throw new Error("`startPosition` cannot be greater than `endPosition`");
    }
    if (progressCallback) {
      C.currentQueryProgressCallback = progressCallback;
    }
    marshalNode(node);
    C._ts_query_captures_wasm(
      this[0],
      node.tree[0],
      startPosition.row,
      startPosition.column,
      endPosition.row,
      endPosition.column,
      startIndex,
      endIndex,
      matchLimit,
      maxStartDepth,
      timeoutMicros
    );
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
    const result = new Array();
    this.exceededMatchLimit = Boolean(didExceedMatchLimit);
    const captures = new Array();
    let address = startAddress;
    for (let i2 = 0; i2 < count2; i2++) {
      const patternIndex = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captureCount = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captureIndex = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      captures.length = captureCount;
      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);
      if (this.textPredicates[patternIndex].every((p) => p(captures))) {
        const capture = captures[captureIndex];
        const setProperties = this.setProperties[patternIndex];
        capture.setProperties = setProperties;
        const assertedProperties = this.assertedProperties[patternIndex];
        capture.assertedProperties = assertedProperties;
        const refutedProperties = this.refutedProperties[patternIndex];
        capture.refutedProperties = refutedProperties;
        result.push(capture);
      }
    }
    C._free(startAddress);
    C.currentQueryProgressCallback = null;
    return result;
  }
  /** Get the predicates for a given pattern. */
  predicatesForPattern(patternIndex) {
    return this.predicates[patternIndex];
  }
  /**
   * Disable a certain capture within a query.
   *
   * This prevents the capture from being returned in matches, and also
   * avoids any resource usage associated with recording the capture.
   */
  disableCapture(captureName) {
    const captureNameLength = C.lengthBytesUTF8(captureName);
    const captureNameAddress = C._malloc(captureNameLength + 1);
    C.stringToUTF8(captureName, captureNameAddress, captureNameLength + 1);
    C._ts_query_disable_capture(this[0], captureNameAddress, captureNameLength);
    C._free(captureNameAddress);
  }
  /**
   * Disable a certain pattern within a query.
   *
   * This prevents the pattern from matching, and also avoids any resource
   * usage associated with the pattern. This throws an error if the pattern
   * index is out of bounds.
   */
  disablePattern(patternIndex) {
    if (patternIndex >= this.predicates.length) {
      throw new Error(
        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`
      );
    }
    C._ts_query_disable_pattern(this[0], patternIndex);
  }
  /**
   * Check if, on its last execution, this cursor exceeded its maximum number
   * of in-progress matches.
   */
  didExceedMatchLimit() {
    return this.exceededMatchLimit;
  }
  /** Get the byte offset where the given pattern starts in the query's source. */
  startIndexForPattern(patternIndex) {
    if (patternIndex >= this.predicates.length) {
      throw new Error(
        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`
      );
    }
    return C._ts_query_start_byte_for_pattern(this[0], patternIndex);
  }
  /** Get the byte offset where the given pattern ends in the query's source. */
  endIndexForPattern(patternIndex) {
    if (patternIndex >= this.predicates.length) {
      throw new Error(
        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`
      );
    }
    return C._ts_query_end_byte_for_pattern(this[0], patternIndex);
  }
  /** Get the number of patterns in the query. */
  patternCount() {
    return C._ts_query_pattern_count(this[0]);
  }
  /** Get the index for a given capture name. */
  captureIndexForName(captureName) {
    return this.captureNames.indexOf(captureName);
  }
  /** Check if a given pattern within a query has a single root node. */
  isPatternRooted(patternIndex) {
    return C._ts_query_is_pattern_rooted(this[0], patternIndex) === 1;
  }
  /** Check if a given pattern within a query has a single root node. */
  isPatternNonLocal(patternIndex) {
    return C._ts_query_is_pattern_non_local(this[0], patternIndex) === 1;
  }
  /**
   * Check if a given step in a query is 'definite'.
   *
   * A query step is 'definite' if its parent pattern will be guaranteed to
   * match successfully once it reaches the step.
   */
  isPatternGuaranteedAtStep(byteIndex) {
    return C._ts_query_is_pattern_guaranteed_at_step(this[0], byteIndex) === 1;
  }
}, __name(_a7, "Query"), _a7);
var LANGUAGE_FUNCTION_REGEX = /^tree_sitter_\w+$/;
var _a8;
var Language = (_a8 = class {
  /** @internal */
  constructor(internal, address) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /**
     * A list of all node types in the language. The index of each type in this
     * array is its node type id.
     */
    __publicField(this, "types");
    /**
     * A list of all field names in the language. The index of each field name in
     * this array is its field id.
     */
    __publicField(this, "fields");
    assertInternal(internal);
    this[0] = address;
    this.types = new Array(C._ts_language_symbol_count(this[0]));
    for (let i2 = 0, n = this.types.length; i2 < n; i2++) {
      if (C._ts_language_symbol_type(this[0], i2) < 2) {
        this.types[i2] = C.UTF8ToString(C._ts_language_symbol_name(this[0], i2));
      }
    }
    this.fields = new Array(C._ts_language_field_count(this[0]) + 1);
    for (let i2 = 0, n = this.fields.length; i2 < n; i2++) {
      const fieldName = C._ts_language_field_name_for_id(this[0], i2);
      if (fieldName !== 0) {
        this.fields[i2] = C.UTF8ToString(fieldName);
      } else {
        this.fields[i2] = null;
      }
    }
  }
  /**
   * Gets the name of the language.
   */
  get name() {
    const ptr = C._ts_language_name(this[0]);
    if (ptr === 0) return null;
    return C.UTF8ToString(ptr);
  }
  /**
   * @deprecated since version 0.25.0, use {@link Language#abiVersion} instead
   * Gets the version of the language.
   */
  get version() {
    return C._ts_language_version(this[0]);
  }
  /**
   * Gets the ABI version of the language.
   */
  get abiVersion() {
    return C._ts_language_abi_version(this[0]);
  }
  /**
  * Get the metadata for this language. This information is generated by the
  * CLI, and relies on the language author providing the correct metadata in
  * the language's `tree-sitter.json` file.
  */
  get metadata() {
    C._ts_language_metadata(this[0]);
    const length = C.getValue(TRANSFER_BUFFER, "i32");
    const address = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    if (length === 0) return null;
    return unmarshalLanguageMetadata(address);
  }
  /**
   * Gets the number of fields in the language.
   */
  get fieldCount() {
    return this.fields.length - 1;
  }
  /**
   * Gets the number of states in the language.
   */
  get stateCount() {
    return C._ts_language_state_count(this[0]);
  }
  /**
   * Get the field id for a field name.
   */
  fieldIdForName(fieldName) {
    const result = this.fields.indexOf(fieldName);
    return result !== -1 ? result : null;
  }
  /**
   * Get the field name for a field id.
   */
  fieldNameForId(fieldId) {
    return this.fields[fieldId] ?? null;
  }
  /**
   * Get the node type id for a node type name.
   */
  idForNodeType(type2, named) {
    const typeLength = C.lengthBytesUTF8(type2);
    const typeAddress = C._malloc(typeLength + 1);
    C.stringToUTF8(type2, typeAddress, typeLength + 1);
    const result = C._ts_language_symbol_for_name(this[0], typeAddress, typeLength, named ? 1 : 0);
    C._free(typeAddress);
    return result || null;
  }
  /**
   * Gets the number of node types in the language.
   */
  get nodeTypeCount() {
    return C._ts_language_symbol_count(this[0]);
  }
  /**
   * Get the node type name for a node type id.
   */
  nodeTypeForId(typeId) {
    const name2 = C._ts_language_symbol_name(this[0], typeId);
    return name2 ? C.UTF8ToString(name2) : null;
  }
  /**
   * Check if a node type is named.
   *
   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/2-basic-parsing.html#named-vs-anonymous-nodes}
   */
  nodeTypeIsNamed(typeId) {
    return C._ts_language_type_is_named_wasm(this[0], typeId) ? true : false;
  }
  /**
   * Check if a node type is visible.
   */
  nodeTypeIsVisible(typeId) {
    return C._ts_language_type_is_visible_wasm(this[0], typeId) ? true : false;
  }
  /**
   * Get the supertypes ids of this language.
   *
   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/6-static-node-types.html?highlight=supertype#supertype-nodes}
   */
  get supertypes() {
    C._ts_language_supertypes_wasm(this[0]);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = C.getValue(address, "i16");
        address += SIZE_OF_SHORT;
      }
    }
    return result;
  }
  /**
   * Get the subtype ids for a given supertype node id.
   */
  subtypes(supertype) {
    C._ts_language_subtypes_wasm(this[0], supertype);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = C.getValue(address, "i16");
        address += SIZE_OF_SHORT;
      }
    }
    return result;
  }
  /**
   * Get the next state id for a given state id and node type id.
   */
  nextState(stateId, typeId) {
    return C._ts_language_next_state(this[0], stateId, typeId);
  }
  /**
   * Create a new lookahead iterator for this language and parse state.
   *
   * This returns `null` if state is invalid for this language.
   *
   * Iterating {@link LookaheadIterator} will yield valid symbols in the given
   * parse state. Newly created lookahead iterators will return the `ERROR`
   * symbol from {@link LookaheadIterator#currentType}.
   *
   * Lookahead iterators can be useful for generating suggestions and improving
   * syntax error diagnostics. To get symbols valid in an `ERROR` node, use the
   * lookahead iterator on its first leaf node state. For `MISSING` nodes, a
   * lookahead iterator created on the previous non-extra leaf node may be
   * appropriate.
   */
  lookaheadIterator(stateId) {
    const address = C._ts_lookahead_iterator_new(this[0], stateId);
    if (address) return new LookaheadIterator(INTERNAL, address, this);
    return null;
  }
  /**
   * @deprecated since version 0.25.0, call `new` on a {@link Query} instead
   *
   * Create a new query from a string containing one or more S-expression
   * patterns.
   *
   * The query is associated with a particular language, and can only be run
   * on syntax nodes parsed with that language. References to Queries can be
   * shared between multiple threads.
   *
   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}
   */
  query(source) {
    console.warn("Language.query is deprecated. Use new Query(language, source) instead.");
    return new Query(this, source);
  }
  /**
   * Load a language from a WebAssembly module.
   * The module can be provided as a path to a file or as a buffer.
   */
  static async load(input) {
    let bytes;
    if (input instanceof Uint8Array) {
      bytes = Promise.resolve(input);
    } else {
      if (globalThis.process?.versions.node) {
        const fs2 = await import("fs/promises");
        bytes = fs2.readFile(input);
      } else {
        bytes = fetch(input).then((response) => response.arrayBuffer().then((buffer) => {
          if (response.ok) {
            return new Uint8Array(buffer);
          } else {
            const body2 = new TextDecoder("utf-8").decode(buffer);
            throw new Error(`Language.load failed with status ${response.status}.

${body2}`);
          }
        }));
      }
    }
    const mod = await C.loadWebAssemblyModule(await bytes, { loadAsync: true });
    const symbolNames = Object.keys(mod);
    const functionName = symbolNames.find((key) => LANGUAGE_FUNCTION_REGEX.test(key) && !key.includes("external_scanner_"));
    if (!functionName) {
      console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(symbolNames, null, 2)}`);
      throw new Error("Language.load failed: no language function found in WASM file");
    }
    const languageAddress = mod[functionName]();
    return new _a8(INTERNAL, languageAddress);
  }
}, __name(_a8, "Language"), _a8);
var Module2 = (() => {
  var _scriptName = import.meta.url;
  return async function(moduleArg = {}) {
    var moduleRtn;
    var Module = moduleArg;
    var readyPromiseResolve, readyPromiseReject;
    var readyPromise = new Promise((resolve, reject) => {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    var ENVIRONMENT_IS_WEB = typeof window == "object";
    var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != "undefined";
    var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
    if (ENVIRONMENT_IS_NODE) {
      const { createRequire } = await import("module");
      var require = createRequire(import.meta.url);
    }
    Module.currentQueryProgressCallback = null;
    Module.currentProgressCallback = null;
    Module.currentLogCallback = null;
    Module.currentParseCallback = null;
    var moduleOverrides = Object.assign({}, Module);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = /* @__PURE__ */ __name((status, toThrow) => {
      throw toThrow;
    }, "quit_");
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    __name(locateFile, "locateFile");
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_NODE) {
      var fs = require("fs");
      var nodePath = require("path");
      if (!import.meta.url.startsWith("data:")) {
        scriptDirectory = nodePath.dirname(require("url").fileURLToPath(import.meta.url)) + "/";
      }
      readBinary = /* @__PURE__ */ __name((filename) => {
        filename = isFileURI(filename) ? new URL(filename) : filename;
        var ret = fs.readFileSync(filename);
        return ret;
      }, "readBinary");
      readAsync = /* @__PURE__ */ __name(async (filename, binary22 = true) => {
        filename = isFileURI(filename) ? new URL(filename) : filename;
        var ret = fs.readFileSync(filename, binary22 ? void 0 : "utf8");
        return ret;
      }, "readAsync");
      if (!Module["thisProgram"] && process.argv.length > 1) {
        thisProgram = process.argv[1].replace(/\\/g, "/");
      }
      arguments_ = process.argv.slice(2);
      quit_ = /* @__PURE__ */ __name((status, toThrow) => {
        process.exitCode = status;
        throw toThrow;
      }, "quit_");
    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptName) {
        scriptDirectory = _scriptName;
      }
      if (scriptDirectory.startsWith("blob:")) {
        scriptDirectory = "";
      } else {
        scriptDirectory = scriptDirectory.slice(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      }
      {
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = /* @__PURE__ */ __name((url2) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url2, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(
              /** @type{!ArrayBuffer} */
              xhr.response
            );
          }, "readBinary");
        }
        readAsync = /* @__PURE__ */ __name(async (url2) => {
          if (isFileURI(url2)) {
            return new Promise((resolve, reject) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url2, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = () => {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  resolve(xhr.response);
                  return;
                }
                reject(xhr.status);
              };
              xhr.onerror = reject;
              xhr.send(null);
            });
          }
          var response = await fetch(url2, {
            credentials: "same-origin"
          });
          if (response.ok) {
            return response.arrayBuffer();
          }
          throw new Error(response.status + " : " + response.url);
        }, "readAsync");
      }
    } else {
    }
    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.error.bind(console);
    Object.assign(Module, moduleOverrides);
    moduleOverrides = null;
    if (Module["arguments"]) arguments_ = Module["arguments"];
    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
    var dynamicLibraries = Module["dynamicLibraries"] || [];
    var wasmBinary = Module["wasmBinary"];
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }
    __name(assert, "assert");
    var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
    var HEAP_DATA_VIEW;
    var runtimeInitialized = false;
    var isFileURI = /* @__PURE__ */ __name((filename) => filename.startsWith("file://"), "isFileURI");
    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module["HEAP_DATA_VIEW"] = HEAP_DATA_VIEW = new DataView(b);
      Module["HEAP8"] = HEAP8 = new Int8Array(b);
      Module["HEAP16"] = HEAP16 = new Int16Array(b);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
      Module["HEAP32"] = HEAP32 = new Int32Array(b);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
      Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
      Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
    }
    __name(updateMemoryViews, "updateMemoryViews");
    if (Module["wasmMemory"]) {
      wasmMemory = Module["wasmMemory"];
    } else {
      var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 33554432;
      wasmMemory = new WebAssembly.Memory({
        "initial": INITIAL_MEMORY / 65536,
        // In theory we should not need to emit the maximum if we want "unlimited"
        // or 4GB of memory, but VMs error on that atm, see
        // https://github.com/emscripten-core/emscripten/issues/14130
        // And in the pthreads case we definitely need to emit a maximum. So
        // always emit one.
        "maximum": 32768
      });
    }
    updateMemoryViews();
    var __RELOC_FUNCS__ = [];
    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];
        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }
      callRuntimeCallbacks(onPreRuns);
    }
    __name(preRun, "preRun");
    function initRuntime() {
      runtimeInitialized = true;
      callRuntimeCallbacks(__RELOC_FUNCS__);
      wasmExports["__wasm_call_ctors"]();
      callRuntimeCallbacks(onPostCtors);
    }
    __name(initRuntime, "initRuntime");
    function preMain() {
    }
    __name(preMain, "preMain");
    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];
        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }
      callRuntimeCallbacks(onPostRuns);
    }
    __name(postRun, "postRun");
    var runDependencies = 0;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id2) {
      return id2;
    }
    __name(getUniqueRunDependency, "getUniqueRunDependency");
    function addRunDependency(id2) {
      runDependencies++;
      Module["monitorRunDependencies"]?.(runDependencies);
    }
    __name(addRunDependency, "addRunDependency");
    function removeRunDependency(id2) {
      runDependencies--;
      Module["monitorRunDependencies"]?.(runDependencies);
      if (runDependencies == 0) {
        if (dependenciesFulfilled) {
          var callback2 = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback2();
        }
      }
    }
    __name(removeRunDependency, "removeRunDependency");
    function abort(what) {
      Module["onAbort"]?.(what);
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      what += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    __name(abort, "abort");
    var wasmBinaryFile;
    function findWasmBinary() {
      if (Module["locateFile"]) {
        return locateFile("tree-sitter.wasm");
      }
      return new URL("tree-sitter.wasm", import.meta.url).href;
    }
    __name(findWasmBinary, "findWasmBinary");
    function getBinarySync(file2) {
      if (file2 == wasmBinaryFile && wasmBinary) {
        return new Uint8Array(wasmBinary);
      }
      if (readBinary) {
        return readBinary(file2);
      }
      throw "both async and sync fetching of the wasm failed";
    }
    __name(getBinarySync, "getBinarySync");
    async function getWasmBinary(binaryFile) {
      if (!wasmBinary) {
        try {
          var response = await readAsync(binaryFile);
          return new Uint8Array(response);
        } catch {
        }
      }
      return getBinarySync(binaryFile);
    }
    __name(getWasmBinary, "getWasmBinary");
    async function instantiateArrayBuffer(binaryFile, imports) {
      try {
        var binary22 = await getWasmBinary(binaryFile);
        var instance2 = await WebAssembly.instantiate(binary22, imports);
        return instance2;
      } catch (reason) {
        err(`failed to asynchronously prepare wasm: ${reason}`);
        abort(reason);
      }
    }
    __name(instantiateArrayBuffer, "instantiateArrayBuffer");
    async function instantiateAsync(binary22, binaryFile, imports) {
      if (!binary22 && typeof WebAssembly.instantiateStreaming == "function" && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE) {
        try {
          var response = fetch(binaryFile, {
            credentials: "same-origin"
          });
          var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
          return instantiationResult;
        } catch (reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
        }
      }
      return instantiateArrayBuffer(binaryFile, imports);
    }
    __name(instantiateAsync, "instantiateAsync");
    function getWasmImports() {
      return {
        "env": wasmImports,
        "wasi_snapshot_preview1": wasmImports,
        "GOT.mem": new Proxy(wasmImports, GOTHandler),
        "GOT.func": new Proxy(wasmImports, GOTHandler)
      };
    }
    __name(getWasmImports, "getWasmImports");
    async function createWasm() {
      function receiveInstance(instance2, module2) {
        wasmExports = instance2.exports;
        wasmExports = relocateExports(wasmExports, 1024);
        var metadata2 = getDylinkMetadata(module2);
        if (metadata2.neededDynlibs) {
          dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries);
        }
        mergeLibSymbols(wasmExports, "main");
        LDSO.init();
        loadDylibs();
        __RELOC_FUNCS__.push(wasmExports["__wasm_apply_data_relocs"]);
        removeRunDependency("wasm-instantiate");
        return wasmExports;
      }
      __name(receiveInstance, "receiveInstance");
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result2) {
        return receiveInstance(result2["instance"], result2["module"]);
      }
      __name(receiveInstantiationResult, "receiveInstantiationResult");
      var info2 = getWasmImports();
      if (Module["instantiateWasm"]) {
        return new Promise((resolve, reject) => {
          Module["instantiateWasm"](info2, (mod, inst) => {
            receiveInstance(mod, inst);
            resolve(mod.exports);
          });
        });
      }
      wasmBinaryFile ?? (wasmBinaryFile = findWasmBinary());
      try {
        var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info2);
        var exports2 = receiveInstantiationResult(result);
        return exports2;
      } catch (e) {
        readyPromiseReject(e);
        return Promise.reject(e);
      }
    }
    __name(createWasm, "createWasm");
    var ASM_CONSTS = {};
    const _ExitStatus = class _ExitStatus {
      constructor(status) {
        __publicField(this, "name", "ExitStatus");
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
    };
    __name(_ExitStatus, "ExitStatus");
    let ExitStatus = _ExitStatus;
    var GOT = {};
    var currentModuleWeakSymbols = /* @__PURE__ */ new Set([]);
    var GOTHandler = {
      get(obj, symName) {
        var rtn = GOT[symName];
        if (!rtn) {
          rtn = GOT[symName] = new WebAssembly.Global({
            "value": "i32",
            "mutable": true
          });
        }
        if (!currentModuleWeakSymbols.has(symName)) {
          rtn.required = true;
        }
        return rtn;
      }
    };
    var LE_HEAP_LOAD_F32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getFloat32(byteOffset, true), "LE_HEAP_LOAD_F32");
    var LE_HEAP_LOAD_F64 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getFloat64(byteOffset, true), "LE_HEAP_LOAD_F64");
    var LE_HEAP_LOAD_I16 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getInt16(byteOffset, true), "LE_HEAP_LOAD_I16");
    var LE_HEAP_LOAD_I32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getInt32(byteOffset, true), "LE_HEAP_LOAD_I32");
    var LE_HEAP_LOAD_U16 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getUint16(byteOffset, true), "LE_HEAP_LOAD_U16");
    var LE_HEAP_LOAD_U32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getUint32(byteOffset, true), "LE_HEAP_LOAD_U32");
    var LE_HEAP_STORE_F32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setFloat32(byteOffset, value, true), "LE_HEAP_STORE_F32");
    var LE_HEAP_STORE_F64 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setFloat64(byteOffset, value, true), "LE_HEAP_STORE_F64");
    var LE_HEAP_STORE_I16 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setInt16(byteOffset, value, true), "LE_HEAP_STORE_I16");
    var LE_HEAP_STORE_I32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setInt32(byteOffset, value, true), "LE_HEAP_STORE_I32");
    var LE_HEAP_STORE_U16 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setUint16(byteOffset, value, true), "LE_HEAP_STORE_U16");
    var LE_HEAP_STORE_U32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setUint32(byteOffset, value, true), "LE_HEAP_STORE_U32");
    var callRuntimeCallbacks = /* @__PURE__ */ __name((callbacks) => {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    }, "callRuntimeCallbacks");
    var onPostRuns = [];
    var addOnPostRun = /* @__PURE__ */ __name((cb) => onPostRuns.unshift(cb), "addOnPostRun");
    var onPreRuns = [];
    var addOnPreRun = /* @__PURE__ */ __name((cb) => onPreRuns.unshift(cb), "addOnPreRun");
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
    var UTF8ArrayToString = /* @__PURE__ */ __name((heapOrArray, idx = 0, maxBytesToRead = NaN) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str2 = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str2 += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str2 += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str2 += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str2 += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
      return str2;
    }, "UTF8ArrayToString");
    var getDylinkMetadata = /* @__PURE__ */ __name((binary22) => {
      var offset = 0;
      var end = 0;
      function getU8() {
        return binary22[offset++];
      }
      __name(getU8, "getU8");
      function getLEB() {
        var ret = 0;
        var mul = 1;
        while (1) {
          var byte = binary22[offset++];
          ret += (byte & 127) * mul;
          mul *= 128;
          if (!(byte & 128)) break;
        }
        return ret;
      }
      __name(getLEB, "getLEB");
      function getString() {
        var len = getLEB();
        offset += len;
        return UTF8ArrayToString(binary22, offset - len, len);
      }
      __name(getString, "getString");
      function failIf(condition, message) {
        if (condition) throw new Error(message);
      }
      __name(failIf, "failIf");
      var name2 = "dylink.0";
      if (binary22 instanceof WebAssembly.Module) {
        var dylinkSection = WebAssembly.Module.customSections(binary22, name2);
        if (dylinkSection.length === 0) {
          name2 = "dylink";
          dylinkSection = WebAssembly.Module.customSections(binary22, name2);
        }
        failIf(dylinkSection.length === 0, "need dylink section");
        binary22 = new Uint8Array(dylinkSection[0]);
        end = binary22.length;
      } else {
        var int32View = new Uint32Array(new Uint8Array(binary22.subarray(0, 24)).buffer);
        var magicNumberFound = int32View[0] == 1836278016 || int32View[0] == 6386541;
        failIf(!magicNumberFound, "need to see wasm magic number");
        failIf(binary22[8] !== 0, "need the dylink section to be first");
        offset = 9;
        var section_size = getLEB();
        end = offset + section_size;
        name2 = getString();
      }
      var customSection = {
        neededDynlibs: [],
        tlsExports: /* @__PURE__ */ new Set(),
        weakImports: /* @__PURE__ */ new Set()
      };
      if (name2 == "dylink") {
        customSection.memorySize = getLEB();
        customSection.memoryAlign = getLEB();
        customSection.tableSize = getLEB();
        customSection.tableAlign = getLEB();
        var neededDynlibsCount = getLEB();
        for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
          var libname = getString();
          customSection.neededDynlibs.push(libname);
        }
      } else {
        failIf(name2 !== "dylink.0");
        var WASM_DYLINK_MEM_INFO = 1;
        var WASM_DYLINK_NEEDED = 2;
        var WASM_DYLINK_EXPORT_INFO = 3;
        var WASM_DYLINK_IMPORT_INFO = 4;
        var WASM_SYMBOL_TLS = 256;
        var WASM_SYMBOL_BINDING_MASK = 3;
        var WASM_SYMBOL_BINDING_WEAK = 1;
        while (offset < end) {
          var subsectionType = getU8();
          var subsectionSize = getLEB();
          if (subsectionType === WASM_DYLINK_MEM_INFO) {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
          } else if (subsectionType === WASM_DYLINK_NEEDED) {
            var neededDynlibsCount = getLEB();
            for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
              libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
            var count2 = getLEB();
            while (count2--) {
              var symname = getString();
              var flags2 = getLEB();
              if (flags2 & WASM_SYMBOL_TLS) {
                customSection.tlsExports.add(symname);
              }
            }
          } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
            var count2 = getLEB();
            while (count2--) {
              var modname = getString();
              var symname = getString();
              var flags2 = getLEB();
              if ((flags2 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                customSection.weakImports.add(symname);
              }
            }
          } else {
            offset += subsectionSize;
          }
        }
      }
      return customSection;
    }, "getDylinkMetadata");
    function getValue(ptr, type2 = "i8") {
      if (type2.endsWith("*")) type2 = "*";
      switch (type2) {
        case "i1":
          return HEAP8[ptr];
        case "i8":
          return HEAP8[ptr];
        case "i16":
          return LE_HEAP_LOAD_I16((ptr >> 1) * 2);
        case "i32":
          return LE_HEAP_LOAD_I32((ptr >> 2) * 4);
        case "i64":
          return HEAP64[ptr >> 3];
        case "float":
          return LE_HEAP_LOAD_F32((ptr >> 2) * 4);
        case "double":
          return LE_HEAP_LOAD_F64((ptr >> 3) * 8);
        case "*":
          return LE_HEAP_LOAD_U32((ptr >> 2) * 4);
        default:
          abort(`invalid type for getValue: ${type2}`);
      }
    }
    __name(getValue, "getValue");
    var newDSO = /* @__PURE__ */ __name((name2, handle2, syms) => {
      var dso = {
        refcount: Infinity,
        name: name2,
        exports: syms,
        global: true
      };
      LDSO.loadedLibsByName[name2] = dso;
      if (handle2 != void 0) {
        LDSO.loadedLibsByHandle[handle2] = dso;
      }
      return dso;
    }, "newDSO");
    var LDSO = {
      loadedLibsByName: {},
      loadedLibsByHandle: {},
      init() {
        newDSO("__main__", 0, wasmImports);
      }
    };
    var ___heap_base = 78224;
    var alignMemory = /* @__PURE__ */ __name((size, alignment) => Math.ceil(size / alignment) * alignment, "alignMemory");
    var getMemory = /* @__PURE__ */ __name((size) => {
      if (runtimeInitialized) {
        return _calloc(size, 1);
      }
      var ret = ___heap_base;
      var end = ret + alignMemory(size, 16);
      ___heap_base = end;
      GOT["__heap_base"].value = end;
      return ret;
    }, "getMemory");
    var isInternalSym = /* @__PURE__ */ __name((symName) => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(symName) || symName.startsWith("__em_js__"), "isInternalSym");
    var uleb128Encode = /* @__PURE__ */ __name((n, target) => {
      if (n < 128) {
        target.push(n);
      } else {
        target.push(n % 128 | 128, n >> 7);
      }
    }, "uleb128Encode");
    var sigToWasmTypes = /* @__PURE__ */ __name((sig) => {
      var typeNames = {
        "i": "i32",
        "j": "i64",
        "f": "f32",
        "d": "f64",
        "e": "externref",
        "p": "i32"
      };
      var type2 = {
        parameters: [],
        results: sig[0] == "v" ? [] : [typeNames[sig[0]]]
      };
      for (var i2 = 1; i2 < sig.length; ++i2) {
        type2.parameters.push(typeNames[sig[i2]]);
      }
      return type2;
    }, "sigToWasmTypes");
    var generateFuncType = /* @__PURE__ */ __name((sig, target) => {
      var sigRet = sig.slice(0, 1);
      var sigParam = sig.slice(1);
      var typeCodes = {
        "i": 127,
        // i32
        "p": 127,
        // i32
        "j": 126,
        // i64
        "f": 125,
        // f32
        "d": 124,
        // f64
        "e": 111
      };
      target.push(96);
      uleb128Encode(sigParam.length, target);
      for (var i2 = 0; i2 < sigParam.length; ++i2) {
        target.push(typeCodes[sigParam[i2]]);
      }
      if (sigRet == "v") {
        target.push(0);
      } else {
        target.push(1, typeCodes[sigRet]);
      }
    }, "generateFuncType");
    var convertJsFunctionToWasm = /* @__PURE__ */ __name((func2, sig) => {
      if (typeof WebAssembly.Function == "function") {
        return new WebAssembly.Function(sigToWasmTypes(sig), func2);
      }
      var typeSectionBody = [1];
      generateFuncType(sig, typeSectionBody);
      var bytes = [
        0,
        97,
        115,
        109,
        // magic ("\0asm")
        1,
        0,
        0,
        0,
        // version: 1
        1
      ];
      uleb128Encode(typeSectionBody.length, bytes);
      bytes.push(...typeSectionBody);
      bytes.push(
        2,
        7,
        // import section
        // (import "e" "f" (func 0 (type 0)))
        1,
        1,
        101,
        1,
        102,
        0,
        0,
        7,
        5,
        // export section
        // (export "f" (func 0 (type 0)))
        1,
        1,
        102,
        0,
        0
      );
      var module2 = new WebAssembly.Module(new Uint8Array(bytes));
      var instance2 = new WebAssembly.Instance(module2, {
        "e": {
          "f": func2
        }
      });
      var wrappedFunc = instance2.exports["f"];
      return wrappedFunc;
    }, "convertJsFunctionToWasm");
    var wasmTableMirror = [];
    var wasmTable = new WebAssembly.Table({
      "initial": 31,
      "element": "anyfunc"
    });
    var getWasmTableEntry = /* @__PURE__ */ __name((funcPtr) => {
      var func2 = wasmTableMirror[funcPtr];
      if (!func2) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func2 = wasmTable.get(funcPtr);
      }
      return func2;
    }, "getWasmTableEntry");
    var updateTableMap = /* @__PURE__ */ __name((offset, count2) => {
      if (functionsInTableMap) {
        for (var i2 = offset; i2 < offset + count2; i2++) {
          var item = getWasmTableEntry(i2);
          if (item) {
            functionsInTableMap.set(item, i2);
          }
        }
      }
    }, "updateTableMap");
    var functionsInTableMap;
    var getFunctionAddress = /* @__PURE__ */ __name((func2) => {
      if (!functionsInTableMap) {
        functionsInTableMap = /* @__PURE__ */ new WeakMap();
        updateTableMap(0, wasmTable.length);
      }
      return functionsInTableMap.get(func2) || 0;
    }, "getFunctionAddress");
    var freeTableIndexes = [];
    var getEmptyTableSlot = /* @__PURE__ */ __name(() => {
      if (freeTableIndexes.length) {
        return freeTableIndexes.pop();
      }
      try {
        wasmTable.grow(1);
      } catch (err2) {
        if (!(err2 instanceof RangeError)) {
          throw err2;
        }
        throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
      }
      return wasmTable.length - 1;
    }, "getEmptyTableSlot");
    var setWasmTableEntry = /* @__PURE__ */ __name((idx, func2) => {
      wasmTable.set(idx, func2);
      wasmTableMirror[idx] = wasmTable.get(idx);
    }, "setWasmTableEntry");
    var addFunction = /* @__PURE__ */ __name((func2, sig) => {
      var rtn = getFunctionAddress(func2);
      if (rtn) {
        return rtn;
      }
      var ret = getEmptyTableSlot();
      try {
        setWasmTableEntry(ret, func2);
      } catch (err2) {
        if (!(err2 instanceof TypeError)) {
          throw err2;
        }
        var wrapped = convertJsFunctionToWasm(func2, sig);
        setWasmTableEntry(ret, wrapped);
      }
      functionsInTableMap.set(func2, ret);
      return ret;
    }, "addFunction");
    var updateGOT = /* @__PURE__ */ __name((exports2, replace) => {
      for (var symName in exports2) {
        if (isInternalSym(symName)) {
          continue;
        }
        var value = exports2[symName];
        GOT[symName] || (GOT[symName] = new WebAssembly.Global({
          "value": "i32",
          "mutable": true
        }));
        if (replace || GOT[symName].value == 0) {
          if (typeof value == "function") {
            GOT[symName].value = addFunction(value);
          } else if (typeof value == "number") {
            GOT[symName].value = value;
          } else {
            err(`unhandled export type for '${symName}': ${typeof value}`);
          }
        }
      }
    }, "updateGOT");
    var relocateExports = /* @__PURE__ */ __name((exports2, memoryBase2, replace) => {
      var relocated = {};
      for (var e in exports2) {
        var value = exports2[e];
        if (typeof value == "object") {
          value = value.value;
        }
        if (typeof value == "number") {
          value += memoryBase2;
        }
        relocated[e] = value;
      }
      updateGOT(relocated, replace);
      return relocated;
    }, "relocateExports");
    var isSymbolDefined = /* @__PURE__ */ __name((symName) => {
      var existing = wasmImports[symName];
      if (!existing || existing.stub) {
        return false;
      }
      return true;
    }, "isSymbolDefined");
    var dynCall = /* @__PURE__ */ __name((sig, ptr, args2 = []) => {
      var rtn = getWasmTableEntry(ptr)(...args2);
      return rtn;
    }, "dynCall");
    var stackSave = /* @__PURE__ */ __name(() => _emscripten_stack_get_current(), "stackSave");
    var stackRestore = /* @__PURE__ */ __name((val) => __emscripten_stack_restore(val), "stackRestore");
    var createInvokeFunction = /* @__PURE__ */ __name((sig) => (ptr, ...args2) => {
      var sp = stackSave();
      try {
        return dynCall(sig, ptr, args2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0) throw e;
        _setThrew(1, 0);
        if (sig[0] == "j") return 0n;
      }
    }, "createInvokeFunction");
    var resolveGlobalSymbol = /* @__PURE__ */ __name((symName, direct = false) => {
      var sym;
      if (isSymbolDefined(symName)) {
        sym = wasmImports[symName];
      } else if (symName.startsWith("invoke_")) {
        sym = wasmImports[symName] = createInvokeFunction(symName.split("_")[1]);
      }
      return {
        sym,
        name: symName
      };
    }, "resolveGlobalSymbol");
    var onPostCtors = [];
    var addOnPostCtor = /* @__PURE__ */ __name((cb) => onPostCtors.unshift(cb), "addOnPostCtor");
    var UTF8ToString = /* @__PURE__ */ __name((ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "", "UTF8ToString");
    var loadWebAssemblyModule = /* @__PURE__ */ __name((binary, flags, libName, localScope, handle) => {
      var metadata = getDylinkMetadata(binary);
      currentModuleWeakSymbols = metadata.weakImports;
      function loadModule() {
        var memAlign = Math.pow(2, metadata.memoryAlign);
        var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;
        var tableBase = metadata.tableSize ? wasmTable.length : 0;
        if (handle) {
          HEAP8[handle + 8] = 1;
          LE_HEAP_STORE_U32((handle + 12 >> 2) * 4, memoryBase);
          LE_HEAP_STORE_I32((handle + 16 >> 2) * 4, metadata.memorySize);
          LE_HEAP_STORE_U32((handle + 20 >> 2) * 4, tableBase);
          LE_HEAP_STORE_I32((handle + 24 >> 2) * 4, metadata.tableSize);
        }
        if (metadata.tableSize) {
          wasmTable.grow(metadata.tableSize);
        }
        var moduleExports;
        function resolveSymbol(sym) {
          var resolved = resolveGlobalSymbol(sym).sym;
          if (!resolved && localScope) {
            resolved = localScope[sym];
          }
          if (!resolved) {
            resolved = moduleExports[sym];
          }
          return resolved;
        }
        __name(resolveSymbol, "resolveSymbol");
        var proxyHandler = {
          get(stubs, prop) {
            switch (prop) {
              case "__memory_base":
                return memoryBase;
              case "__table_base":
                return tableBase;
            }
            if (prop in wasmImports && !wasmImports[prop].stub) {
              var res = wasmImports[prop];
              return res;
            }
            if (!(prop in stubs)) {
              var resolved;
              stubs[prop] = (...args2) => {
                resolved || (resolved = resolveSymbol(prop));
                return resolved(...args2);
              };
            }
            return stubs[prop];
          }
        };
        var proxy = new Proxy({}, proxyHandler);
        var info = {
          "GOT.mem": new Proxy({}, GOTHandler),
          "GOT.func": new Proxy({}, GOTHandler),
          "env": proxy,
          "wasi_snapshot_preview1": proxy
        };
        function postInstantiation(module, instance) {
          updateTableMap(tableBase, metadata.tableSize);
          moduleExports = relocateExports(instance.exports, memoryBase);
          if (!flags.allowUndefined) {
            reportUndefinedSymbols();
          }
          function addEmAsm(addr, body) {
            var args = [];
            var arity = 0;
            for (; arity < 16; arity++) {
              if (body.indexOf("$" + arity) != -1) {
                args.push("$" + arity);
              } else {
                break;
              }
            }
            args = args.join(",");
            var func = `(${args}) => { ${body} };`;
            ASM_CONSTS[start] = eval(func);
          }
          __name(addEmAsm, "addEmAsm");
          if ("__start_em_asm" in moduleExports) {
            var start = moduleExports["__start_em_asm"];
            var stop = moduleExports["__stop_em_asm"];
            while (start < stop) {
              var jsString = UTF8ToString(start);
              addEmAsm(start, jsString);
              start = HEAPU8.indexOf(0, start) + 1;
            }
          }
          function addEmJs(name, cSig, body) {
            var jsArgs = [];
            cSig = cSig.slice(1, -1);
            if (cSig != "void") {
              cSig = cSig.split(",");
              for (var i in cSig) {
                var jsArg = cSig[i].split(" ").pop();
                jsArgs.push(jsArg.replace("*", ""));
              }
            }
            var func = `(${jsArgs}) => ${body};`;
            moduleExports[name] = eval(func);
          }
          __name(addEmJs, "addEmJs");
          for (var name in moduleExports) {
            if (name.startsWith("__em_js__")) {
              var start = moduleExports[name];
              var jsString = UTF8ToString(start);
              var parts = jsString.split("<::>");
              addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]);
              delete moduleExports[name];
            }
          }
          var applyRelocs = moduleExports["__wasm_apply_data_relocs"];
          if (applyRelocs) {
            if (runtimeInitialized) {
              applyRelocs();
            } else {
              __RELOC_FUNCS__.push(applyRelocs);
            }
          }
          var init = moduleExports["__wasm_call_ctors"];
          if (init) {
            if (runtimeInitialized) {
              init();
            } else {
              addOnPostCtor(init);
            }
          }
          return moduleExports;
        }
        __name(postInstantiation, "postInstantiation");
        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(binary, instance));
          }
          return WebAssembly.instantiate(binary, info).then((result) => postInstantiation(result.module, result.instance));
        }
        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
        var instance = new WebAssembly.Instance(module, info);
        return postInstantiation(module, instance);
      }
      __name(loadModule, "loadModule");
      if (flags.loadAsync) {
        return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags, localScope)), Promise.resolve()).then(loadModule);
      }
      metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
      return loadModule();
    }, "loadWebAssemblyModule");
    var mergeLibSymbols = /* @__PURE__ */ __name((exports2, libName2) => {
      for (var [sym, exp] of Object.entries(exports2)) {
        const setImport = /* @__PURE__ */ __name((target) => {
          if (!isSymbolDefined(target)) {
            wasmImports[target] = exp;
          }
        }, "setImport");
        setImport(sym);
        const main_alias = "__main_argc_argv";
        if (sym == "main") {
          setImport(main_alias);
        }
        if (sym == main_alias) {
          setImport("main");
        }
      }
    }, "mergeLibSymbols");
    var asyncLoad = /* @__PURE__ */ __name(async (url2) => {
      var arrayBuffer = await readAsync(url2);
      return new Uint8Array(arrayBuffer);
    }, "asyncLoad");
    function loadDynamicLibrary(libName2, flags2 = {
      global: true,
      nodelete: true
    }, localScope2, handle2) {
      var dso = LDSO.loadedLibsByName[libName2];
      if (dso) {
        if (!flags2.global) {
          if (localScope2) {
            Object.assign(localScope2, dso.exports);
          }
        } else if (!dso.global) {
          dso.global = true;
          mergeLibSymbols(dso.exports, libName2);
        }
        if (flags2.nodelete && dso.refcount !== Infinity) {
          dso.refcount = Infinity;
        }
        dso.refcount++;
        if (handle2) {
          LDSO.loadedLibsByHandle[handle2] = dso;
        }
        return flags2.loadAsync ? Promise.resolve(true) : true;
      }
      dso = newDSO(libName2, handle2, "loading");
      dso.refcount = flags2.nodelete ? Infinity : 1;
      dso.global = flags2.global;
      function loadLibData() {
        if (handle2) {
          var data = LE_HEAP_LOAD_U32((handle2 + 28 >> 2) * 4);
          var dataSize = LE_HEAP_LOAD_U32((handle2 + 32 >> 2) * 4);
          if (data && dataSize) {
            var libData = HEAP8.slice(data, data + dataSize);
            return flags2.loadAsync ? Promise.resolve(libData) : libData;
          }
        }
        var libFile = locateFile(libName2);
        if (flags2.loadAsync) {
          return asyncLoad(libFile);
        }
        if (!readBinary) {
          throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
        }
        return readBinary(libFile);
      }
      __name(loadLibData, "loadLibData");
      function getExports() {
        if (flags2.loadAsync) {
          return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags2, libName2, localScope2, handle2));
        }
        return loadWebAssemblyModule(loadLibData(), flags2, libName2, localScope2, handle2);
      }
      __name(getExports, "getExports");
      function moduleLoaded(exports2) {
        if (dso.global) {
          mergeLibSymbols(exports2, libName2);
        } else if (localScope2) {
          Object.assign(localScope2, exports2);
        }
        dso.exports = exports2;
      }
      __name(moduleLoaded, "moduleLoaded");
      if (flags2.loadAsync) {
        return getExports().then((exports2) => {
          moduleLoaded(exports2);
          return true;
        });
      }
      moduleLoaded(getExports());
      return true;
    }
    __name(loadDynamicLibrary, "loadDynamicLibrary");
    var reportUndefinedSymbols = /* @__PURE__ */ __name(() => {
      for (var [symName, entry] of Object.entries(GOT)) {
        if (entry.value == 0) {
          var value = resolveGlobalSymbol(symName, true).sym;
          if (!value && !entry.required) {
            continue;
          }
          if (typeof value == "function") {
            entry.value = addFunction(value, value.sig);
          } else if (typeof value == "number") {
            entry.value = value;
          } else {
            throw new Error(`bad export type for '${symName}': ${typeof value}`);
          }
        }
      }
    }, "reportUndefinedSymbols");
    var loadDylibs = /* @__PURE__ */ __name(() => {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }
      addRunDependency("loadDylibs");
      dynamicLibraries.reduce((chain, lib) => chain.then(() => loadDynamicLibrary(lib, {
        loadAsync: true,
        global: true,
        nodelete: true,
        allowUndefined: true
      })), Promise.resolve()).then(() => {
        reportUndefinedSymbols();
        removeRunDependency("loadDylibs");
      });
    }, "loadDylibs");
    var noExitRuntime = Module["noExitRuntime"] || true;
    function setValue(ptr, value, type2 = "i8") {
      if (type2.endsWith("*")) type2 = "*";
      switch (type2) {
        case "i1":
          HEAP8[ptr] = value;
          break;
        case "i8":
          HEAP8[ptr] = value;
          break;
        case "i16":
          LE_HEAP_STORE_I16((ptr >> 1) * 2, value);
          break;
        case "i32":
          LE_HEAP_STORE_I32((ptr >> 2) * 4, value);
          break;
        case "i64":
          HEAP64[ptr >> 3] = BigInt(value);
          break;
        case "float":
          LE_HEAP_STORE_F32((ptr >> 2) * 4, value);
          break;
        case "double":
          LE_HEAP_STORE_F64((ptr >> 3) * 8, value);
          break;
        case "*":
          LE_HEAP_STORE_U32((ptr >> 2) * 4, value);
          break;
        default:
          abort(`invalid type for setValue: ${type2}`);
      }
    }
    __name(setValue, "setValue");
    var ___memory_base = new WebAssembly.Global({
      "value": "i32",
      "mutable": false
    }, 1024);
    var ___stack_pointer = new WebAssembly.Global({
      "value": "i32",
      "mutable": true
    }, 78224);
    var ___table_base = new WebAssembly.Global({
      "value": "i32",
      "mutable": false
    }, 1);
    var __abort_js = /* @__PURE__ */ __name(() => abort(""), "__abort_js");
    __abort_js.sig = "v";
    var _emscripten_get_now = /* @__PURE__ */ __name(() => performance.now(), "_emscripten_get_now");
    _emscripten_get_now.sig = "d";
    var _emscripten_date_now = /* @__PURE__ */ __name(() => Date.now(), "_emscripten_date_now");
    _emscripten_date_now.sig = "d";
    var nowIsMonotonic = 1;
    var checkWasiClock = /* @__PURE__ */ __name((clock_id) => clock_id >= 0 && clock_id <= 3, "checkWasiClock");
    var INT53_MAX = 9007199254740992;
    var INT53_MIN = -9007199254740992;
    var bigintToI53Checked = /* @__PURE__ */ __name((num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num), "bigintToI53Checked");
    function _clock_time_get(clk_id, ignored_precision, ptime) {
      ignored_precision = bigintToI53Checked(ignored_precision);
      if (!checkWasiClock(clk_id)) {
        return 28;
      }
      var now;
      if (clk_id === 0) {
        now = _emscripten_date_now();
      } else if (nowIsMonotonic) {
        now = _emscripten_get_now();
      } else {
        return 52;
      }
      var nsec = Math.round(now * 1e3 * 1e3);
      HEAP64[ptime >> 3] = BigInt(nsec);
      return 0;
    }
    __name(_clock_time_get, "_clock_time_get");
    _clock_time_get.sig = "iijp";
    var getHeapMax = /* @__PURE__ */ __name(() => (
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648
    ), "getHeapMax");
    var growMemory = /* @__PURE__ */ __name((size) => {
      var b = wasmMemory.buffer;
      var pages = (size - b.byteLength + 65535) / 65536 | 0;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e) {
      }
    }, "growMemory");
    var _emscripten_resize_heap = /* @__PURE__ */ __name((requestedSize) => {
      var oldSize = HEAPU8.length;
      requestedSize >>>= 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }, "_emscripten_resize_heap");
    _emscripten_resize_heap.sig = "ip";
    var _fd_close = /* @__PURE__ */ __name((fd) => 52, "_fd_close");
    _fd_close.sig = "ii";
    function _fd_seek(fd, offset, whence, newOffset) {
      offset = bigintToI53Checked(offset);
      return 70;
    }
    __name(_fd_seek, "_fd_seek");
    _fd_seek.sig = "iijip";
    var printCharBuffers = [null, [], []];
    var printChar = /* @__PURE__ */ __name((stream, curr) => {
      var buffer = printCharBuffers[stream];
      if (curr === 0 || curr === 10) {
        (stream === 1 ? out : err)(UTF8ArrayToString(buffer));
        buffer.length = 0;
      } else {
        buffer.push(curr);
      }
    }, "printChar");
    var flush_NO_FILESYSTEM = /* @__PURE__ */ __name(() => {
      if (printCharBuffers[1].length) printChar(1, 10);
      if (printCharBuffers[2].length) printChar(2, 10);
    }, "flush_NO_FILESYSTEM");
    var SYSCALLS = {
      varargs: void 0,
      getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }
    };
    var _fd_write = /* @__PURE__ */ __name((fd, iov, iovcnt, pnum) => {
      var num = 0;
      for (var i2 = 0; i2 < iovcnt; i2++) {
        var ptr = LE_HEAP_LOAD_U32((iov >> 2) * 4);
        var len = LE_HEAP_LOAD_U32((iov + 4 >> 2) * 4);
        iov += 8;
        for (var j = 0; j < len; j++) {
          printChar(fd, HEAPU8[ptr + j]);
        }
        num += len;
      }
      LE_HEAP_STORE_U32((pnum >> 2) * 4, num);
      return 0;
    }, "_fd_write");
    _fd_write.sig = "iippp";
    function _tree_sitter_log_callback(isLexMessage, messageAddress) {
      if (Module.currentLogCallback) {
        const message = UTF8ToString(messageAddress);
        Module.currentLogCallback(message, isLexMessage !== 0);
      }
    }
    __name(_tree_sitter_log_callback, "_tree_sitter_log_callback");
    function _tree_sitter_parse_callback(inputBufferAddress, index, row, column, lengthAddress) {
      const INPUT_BUFFER_SIZE = 10 * 1024;
      const string5 = Module.currentParseCallback(index, {
        row,
        column
      });
      if (typeof string5 === "string") {
        setValue(lengthAddress, string5.length, "i32");
        stringToUTF16(string5, inputBufferAddress, INPUT_BUFFER_SIZE);
      } else {
        setValue(lengthAddress, 0, "i32");
      }
    }
    __name(_tree_sitter_parse_callback, "_tree_sitter_parse_callback");
    function _tree_sitter_progress_callback(currentOffset, hasError) {
      if (Module.currentProgressCallback) {
        return Module.currentProgressCallback({
          currentOffset,
          hasError
        });
      }
      return false;
    }
    __name(_tree_sitter_progress_callback, "_tree_sitter_progress_callback");
    function _tree_sitter_query_progress_callback(currentOffset) {
      if (Module.currentQueryProgressCallback) {
        return Module.currentQueryProgressCallback({
          currentOffset
        });
      }
      return false;
    }
    __name(_tree_sitter_query_progress_callback, "_tree_sitter_query_progress_callback");
    var runtimeKeepaliveCounter = 0;
    var keepRuntimeAlive = /* @__PURE__ */ __name(() => noExitRuntime || runtimeKeepaliveCounter > 0, "keepRuntimeAlive");
    var _proc_exit = /* @__PURE__ */ __name((code) => {
      EXITSTATUS = code;
      if (!keepRuntimeAlive()) {
        Module["onExit"]?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    }, "_proc_exit");
    _proc_exit.sig = "vi";
    var exitJS = /* @__PURE__ */ __name((status, implicit) => {
      EXITSTATUS = status;
      _proc_exit(status);
    }, "exitJS");
    var handleException = /* @__PURE__ */ __name((e) => {
      if (e instanceof ExitStatus || e == "unwind") {
        return EXITSTATUS;
      }
      quit_(1, e);
    }, "handleException");
    var lengthBytesUTF8 = /* @__PURE__ */ __name((str2) => {
      var len = 0;
      for (var i2 = 0; i2 < str2.length; ++i2) {
        var c = str2.charCodeAt(i2);
        if (c <= 127) {
          len++;
        } else if (c <= 2047) {
          len += 2;
        } else if (c >= 55296 && c <= 57343) {
          len += 4;
          ++i2;
        } else {
          len += 3;
        }
      }
      return len;
    }, "lengthBytesUTF8");
    var stringToUTF8Array = /* @__PURE__ */ __name((str2, heap, outIdx, maxBytesToWrite) => {
      if (!(maxBytesToWrite > 0)) return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i2 = 0; i2 < str2.length; ++i2) {
        var u = str2.charCodeAt(i2);
        if (u >= 55296 && u <= 57343) {
          var u1 = str2.charCodeAt(++i2);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }, "stringToUTF8Array");
    var stringToUTF8 = /* @__PURE__ */ __name((str2, outPtr, maxBytesToWrite) => stringToUTF8Array(str2, HEAPU8, outPtr, maxBytesToWrite), "stringToUTF8");
    var stackAlloc = /* @__PURE__ */ __name((sz) => __emscripten_stack_alloc(sz), "stackAlloc");
    var stringToUTF8OnStack = /* @__PURE__ */ __name((str2) => {
      var size = lengthBytesUTF8(str2) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str2, ret, size);
      return ret;
    }, "stringToUTF8OnStack");
    var AsciiToString = /* @__PURE__ */ __name((ptr) => {
      var str2 = "";
      while (1) {
        var ch = HEAPU8[ptr++];
        if (!ch) return str2;
        str2 += String.fromCharCode(ch);
      }
    }, "AsciiToString");
    var stringToUTF16 = /* @__PURE__ */ __name((str2, outPtr, maxBytesToWrite) => {
      maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2;
      var startPtr = outPtr;
      var numCharsToWrite = maxBytesToWrite < str2.length * 2 ? maxBytesToWrite / 2 : str2.length;
      for (var i2 = 0; i2 < numCharsToWrite; ++i2) {
        var codeUnit = str2.charCodeAt(i2);
        LE_HEAP_STORE_I16((outPtr >> 1) * 2, codeUnit);
        outPtr += 2;
      }
      LE_HEAP_STORE_I16((outPtr >> 1) * 2, 0);
      return outPtr - startPtr;
    }, "stringToUTF16");
    var wasmImports = {
      /** @export */
      __heap_base: ___heap_base,
      /** @export */
      __indirect_function_table: wasmTable,
      /** @export */
      __memory_base: ___memory_base,
      /** @export */
      __stack_pointer: ___stack_pointer,
      /** @export */
      __table_base: ___table_base,
      /** @export */
      _abort_js: __abort_js,
      /** @export */
      clock_time_get: _clock_time_get,
      /** @export */
      emscripten_resize_heap: _emscripten_resize_heap,
      /** @export */
      fd_close: _fd_close,
      /** @export */
      fd_seek: _fd_seek,
      /** @export */
      fd_write: _fd_write,
      /** @export */
      memory: wasmMemory,
      /** @export */
      tree_sitter_log_callback: _tree_sitter_log_callback,
      /** @export */
      tree_sitter_parse_callback: _tree_sitter_parse_callback,
      /** @export */
      tree_sitter_progress_callback: _tree_sitter_progress_callback,
      /** @export */
      tree_sitter_query_progress_callback: _tree_sitter_query_progress_callback
    };
    var wasmExports = await createWasm();
    var ___wasm_call_ctors = wasmExports["__wasm_call_ctors"];
    var _malloc = Module["_malloc"] = wasmExports["malloc"];
    var _calloc = Module["_calloc"] = wasmExports["calloc"];
    var _realloc = Module["_realloc"] = wasmExports["realloc"];
    var _free = Module["_free"] = wasmExports["free"];
    var _memcmp = Module["_memcmp"] = wasmExports["memcmp"];
    var _ts_language_symbol_count = Module["_ts_language_symbol_count"] = wasmExports["ts_language_symbol_count"];
    var _ts_language_state_count = Module["_ts_language_state_count"] = wasmExports["ts_language_state_count"];
    var _ts_language_version = Module["_ts_language_version"] = wasmExports["ts_language_version"];
    var _ts_language_abi_version = Module["_ts_language_abi_version"] = wasmExports["ts_language_abi_version"];
    var _ts_language_metadata = Module["_ts_language_metadata"] = wasmExports["ts_language_metadata"];
    var _ts_language_name = Module["_ts_language_name"] = wasmExports["ts_language_name"];
    var _ts_language_field_count = Module["_ts_language_field_count"] = wasmExports["ts_language_field_count"];
    var _ts_language_next_state = Module["_ts_language_next_state"] = wasmExports["ts_language_next_state"];
    var _ts_language_symbol_name = Module["_ts_language_symbol_name"] = wasmExports["ts_language_symbol_name"];
    var _ts_language_symbol_for_name = Module["_ts_language_symbol_for_name"] = wasmExports["ts_language_symbol_for_name"];
    var _strncmp = Module["_strncmp"] = wasmExports["strncmp"];
    var _ts_language_symbol_type = Module["_ts_language_symbol_type"] = wasmExports["ts_language_symbol_type"];
    var _ts_language_field_name_for_id = Module["_ts_language_field_name_for_id"] = wasmExports["ts_language_field_name_for_id"];
    var _ts_lookahead_iterator_new = Module["_ts_lookahead_iterator_new"] = wasmExports["ts_lookahead_iterator_new"];
    var _ts_lookahead_iterator_delete = Module["_ts_lookahead_iterator_delete"] = wasmExports["ts_lookahead_iterator_delete"];
    var _ts_lookahead_iterator_reset_state = Module["_ts_lookahead_iterator_reset_state"] = wasmExports["ts_lookahead_iterator_reset_state"];
    var _ts_lookahead_iterator_reset = Module["_ts_lookahead_iterator_reset"] = wasmExports["ts_lookahead_iterator_reset"];
    var _ts_lookahead_iterator_next = Module["_ts_lookahead_iterator_next"] = wasmExports["ts_lookahead_iterator_next"];
    var _ts_lookahead_iterator_current_symbol = Module["_ts_lookahead_iterator_current_symbol"] = wasmExports["ts_lookahead_iterator_current_symbol"];
    var _ts_parser_delete = Module["_ts_parser_delete"] = wasmExports["ts_parser_delete"];
    var _ts_parser_reset = Module["_ts_parser_reset"] = wasmExports["ts_parser_reset"];
    var _ts_parser_set_language = Module["_ts_parser_set_language"] = wasmExports["ts_parser_set_language"];
    var _ts_parser_timeout_micros = Module["_ts_parser_timeout_micros"] = wasmExports["ts_parser_timeout_micros"];
    var _ts_parser_set_timeout_micros = Module["_ts_parser_set_timeout_micros"] = wasmExports["ts_parser_set_timeout_micros"];
    var _ts_parser_set_included_ranges = Module["_ts_parser_set_included_ranges"] = wasmExports["ts_parser_set_included_ranges"];
    var _ts_query_new = Module["_ts_query_new"] = wasmExports["ts_query_new"];
    var _ts_query_delete = Module["_ts_query_delete"] = wasmExports["ts_query_delete"];
    var _iswspace = Module["_iswspace"] = wasmExports["iswspace"];
    var _iswalnum = Module["_iswalnum"] = wasmExports["iswalnum"];
    var _ts_query_pattern_count = Module["_ts_query_pattern_count"] = wasmExports["ts_query_pattern_count"];
    var _ts_query_capture_count = Module["_ts_query_capture_count"] = wasmExports["ts_query_capture_count"];
    var _ts_query_string_count = Module["_ts_query_string_count"] = wasmExports["ts_query_string_count"];
    var _ts_query_capture_name_for_id = Module["_ts_query_capture_name_for_id"] = wasmExports["ts_query_capture_name_for_id"];
    var _ts_query_capture_quantifier_for_id = Module["_ts_query_capture_quantifier_for_id"] = wasmExports["ts_query_capture_quantifier_for_id"];
    var _ts_query_string_value_for_id = Module["_ts_query_string_value_for_id"] = wasmExports["ts_query_string_value_for_id"];
    var _ts_query_predicates_for_pattern = Module["_ts_query_predicates_for_pattern"] = wasmExports["ts_query_predicates_for_pattern"];
    var _ts_query_start_byte_for_pattern = Module["_ts_query_start_byte_for_pattern"] = wasmExports["ts_query_start_byte_for_pattern"];
    var _ts_query_end_byte_for_pattern = Module["_ts_query_end_byte_for_pattern"] = wasmExports["ts_query_end_byte_for_pattern"];
    var _ts_query_is_pattern_rooted = Module["_ts_query_is_pattern_rooted"] = wasmExports["ts_query_is_pattern_rooted"];
    var _ts_query_is_pattern_non_local = Module["_ts_query_is_pattern_non_local"] = wasmExports["ts_query_is_pattern_non_local"];
    var _ts_query_is_pattern_guaranteed_at_step = Module["_ts_query_is_pattern_guaranteed_at_step"] = wasmExports["ts_query_is_pattern_guaranteed_at_step"];
    var _ts_query_disable_capture = Module["_ts_query_disable_capture"] = wasmExports["ts_query_disable_capture"];
    var _ts_query_disable_pattern = Module["_ts_query_disable_pattern"] = wasmExports["ts_query_disable_pattern"];
    var _ts_tree_copy = Module["_ts_tree_copy"] = wasmExports["ts_tree_copy"];
    var _ts_tree_delete = Module["_ts_tree_delete"] = wasmExports["ts_tree_delete"];
    var _ts_init = Module["_ts_init"] = wasmExports["ts_init"];
    var _ts_parser_new_wasm = Module["_ts_parser_new_wasm"] = wasmExports["ts_parser_new_wasm"];
    var _ts_parser_enable_logger_wasm = Module["_ts_parser_enable_logger_wasm"] = wasmExports["ts_parser_enable_logger_wasm"];
    var _ts_parser_parse_wasm = Module["_ts_parser_parse_wasm"] = wasmExports["ts_parser_parse_wasm"];
    var _ts_parser_included_ranges_wasm = Module["_ts_parser_included_ranges_wasm"] = wasmExports["ts_parser_included_ranges_wasm"];
    var _ts_language_type_is_named_wasm = Module["_ts_language_type_is_named_wasm"] = wasmExports["ts_language_type_is_named_wasm"];
    var _ts_language_type_is_visible_wasm = Module["_ts_language_type_is_visible_wasm"] = wasmExports["ts_language_type_is_visible_wasm"];
    var _ts_language_supertypes_wasm = Module["_ts_language_supertypes_wasm"] = wasmExports["ts_language_supertypes_wasm"];
    var _ts_language_subtypes_wasm = Module["_ts_language_subtypes_wasm"] = wasmExports["ts_language_subtypes_wasm"];
    var _ts_tree_root_node_wasm = Module["_ts_tree_root_node_wasm"] = wasmExports["ts_tree_root_node_wasm"];
    var _ts_tree_root_node_with_offset_wasm = Module["_ts_tree_root_node_with_offset_wasm"] = wasmExports["ts_tree_root_node_with_offset_wasm"];
    var _ts_tree_edit_wasm = Module["_ts_tree_edit_wasm"] = wasmExports["ts_tree_edit_wasm"];
    var _ts_tree_included_ranges_wasm = Module["_ts_tree_included_ranges_wasm"] = wasmExports["ts_tree_included_ranges_wasm"];
    var _ts_tree_get_changed_ranges_wasm = Module["_ts_tree_get_changed_ranges_wasm"] = wasmExports["ts_tree_get_changed_ranges_wasm"];
    var _ts_tree_cursor_new_wasm = Module["_ts_tree_cursor_new_wasm"] = wasmExports["ts_tree_cursor_new_wasm"];
    var _ts_tree_cursor_copy_wasm = Module["_ts_tree_cursor_copy_wasm"] = wasmExports["ts_tree_cursor_copy_wasm"];
    var _ts_tree_cursor_delete_wasm = Module["_ts_tree_cursor_delete_wasm"] = wasmExports["ts_tree_cursor_delete_wasm"];
    var _ts_tree_cursor_reset_wasm = Module["_ts_tree_cursor_reset_wasm"] = wasmExports["ts_tree_cursor_reset_wasm"];
    var _ts_tree_cursor_reset_to_wasm = Module["_ts_tree_cursor_reset_to_wasm"] = wasmExports["ts_tree_cursor_reset_to_wasm"];
    var _ts_tree_cursor_goto_first_child_wasm = Module["_ts_tree_cursor_goto_first_child_wasm"] = wasmExports["ts_tree_cursor_goto_first_child_wasm"];
    var _ts_tree_cursor_goto_last_child_wasm = Module["_ts_tree_cursor_goto_last_child_wasm"] = wasmExports["ts_tree_cursor_goto_last_child_wasm"];
    var _ts_tree_cursor_goto_first_child_for_index_wasm = Module["_ts_tree_cursor_goto_first_child_for_index_wasm"] = wasmExports["ts_tree_cursor_goto_first_child_for_index_wasm"];
    var _ts_tree_cursor_goto_first_child_for_position_wasm = Module["_ts_tree_cursor_goto_first_child_for_position_wasm"] = wasmExports["ts_tree_cursor_goto_first_child_for_position_wasm"];
    var _ts_tree_cursor_goto_next_sibling_wasm = Module["_ts_tree_cursor_goto_next_sibling_wasm"] = wasmExports["ts_tree_cursor_goto_next_sibling_wasm"];
    var _ts_tree_cursor_goto_previous_sibling_wasm = Module["_ts_tree_cursor_goto_previous_sibling_wasm"] = wasmExports["ts_tree_cursor_goto_previous_sibling_wasm"];
    var _ts_tree_cursor_goto_descendant_wasm = Module["_ts_tree_cursor_goto_descendant_wasm"] = wasmExports["ts_tree_cursor_goto_descendant_wasm"];
    var _ts_tree_cursor_goto_parent_wasm = Module["_ts_tree_cursor_goto_parent_wasm"] = wasmExports["ts_tree_cursor_goto_parent_wasm"];
    var _ts_tree_cursor_current_node_type_id_wasm = Module["_ts_tree_cursor_current_node_type_id_wasm"] = wasmExports["ts_tree_cursor_current_node_type_id_wasm"];
    var _ts_tree_cursor_current_node_state_id_wasm = Module["_ts_tree_cursor_current_node_state_id_wasm"] = wasmExports["ts_tree_cursor_current_node_state_id_wasm"];
    var _ts_tree_cursor_current_node_is_named_wasm = Module["_ts_tree_cursor_current_node_is_named_wasm"] = wasmExports["ts_tree_cursor_current_node_is_named_wasm"];
    var _ts_tree_cursor_current_node_is_missing_wasm = Module["_ts_tree_cursor_current_node_is_missing_wasm"] = wasmExports["ts_tree_cursor_current_node_is_missing_wasm"];
    var _ts_tree_cursor_current_node_id_wasm = Module["_ts_tree_cursor_current_node_id_wasm"] = wasmExports["ts_tree_cursor_current_node_id_wasm"];
    var _ts_tree_cursor_start_position_wasm = Module["_ts_tree_cursor_start_position_wasm"] = wasmExports["ts_tree_cursor_start_position_wasm"];
    var _ts_tree_cursor_end_position_wasm = Module["_ts_tree_cursor_end_position_wasm"] = wasmExports["ts_tree_cursor_end_position_wasm"];
    var _ts_tree_cursor_start_index_wasm = Module["_ts_tree_cursor_start_index_wasm"] = wasmExports["ts_tree_cursor_start_index_wasm"];
    var _ts_tree_cursor_end_index_wasm = Module["_ts_tree_cursor_end_index_wasm"] = wasmExports["ts_tree_cursor_end_index_wasm"];
    var _ts_tree_cursor_current_field_id_wasm = Module["_ts_tree_cursor_current_field_id_wasm"] = wasmExports["ts_tree_cursor_current_field_id_wasm"];
    var _ts_tree_cursor_current_depth_wasm = Module["_ts_tree_cursor_current_depth_wasm"] = wasmExports["ts_tree_cursor_current_depth_wasm"];
    var _ts_tree_cursor_current_descendant_index_wasm = Module["_ts_tree_cursor_current_descendant_index_wasm"] = wasmExports["ts_tree_cursor_current_descendant_index_wasm"];
    var _ts_tree_cursor_current_node_wasm = Module["_ts_tree_cursor_current_node_wasm"] = wasmExports["ts_tree_cursor_current_node_wasm"];
    var _ts_node_symbol_wasm = Module["_ts_node_symbol_wasm"] = wasmExports["ts_node_symbol_wasm"];
    var _ts_node_field_name_for_child_wasm = Module["_ts_node_field_name_for_child_wasm"] = wasmExports["ts_node_field_name_for_child_wasm"];
    var _ts_node_field_name_for_named_child_wasm = Module["_ts_node_field_name_for_named_child_wasm"] = wasmExports["ts_node_field_name_for_named_child_wasm"];
    var _ts_node_children_by_field_id_wasm = Module["_ts_node_children_by_field_id_wasm"] = wasmExports["ts_node_children_by_field_id_wasm"];
    var _ts_node_first_child_for_byte_wasm = Module["_ts_node_first_child_for_byte_wasm"] = wasmExports["ts_node_first_child_for_byte_wasm"];
    var _ts_node_first_named_child_for_byte_wasm = Module["_ts_node_first_named_child_for_byte_wasm"] = wasmExports["ts_node_first_named_child_for_byte_wasm"];
    var _ts_node_grammar_symbol_wasm = Module["_ts_node_grammar_symbol_wasm"] = wasmExports["ts_node_grammar_symbol_wasm"];
    var _ts_node_child_count_wasm = Module["_ts_node_child_count_wasm"] = wasmExports["ts_node_child_count_wasm"];
    var _ts_node_named_child_count_wasm = Module["_ts_node_named_child_count_wasm"] = wasmExports["ts_node_named_child_count_wasm"];
    var _ts_node_child_wasm = Module["_ts_node_child_wasm"] = wasmExports["ts_node_child_wasm"];
    var _ts_node_named_child_wasm = Module["_ts_node_named_child_wasm"] = wasmExports["ts_node_named_child_wasm"];
    var _ts_node_child_by_field_id_wasm = Module["_ts_node_child_by_field_id_wasm"] = wasmExports["ts_node_child_by_field_id_wasm"];
    var _ts_node_next_sibling_wasm = Module["_ts_node_next_sibling_wasm"] = wasmExports["ts_node_next_sibling_wasm"];
    var _ts_node_prev_sibling_wasm = Module["_ts_node_prev_sibling_wasm"] = wasmExports["ts_node_prev_sibling_wasm"];
    var _ts_node_next_named_sibling_wasm = Module["_ts_node_next_named_sibling_wasm"] = wasmExports["ts_node_next_named_sibling_wasm"];
    var _ts_node_prev_named_sibling_wasm = Module["_ts_node_prev_named_sibling_wasm"] = wasmExports["ts_node_prev_named_sibling_wasm"];
    var _ts_node_descendant_count_wasm = Module["_ts_node_descendant_count_wasm"] = wasmExports["ts_node_descendant_count_wasm"];
    var _ts_node_parent_wasm = Module["_ts_node_parent_wasm"] = wasmExports["ts_node_parent_wasm"];
    var _ts_node_child_with_descendant_wasm = Module["_ts_node_child_with_descendant_wasm"] = wasmExports["ts_node_child_with_descendant_wasm"];
    var _ts_node_descendant_for_index_wasm = Module["_ts_node_descendant_for_index_wasm"] = wasmExports["ts_node_descendant_for_index_wasm"];
    var _ts_node_named_descendant_for_index_wasm = Module["_ts_node_named_descendant_for_index_wasm"] = wasmExports["ts_node_named_descendant_for_index_wasm"];
    var _ts_node_descendant_for_position_wasm = Module["_ts_node_descendant_for_position_wasm"] = wasmExports["ts_node_descendant_for_position_wasm"];
    var _ts_node_named_descendant_for_position_wasm = Module["_ts_node_named_descendant_for_position_wasm"] = wasmExports["ts_node_named_descendant_for_position_wasm"];
    var _ts_node_start_point_wasm = Module["_ts_node_start_point_wasm"] = wasmExports["ts_node_start_point_wasm"];
    var _ts_node_end_point_wasm = Module["_ts_node_end_point_wasm"] = wasmExports["ts_node_end_point_wasm"];
    var _ts_node_start_index_wasm = Module["_ts_node_start_index_wasm"] = wasmExports["ts_node_start_index_wasm"];
    var _ts_node_end_index_wasm = Module["_ts_node_end_index_wasm"] = wasmExports["ts_node_end_index_wasm"];
    var _ts_node_to_string_wasm = Module["_ts_node_to_string_wasm"] = wasmExports["ts_node_to_string_wasm"];
    var _ts_node_children_wasm = Module["_ts_node_children_wasm"] = wasmExports["ts_node_children_wasm"];
    var _ts_node_named_children_wasm = Module["_ts_node_named_children_wasm"] = wasmExports["ts_node_named_children_wasm"];
    var _ts_node_descendants_of_type_wasm = Module["_ts_node_descendants_of_type_wasm"] = wasmExports["ts_node_descendants_of_type_wasm"];
    var _ts_node_is_named_wasm = Module["_ts_node_is_named_wasm"] = wasmExports["ts_node_is_named_wasm"];
    var _ts_node_has_changes_wasm = Module["_ts_node_has_changes_wasm"] = wasmExports["ts_node_has_changes_wasm"];
    var _ts_node_has_error_wasm = Module["_ts_node_has_error_wasm"] = wasmExports["ts_node_has_error_wasm"];
    var _ts_node_is_error_wasm = Module["_ts_node_is_error_wasm"] = wasmExports["ts_node_is_error_wasm"];
    var _ts_node_is_missing_wasm = Module["_ts_node_is_missing_wasm"] = wasmExports["ts_node_is_missing_wasm"];
    var _ts_node_is_extra_wasm = Module["_ts_node_is_extra_wasm"] = wasmExports["ts_node_is_extra_wasm"];
    var _ts_node_parse_state_wasm = Module["_ts_node_parse_state_wasm"] = wasmExports["ts_node_parse_state_wasm"];
    var _ts_node_next_parse_state_wasm = Module["_ts_node_next_parse_state_wasm"] = wasmExports["ts_node_next_parse_state_wasm"];
    var _ts_query_matches_wasm = Module["_ts_query_matches_wasm"] = wasmExports["ts_query_matches_wasm"];
    var _ts_query_captures_wasm = Module["_ts_query_captures_wasm"] = wasmExports["ts_query_captures_wasm"];
    var _memset = Module["_memset"] = wasmExports["memset"];
    var _memcpy = Module["_memcpy"] = wasmExports["memcpy"];
    var _memmove = Module["_memmove"] = wasmExports["memmove"];
    var _iswalpha = Module["_iswalpha"] = wasmExports["iswalpha"];
    var _iswblank = Module["_iswblank"] = wasmExports["iswblank"];
    var _iswdigit = Module["_iswdigit"] = wasmExports["iswdigit"];
    var _iswlower = Module["_iswlower"] = wasmExports["iswlower"];
    var _iswupper = Module["_iswupper"] = wasmExports["iswupper"];
    var _iswxdigit = Module["_iswxdigit"] = wasmExports["iswxdigit"];
    var _memchr = Module["_memchr"] = wasmExports["memchr"];
    var _strlen = Module["_strlen"] = wasmExports["strlen"];
    var _strcmp = Module["_strcmp"] = wasmExports["strcmp"];
    var _strncat = Module["_strncat"] = wasmExports["strncat"];
    var _strncpy = Module["_strncpy"] = wasmExports["strncpy"];
    var _towlower = Module["_towlower"] = wasmExports["towlower"];
    var _towupper = Module["_towupper"] = wasmExports["towupper"];
    var _setThrew = wasmExports["setThrew"];
    var __emscripten_stack_restore = wasmExports["_emscripten_stack_restore"];
    var __emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"];
    var _emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"];
    var ___wasm_apply_data_relocs = wasmExports["__wasm_apply_data_relocs"];
    Module["setValue"] = setValue;
    Module["getValue"] = getValue;
    Module["UTF8ToString"] = UTF8ToString;
    Module["stringToUTF8"] = stringToUTF8;
    Module["lengthBytesUTF8"] = lengthBytesUTF8;
    Module["AsciiToString"] = AsciiToString;
    Module["stringToUTF16"] = stringToUTF16;
    Module["loadWebAssemblyModule"] = loadWebAssemblyModule;
    function callMain(args2 = []) {
      var entryFunction = resolveGlobalSymbol("main").sym;
      if (!entryFunction) return;
      args2.unshift(thisProgram);
      var argc = args2.length;
      var argv = stackAlloc((argc + 1) * 4);
      var argv_ptr = argv;
      args2.forEach((arg) => {
        LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, stringToUTF8OnStack(arg));
        argv_ptr += 4;
      });
      LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, 0);
      try {
        var ret = entryFunction(argc, argv);
        exitJS(
          ret,
          /* implicit = */
          true
        );
        return ret;
      } catch (e) {
        return handleException(e);
      }
    }
    __name(callMain, "callMain");
    function run(args2 = arguments_) {
      if (runDependencies > 0) {
        dependenciesFulfilled = run;
        return;
      }
      preRun();
      if (runDependencies > 0) {
        dependenciesFulfilled = run;
        return;
      }
      function doRun() {
        Module["calledRun"] = true;
        if (ABORT) return;
        initRuntime();
        preMain();
        readyPromiseResolve(Module);
        Module["onRuntimeInitialized"]?.();
        var noInitialRun = Module["noInitialRun"];
        if (!noInitialRun) callMain(args2);
        postRun();
      }
      __name(doRun, "doRun");
      if (Module["setStatus"]) {
        Module["setStatus"]("Running...");
        setTimeout(() => {
          setTimeout(() => Module["setStatus"](""), 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    __name(run, "run");
    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];
      while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }
    run();
    moduleRtn = readyPromise;
    return moduleRtn;
  };
})();
var tree_sitter_default = Module2;
var Module3 = null;
async function initializeBinding(moduleOptions) {
  if (!Module3) {
    Module3 = await tree_sitter_default(moduleOptions);
  }
  return Module3;
}
__name(initializeBinding, "initializeBinding");
function checkModule() {
  return !!Module3;
}
__name(checkModule, "checkModule");
var TRANSFER_BUFFER;
var LANGUAGE_VERSION;
var MIN_COMPATIBLE_VERSION;
var _a9;
var Parser2 = (_a9 = class {
  /**
   * Create a new parser.
   */
  constructor() {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, 1, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "logCallback", null);
    /** The parser's current language. */
    __publicField(this, "language", null);
    this.initialize();
  }
  /**
   * This must always be called before creating a Parser.
   *
   * You can optionally pass in options to configure the WASM module, the most common
   * one being `locateFile` to help the module find the `.wasm` file.
   */
  static async init(moduleOptions) {
    setModule(await initializeBinding(moduleOptions));
    TRANSFER_BUFFER = C._ts_init();
    LANGUAGE_VERSION = C.getValue(TRANSFER_BUFFER, "i32");
    MIN_COMPATIBLE_VERSION = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
  }
  /** @internal */
  initialize() {
    if (!checkModule()) {
      throw new Error("cannot construct a Parser before calling `init()`");
    }
    C._ts_parser_new_wasm();
    this[0] = C.getValue(TRANSFER_BUFFER, "i32");
    this[1] = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
  }
  /** Delete the parser, freeing its resources. */
  delete() {
    C._ts_parser_delete(this[0]);
    C._free(this[1]);
    this[0] = 0;
    this[1] = 0;
  }
  /**
   * Set the language that the parser should use for parsing.
   *
   * If the language was not successfully assigned, an error will be thrown.
   * This happens if the language was generated with an incompatible
   * version of the Tree-sitter CLI. Check the language's version using
   * {@link Language#version} and compare it to this library's
   * {@link LANGUAGE_VERSION} and {@link MIN_COMPATIBLE_VERSION} constants.
   */
  setLanguage(language) {
    let address;
    if (!language) {
      address = 0;
      this.language = null;
    } else if (language.constructor === Language) {
      address = language[0];
      const version2 = C._ts_language_version(address);
      if (version2 < MIN_COMPATIBLE_VERSION || LANGUAGE_VERSION < version2) {
        throw new Error(
          `Incompatible language version ${version2}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${LANGUAGE_VERSION}.`
        );
      }
      this.language = language;
    } else {
      throw new Error("Argument must be a Language");
    }
    C._ts_parser_set_language(this[0], address);
    return this;
  }
  /**
   * Parse a slice of UTF8 text.
   *
   * @param {string | ParseCallback} callback - The UTF8-encoded text to parse or a callback function.
   *
   * @param {Tree | null} [oldTree] - A previous syntax tree parsed from the same document. If the text of the
   *   document has changed since `oldTree` was created, then you must edit `oldTree` to match
   *   the new text using {@link Tree#edit}.
   *
   * @param {ParseOptions} [options] - Options for parsing the text.
   *  This can be used to set the included ranges, or a progress callback.
   *
   * @returns {Tree | null} A {@link Tree} if parsing succeeded, or `null` if:
   *  - The parser has not yet had a language assigned with {@link Parser#setLanguage}.
   *  - The progress callback returned true.
   */
  parse(callback2, oldTree, options2) {
    if (typeof callback2 === "string") {
      C.currentParseCallback = (index) => callback2.slice(index);
    } else if (typeof callback2 === "function") {
      C.currentParseCallback = callback2;
    } else {
      throw new Error("Argument must be a string or a function");
    }
    if (options2?.progressCallback) {
      C.currentProgressCallback = options2.progressCallback;
    } else {
      C.currentProgressCallback = null;
    }
    if (this.logCallback) {
      C.currentLogCallback = this.logCallback;
      C._ts_parser_enable_logger_wasm(this[0], 1);
    } else {
      C.currentLogCallback = null;
      C._ts_parser_enable_logger_wasm(this[0], 0);
    }
    let rangeCount = 0;
    let rangeAddress = 0;
    if (options2?.includedRanges) {
      rangeCount = options2.includedRanges.length;
      rangeAddress = C._calloc(rangeCount, SIZE_OF_RANGE);
      let address = rangeAddress;
      for (let i2 = 0; i2 < rangeCount; i2++) {
        marshalRange(address, options2.includedRanges[i2]);
        address += SIZE_OF_RANGE;
      }
    }
    const treeAddress = C._ts_parser_parse_wasm(
      this[0],
      this[1],
      oldTree ? oldTree[0] : 0,
      rangeAddress,
      rangeCount
    );
    if (!treeAddress) {
      C.currentParseCallback = null;
      C.currentLogCallback = null;
      C.currentProgressCallback = null;
      return null;
    }
    if (!this.language) {
      throw new Error("Parser must have a language to parse");
    }
    const result = new Tree(INTERNAL, treeAddress, this.language, C.currentParseCallback);
    C.currentParseCallback = null;
    C.currentLogCallback = null;
    C.currentProgressCallback = null;
    return result;
  }
  /**
   * Instruct the parser to start the next parse from the beginning.
   *
   * If the parser previously failed because of a timeout, cancellation,
   * or callback, then by default, it will resume where it left off on the
   * next call to {@link Parser#parse} or other parsing functions.
   * If you don't want to resume, and instead intend to use this parser to
   * parse some other document, you must call `reset` first.
   */
  reset() {
    C._ts_parser_reset(this[0]);
  }
  /** Get the ranges of text that the parser will include when parsing. */
  getIncludedRanges() {
    C._ts_parser_included_ranges_wasm(this[0]);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = unmarshalRange(address);
        address += SIZE_OF_RANGE;
      }
      C._free(buffer);
    }
    return result;
  }
  /**
   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}
   *
   * Get the duration in microseconds that parsing is allowed to take.
   *
   * This is set via {@link Parser#setTimeoutMicros}.
   */
  getTimeoutMicros() {
    return C._ts_parser_timeout_micros(this[0]);
  }
  /**
   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}
   *
   * Set the maximum duration in microseconds that parsing should be allowed
   * to take before halting.
   *
   * If parsing takes longer than this, it will halt early, returning `null`.
   * See {@link Parser#parse} for more information.
   */
  setTimeoutMicros(timeout) {
    C._ts_parser_set_timeout_micros(this[0], 0, timeout);
  }
  /** Set the logging callback that a parser should use during parsing. */
  setLogger(callback2) {
    if (!callback2) {
      this.logCallback = null;
    } else if (typeof callback2 !== "function") {
      throw new Error("Logger callback must be a function");
    } else {
      this.logCallback = callback2;
    }
    return this;
  }
  /** Get the parser's current logger. */
  getLogger() {
    return this.logCallback;
  }
}, __name(_a9, "Parser"), _a9);

// src/ide/languageToWasmModule.ts
var languageToWasmModule = {
  "java-properties": "tree-sitter-properties",
  "talon-list": "tree-sitter-talon",
  agda: "tree-sitter-agda",
  c: "tree-sitter-c",
  clojure: "tree-sitter-clojure",
  cpp: "tree-sitter-cpp",
  csharp: "tree-sitter-c_sharp",
  css: "tree-sitter-css",
  dart: "tree-sitter-dart",
  elixir: "tree-sitter-elixir",
  elm: "tree-sitter-elm",
  gdscript: "tree-sitter-gdscript",
  gleam: "tree-sitter-gleam",
  go: "tree-sitter-go",
  haskell: "tree-sitter-haskell",
  html: "tree-sitter-html",
  java: "tree-sitter-java",
  javascript: "tree-sitter-javascript",
  javascriptreact: "tree-sitter-javascript",
  json: "tree-sitter-json",
  jsonc: "tree-sitter-json",
  jsonl: "tree-sitter-json",
  julia: "tree-sitter-julia",
  kotlin: "tree-sitter-kotlin",
  latex: "tree-sitter-latex",
  lua: "tree-sitter-lua",
  markdown: "tree-sitter-markdown",
  nix: "tree-sitter-nix",
  perl: "tree-sitter-perl",
  php: "tree-sitter-php",
  properties: "tree-sitter-properties",
  python: "tree-sitter-python",
  r: "tree-sitter-r",
  ruby: "tree-sitter-ruby",
  rust: "tree-sitter-rust",
  scala: "tree-sitter-scala",
  scm: "tree-sitter-query",
  scss: "tree-sitter-scss",
  shellscript: "tree-sitter-bash",
  sparql: "tree-sitter-sparql",
  starlark: "tree-sitter-python",
  swift: "tree-sitter-swift",
  talon: "tree-sitter-talon",
  terraform: "tree-sitter-hcl",
  typescript: "tree-sitter-typescript",
  typescriptreact: "tree-sitter-tsx",
  xml: "tree-sitter-xml",
  yaml: "tree-sitter-yaml",
  zig: "tree-sitter-zig"
};
function getWasmModuleName(languageId) {
  return languageToWasmModule[languageId] ?? `tree-sitter-${languageId}`;
}

// src/ide/pathJoin.ts
function pathJoin(...segments) {
  return segments.join(pathSep());
}
function pathSep() {
  if (/^win/i.test(process.platform)) {
    return "\\";
  } else {
    return "/";
  }
}

// src/ide/JetbrainsTreeSitter.ts
var JetbrainsTreeSitter = class {
  constructor(wasmDirectory) {
    this.wasmDirectory = wasmDirectory;
    this.parsers = /* @__PURE__ */ new Map();
  }
  getTree(document2) {
    if (this.getLanguage(document2.languageId)) {
      const parser = this.parsers.get(document2.languageId);
      if (parser) {
        const tree = parser.parse(document2.getText());
        if (!tree) {
          throw new Error("Failed to parse document");
        }
        return tree;
      }
    }
    throw new Error("Language not supported");
  }
  async loadLanguage(languageId) {
    const parser = new Parser2();
    const wasmModule = getWasmModuleName(languageId);
    const filePath = pathJoin(this.wasmDirectory, `${wasmModule}.wasm`);
    const language = await Language.load(filePath);
    parser.setLanguage(language);
    this.parsers.set(languageId, parser);
    return true;
  }
  getLanguage(languageId) {
    const parser = this.parsers.get(languageId);
    return parser?.language || void 0;
  }
  getNodeAtLocation(document2, range3) {
    const tree = this.getTree(document2);
    const node = tree.rootNode.descendantForPosition(
      {
        row: range3.start.line,
        column: range3.start.character
      },
      {
        row: range3.end.line,
        column: range3.end.character
      }
    );
    if (!node) {
      throw new Error("Node not found at location");
    }
    return node;
  }
  createQuery(languageId, source) {
    const language = this.getLanguage(languageId);
    if (!language) {
      return void 0;
    }
    try {
      return new Query(language, source);
    } catch (error48) {
      console.error(`Failed to create query for language ${languageId}:`, error48);
      return void 0;
    }
  }
};

// src/ide/JetbrainsTreeSitterQueryProvider.ts
var JetbrainsTreeSitterQueryProvider = class {
  constructor(ide2) {
    this.ide = ide2;
    this.notifier = new Notifier();
    this.disposables = [];
    this.onChanges = this.notifier.registerListener;
  }
  async readQuery(filename) {
    const queryContents = await this.ide.readQuery(filename);
    return queryContents;
  }
  dispose() {
    this.disposables.forEach((disposable) => disposable.dispose());
  }
};

// src/ide/JetbrainsCommandServer.ts
var JetbrainsCommandServer = class {
  constructor(client) {
    this.signals = {
      prePhrase: {
        getVersion: async () => {
          return this.client.prePhraseVersion();
        }
      }
    };
    this.client = client;
  }
  getFocusedElementType() {
    return Promise.resolve(void 0);
  }
};

// src/extension.ts
async function activate(plugin, wasmDirectory) {
  console.log("activate started");
  await Parser2.init({
    locateFile(scriptName, _scriptDirectory) {
      const fullPath = pathJoin(wasmDirectory, scriptName);
      return fullPath;
    }
  });
  console.log("Parser initialized");
  const commandServerApi = new JetbrainsCommandServer(plugin.client);
  const queryProvider = new JetbrainsTreeSitterQueryProvider(plugin.ide);
  const engine = await createCursorlessEngine({
    ide: plugin.ide,
    hats: plugin.hats,
    treeSitterQueryProvider: queryProvider,
    treeSitter: new JetbrainsTreeSitter(wasmDirectory),
    commandServerApi
  });
  console.log("activate completed");
  return engine;
}
export {
  JetbrainsConfiguration,
  JetbrainsIDE,
  JetbrainsPlugin,
  activate,
  createIDE,
  createJetbrainsConfiguration,
  createPlugin
};
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

itertools/dist/index.js:
  (* istanbul ignore else -- @preserve *)
  (* istanbul ignore if -- @preserve *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=cursorless.js.map
