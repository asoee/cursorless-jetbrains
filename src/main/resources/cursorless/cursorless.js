var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../node_modules/.pnpm/nearley@2.20.1_patch_hash=mg2fc7wgvzub3myuz6m74hllma/node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "../../node_modules/.pnpm/nearley@2.20.1_patch_hash=mg2fc7wgvzub3myuz6m74hllma/node_modules/nearley/lib/nearley.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root2.nearley = factory();
      }
    })(exports2, function() {
      function Rule(name2, symbols2, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name2;
        this.symbols = symbols2;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " \u25CF " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " \u2192 " + symbolSequence;
      };
      function State2(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State2.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State2.prototype.nextState = function(child) {
        var state = new State2(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State2.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State2.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser3.fail);
        }
      };
      function Column(grammar2, index) {
        this.grammar = grammar2;
        this.index = index;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser3.fail) {
              var wantedBy = state.wantedBy;
              for (var i2 = wantedBy.length; i2--; ) {
                var left = wantedBy[i2];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i2 = 0; i2 < nulls.length; i2++) {
                  var right = nulls[i2];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i2 = 0; i2 < rules.length; i2++) {
          var r = rules[i2];
          var wantedBy = this.wants[exp];
          var s = new State2(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
      };
      function Grammar2(rules, start2) {
        this.rules = rules;
        this.start = start2 || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar2.fromCompiled = function(rules, start2) {
        var lexer2 = rules.Lexer;
        if (rules.ParserStart) {
          start2 = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar2(rules, start2);
        g.lexer = lexer2;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1) nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i2) {
            return pad(this.line - lines.length + i2 + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
      };
      function Parser3(rules, start2, options2) {
        if (rules instanceof Grammar2) {
          var grammar2 = rules;
          var options2 = start2;
        } else {
          var grammar2 = Grammar2.fromCompiled(rules, start2);
        }
        this.grammar = grammar2;
        this.options = {
          keepHistory: false,
          lexer: grammar2.lexer || new StreamLexer()
        };
        for (var key in options2 || {}) {
          this.options[key] = options2[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar2, 0);
        var table = this.table = [column];
        column.wants[grammar2.start] = [];
        column.predict(grammar2.start);
        column.process();
        this.current = 0;
      }
      Parser3.fail = {};
      Parser3.prototype.feed = function(chunk) {
        var lexer2 = this.lexer;
        lexer2.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer2.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err2 = new Error(this.reportLexerError(e));
            err2.offset = this.current;
            err2.token = e.token;
            throw err2;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value = lexer2.constructor === StreamLexer ? token.value : lexer2.transform?.(token) ?? token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next = state.nextState({ data: value, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err2 = new Error(this.reportError(token));
            err2.offset = this.current;
            err2.token = token;
            throw err2;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer2.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer2.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser3.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser3.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser3.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser3.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser3.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser3.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser3.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser3.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser3.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index]);
      };
      Parser3.prototype.finish = function() {
        var considerations = [];
        var start2 = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start2 && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser3.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type2 = typeof symbol;
        if (type2 === "string") {
          return symbol;
        } else if (type2 === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type2 = typeof symbol;
        if (type2 === "string") {
          return symbol;
        } else if (type2 === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser: Parser3,
        Grammar: Grammar2,
        Rule
      };
    });
  }
});

// ../../node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js
var require_moo = __commonJS({
  "../../node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root2.moo = factory();
      }
    })(exports2, function() {
      "use strict";
      var hasOwnProperty12 = Object.prototype.hasOwnProperty;
      var toString3 = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === "boolean";
      function isRegExp(o) {
        return o && toString3.call(o) === "[object RegExp]";
      }
      function isObject4(o) {
        return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
      }
      function reEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function reGroups(s) {
        var re = new RegExp("|" + s);
        return re.exec("").length - 1;
      }
      function reCapture(s) {
        return "(" + s + ")";
      }
      function reUnion(regexps) {
        if (!regexps.length) return "(?!)";
        var source = regexps.map(function(s) {
          return "(?:" + s + ")";
        }).join("|");
        return "(?:" + source + ")";
      }
      function regexpOrLiteral(obj) {
        if (typeof obj === "string") {
          return "(?:" + reEscape(obj) + ")";
        } else if (isRegExp(obj)) {
          if (obj.ignoreCase) throw new Error("RegExp /i flag not allowed");
          if (obj.global) throw new Error("RegExp /g flag is implied");
          if (obj.sticky) throw new Error("RegExp /y flag is implied");
          if (obj.multiline) throw new Error("RegExp /m flag is implied");
          return obj.source;
        } else {
          throw new Error("Not a pattern: " + obj);
        }
      }
      function pad(s, length) {
        if (s.length > length) {
          return s;
        }
        return Array(length - s.length + 1).join(" ") + s;
      }
      function lastNLines(string2, numLines) {
        var position = string2.length;
        var lineBreaks = 0;
        while (true) {
          var idx = string2.lastIndexOf("\n", position - 1);
          if (idx === -1) {
            break;
          } else {
            lineBreaks++;
          }
          position = idx;
          if (lineBreaks === numLines) {
            break;
          }
          if (position === 0) {
            break;
          }
        }
        var startPosition = lineBreaks < numLines ? 0 : position + 1;
        return string2.substring(startPosition).split("\n");
      }
      function objectToRules(object) {
        var keys2 = Object.getOwnPropertyNames(object);
        var result = [];
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          var thing = object[key];
          var rules = [].concat(thing);
          if (key === "include") {
            for (var j = 0; j < rules.length; j++) {
              result.push({ include: rules[j] });
            }
            continue;
          }
          var match = [];
          rules.forEach(function(rule) {
            if (isObject4(rule)) {
              if (match.length) result.push(ruleOptions(key, match));
              result.push(ruleOptions(key, rule));
              match = [];
            } else {
              match.push(rule);
            }
          });
          if (match.length) result.push(ruleOptions(key, match));
        }
        return result;
      }
      function arrayToRules(array) {
        var result = [];
        for (var i2 = 0; i2 < array.length; i2++) {
          var obj = array[i2];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j = 0; j < include.length; j++) {
              result.push({ include: include[j] });
            }
            continue;
          }
          if (!obj.type) {
            throw new Error("Rule has no type: " + JSON.stringify(obj));
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result;
      }
      function ruleOptions(type2, obj) {
        if (!isObject4(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error("Matching rules cannot also include states");
        }
        var options2 = {
          defaultType: type2,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false
        };
        for (var key in obj) {
          if (hasOwnProperty12.call(obj, key)) {
            options2[key] = obj[key];
          }
        }
        if (typeof options2.type === "string" && type2 !== options2.type) {
          throw new Error("Type transform cannot be a string (type '" + options2.type + "' for token '" + type2 + "')");
        }
        var match = options2.match;
        options2.match = Array.isArray(match) ? match : match ? [match] : [];
        options2.match.sort(function(a, b) {
          return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? 1 : b.length - a.length;
        });
        return options2;
      }
      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
      }
      var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = /* @__PURE__ */ Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts2 = [];
        for (var i2 = 0; i2 < rules.length; i2++) {
          if (rules[i2].fallback) {
            fastAllowed = false;
          }
        }
        for (var i2 = 0; i2 < rules.length; i2++) {
          var options2 = rules[i2];
          if (options2.include) {
            throw new Error("Inheritance is not allowed in stateless lexers");
          }
          if (options2.error || options2.fallback) {
            if (errorRule) {
              if (!options2.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options2.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options2.defaultType + "')");
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options2.defaultType + "')");
              }
            }
            errorRule = options2;
          }
          var match = options2.match.slice();
          if (fastAllowed) {
            while (match.length && typeof match[0] === "string" && match[0].length === 1) {
              var word = match.shift();
              fast[word.charCodeAt(0)] = options2;
            }
          }
          if (options2.pop || options2.push || options2.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options2.defaultType + "')");
            }
            if (options2.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options2.defaultType + "')");
            }
          }
          if (match.length === 0) {
            continue;
          }
          fastAllowed = false;
          groups.push(options2);
          for (var j = 0; j < match.length; j++) {
            var obj = match[j];
            if (!isRegExp(obj)) {
              continue;
            }
            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options2.fallback === false) {
              throw new Error("If one rule is /u then all must be");
            }
          }
          var pat = reUnion(match.map(regexpOrLiteral));
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
          }
          if (!options2.lineBreaks && regexp.test("\n")) {
            throw new Error("Rule should declare lineBreaks: " + regexp);
          }
          parts2.push(reCapture(pat));
        }
        var fallbackRule = errorRule && errorRule.fallback;
        var flags2 = hasSticky && !fallbackRule ? "ym" : "gm";
        var suffix = hasSticky || fallbackRule ? "" : "|";
        if (unicodeFlag === true) flags2 += "u";
        var combined = new RegExp(reUnion(parts2) + suffix, flags2);
        return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
      }
      function compile(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({ start: result }, "start");
      }
      function checkStateGroup(g, name2, map3) {
        var state = g && (g.push || g.next);
        if (state && !map3[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name2 + "')");
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name2 + "')");
        }
      }
      function compileStates(states, start2) {
        var all = states.$all ? toRules(states.$all) : [];
        delete states.$all;
        var keys2 = Object.getOwnPropertyNames(states);
        if (!start2) start2 = keys2[0];
        var ruleMap = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          ruleMap[key] = toRules(states[key]).concat(all);
        }
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          var rules = ruleMap[key];
          var included = /* @__PURE__ */ Object.create(null);
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (!rule.include) continue;
            var splice3 = [j, 1];
            if (rule.include !== key && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
              }
              for (var k = 0; k < newRules.length; k++) {
                var newRule = newRules[k];
                if (rules.indexOf(newRule) !== -1) continue;
                splice3.push(newRule);
              }
            }
            rules.splice.apply(rules, splice3);
            j--;
          }
        }
        var map3 = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          map3[key] = compileRules(ruleMap[key], true);
        }
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var name2 = keys2[i2];
          var state = map3[name2];
          var groups = state.groups;
          for (var j = 0; j < groups.length; j++) {
            checkStateGroup(groups[j], name2, map3);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j = 0; j < fastKeys.length; j++) {
            checkStateGroup(state.fast[fastKeys[j]], name2, map3);
          }
        }
        return new Lexer(map3, start2);
      }
      function keywordTransform(map3) {
        var isMap2 = typeof Map !== "undefined";
        var reverseMap = isMap2 ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        var types = Object.getOwnPropertyNames(map3);
        for (var i2 = 0; i2 < types.length; i2++) {
          var tokenType = types[i2];
          var item = map3[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            if (typeof keyword !== "string") {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            if (isMap2) {
              reverseMap.set(keyword, tokenType);
            } else {
              reverseMap[keyword] = tokenType;
            }
          });
        }
        return function(k) {
          return isMap2 ? reverseMap.get(k) : reverseMap[k];
        };
      }
      var Lexer = function(states, state) {
        this.startState = state;
        this.states = states;
        this.buffer = "";
        this.stack = [];
        this.reset();
      };
      Lexer.prototype.reset = function(data, info2) {
        this.buffer = data || "";
        this.index = 0;
        this.line = info2 ? info2.line : 1;
        this.col = info2 ? info2.col : 1;
        this.queuedToken = info2 ? info2.queuedToken : null;
        this.queuedText = info2 ? info2.queuedText : "";
        this.queuedThrow = info2 ? info2.queuedThrow : null;
        this.setState(info2 ? info2.state : this.startState);
        this.stack = info2 && info2.stack ? info2.stack.slice() : [];
        return this;
      };
      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedText: this.queuedText,
          queuedThrow: this.queuedThrow
        };
      };
      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state) return;
        this.state = state;
        var info2 = this.states[state];
        this.groups = info2.groups;
        this.error = info2.error;
        this.re = info2.regexp;
        this.fast = info2.fast;
      };
      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };
      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };
      var eat = hasSticky ? function(re, buffer) {
        return re.exec(buffer);
      } : function(re, buffer) {
        var match = re.exec(buffer);
        if (match[0].length === 0) {
          return null;
        }
        return match;
      };
      Lexer.prototype._getGroup = function(match) {
        var groupCount = this.groups.length;
        for (var i2 = 0; i2 < groupCount; i2++) {
          if (match[i2 + 1] !== void 0) {
            return this.groups[i2];
          }
        }
        throw new Error("Cannot find token type for matched text");
      };
      function tokenToString() {
        return this.value;
      }
      Lexer.prototype.next = function() {
        var index = this.index;
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index);
          this.queuedGroup = null;
          this.queuedText = "";
          return token;
        }
        var buffer = this.buffer;
        if (index === buffer.length) {
          return;
        }
        var group = this.fast[buffer.charCodeAt(index)];
        if (group) {
          return this._token(group, buffer.charAt(index), index);
        }
        var re = this.re;
        re.lastIndex = index;
        var match = eat(re, buffer);
        var error = this.error;
        if (match == null) {
          return this._token(error, buffer.slice(index, buffer.length), index);
        }
        var group = this._getGroup(match);
        var text = match[0];
        if (error.fallback && match.index !== index) {
          this.queuedGroup = group;
          this.queuedText = text;
          return this._token(error, buffer.slice(index, match.index), index);
        }
        return this._token(group, text, index);
      };
      Lexer.prototype._token = function(group, text, offset) {
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl = 1;
          if (text === "\n") {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) {
              lineBreaks++;
              nl = matchNL.lastIndex;
            }
          }
        }
        var token = {
          type: typeof group.type === "function" && group.type(text) || group.defaultType,
          value: typeof group.value === "function" ? group.value(text) : text,
          text,
          toString: tokenToString,
          offset,
          lineBreaks,
          line: this.line,
          col: this.col
        };
        var size = text.length;
        this.index += size;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size - nl + 1;
        } else {
          this.col += size;
        }
        if (group.shouldThrow) {
          var err2 = new Error(this.formatError(token, "invalid syntax"));
          throw err2;
        }
        if (group.pop) this.popState();
        else if (group.push) this.pushState(group.push);
        else if (group.next) this.setState(group.next);
        return token;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var LexerIterator = function(lexer2) {
          this.lexer = lexer2;
        };
        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return { value: token, done: !token };
        };
        LexerIterator.prototype[Symbol.iterator] = function() {
          return this;
        };
        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this);
        };
      }
      Lexer.prototype.formatError = function(token, message) {
        if (token == null) {
          var text = this.buffer.slice(this.index);
          var token = {
            text,
            offset: this.index,
            lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
            line: this.line,
            col: this.col
          };
        }
        var numLinesAround = 2;
        var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
        var lastDisplayedLine = token.line + numLinesAround;
        var lastLineDigits = String(lastDisplayedLine).length;
        var displayedLines = lastNLines(
          this.buffer,
          this.line - token.line + numLinesAround + 1
        ).slice(0, 5);
        var errorLines = [];
        errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
        errorLines.push("");
        for (var i2 = 0; i2 < displayedLines.length; i2++) {
          var line = displayedLines[i2];
          var lineNo = firstDisplayedLine + i2;
          errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
          if (lineNo === token.line) {
            errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
          }
        }
        return errorLines.join("\n");
      };
      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state);
      };
      Lexer.prototype.has = function(tokenType) {
        return true;
      };
      return {
        compile,
        states: compileStates,
        error: Object.freeze({ error: true }),
        fallback: Object.freeze({ fallback: true }),
        keywords: keywordTransform
      };
    });
  }
});

// ../../node_modules/.pnpm/immutability-helper@3.1.1/node_modules/immutability-helper/index.js
var require_immutability_helper = __commonJS({
  "../../node_modules/.pnpm/immutability-helper@3.1.1/node_modules/immutability-helper/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function stringifiable(obj) {
      return typeof obj === "object" && !("toString" in obj) ? Object.prototype.toString.call(obj).slice(8, -1) : obj;
    }
    var isProduction = typeof process === "object" && process.env.NODE_ENV === "production";
    function invariant4(condition, message) {
      if (!condition) {
        if (isProduction) {
          throw new Error("Invariant failed");
        }
        throw new Error(message());
      }
    }
    exports2.invariant = invariant4;
    var hasOwnProperty12 = Object.prototype.hasOwnProperty;
    var splice3 = Array.prototype.splice;
    var toString3 = Object.prototype.toString;
    function type2(obj) {
      return toString3.call(obj).slice(8, -1);
    }
    var assign = Object.assign || /* istanbul ignore next */
    function(target, source) {
      getAllKeys2(source).forEach(function(key) {
        if (hasOwnProperty12.call(source, key)) {
          target[key] = source[key];
        }
      });
      return target;
    };
    var getAllKeys2 = typeof Object.getOwnPropertySymbols === "function" ? function(obj) {
      return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
    } : function(obj) {
      return Object.keys(obj);
    };
    function copy(object) {
      return Array.isArray(object) ? assign(object.constructor(object.length), object) : type2(object) === "Map" ? new Map(object) : type2(object) === "Set" ? new Set(object) : object && typeof object === "object" ? assign(Object.create(Object.getPrototypeOf(object)), object) : object;
    }
    var Context = (
      /** @class */
      function() {
        function Context2() {
          this.commands = assign({}, defaultCommands);
          this.update = this.update.bind(this);
          this.update.extend = this.extend = this.extend.bind(this);
          this.update.isEquals = function(x, y) {
            return x === y;
          };
          this.update.newContext = function() {
            return new Context2().update;
          };
        }
        Object.defineProperty(Context2.prototype, "isEquals", {
          get: function() {
            return this.update.isEquals;
          },
          set: function(value) {
            this.update.isEquals = value;
          },
          enumerable: true,
          configurable: true
        });
        Context2.prototype.extend = function(directive, fn) {
          this.commands[directive] = fn;
        };
        Context2.prototype.update = function(object, $spec) {
          var _this = this;
          var spec = typeof $spec === "function" ? { $apply: $spec } : $spec;
          if (!(Array.isArray(object) && Array.isArray(spec))) {
            invariant4(!Array.isArray(spec), function() {
              return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
            });
          }
          invariant4(typeof spec === "object" && spec !== null, function() {
            return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(_this.commands).join(", ") + ".");
          });
          var nextObject = object;
          getAllKeys2(spec).forEach(function(key) {
            if (hasOwnProperty12.call(_this.commands, key)) {
              var objectWasNextObject = object === nextObject;
              nextObject = _this.commands[key](spec[key], nextObject, spec, object);
              if (objectWasNextObject && _this.isEquals(nextObject, object)) {
                nextObject = object;
              }
            } else {
              var nextValueForKey = type2(object) === "Map" ? _this.update(object.get(key), spec[key]) : _this.update(object[key], spec[key]);
              var nextObjectValue = type2(nextObject) === "Map" ? nextObject.get(key) : nextObject[key];
              if (!_this.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === "undefined" && !hasOwnProperty12.call(object, key)) {
                if (nextObject === object) {
                  nextObject = copy(object);
                }
                if (type2(nextObject) === "Map") {
                  nextObject.set(key, nextValueForKey);
                } else {
                  nextObject[key] = nextValueForKey;
                }
              }
            }
          });
          return nextObject;
        };
        return Context2;
      }()
    );
    exports2.Context = Context;
    var defaultCommands = {
      $push: function(value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, "$push");
        return value.length ? nextObject.concat(value) : nextObject;
      },
      $unshift: function(value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, "$unshift");
        return value.length ? value.concat(nextObject) : nextObject;
      },
      $splice: function(value, nextObject, spec, originalObject) {
        invariantSplices(nextObject, spec);
        value.forEach(function(args2) {
          invariantSplice(args2);
          if (nextObject === originalObject && args2.length) {
            nextObject = copy(originalObject);
          }
          splice3.apply(nextObject, args2);
        });
        return nextObject;
      },
      $set: function(value, _nextObject, spec) {
        invariantSet(spec);
        return value;
      },
      $toggle: function(targets, nextObject) {
        invariantSpecArray(targets, "$toggle");
        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;
        targets.forEach(function(target) {
          nextObjectCopy[target] = !nextObject[target];
        });
        return nextObjectCopy;
      },
      $unset: function(value, nextObject, _spec, originalObject) {
        invariantSpecArray(value, "$unset");
        value.forEach(function(key) {
          if (Object.hasOwnProperty.call(nextObject, key)) {
            if (nextObject === originalObject) {
              nextObject = copy(originalObject);
            }
            delete nextObject[key];
          }
        });
        return nextObject;
      },
      $add: function(values2, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, "$add");
        invariantSpecArray(values2, "$add");
        if (type2(nextObject) === "Map") {
          values2.forEach(function(_a9) {
            var key = _a9[0], value = _a9[1];
            if (nextObject === originalObject && nextObject.get(key) !== value) {
              nextObject = copy(originalObject);
            }
            nextObject.set(key, value);
          });
        } else {
          values2.forEach(function(value) {
            if (nextObject === originalObject && !nextObject.has(value)) {
              nextObject = copy(originalObject);
            }
            nextObject.add(value);
          });
        }
        return nextObject;
      },
      $remove: function(value, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, "$remove");
        invariantSpecArray(value, "$remove");
        value.forEach(function(key) {
          if (nextObject === originalObject && nextObject.has(key)) {
            nextObject = copy(originalObject);
          }
          nextObject.delete(key);
        });
        return nextObject;
      },
      $merge: function(value, nextObject, _spec, originalObject) {
        invariantMerge(nextObject, value);
        getAllKeys2(value).forEach(function(key) {
          if (value[key] !== nextObject[key]) {
            if (nextObject === originalObject) {
              nextObject = copy(originalObject);
            }
            nextObject[key] = value[key];
          }
        });
        return nextObject;
      },
      $apply: function(value, original) {
        invariantApply(value);
        return value(original);
      }
    };
    var defaultContext = new Context();
    exports2.isEquals = defaultContext.update.isEquals;
    exports2.extend = defaultContext.extend;
    exports2.default = defaultContext.update;
    exports2.default.default = module2.exports = assign(exports2.default, exports2);
    function invariantPushAndUnshift(value, spec, command) {
      invariant4(Array.isArray(value), function() {
        return "update(): expected target of " + stringifiable(command) + " to be an array; got " + stringifiable(value) + ".";
      });
      invariantSpecArray(spec[command], command);
    }
    function invariantSpecArray(spec, command) {
      invariant4(Array.isArray(spec), function() {
        return "update(): expected spec of " + stringifiable(command) + " to be an array; got " + stringifiable(spec) + ". Did you forget to wrap your parameter in an array?";
      });
    }
    function invariantSplices(value, spec) {
      invariant4(Array.isArray(value), function() {
        return "Expected $splice target to be an array; got " + stringifiable(value);
      });
      invariantSplice(spec.$splice);
    }
    function invariantSplice(value) {
      invariant4(Array.isArray(value), function() {
        return "update(): expected spec of $splice to be an array of arrays; got " + stringifiable(value) + ". Did you forget to wrap your parameters in an array?";
      });
    }
    function invariantApply(fn) {
      invariant4(typeof fn === "function", function() {
        return "update(): expected spec of $apply to be a function; got " + stringifiable(fn) + ".";
      });
    }
    function invariantSet(spec) {
      invariant4(Object.keys(spec).length === 1, function() {
        return "Cannot have more than one key in an object with $set";
      });
    }
    function invariantMerge(target, specValue) {
      invariant4(specValue && typeof specValue === "object", function() {
        return "update(): $merge expects a spec of type 'object'; got " + stringifiable(specValue);
      });
      invariant4(target && typeof target === "object", function() {
        return "update(): $merge expects a target of type 'object'; got " + stringifiable(target);
      });
    }
    function invariantMapOrSet(target, command) {
      var typeOfTarget = type2(target);
      invariant4(typeOfTarget === "Map" || typeOfTarget === "Set", function() {
        return "update(): " + stringifiable(command) + " expects a target of type Set or Map; got " + stringifiable(typeOfTarget);
      });
    }
  }
});

// ../common/src/cursorlessCommandIds.ts
var Command = class {
  constructor(baseTitle) {
    this.baseTitle = baseTitle;
  }
  get title() {
    return `Cursorless: ${this.baseTitle}`;
  }
};
var HiddenCommand = class extends Command {
  constructor() {
    super(...arguments);
    this.isVisible = false;
  }
};
var VisibleCommand = class extends Command {
  constructor() {
    super(...arguments);
    this.isVisible = true;
  }
};
var cursorlessCommandDescriptions = {
  ["cursorless.toggleDecorations"]: new VisibleCommand("Toggle decorations"),
  ["cursorless.recomputeDecorationStyles"]: new VisibleCommand(
    "Recompute decoration styles"
  ),
  ["cursorless.recordTestCase"]: new VisibleCommand("Record test case"),
  ["cursorless.recordOneTestCaseThenPause"]: new VisibleCommand(
    "Record one test case, then pause"
  ),
  ["cursorless.pauseRecording"]: new VisibleCommand(
    "Pause test case recording"
  ),
  ["cursorless.resumeRecording"]: new VisibleCommand(
    "Resume test case recording"
  ),
  ["cursorless.recordScopeTests.showUnimplementedFacets"]: new VisibleCommand(
    "Bulk record unimplemented scope facets"
  ),
  ["cursorless.recordScopeTests.saveActiveDocument"]: new VisibleCommand(
    "Bulk save scope tests for the active document"
  ),
  ["cursorless.showDocumentation"]: new VisibleCommand("Show documentation"),
  ["cursorless.showInstallationDependencies"]: new VisibleCommand(
    "Show installation dependencies"
  ),
  ["cursorless.showScopeVisualizer"]: new VisibleCommand(
    "Show the scope visualizer"
  ),
  ["cursorless.hideScopeVisualizer"]: new VisibleCommand(
    "Hide the scope visualizer"
  ),
  ["cursorless.analyzeCommandHistory"]: new VisibleCommand(
    "Analyze collected command history"
  ),
  ["cursorless.tutorial.start"]: new HiddenCommand("Start a tutorial"),
  ["cursorless.tutorial.next"]: new VisibleCommand("Tutorial next"),
  ["cursorless.tutorial.previous"]: new VisibleCommand("Tutorial previous"),
  ["cursorless.tutorial.restart"]: new VisibleCommand("Tutorial restart"),
  ["cursorless.tutorial.resume"]: new VisibleCommand("Tutorial resume"),
  ["cursorless.tutorial.list"]: new VisibleCommand("Tutorial list"),
  ["cursorless.documentationOpened"]: new HiddenCommand(
    "Used by talon to notify us that the docs have been opened; for use with tutorial"
  ),
  ["cursorless.command"]: new HiddenCommand("The core cursorless command"),
  ["cursorless.repeatPreviousCommand"]: new VisibleCommand(
    "Repeat the previous Cursorless command"
  ),
  ["cursorless.showQuickPick"]: new HiddenCommand(
    "Pop up a quick pick of all cursorless commands"
  ),
  ["cursorless.showCheatsheet"]: new HiddenCommand(
    "Display the cursorless cheatsheet"
  ),
  ["cursorless.internal.updateCheatsheetDefaults"]: new HiddenCommand(
    "Update the default values of the cheatsheet payload used on the website and for local development. Be sure to run this on stock community and cursorless."
  ),
  ["cursorless.private.logQuickActions"]: new HiddenCommand(
    "Log the quick actions available at the current cursor position"
  ),
  ["cursorless.takeSnapshot"]: new HiddenCommand(
    "Take a snapshot of the current editor state"
  ),
  ["cursorless.keyboard.escape"]: new HiddenCommand(
    "Should be mapped to the escape key when using cursorless keyboard. By default, exits modal keyboard mode, but changes behaviour when Cursorless is expecting a continuation keystroke.  For example, when you type a color and Cursorless is waiting for a character, it cancels the color and switches back to modal mode."
  ),
  ["cursorless.keyboard.targeted.targetHat"]: new HiddenCommand(
    "Sets the keyboard target to the given hat"
  ),
  ["cursorless.keyboard.targeted.targetScope"]: new HiddenCommand(
    "Sets the keyboard target to the scope containing the current target"
  ),
  ["cursorless.keyboard.targeted.targetSelection"]: new HiddenCommand(
    "Sets the keyboard target to the current selection"
  ),
  ["cursorless.keyboard.targeted.clearTarget"]: new HiddenCommand(
    "Clears the current keyboard target"
  ),
  ["cursorless.keyboard.targeted.runActionOnTarget"]: new HiddenCommand(
    "Run the given action on the current keyboard target"
  ),
  ["cursorless.keyboard.modal.modeOn"]: new HiddenCommand(
    "Turn on the cursorless modal mode"
  ),
  ["cursorless.keyboard.modal.modeOff"]: new HiddenCommand(
    "Turn off the cursorless modal mode"
  ),
  ["cursorless.keyboard.modal.modeToggle"]: new HiddenCommand(
    "Toggle the cursorless modal mode"
  ),
  ["cursorless.keyboard.undoTarget"]: new HiddenCommand(
    "Undo keyboard targeting changes"
  ),
  ["cursorless.keyboard.redoTarget"]: new HiddenCommand(
    "Redo keyboard targeting changes"
  ),
  ["cursorless.migrateSnippets"]: new HiddenCommand(
    "Migrate snippets from the old Cursorless format to the new community format"
  )
};

// ../common/src/Debouncer.ts
var Debouncer = class {
  constructor(callback2, debounceDelayMs) {
    this.callback = callback2;
    this.debounceDelayMs = debounceDelayMs;
    this.timeoutHandle = null;
    this.run = this.run.bind(this);
  }
  run() {
    if (this.timeoutHandle != null) {
      clearTimeout(this.timeoutHandle);
    }
    this.timeoutHandle = setTimeout(() => {
      this.callback();
      this.timeoutHandle = null;
    }, this.debounceDelayMs);
  }
  dispose() {
    if (this.timeoutHandle != null) {
      clearTimeout(this.timeoutHandle);
    }
  }
};

// ../common/src/errors.ts
var OutdatedExtensionError = class extends Error {
  constructor() {
    super(
      "Cursorless Talon version is ahead of Cursorless VSCode extension version. Please update Cursorless VSCode."
    );
  }
};
var NoContainingScopeError = class extends Error {
  /**
   *
   * @param scopeType The scopeType for the failed match to show to the user
   */
  constructor(scopeType) {
    super(`Couldn't find containing ${scopeType}.`);
    this.name = "NoContainingScopeError";
  }
};

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
  var index = string2.length;
  while (index-- && reWhitespace.test(string2.charAt(index))) {
  }
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_default = isObject;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary2 = reIsBinary.test(value);
  return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result = toFinite_default(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_default = toInteger;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func2) {
  return !!maskSrcKey && maskSrcKey in func2;
}
var isMasked_default = isMasked;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func2) {
  if (func2 != null) {
    try {
      return funcToString.call(func2);
    } catch (e) {
    }
    try {
      return func2 + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js
function getValue2(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_apply.js
function apply(func2, thisArg, args2) {
  switch (args2.length) {
    case 0:
      return func2.call(thisArg);
    case 1:
      return func2.call(thisArg, args2[0]);
    case 2:
      return func2.call(thisArg, args2[0], args2[1]);
    case 3:
      return func2.call(thisArg, args2[0], args2[1], args2[2]);
  }
  return func2.apply(thisArg, args2);
}
var apply_default = apply;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/noop.js
function noop() {
}
var noop_default = noop;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getData.js
var getData = !metaMap_default ? noop_default : function(func2) {
  return metaMap_default.get(func2);
};
var getData_default = getData;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getFuncName.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function getFuncName(func2) {
  var result = func2.name + "", array = realNames_default[result], length = hasOwnProperty3.call(realNames_default, result) ? array.length : 0;
  while (length--) {
    var data = array[length], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func2) {
      return data.name;
    }
  }
  return result;
}
var getFuncName_default = getFuncName;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray_default(wrapper.__actions__);
  result.__index__ = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}
var wrapperClone_default = wrapperClone;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/wrapperLodash.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function lodash(value) {
  if (isObjectLike_default(value) && !isArray_default(value) && !(value instanceof LazyWrapper_default)) {
    if (value instanceof LodashWrapper_default) {
      return value;
    }
    if (hasOwnProperty4.call(value, "__wrapped__")) {
      return wrapperClone_default(value);
    }
  }
  return new LodashWrapper_default(value);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isLaziable.js
function isLaziable(func2) {
  var funcName = getFuncName_default(func2), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func2 === other) {
    return true;
  }
  var data = getData_default(other);
  return !!data && func2 === data[0];
}
var isLaziable_default = isLaziable;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func2) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func2.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func2 = getNative_default(Object, "defineProperty");
    func2({}, "", {});
    return func2;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func2, string2) {
  return defineProperty_default(func2, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string2),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf_default(array, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func2, start2, transform) {
  start2 = nativeMax(start2 === void 0 ? func2.length - 1 : start2, 0);
  return function() {
    var args2 = arguments, index = -1, length = nativeMax(args2.length - start2, 0), array = Array(length);
    while (++index < length) {
      array[index] = args2[start2 + index];
    }
    index = -1;
    var otherArgs = Array(start2 + 1);
    while (++index < start2) {
      otherArgs[index] = args2[index];
    }
    otherArgs[start2] = transform(array);
    return apply_default(func2, this, otherArgs);
  };
}
var overRest_default = overRest;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRest.js
function baseRest(func2, start2) {
  return setToString_default(overRest_default(func2, start2, identity_default), func2 + "");
}
var baseRest_default = baseRest;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type2 = typeof index;
  if (type2 == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type2 == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js
var objectProto6 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto6;
  return value === proto;
}
var isPrototype_default = isPrototype;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
var propertyIsEnumerable = objectProto7.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty5.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports2 ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js
function baseUnary(func2) {
  return function(value) {
    return func2(value);
  };
}
var baseUnary_default = baseUnary;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports3 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayLikeKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty6.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js
function overArg(func2, transform) {
  return function(arg) {
    return func2(transform(arg));
  };
}
var overArg_default = overArg;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeys.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty7.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty8.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
}
var hashHas_default = hashHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMapData.js
function getMapData(map3, key) {
  var data = map3.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func2, resolver) {
  if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func2.apply(this, args2);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func2) {
  var result = memoize_default(func2, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
}
var toKey_default = toKey;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values2) {
  var index = -1, length = values2.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values2[index];
  }
  return array;
}
var arrayPush_default = arrayPush;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable_default);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush_default(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var baseFlatten_default = baseFlatten;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatten.js
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, 1) : [];
}
var flatten_default = flatten;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_flatRest.js
function flatRest(func2) {
  return setToString_default(overRest_default(func2, void 0, flatten_default), func2 + "");
}
var flatRest_default = flatRest;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  "\xC6": "Ae",
  "\xE6": "ae",
  "\xDE": "Th",
  "\xFE": "th",
  "\xDF": "ss",
  // Latin Extended-A block.
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0152": "Oe",
  "\u0153": "oe",
  "\u0149": "'n",
  "\u017F": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsCombo = "[" + rsComboRange + "]";
var reComboMark = RegExp(rsCombo, "g");
function deburr(string2) {
  string2 = toString_default(string2);
  return string2 && string2.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs2 = data.__data__;
    if (!Map_default || pairs2.length < LARGE_ARRAY_SIZE - 1) {
      pairs2.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs2);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbols.js
var objectProto12 = Object.prototype;
var propertyIsEnumerable2 = objectProto12.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/concat.js
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args2 = Array(length - 1), array = arguments[0], index = length;
  while (index--) {
    args2[index - 1] = arguments[index];
  }
  return arrayPush_default(isArray_default(array) ? copyArray_default(array) : [array], baseFlatten_default(args2, 1));
}
var concat_default = concat;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values2[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
var cacheHas_default = cacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var equalArrays_default = equalArrays;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapToArray.js
function mapToArray(map3) {
  var index = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToArray.js
function setToArray(set3) {
  var index = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq_default(+object, +other);
    case errorTag2:
      return object.name == other.name && object.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object == other + "";
    case mapTag3:
      var convert = mapToArray_default;
    case setTag3:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag2:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto13 = Object.prototype;
var hasOwnProperty10 = objectProto13.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty10.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var equalObjects_default = equalObjects;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag3 = "[object Object]";
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
  objTag = objTag == argsTag3 ? objectTag3 : objTag;
  othTag = othTag == argsTag3 ? objectTag3 : othTag;
  var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty11.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty11.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default = getMatchData;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey_default(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array, value, comparator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/last.js
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_default = last;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string2) {
  string2 = toString_default(string2);
  return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar2, "\\$&") : string2;
}
var escapeRegExp_default = escapeRegExp;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/findLastIndex.js
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = fromIndex < 0 ? nativeMax2(length + index, 0) : nativeMin(index, length - 1);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index, true);
}
var findLastIndex_default = findLastIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee) {
  var index = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index] = iteratee(value, key, collection2);
  });
  return result;
}
var baseMap_default = baseMap;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_CURRY_FLAG = 8;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length = funcs.length, index = length, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func2 = funcs[index];
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT2);
      }
      if (prereq && !wrapper && getFuncName_default(func2) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func2 = funcs[index];
      var funcName = getFuncName_default(func2), data = funcName == "wrapper" ? getData_default(func2) : void 0;
      if (data && isLaziable_default(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName_default(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func2.length == 1 && isLaziable_default(func2) ? wrapper[funcName]() : wrapper.thru(func2);
      }
    }
    return function() {
      var args2 = arguments, value = args2[0];
      if (wrapper && args2.length == 1 && isArray_default(value)) {
        return wrapper.plant(value).value();
      }
      var index2 = 0, result = length ? funcs[index2].apply(this, args2) : value;
      while (++index2 < length) {
        result = funcs[index2].call(this, result);
      }
      return result;
    };
  });
}
var createFlow_default = createFlow;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flow.js
var flow = createFlow_default();
var flow_default = flow;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default = values;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default = isEqual;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseLt.js
function baseLt(value, other) {
  return value < other;
}
var baseLt_default = baseLt;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array, iteratee, comparator) {
  var index = -1, length = array.length;
  while (++index < length) {
    var value = array[index], current2 = iteratee(value);
    if (current2 != null && (computed === void 0 ? current2 === current2 && !isSymbol_default(current2) : comparator(current2, computed))) {
      var computed = current2, result = value;
    }
  }
  return result;
}
var baseExtremum_default = baseExtremum;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSum.js
function baseSum(array, iteratee) {
  var result, index = -1, length = array.length;
  while (++index < length) {
    var current2 = iteratee(array[index]);
    if (current2 !== void 0) {
      result = result === void 0 ? current2 : result + current2;
    }
  }
  return result;
}
var baseSum_default = baseSum;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/min.js
function min(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseLt_default) : void 0;
}
var min_default = min;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}
var baseSortBy_default = baseSortBy;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_compareAscending.js
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index < length) {
    var result = compareAscending_default(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var compareMultiple_default = compareMultiple;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee) {
      if (isArray_default(iteratee)) {
        return function(value) {
          return baseGet_default(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity_default];
  }
  var index = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index, "value": value };
  });
  return baseSortBy_default(result, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string2, n) {
  var result = "";
  if (!string2 || n < 1 || n > MAX_SAFE_INTEGER3) {
    return result;
  }
  do {
    if (n % 2) {
      result += string2;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string2 += string2;
    }
  } while (n);
  return result;
}
var baseRepeat_default = baseRepeat;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePullAll.js
var arrayProto2 = Array.prototype;
var splice2 = arrayProto2.splice;
function basePullAll(array, values2, iteratee, comparator) {
  var indexOf = comparator ? baseIndexOfWith_default : baseIndexOf_default, index = -1, length = values2.length, seen = array;
  if (array === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee) {
    seen = arrayMap_default(array, baseUnary_default(iteratee));
  }
  while (++index < length) {
    var fromIndex = 0, value = values2[index], computed = iteratee ? iteratee(value) : value;
    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice2.call(seen, fromIndex, 1);
      }
      splice2.call(array, fromIndex, 1);
    }
  }
  return array;
}
var basePullAll_default = basePullAll;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pullAll.js
function pullAll(array, values2) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2) : array;
}
var pullAll_default = pullAll;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default = pull;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRandom.js
var nativeFloor2 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor2(nativeRandom() * (upper - lower + 1));
}
var baseRandom_default = baseRandom;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRange.js
var nativeCeil = Math.ceil;
var nativeMax3 = Math.max;
function baseRange(start2, end, step, fromRight) {
  var index = -1, length = nativeMax3(nativeCeil((end - start2) / (step || 1)), 0), result = Array(length);
  while (length--) {
    result[fromRight ? length : ++index] = start2;
    start2 += step;
  }
  return result;
}
var baseRange_default = baseRange;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start2, end, step) {
    if (step && typeof step != "number" && isIterateeCall_default(start2, end, step)) {
      end = step = void 0;
    }
    start2 = toFinite_default(start2);
    if (end === void 0) {
      end = start2;
      start2 = 0;
    } else {
      end = toFinite_default(end);
    }
    step = step === void 0 ? start2 < end ? 1 : -1 : toFinite_default(step);
    return baseRange_default(start2, end, step, fromRight);
  };
}
var createRange_default = createRange;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/range.js
var range = createRange_default();
var range_default = range;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/repeat.js
function repeat(string2, n, guard) {
  if (guard ? isIterateeCall_default(string2, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  return baseRepeat_default(toString_default(string2), n);
}
var repeat_default = repeat;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array, size) {
  var index = -1, length = array.length, lastIndex = length - 1;
  size = size === void 0 ? length : size;
  while (++index < size) {
    var rand = baseRandom_default(index, lastIndex), value = array[rand];
    array[rand] = array[index];
    array[index] = value;
  }
  array.length = size;
  return array;
}
var shuffleSelf_default = shuffleSelf;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array) {
  return shuffleSelf_default(copyArray_default(array));
}
var arrayShuffle_default = arrayShuffle;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default(collection));
}
var baseShuffle_default = baseShuffle;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/shuffle.js
function shuffle(collection) {
  var func2 = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func2(collection);
}
var shuffle_default = shuffle;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sumBy.js
function sumBy(array, iteratee) {
  return array && array.length ? baseSum_default(array, baseIteratee_default(iteratee, 2)) : 0;
}
var sumBy_default = sumBy;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createSet.js
var INFINITY4 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values2) {
  return new Set_default(values2);
};
var createSet_default = createSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE2 = 200;
function baseUniq(array, iteratee, comparator) {
  var index = -1, includes = arrayIncludes_default, length = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE2) {
    var set3 = iteratee ? null : createSet_default(array);
    if (set3) {
      return setToArray_default(set3);
    }
    isCommon = false;
    includes = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var baseUniq_default = baseUniq;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniq.js
function uniq(array) {
  return array && array.length ? baseUniq_default(array) : [];
}
var uniq_default = uniq;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqWith.js
function uniqWith(array, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array && array.length ? baseUniq_default(array, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unzip.js
var nativeMax4 = Math.max;
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = arrayFilter_default(array, function(group) {
    if (isArrayLikeObject_default(group)) {
      length = nativeMax4(group.length, length);
      return true;
    }
  });
  return baseTimes_default(length, function(index) {
    return arrayMap_default(array, baseProperty_default(index));
  });
}
var unzip_default = unzip;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/zip.js
var zip = baseRest_default(unzip_default);
var zip_default = zip;

// ../common/src/util/Notifier.ts
var Notifier = class {
  constructor() {
    this.listeners = [];
    /**
     * Notify all listeners that something has changed
     */
    this.notifyListeners = (...args2) => {
      this.listeners.forEach((listener) => listener(...args2));
    };
    this.registerListener = this.registerListener.bind(this);
  }
  /**
   * Register to be notified when {@link notifyListeners} is called
   * @param listener A function to be called when {@link notifyListeners} is called
   * @returns A function that can be called to unsubscribe from notifications
   */
  registerListener(listener) {
    this.listeners.push(listener);
    return {
      dispose: () => {
        pull_default(this.listeners, listener);
      }
    };
  }
};

// ../common/src/ide/types/Configuration.ts
var CONFIGURATION_DEFAULTS = {
  tokenHatSplittingMode: {
    preserveCase: false,
    lettersToPreserve: [],
    symbolsToPreserve: []
  },
  wordSeparators: ["_"],
  decorationDebounceDelayMs: 50,
  experimental: {
    snippetsDir: void 0,
    hatStability: "balanced" /* balanced */,
    keyboardTargetFollowsSelection: false
  },
  commandHistory: false,
  debug: false
};

// ../common/src/ide/types/KeyValueStore.ts
var KEY_VALUE_STORE_DEFAULTS = {
  hideInferenceWarning: false,
  tutorialProgress: {}
};

// ../common/src/types/Position.ts
var Position = class _Position {
  /**
   * @param line A zero-based line value.
   * @param character A zero-based character value.
   */
  constructor(line, character) {
    this.line = line;
    this.character = character;
  }
  /**
   * Check if this position is equal to `other`.
   *
   * @param other A position.
   * @return `true` if the line and character of the given position are equal to
   * the line and character of this position.
   */
  isEqual(other) {
    return this.line === other.line && this.character === other.character;
  }
  /**
   * Check if this position is before `other`.
   *
   * @param other A position.
   * @return `true` if position is on a smaller line
   * or on the same line on a smaller character.
   */
  isBefore(other) {
    if (this.line < other.line) {
      return true;
    }
    if (this.line > other.line) {
      return false;
    }
    return this.character < other.character;
  }
  /**
   * Check if this position is after `other`.
   *
   * @param other A position.
   * @return `true` if position is on a greater line
   * or on the same line on a greater character.
   */
  isAfter(other) {
    if (this.line > other.line) {
      return true;
    }
    if (this.line < other.line) {
      return false;
    }
    return this.character > other.character;
  }
  /**
   * Check if this position is before or equal to `other`.
   *
   * @param other A position.
   * @return `true` if position is on a smaller line
   * or on the same line on a smaller or equal character.
   */
  isBeforeOrEqual(other) {
    return this.isEqual(other) || this.isBefore(other);
  }
  /**
   * Check if this position is after or equal to `other`.
   *
   * @param other A position.
   * @return `true` if position is on a greater line
   * or on the same line on a greater or equal character.
   */
  isAfterOrEqual(other) {
    return this.isEqual(other) || this.isAfter(other);
  }
  /**
   * Compare this to `other`.
   *
   * @param other A position.
   * @return A number smaller than zero if this position is before the given position,
   * a number greater than zero if this position is after the given position, or zero when
   * this and the given position are equal.
   */
  compareTo(other) {
    if (this.isBefore(other)) {
      return -1;
    }
    if (this.isAfter(other)) {
      return 1;
    }
    return 0;
  }
  /**
   * Create a new position derived from this position.
   *
   * @param line Value that should be used as line value, default is the {@link Position.line existing value}
   * @param character Value that should be used as character value, default is the {@link Position.character existing value}
   * @return A position where line and character are replaced by the given values.
   */
  with(line, character) {
    return new _Position(line ?? this.line, character ?? this.character);
  }
  /**
   * Create a new position relative to this position.
   *
   * @param lineDelta Delta value for the line value, default is `0`.
   * @param characterDelta Delta value for the character value, default is `0`.
   * @return A position which line and character is the sum of the current line and
   * character and the corresponding deltas.
   */
  translate(lineDelta, characterDelta) {
    return new _Position(
      this.line + (lineDelta ?? 0),
      this.character + (characterDelta ?? 0)
    );
  }
  /**
   * Create a new empty range from this position.
   * @returns A {@link Range}
   */
  toEmptyRange() {
    return new Range(this, this);
  }
  /**
   * Return a concise string representation of the position. 0-based.
   * @returns concise representation
   **/
  concise() {
    return `${this.line}:${this.character}`;
  }
  /**
   * Return a concise string representation of the position. 1-based.
   * @returns concise representation
   **/
  conciseOneBased() {
    return `${this.line + 1}:${this.character + 1}`;
  }
  toString() {
    return this.concise();
  }
};
function adjustPosition(doc, pos, by) {
  return doc.positionAt(doc.offsetAt(pos) + by);
}

// ../common/src/types/Range.ts
var Range = class _Range {
  constructor(...args2) {
    const [p1, p2] = (() => {
      if (args2.length === 2) {
        return args2;
      }
      return [new Position(args2[0], args2[1]), new Position(args2[2], args2[3])];
    })();
    if (p1.isBefore(p2)) {
      this.start = p1;
      this.end = p2;
    } else {
      this.start = p2;
      this.end = p1;
    }
  }
  /**
   * `true` if `start` and `end` are equal.
   */
  get isEmpty() {
    return this.start.isEqual(this.end);
  }
  /**
   * `true` if `start.line` and `end.line` are equal.
   */
  get isSingleLine() {
    return this.start.line === this.end.line;
  }
  /**
   * Check if `other` equals this range.
   *
   * @param other A range.
   * @return `true` when start and end are {@link Position.isEqual equal} to
   * start and end of this range.
   */
  isRangeEqual(other) {
    return this.start.isEqual(other.start) && this.end.isEqual(other.end);
  }
  /**
   * Check if a position or a range is contained in this range.
   *
   * @param positionOrRange A position or a range.
   * @return `true` if the position or range is inside or equal
   * to this range.
   */
  contains(positionOrRange) {
    const [start2, end] = positionOrRange instanceof Position ? [positionOrRange, positionOrRange] : [positionOrRange.start, positionOrRange.end];
    return start2.isAfterOrEqual(this.start) && end.isBeforeOrEqual(this.end);
  }
  /**
   * Intersect `range` with this range and returns a new range.
   * If the ranges are adjacent but non-overlapping, the resulting range is empty.
   * If the ranges have no overlap and are not adjacent, it returns `undefined`.
   *
   * @param other A range.
   * @return A range of the greater start and smaller end positions. Will
   * return undefined when there is no overlap.
   */
  intersection(other) {
    const start2 = this.start.isAfter(other.start) ? this.start : other.start;
    const end = this.end.isBefore(other.end) ? this.end : other.end;
    return start2.isBeforeOrEqual(end) ? new _Range(start2, end) : void 0;
  }
  /**
   * Compute the union of `other` with this range.
   *
   * @param other A range.
   * @return A range of smaller start position and the greater end position.
   */
  union(other) {
    return new _Range(
      this.start.isBefore(other.start) ? this.start : other.start,
      this.end.isAfter(other.end) ? this.end : other.end
    );
  }
  /**
   * Derive a new range from this range.
   * If the resulting range has end before start, they are swapped.
   *
   * @param start A position that should be used as start. The default value is the {@link Range.start current start}.
   * @param end A position that should be used as end. The default value is the {@link Range.end current end}.
   * @return A range derived from this range with the given start and end position.
   */
  with(start2, end) {
    return new _Range(start2 ?? this.start, end ?? this.end);
  }
  /**
   * Construct a new selection from this range
   * @param isReversed If true active is before anchor
   * @returns A new selection
   */
  toSelection(isReversed) {
    return isReversed ? new Selection(this.end, this.start) : new Selection(this.start, this.end);
  }
  /**
   * Return a concise string representation of the range. 0-based.
   * @returns concise representation
   **/
  concise() {
    return `${this.start.concise()}-${this.end.concise()}`;
  }
  /**
   * Return a concise string representation of the range. 1-based.
   * @returns concise representation
   **/
  conciseOneBased() {
    return `${this.start.conciseOneBased()}-${this.end.conciseOneBased()}`;
  }
  toString() {
    return `${this.start.concise()}-${this.end.concise()}`;
  }
};

// ../common/src/util/regex.ts
function _rightAnchored(regex) {
  const { source, flags: flags2 } = regex;
  return new RegExp(`(${source})$`, flags2.replace("m", ""));
}
function _leftAnchored(regex) {
  const { source, flags: flags2 } = regex;
  return new RegExp(`^(${source})`, flags2.replace("m", ""));
}
function makeCache(func2) {
  const cache = /* @__PURE__ */ new Map();
  function wrapper(arg) {
    let cachedValue = cache.get(arg);
    if (cachedValue == null) {
      cachedValue = func2(arg);
      cache.set(arg, cachedValue);
    }
    return cachedValue;
  }
  return wrapper;
}
var rightAnchored = makeCache(_rightAnchored);
var leftAnchored = makeCache(_leftAnchored);
function matchAllIterator(text, regex) {
  regex.lastIndex = 0;
  return text.matchAll(regex);
}
function matchAll(text, regex, mapfn) {
  return Array.from(matchAllIterator(text, regex), mapfn);
}
function testRegex(regex, text) {
  regex.lastIndex = 0;
  return regex.test(text);
}
function matchRegex(regex, text) {
  regex.lastIndex = 0;
  return text.match(regex);
}
function matchText(text, regex) {
  return matchAll(text, regex, (match) => ({
    index: match.index,
    text: match[0]
  }));
}
function getLeadingWhitespace(text) {
  return text.match(/^\s+/)?.[0] ?? "";
}
function getTrailingWhitespace(text) {
  return text.match(/\s+$/)?.[0] ?? "";
}

// ../common/src/ide/inMemoryTextDocument/InMemoryTextLine.ts
var InMemoryTextLine = class {
  constructor(lineNumber, offset, text, eol) {
    this.lineNumber = lineNumber;
    this.offset = offset;
    this.text = text;
    this.isEmptyOrWhitespace = /^\s*$/.test(text);
    this.lengthIncludingEol = text.length + (eol?.length ?? 0);
    const start2 = new Position(lineNumber, 0);
    const end = new Position(lineNumber, text.length);
    const endIncludingLineBreak = eol != null ? new Position(lineNumber + 1, 0) : end;
    this.range = new Range(start2, end);
    this.rangeIncludingLineBreak = new Range(start2, endIncludingLineBreak);
    this.rangeTrimmed = this.isEmptyOrWhitespace ? void 0 : new Range(
      start2.translate(void 0, getLeadingWhitespace(text).length),
      end.translate(void 0, -getTrailingWhitespace(text).length)
    );
  }
};

// ../common/src/ide/inMemoryTextDocument/performEdits.ts
function performEdits(document2, edits) {
  const changes = createChangeEvents(document2, edits);
  let result = document2.getText();
  for (const change of changes) {
    const { text, rangeOffset, rangeLength } = change;
    result = result.slice(0, rangeOffset) + text + result.slice(rangeOffset + rangeLength);
  }
  return { text: result, changes };
}
function createChangeEvents(document2, edits) {
  const changes = [];
  const sortedEdits = edits.map((edit, index) => ({ edit, index })).sort((a, b) => {
    if (a.edit.range.start.isEqual(b.edit.range.start)) {
      return b.index - a.index;
    }
    return b.edit.range.start.compareTo(a.edit.range.start);
  }).map(({ edit }) => edit);
  const eol = document2.eol === "LF" ? "\n" : "\r\n";
  for (const edit of sortedEdits) {
    const previousChange = changes[changes.length - 1];
    const intersection = previousChange?.range.intersection(edit.range);
    if (intersection != null && !intersection.isEmpty) {
      if (!previousChange.text && !edit.text) {
        changes[changes.length - 1] = createChangeEvent(
          document2,
          previousChange.range.union(edit.range),
          ""
        );
        continue;
      }
      throw Error("Overlapping ranges are not allowed!");
    }
    const text = edit.text.replace(/\r?\n/g, eol);
    changes.push(createChangeEvent(document2, edit.range, text));
  }
  return changes;
}
function createChangeEvent(document2, range3, text) {
  const start2 = document2.offsetAt(range3.start);
  const end = document2.offsetAt(range3.end);
  return {
    text,
    range: range3,
    rangeOffset: start2,
    rangeLength: end - start2
  };
}

// ../common/src/ide/inMemoryTextDocument/InMemoryTextDocument.ts
var InMemoryTextDocument = class {
  constructor(uri, languageId, text) {
    this.uri = uri;
    this.languageId = languageId;
    this.filename = uri.path.split(/\\|\//g).at(-1) ?? "";
    this._text = "";
    this._eol = "LF";
    this._version = -1;
    this._lines = [];
    this.setTextInternal(text);
  }
  get version() {
    return this._version;
  }
  get lineCount() {
    return this._lines.length;
  }
  get eol() {
    return this._eol;
  }
  get text() {
    return this._text;
  }
  get range() {
    return new Range(this._lines[0].range.start, this._lines.at(-1).range.end);
  }
  setTextInternal(text) {
    this._text = text;
    this._eol = text.includes("\r\n") ? "CRLF" : "LF";
    this._version++;
    this._lines = createLines(text);
  }
  lineAt(lineOrPosition) {
    const value = typeof lineOrPosition === "number" ? lineOrPosition : lineOrPosition.line;
    const index = clamp(value, 0, this.lineCount - 1);
    return this._lines[index];
  }
  offsetAt(position) {
    if (position.line < 0) {
      return 0;
    }
    if (position.line > this._lines.length - 1) {
      return this._text.length;
    }
    const line = this._lines[position.line];
    return line.offset + clamp(position.character, 0, line.text.length);
  }
  positionAt(offset) {
    if (offset <= 0) {
      return this.range.start;
    }
    if (offset >= this._text.length) {
      return this.range.end;
    }
    const line = this._lines.find(
      (line2) => offset < line2.offset + line2.lengthIncludingEol
    );
    if (line == null) {
      throw Error(`Couldn't find line for offset ${offset}`);
    }
    return new Position(
      line.lineNumber,
      Math.min(offset - line.offset, line.text.length)
    );
  }
  getText(range3) {
    if (range3 == null) {
      return this.text;
    }
    const startOffset = this.offsetAt(range3.start);
    const endOffset = this.offsetAt(range3.end);
    return this.text.slice(startOffset, endOffset);
  }
  edit(edits) {
    const { text, changes } = performEdits(this, edits);
    this.setTextInternal(text);
    return changes;
  }
};
function createLines(text) {
  const documentParts = text.split(/(\r?\n)/g);
  const result = [];
  let offset = 0;
  for (let i2 = 0; i2 < documentParts.length; i2 += 2) {
    const line = new InMemoryTextLine(
      result.length,
      offset,
      documentParts[i2],
      documentParts[i2 + 1]
    );
    result.push(line);
    offset += line.lengthIncludingEol;
  }
  return result;
}
function clamp(value, min2, max) {
  return Math.min(Math.max(value, min2), max);
}

// ../common/src/ide/util/messages.ts
function showWarning(messages, id2, message, ...options2) {
  return messages.showMessage("warning" /* warning */, id2, message, ...options2);
}
function showError(messages, id2, message, ...options2) {
  return messages.showMessage("error" /* error */, id2, message, ...options2);
}

// ../common/src/scopeSupportFacets/scopeSupportFacets.types.ts
var ScopeSupportFacetLevel = /* @__PURE__ */ ((ScopeSupportFacetLevel2) => {
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["supported"] = 0] = "supported";
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["unsupported"] = 1] = "unsupported";
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["notApplicable"] = 2] = "notApplicable";
  return ScopeSupportFacetLevel2;
})(ScopeSupportFacetLevel || {});

// ../common/src/scopeSupportFacets/c.ts
var { supported, unsupported, notApplicable } = ScopeSupportFacetLevel;
var cCoreScopeSupport = {
  list: supported,
  disqualifyDelimiter: supported,
  switchStatementSubject: supported,
  ifStatement: supported,
  statement: supported,
  "statement.class": supported,
  "statement.iteration.document": supported,
  "statement.iteration.block": supported,
  class: supported,
  "class.iteration.document": supported,
  className: supported,
  "className.iteration.document": supported,
  "collectionItem.unenclosed": supported,
  "collectionItem.unenclosed.iteration": supported,
  namedFunction: supported,
  functionName: supported,
  "functionName.iteration.document": supported,
  "namedFunction.iteration.document": supported,
  functionCall: supported,
  functionCallee: supported,
  "argument.actual": supported,
  "argument.actual.iteration": supported,
  "argument.actual.method": supported,
  "argument.actual.method.iteration": supported,
  "argument.formal": supported,
  "argument.formal.iteration": supported,
  "argumentList.actual.empty": supported,
  "argumentList.actual.singleLine": supported,
  "argumentList.actual.multiLine": supported,
  "argumentList.actual.method.empty": supported,
  "argumentList.actual.method.singleLine": supported,
  "argumentList.actual.method.multiLine": supported,
  "argumentList.formal.empty": supported,
  "argumentList.formal.singleLine": supported,
  "argumentList.formal.multiLine": supported,
  "branch.if": supported,
  "branch.if.iteration": supported,
  "branch.switchCase": supported,
  "branch.switchCase.iteration": supported,
  "branch.ternary": supported,
  "branch.loop": supported,
  "comment.line": supported,
  "comment.block": supported,
  "string.singleLine": supported,
  "textFragment.comment.line": supported,
  "textFragment.comment.block": supported,
  "textFragment.string.singleLine": supported,
  "condition.if": supported,
  "condition.while": supported,
  "condition.doWhile": supported,
  "condition.for": supported,
  "condition.ternary": supported,
  "condition.switchCase": supported,
  "condition.switchCase.iteration": supported,
  "name.assignment": supported,
  "name.variable": supported,
  "name.function": supported,
  "name.class": supported,
  "name.field": supported,
  "name.iteration.block": supported,
  "name.iteration.document": supported,
  "name.argument.formal": supported,
  "name.argument.formal.iteration": supported,
  "value.assignment": supported,
  "value.variable": supported,
  "value.return": supported,
  "type.variable": supported,
  "type.argument.formal": supported,
  "type.argument.formal.iteration": supported,
  "type.field": supported,
  "type.field.iteration": supported,
  "type.enum": supported,
  "type.cast": supported,
  "type.class": supported,
  "type.return": supported,
  "interior.class": supported,
  "interior.function": supported,
  "interior.if": supported,
  "interior.switchCase": supported,
  "interior.ternary": supported,
  "interior.loop": supported,
  /* UNSUPPORTED  */
  fieldAccess: unsupported,
  /* NOT APPLICABLE (C and C++) */
  // Element and tags
  element: notApplicable,
  tags: notApplicable,
  startTag: notApplicable,
  endTag: notApplicable,
  "interior.element": notApplicable,
  "textFragment.element": notApplicable,
  // Resource syntax
  "interior.resource": notApplicable,
  "type.resource": notApplicable,
  "type.resource.iteration": notApplicable,
  "name.resource": notApplicable,
  "name.resource.iteration": notApplicable,
  "value.resource": notApplicable,
  "value.resource.iteration": notApplicable,
  // Map literal
  map: notApplicable,
  "key.mapPair": notApplicable,
  "key.mapPair.iteration": notApplicable,
  "value.mapPair": notApplicable,
  "value.mapPair.iteration": notApplicable,
  // Keyword argument
  "name.argument.actual": notApplicable,
  "name.argument.actual.iteration": notApplicable,
  "value.argument.actual": notApplicable,
  "value.argument.actual.iteration": notApplicable,
  // Multiline string
  "string.multiLine": notApplicable,
  "textFragment.string.multiLine": notApplicable,
  // Section
  section: notApplicable,
  "section.iteration.document": notApplicable,
  "section.iteration.parent": notApplicable,
  // Pattern destructing
  "name.assignment.pattern": notApplicable,
  "name.variable.pattern": notApplicable,
  "value.variable.pattern": notApplicable,
  // Command
  command: notApplicable,
  "interior.command": notApplicable,
  // Type alias
  "type.alias": notApplicable,
  "value.typeAlias": notApplicable,
  // Notebook cell
  notebookCell: notApplicable,
  "interior.cell": notApplicable,
  // Nested class
  "class.iteration.block": notApplicable,
  "className.iteration.block": notApplicable,
  // Nested function
  "functionName.iteration.block": notApplicable,
  "namedFunction.iteration.block": notApplicable,
  // Try catch
  "branch.try": notApplicable,
  "branch.try.iteration": notApplicable,
  "interior.try": notApplicable,
  // Miscellaneous
  "key.attribute": notApplicable,
  "type.interface": notApplicable,
  "value.attribute": notApplicable,
  "value.yield": notApplicable,
  "value.field": notApplicable,
  environment: notApplicable,
  pairDelimiter: notApplicable,
  regularExpression: notApplicable
};
var cScopeSupport = {
  ...cCoreScopeSupport,
  // Not applicable for C, but supported for C++
  // These are defined here because we don't want C++ to import them and
  // accidentally forget to add support for them.
  attribute: notApplicable,
  // Lambda
  "argument.formal.lambda.iteration": notApplicable,
  "argument.formal.lambda": notApplicable,
  "argumentList.formal.lambda.empty": notApplicable,
  "argumentList.formal.lambda.multiLine": notApplicable,
  "argumentList.formal.lambda.singleLine": notApplicable,
  "interior.lambda": notApplicable,
  "value.return.lambda": notApplicable,
  anonymousFunction: notApplicable,
  // Constructor
  "argument.actual.constructor.iteration": notApplicable,
  "argument.actual.constructor": notApplicable,
  "argument.formal.constructor.iteration": notApplicable,
  "argument.formal.constructor": notApplicable,
  "argumentList.actual.constructor.empty": notApplicable,
  "argumentList.actual.constructor.multiLine": notApplicable,
  "argumentList.actual.constructor.singleLine": notApplicable,
  "argumentList.formal.constructor.empty": notApplicable,
  "argumentList.formal.constructor.multiLine": notApplicable,
  "argumentList.formal.constructor.singleLine": notApplicable,
  "functionCall.constructor": notApplicable,
  "functionCallee.constructor": notApplicable,
  "functionName.constructor": notApplicable,
  "name.argument.formal.constructor.iteration": notApplicable,
  "name.argument.formal.constructor": notApplicable,
  "name.constructor": notApplicable,
  "namedFunction.constructor": notApplicable,
  "type.argument.formal.constructor.iteration": notApplicable,
  "type.argument.formal.constructor": notApplicable,
  "value.argument.formal.constructor.iteration": notApplicable,
  "value.argument.formal.constructor": notApplicable,
  // Method
  "argument.formal.method.iteration": notApplicable,
  "argument.formal.method": notApplicable,
  "argumentList.formal.method.empty": notApplicable,
  "argumentList.formal.method.multiLine": notApplicable,
  "argumentList.formal.method.singleLine": notApplicable,
  "functionName.method.iteration.class": notApplicable,
  "functionName.method": notApplicable,
  "name.argument.formal.method.iteration": notApplicable,
  "name.argument.formal.method": notApplicable,
  "name.method": notApplicable,
  "namedFunction.method.iteration.class": notApplicable,
  "namedFunction.method": notApplicable,
  "type.argument.formal.method.iteration": notApplicable,
  "type.argument.formal.method": notApplicable,
  "value.argument.formal.method.iteration": notApplicable,
  "value.argument.formal.method": notApplicable,
  // Foreach
  "name.foreach": notApplicable,
  "type.foreach": notApplicable,
  "value.foreach": notApplicable,
  // Default argument value
  "value.argument.formal": notApplicable,
  "value.argument.formal.iteration": notApplicable,
  // Generic type
  "type.typeArgument": notApplicable,
  "type.typeArgument.iteration": notApplicable
};

// ../common/src/scopeSupportFacets/clojure.ts
var { supported: supported2, unsupported: unsupported2, notApplicable: notApplicable2 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/cpp.ts
var { supported: supported3 } = ScopeSupportFacetLevel;
var cppScopeSupport = {
  ...cCoreScopeSupport,
  attribute: supported3,
  anonymousFunction: supported3,
  "branch.try": supported3,
  "branch.try.iteration": supported3,
  "argument.actual.constructor": supported3,
  "argument.actual.constructor.iteration": supported3,
  "argument.formal.method": supported3,
  "argument.formal.method.iteration": supported3,
  "argument.formal.constructor": supported3,
  "argument.formal.constructor.iteration": supported3,
  "argument.formal.lambda": supported3,
  "argument.formal.lambda.iteration": supported3,
  "argumentList.actual.constructor.empty": supported3,
  "argumentList.actual.constructor.singleLine": supported3,
  "argumentList.actual.constructor.multiLine": supported3,
  "argumentList.formal.constructor.empty": supported3,
  "argumentList.formal.constructor.singleLine": supported3,
  "argumentList.formal.constructor.multiLine": supported3,
  "argumentList.formal.lambda.empty": supported3,
  "argumentList.formal.lambda.singleLine": supported3,
  "argumentList.formal.lambda.multiLine": supported3,
  "argumentList.formal.method.empty": supported3,
  "argumentList.formal.method.singleLine": supported3,
  "argumentList.formal.method.multiLine": supported3,
  "functionCall.constructor": supported3,
  "functionCallee.constructor": supported3,
  "functionName.constructor": supported3,
  "functionName.method": supported3,
  "functionName.method.iteration.class": supported3,
  "namedFunction.method": supported3,
  "namedFunction.method.iteration.class": supported3,
  "namedFunction.constructor": supported3,
  "name.argument.formal.method": supported3,
  "name.argument.formal.method.iteration": supported3,
  "name.argument.formal.constructor": supported3,
  "name.argument.formal.constructor.iteration": supported3,
  "name.constructor": supported3,
  "name.foreach": supported3,
  "name.method": supported3,
  "value.argument.formal": supported3,
  "value.argument.formal.iteration": supported3,
  "value.argument.formal.method": supported3,
  "value.argument.formal.method.iteration": supported3,
  "value.argument.formal.constructor": supported3,
  "value.argument.formal.constructor.iteration": supported3,
  "value.foreach": supported3,
  "value.return.lambda": supported3,
  "value.field": supported3,
  "type.argument.formal.method": supported3,
  "type.argument.formal.method.iteration": supported3,
  "type.argument.formal.constructor": supported3,
  "type.argument.formal.constructor.iteration": supported3,
  "type.foreach": supported3,
  "type.typeArgument": supported3,
  "type.typeArgument.iteration": supported3,
  "interior.lambda": supported3,
  "interior.try": supported3
};

// ../common/src/scopeSupportFacets/csharp.ts
var { supported: supported4, unsupported: unsupported3, notApplicable: notApplicable3 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/css.ts
var { supported: supported5, notApplicable: notApplicable4 } = ScopeSupportFacetLevel;
var cssScopeSupport = {
  "comment.block": supported5,
  "string.singleLine": supported5,
  disqualifyDelimiter: supported5,
  map: supported5,
  functionCall: supported5,
  functionCallee: supported5,
  "argument.actual": supported5,
  "argument.actual.iteration": supported5,
  "argumentList.actual.empty": supported5,
  "argumentList.actual.singleLine": supported5,
  "argumentList.actual.multiLine": supported5,
  "name.iteration.document": supported5,
  "name.iteration.block": supported5,
  "textFragment.comment.block": supported5,
  "textFragment.string.singleLine": supported5,
  "key.mapPair": supported5,
  "key.mapPair.iteration": supported5,
  "value.mapPair": supported5,
  "value.mapPair.iteration": supported5,
  "collectionItem.unenclosed": supported5,
  "collectionItem.unenclosed.iteration": supported5,
  statement: supported5,
  "statement.iteration.document": supported5,
  // Not applicable
  anonymousFunction: notApplicable4,
  "argument.actual.constructor.iteration": notApplicable4,
  "argument.actual.constructor": notApplicable4,
  "argument.actual.method.iteration": notApplicable4,
  "argument.actual.method": notApplicable4,
  "argument.formal.constructor.iteration": notApplicable4,
  "argument.formal.constructor": notApplicable4,
  "argument.formal.iteration": notApplicable4,
  "argument.formal.method.iteration": notApplicable4,
  "argument.formal.method": notApplicable4,
  "argument.formal": notApplicable4,
  "argument.formal.lambda": notApplicable4,
  "argument.formal.lambda.iteration": notApplicable4,
  "argumentList.actual.method.empty": notApplicable4,
  "argumentList.actual.method.singleLine": notApplicable4,
  "argumentList.actual.method.multiLine": notApplicable4,
  "argumentList.actual.constructor.empty": notApplicable4,
  "argumentList.actual.constructor.singleLine": notApplicable4,
  "argumentList.actual.constructor.multiLine": notApplicable4,
  "argumentList.formal.empty": notApplicable4,
  "argumentList.formal.singleLine": notApplicable4,
  "argumentList.formal.multiLine": notApplicable4,
  "argumentList.formal.lambda.empty": notApplicable4,
  "argumentList.formal.lambda.singleLine": notApplicable4,
  "argumentList.formal.lambda.multiLine": notApplicable4,
  "argumentList.formal.method.empty": notApplicable4,
  "argumentList.formal.method.singleLine": notApplicable4,
  "argumentList.formal.method.multiLine": notApplicable4,
  "argumentList.formal.constructor.empty": notApplicable4,
  "argumentList.formal.constructor.singleLine": notApplicable4,
  "argumentList.formal.constructor.multiLine": notApplicable4,
  attribute: notApplicable4,
  "branch.if.iteration": notApplicable4,
  "branch.if": notApplicable4,
  "branch.loop": notApplicable4,
  "branch.switchCase.iteration": notApplicable4,
  "branch.switchCase": notApplicable4,
  "branch.ternary": notApplicable4,
  "branch.try.iteration": notApplicable4,
  "branch.try": notApplicable4,
  "class.iteration.block": notApplicable4,
  "class.iteration.document": notApplicable4,
  class: notApplicable4,
  "className.iteration.block": notApplicable4,
  "className.iteration.document": notApplicable4,
  className: notApplicable4,
  command: notApplicable4,
  "comment.line": notApplicable4,
  "condition.doWhile": notApplicable4,
  "condition.for": notApplicable4,
  "condition.if": notApplicable4,
  "condition.switchCase.iteration": notApplicable4,
  "condition.switchCase": notApplicable4,
  "condition.ternary": notApplicable4,
  "condition.while": notApplicable4,
  element: notApplicable4,
  endTag: notApplicable4,
  environment: notApplicable4,
  fieldAccess: notApplicable4,
  "functionCall.constructor": notApplicable4,
  "functionCallee.constructor": notApplicable4,
  "functionName.constructor": notApplicable4,
  "functionName.iteration.block": notApplicable4,
  "functionName.iteration.document": notApplicable4,
  "functionName.method.iteration.class": notApplicable4,
  "functionName.method": notApplicable4,
  functionName: notApplicable4,
  ifStatement: notApplicable4,
  "interior.cell": notApplicable4,
  "interior.class": notApplicable4,
  "interior.command": notApplicable4,
  "interior.element": notApplicable4,
  "interior.function": notApplicable4,
  "interior.if": notApplicable4,
  "interior.lambda": notApplicable4,
  "interior.loop": notApplicable4,
  "interior.resource": notApplicable4,
  "interior.switchCase": notApplicable4,
  "interior.ternary": notApplicable4,
  "interior.try": notApplicable4,
  "key.attribute": notApplicable4,
  list: notApplicable4,
  "name.argument.actual.iteration": notApplicable4,
  "name.argument.actual": notApplicable4,
  "name.argument.formal.constructor.iteration": notApplicable4,
  "name.argument.formal.constructor": notApplicable4,
  "name.argument.formal.iteration": notApplicable4,
  "name.argument.formal.method.iteration": notApplicable4,
  "name.argument.formal.method": notApplicable4,
  "name.argument.formal": notApplicable4,
  "name.assignment.pattern": notApplicable4,
  "name.assignment": notApplicable4,
  "name.class": notApplicable4,
  "name.constructor": notApplicable4,
  "name.field": notApplicable4,
  "name.foreach": notApplicable4,
  "name.function": notApplicable4,
  "name.method": notApplicable4,
  "name.resource.iteration": notApplicable4,
  "name.resource": notApplicable4,
  "name.variable.pattern": notApplicable4,
  "name.variable": notApplicable4,
  "namedFunction.constructor": notApplicable4,
  "namedFunction.iteration.block": notApplicable4,
  "namedFunction.iteration.document": notApplicable4,
  "namedFunction.method.iteration.class": notApplicable4,
  "namedFunction.method": notApplicable4,
  namedFunction: notApplicable4,
  notebookCell: notApplicable4,
  pairDelimiter: notApplicable4,
  regularExpression: notApplicable4,
  "section.iteration.document": notApplicable4,
  "section.iteration.parent": notApplicable4,
  section: notApplicable4,
  startTag: notApplicable4,
  "statement.iteration.block": notApplicable4,
  "statement.class": notApplicable4,
  "string.multiLine": notApplicable4,
  switchStatementSubject: notApplicable4,
  tags: notApplicable4,
  "textFragment.comment.line": notApplicable4,
  "textFragment.element": notApplicable4,
  "textFragment.string.multiLine": notApplicable4,
  "type.alias": notApplicable4,
  "type.argument.formal.constructor.iteration": notApplicable4,
  "type.argument.formal.constructor": notApplicable4,
  "type.argument.formal.iteration": notApplicable4,
  "type.argument.formal.method.iteration": notApplicable4,
  "type.argument.formal.method": notApplicable4,
  "type.argument.formal": notApplicable4,
  "type.cast": notApplicable4,
  "type.class": notApplicable4,
  "type.enum": notApplicable4,
  "type.field.iteration": notApplicable4,
  "type.field": notApplicable4,
  "type.foreach": notApplicable4,
  "type.interface": notApplicable4,
  "type.resource": notApplicable4,
  "type.resource.iteration": notApplicable4,
  "type.return": notApplicable4,
  "type.typeArgument.iteration": notApplicable4,
  "type.typeArgument": notApplicable4,
  "type.variable": notApplicable4,
  "value.argument.actual.iteration": notApplicable4,
  "value.argument.actual": notApplicable4,
  "value.argument.formal.constructor.iteration": notApplicable4,
  "value.argument.formal.constructor": notApplicable4,
  "value.argument.formal.iteration": notApplicable4,
  "value.argument.formal.method.iteration": notApplicable4,
  "value.argument.formal.method": notApplicable4,
  "value.argument.formal": notApplicable4,
  "value.assignment": notApplicable4,
  "value.attribute": notApplicable4,
  "value.field": notApplicable4,
  "value.foreach": notApplicable4,
  "value.resource.iteration": notApplicable4,
  "value.resource": notApplicable4,
  "value.return.lambda": notApplicable4,
  "value.return": notApplicable4,
  "value.typeAlias": notApplicable4,
  "value.variable.pattern": notApplicable4,
  "value.variable": notApplicable4,
  "value.yield": notApplicable4
};

// ../common/src/scopeSupportFacets/dart.ts
var { supported: supported6, unsupported: unsupported4, notApplicable: notApplicable5 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/go.ts
var { supported: supported7, unsupported: unsupported5, notApplicable: notApplicable6 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/html.ts
var { supported: supported8, notApplicable: notApplicable7 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/java.ts
var { supported: supported9, unsupported: unsupported6, notApplicable: notApplicable8 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/javascript.ts
var { supported: supported10, notApplicable: notApplicable9 } = ScopeSupportFacetLevel;
var javascriptCoreScopeSupport = {
  list: supported10,
  map: supported10,
  regularExpression: supported10,
  switchStatementSubject: supported10,
  fieldAccess: supported10,
  disqualifyDelimiter: supported10,
  pairDelimiter: supported10,
  "collectionItem.unenclosed": supported10,
  "collectionItem.unenclosed.iteration": supported10,
  "textFragment.string.singleLine": supported10,
  "textFragment.string.multiLine": supported10,
  "textFragment.comment.line": supported10,
  "textFragment.comment.block": supported10,
  ifStatement: supported10,
  statement: supported10,
  "statement.iteration.document": supported10,
  "statement.iteration.block": supported10,
  "statement.class": supported10,
  class: supported10,
  "class.iteration.document": supported10,
  className: supported10,
  "className.iteration.document": supported10,
  anonymousFunction: supported10,
  namedFunction: supported10,
  "namedFunction.iteration.document": supported10,
  "namedFunction.method": supported10,
  "namedFunction.method.iteration.class": supported10,
  "namedFunction.constructor": supported10,
  functionName: supported10,
  "functionName.iteration.document": supported10,
  "functionName.method": supported10,
  "functionName.method.iteration.class": supported10,
  "functionName.constructor": supported10,
  functionCall: supported10,
  "functionCall.constructor": supported10,
  functionCallee: supported10,
  "functionCallee.constructor": supported10,
  "argument.actual": supported10,
  "argument.actual.iteration": supported10,
  "argument.actual.method": supported10,
  "argument.actual.method.iteration": supported10,
  "argument.actual.constructor": supported10,
  "argument.actual.constructor.iteration": supported10,
  "argument.formal": supported10,
  "argument.formal.iteration": supported10,
  "argument.formal.method": supported10,
  "argument.formal.method.iteration": supported10,
  "argument.formal.constructor": supported10,
  "argument.formal.constructor.iteration": supported10,
  "argument.formal.lambda": supported10,
  "argument.formal.lambda.iteration": supported10,
  "argumentList.actual.empty": supported10,
  "argumentList.actual.singleLine": supported10,
  "argumentList.actual.multiLine": supported10,
  "argumentList.actual.method.empty": supported10,
  "argumentList.actual.method.singleLine": supported10,
  "argumentList.actual.method.multiLine": supported10,
  "argumentList.actual.constructor.empty": supported10,
  "argumentList.actual.constructor.singleLine": supported10,
  "argumentList.actual.constructor.multiLine": supported10,
  "argumentList.formal.empty": supported10,
  "argumentList.formal.singleLine": supported10,
  "argumentList.formal.multiLine": supported10,
  "argumentList.formal.lambda.empty": supported10,
  "argumentList.formal.lambda.singleLine": supported10,
  "argumentList.formal.lambda.multiLine": supported10,
  "argumentList.formal.method.empty": supported10,
  "argumentList.formal.method.singleLine": supported10,
  "argumentList.formal.method.multiLine": supported10,
  "argumentList.formal.constructor.empty": supported10,
  "argumentList.formal.constructor.singleLine": supported10,
  "argumentList.formal.constructor.multiLine": supported10,
  "comment.line": supported10,
  "comment.block": supported10,
  "string.singleLine": supported10,
  "string.multiLine": supported10,
  "branch.if": supported10,
  "branch.if.iteration": supported10,
  "branch.try": supported10,
  "branch.try.iteration": supported10,
  "branch.switchCase": supported10,
  "branch.switchCase.iteration": supported10,
  "branch.ternary": supported10,
  "branch.loop": supported10,
  "condition.if": supported10,
  "condition.while": supported10,
  "condition.doWhile": supported10,
  "condition.for": supported10,
  "condition.ternary": supported10,
  "condition.switchCase": supported10,
  "condition.switchCase.iteration": supported10,
  "name.argument.formal": supported10,
  "name.argument.formal.iteration": supported10,
  "name.argument.formal.method": supported10,
  "name.argument.formal.method.iteration": supported10,
  "name.argument.formal.constructor": supported10,
  "name.argument.formal.constructor.iteration": supported10,
  "name.foreach": supported10,
  "name.assignment": supported10,
  "name.assignment.pattern": supported10,
  "name.variable": supported10,
  "name.variable.pattern": supported10,
  "name.function": supported10,
  "name.method": supported10,
  "name.constructor": supported10,
  "name.class": supported10,
  "name.field": supported10,
  "name.iteration.document": supported10,
  "name.iteration.block": supported10,
  "key.mapPair": supported10,
  "key.mapPair.iteration": supported10,
  "value.argument.formal": supported10,
  "value.argument.formal.iteration": supported10,
  "value.argument.formal.method": supported10,
  "value.argument.formal.method.iteration": supported10,
  "value.argument.formal.constructor": supported10,
  "value.argument.formal.constructor.iteration": supported10,
  "value.mapPair": supported10,
  "value.mapPair.iteration": supported10,
  "value.assignment": supported10,
  "value.variable": supported10,
  "value.variable.pattern": supported10,
  "value.foreach": supported10,
  "value.return": supported10,
  "value.return.lambda": supported10,
  "value.field": supported10,
  "value.yield": supported10,
  "type.class": supported10,
  "interior.class": supported10,
  "interior.function": supported10,
  "interior.if": supported10,
  "interior.lambda": supported10,
  "interior.loop": supported10,
  "interior.switchCase": supported10,
  "interior.ternary": supported10,
  "interior.try": supported10,
  /* NOT APPLICABLE (JS & TS) */
  // Nested the classes
  "class.iteration.block": notApplicable9,
  "className.iteration.block": notApplicable9,
  // Section
  section: notApplicable9,
  "section.iteration.document": notApplicable9,
  "section.iteration.parent": notApplicable9,
  // Command
  command: notApplicable9,
  "interior.command": notApplicable9,
  // Notebook cell
  notebookCell: notApplicable9,
  "interior.cell": notApplicable9,
  // Resource
  "interior.resource": notApplicable9,
  "name.resource.iteration": notApplicable9,
  "name.resource": notApplicable9,
  "type.resource.iteration": notApplicable9,
  "type.resource": notApplicable9,
  "value.resource.iteration": notApplicable9,
  "value.resource": notApplicable9,
  // Keyword argument
  "name.argument.actual.iteration": notApplicable9,
  "name.argument.actual": notApplicable9,
  "value.argument.actual.iteration": notApplicable9,
  "value.argument.actual": notApplicable9,
  // Nested functions. Technically supported, but great problem with `every funk` in a method.
  "functionName.iteration.block": notApplicable9,
  "namedFunction.iteration.block": notApplicable9,
  // Miscellaneous
  environment: notApplicable9
};
var javascriptJsxScopeSupport = {
  element: supported10,
  tags: supported10,
  startTag: supported10,
  endTag: supported10,
  attribute: supported10,
  "key.attribute": supported10,
  "value.attribute": supported10,
  "interior.element": supported10,
  "textFragment.element": supported10
};
var javascriptScopeSupport = {
  ...javascriptCoreScopeSupport,
  ...javascriptJsxScopeSupport,
  // Types are defined here because we don't want typescript to import them and
  // accidentally forget to add support for them.
  "type.argument.formal": notApplicable9,
  "type.argument.formal.iteration": notApplicable9,
  "type.argument.formal.method": notApplicable9,
  "type.argument.formal.method.iteration": notApplicable9,
  "type.argument.formal.constructor": notApplicable9,
  "type.argument.formal.constructor.iteration": notApplicable9,
  "type.alias": notApplicable9,
  "type.cast": notApplicable9,
  "type.field": notApplicable9,
  "type.field.iteration": notApplicable9,
  "type.foreach": notApplicable9,
  "type.interface": notApplicable9,
  "type.enum": notApplicable9,
  "type.return": notApplicable9,
  "type.variable": notApplicable9,
  "type.typeArgument": notApplicable9,
  "type.typeArgument.iteration": notApplicable9,
  "value.typeAlias": notApplicable9
};

// ../common/src/scopeSupportFacets/javascriptreact.ts
var javascriptreactScopeSupport = {
  ...javascriptScopeSupport
};

// ../common/src/scopeSupportFacets/json.ts
var { supported: supported11, notApplicable: notApplicable10 } = ScopeSupportFacetLevel;
var jsonScopeSupport = {
  list: supported11,
  map: supported11,
  "string.singleLine": supported11,
  "key.mapPair.iteration": supported11,
  "key.mapPair": supported11,
  "value.mapPair.iteration": supported11,
  "value.mapPair": supported11,
  "comment.block": supported11,
  "comment.line": supported11,
  "textFragment.comment.block": supported11,
  "textFragment.comment.line": supported11,
  "textFragment.string.singleLine": supported11,
  // Not applicable
  anonymousFunction: notApplicable10,
  "argument.actual": notApplicable10,
  "argument.actual.constructor": notApplicable10,
  "argument.actual.constructor.iteration": notApplicable10,
  "argument.actual.iteration": notApplicable10,
  "argument.actual.method": notApplicable10,
  "argument.actual.method.iteration": notApplicable10,
  "argument.formal": notApplicable10,
  "argument.formal.constructor": notApplicable10,
  "argument.formal.constructor.iteration": notApplicable10,
  "argument.formal.iteration": notApplicable10,
  "argument.formal.method": notApplicable10,
  "argument.formal.method.iteration": notApplicable10,
  "argument.formal.lambda": notApplicable10,
  "argument.formal.lambda.iteration": notApplicable10,
  "argumentList.actual.empty": notApplicable10,
  "argumentList.actual.singleLine": notApplicable10,
  "argumentList.actual.multiLine": notApplicable10,
  "argumentList.actual.method.empty": notApplicable10,
  "argumentList.actual.method.singleLine": notApplicable10,
  "argumentList.actual.method.multiLine": notApplicable10,
  "argumentList.actual.constructor.empty": notApplicable10,
  "argumentList.actual.constructor.singleLine": notApplicable10,
  "argumentList.actual.constructor.multiLine": notApplicable10,
  "argumentList.formal.empty": notApplicable10,
  "argumentList.formal.singleLine": notApplicable10,
  "argumentList.formal.multiLine": notApplicable10,
  "argumentList.formal.lambda.empty": notApplicable10,
  "argumentList.formal.lambda.singleLine": notApplicable10,
  "argumentList.formal.lambda.multiLine": notApplicable10,
  "argumentList.formal.method.empty": notApplicable10,
  "argumentList.formal.method.singleLine": notApplicable10,
  "argumentList.formal.method.multiLine": notApplicable10,
  "argumentList.formal.constructor.empty": notApplicable10,
  "argumentList.formal.constructor.singleLine": notApplicable10,
  "argumentList.formal.constructor.multiLine": notApplicable10,
  attribute: notApplicable10,
  "branch.if": notApplicable10,
  "branch.if.iteration": notApplicable10,
  "branch.loop": notApplicable10,
  "branch.switchCase": notApplicable10,
  "branch.switchCase.iteration": notApplicable10,
  "branch.ternary": notApplicable10,
  "branch.try": notApplicable10,
  "branch.try.iteration": notApplicable10,
  class: notApplicable10,
  "class.iteration.block": notApplicable10,
  "class.iteration.document": notApplicable10,
  className: notApplicable10,
  "className.iteration.block": notApplicable10,
  "className.iteration.document": notApplicable10,
  "collectionItem.unenclosed": notApplicable10,
  "collectionItem.unenclosed.iteration": notApplicable10,
  command: notApplicable10,
  "condition.doWhile": notApplicable10,
  "condition.for": notApplicable10,
  "condition.if": notApplicable10,
  "condition.switchCase": notApplicable10,
  "condition.switchCase.iteration": notApplicable10,
  "condition.ternary": notApplicable10,
  "condition.while": notApplicable10,
  disqualifyDelimiter: notApplicable10,
  element: notApplicable10,
  endTag: notApplicable10,
  environment: notApplicable10,
  fieldAccess: notApplicable10,
  functionCall: notApplicable10,
  "functionCall.constructor": notApplicable10,
  functionCallee: notApplicable10,
  "functionCallee.constructor": notApplicable10,
  functionName: notApplicable10,
  "functionName.constructor": notApplicable10,
  "functionName.iteration.block": notApplicable10,
  "functionName.iteration.document": notApplicable10,
  "functionName.method": notApplicable10,
  "functionName.method.iteration.class": notApplicable10,
  ifStatement: notApplicable10,
  "interior.cell": notApplicable10,
  "interior.class": notApplicable10,
  "interior.command": notApplicable10,
  "interior.element": notApplicable10,
  "interior.function": notApplicable10,
  "interior.if": notApplicable10,
  "interior.lambda": notApplicable10,
  "interior.loop": notApplicable10,
  "interior.resource": notApplicable10,
  "interior.switchCase": notApplicable10,
  "interior.ternary": notApplicable10,
  "interior.try": notApplicable10,
  "key.attribute": notApplicable10,
  "name.argument.actual": notApplicable10,
  "name.argument.actual.iteration": notApplicable10,
  "name.argument.formal": notApplicable10,
  "name.argument.formal.constructor": notApplicable10,
  "name.argument.formal.constructor.iteration": notApplicable10,
  "name.argument.formal.iteration": notApplicable10,
  "name.argument.formal.method": notApplicable10,
  "name.argument.formal.method.iteration": notApplicable10,
  "name.assignment": notApplicable10,
  "name.assignment.pattern": notApplicable10,
  "name.class": notApplicable10,
  "name.constructor": notApplicable10,
  "name.field": notApplicable10,
  "name.foreach": notApplicable10,
  "name.function": notApplicable10,
  "name.iteration.block": notApplicable10,
  "name.iteration.document": notApplicable10,
  "name.method": notApplicable10,
  "name.resource": notApplicable10,
  "name.resource.iteration": notApplicable10,
  "name.variable": notApplicable10,
  "name.variable.pattern": notApplicable10,
  namedFunction: notApplicable10,
  "namedFunction.constructor": notApplicable10,
  "namedFunction.iteration.block": notApplicable10,
  "namedFunction.iteration.document": notApplicable10,
  "namedFunction.method": notApplicable10,
  "namedFunction.method.iteration.class": notApplicable10,
  notebookCell: notApplicable10,
  pairDelimiter: notApplicable10,
  regularExpression: notApplicable10,
  section: notApplicable10,
  "section.iteration.document": notApplicable10,
  "section.iteration.parent": notApplicable10,
  startTag: notApplicable10,
  statement: notApplicable10,
  "statement.class": notApplicable10,
  "statement.iteration.block": notApplicable10,
  "statement.iteration.document": notApplicable10,
  "string.multiLine": notApplicable10,
  switchStatementSubject: notApplicable10,
  tags: notApplicable10,
  "textFragment.element": notApplicable10,
  "textFragment.string.multiLine": notApplicable10,
  "type.alias": notApplicable10,
  "type.argument.formal": notApplicable10,
  "type.argument.formal.constructor": notApplicable10,
  "type.argument.formal.constructor.iteration": notApplicable10,
  "type.argument.formal.iteration": notApplicable10,
  "type.argument.formal.method": notApplicable10,
  "type.argument.formal.method.iteration": notApplicable10,
  "type.cast": notApplicable10,
  "type.class": notApplicable10,
  "type.enum": notApplicable10,
  "type.field": notApplicable10,
  "type.field.iteration": notApplicable10,
  "type.foreach": notApplicable10,
  "type.interface": notApplicable10,
  "type.resource": notApplicable10,
  "type.resource.iteration": notApplicable10,
  "type.return": notApplicable10,
  "type.typeArgument": notApplicable10,
  "type.typeArgument.iteration": notApplicable10,
  "type.variable": notApplicable10,
  "value.argument.actual": notApplicable10,
  "value.argument.actual.iteration": notApplicable10,
  "value.argument.formal": notApplicable10,
  "value.argument.formal.constructor": notApplicable10,
  "value.argument.formal.constructor.iteration": notApplicable10,
  "value.argument.formal.iteration": notApplicable10,
  "value.argument.formal.method": notApplicable10,
  "value.argument.formal.method.iteration": notApplicable10,
  "value.assignment": notApplicable10,
  "value.attribute": notApplicable10,
  "value.field": notApplicable10,
  "value.foreach": notApplicable10,
  "value.resource": notApplicable10,
  "value.resource.iteration": notApplicable10,
  "value.return": notApplicable10,
  "value.return.lambda": notApplicable10,
  "value.typeAlias": notApplicable10,
  "value.variable": notApplicable10,
  "value.variable.pattern": notApplicable10,
  "value.yield": notApplicable10
};

// ../common/src/scopeSupportFacets/jsonc.ts
var { supported: supported12, unsupported: unsupported7, notApplicable: notApplicable11 } = ScopeSupportFacetLevel;
var jsoncScopeSupport = {
  ...jsonScopeSupport
};

// ../common/src/scopeSupportFacets/jsonl.ts
var { supported: supported13, unsupported: unsupported8, notApplicable: notApplicable12 } = ScopeSupportFacetLevel;
var jsonlScopeSupport = {
  ...jsonScopeSupport
};

// ../common/src/scopeSupportFacets/latex.ts
var { supported: supported14, unsupported: unsupported9, notApplicable: notApplicable13 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/lua.ts
var { supported: supported15, notApplicable: notApplicable14 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/markdown.ts
var { supported: supported16, notApplicable: notApplicable15 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/php.ts
var { supported: supported17, unsupported: unsupported10, notApplicable: notApplicable16 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/python.ts
var { supported: supported18, notApplicable: notApplicable17 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/r.ts
var { supported: supported19, unsupported: unsupported11, notApplicable: notApplicable18 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/ruby.ts
var { supported: supported20, unsupported: unsupported12, notApplicable: notApplicable19 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/rust.ts
var { supported: supported21, unsupported: unsupported13, notApplicable: notApplicable20 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/scala.ts
var { supported: supported22, unsupported: unsupported14, notApplicable: notApplicable21 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/scm.ts
var { supported: supported23, notApplicable: notApplicable22 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/scss.ts
var { supported: supported24 } = ScopeSupportFacetLevel;
var scssScopeSupport = {
  ...cssScopeSupport,
  "comment.line": supported24,
  namedFunction: supported24,
  "namedFunction.iteration.block": supported24,
  "namedFunction.iteration.document": supported24,
  functionName: supported24,
  "functionName.iteration.block": supported24,
  "functionName.iteration.document": supported24,
  "name.argument.formal": supported24,
  "name.argument.formal.iteration": supported24,
  "name.function": supported24,
  "value.argument.formal": supported24,
  "value.argument.formal.iteration": supported24,
  "value.return": supported24,
  "textFragment.comment.line": supported24,
  ifStatement: supported24,
  "branch.if": supported24,
  "branch.if.iteration": supported24,
  "condition.if": supported24,
  "interior.if": supported24,
  "interior.function": supported24
};

// ../common/src/scopeSupportFacets/talon.ts
var { supported: supported25, unsupported: unsupported15, notApplicable: notApplicable23 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/typescript.ts
var { supported: supported26, notApplicable: notApplicable24 } = ScopeSupportFacetLevel;
var typescriptScopeSupport = {
  ...javascriptCoreScopeSupport,
  "type.argument.formal": supported26,
  "type.argument.formal.iteration": supported26,
  "type.argument.formal.method": supported26,
  "type.argument.formal.method.iteration": supported26,
  "type.argument.formal.constructor": supported26,
  "type.argument.formal.constructor.iteration": supported26,
  "type.alias": supported26,
  "type.cast": supported26,
  "type.field": supported26,
  "type.field.iteration": supported26,
  "type.interface": supported26,
  "type.enum": supported26,
  "type.return": supported26,
  "type.variable": supported26,
  "type.typeArgument": supported26,
  "type.typeArgument.iteration": supported26,
  "value.typeAlias": supported26,
  /* NOT APPLICABLE */
  // Element and tags
  element: notApplicable24,
  tags: notApplicable24,
  startTag: notApplicable24,
  endTag: notApplicable24,
  attribute: notApplicable24,
  "key.attribute": notApplicable24,
  "value.attribute": notApplicable24,
  "interior.element": notApplicable24,
  "textFragment.element": notApplicable24,
  // Miscellaneous
  "type.foreach": notApplicable24
};

// ../common/src/scopeSupportFacets/typescriptreact.ts
var typescriptreactScopeSupport = {
  ...typescriptScopeSupport,
  ...javascriptJsxScopeSupport
};

// ../common/src/scopeSupportFacets/xml.ts
var { supported: supported27, notApplicable: notApplicable25 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/yaml.ts
var { supported: supported28, unsupported: unsupported16, notApplicable: notApplicable26 } = ScopeSupportFacetLevel;

// ../common/src/StoredTargetKey.ts
var storedTargetKeys = [
  "that",
  "source",
  "instanceReference",
  "keyboard"
];

// ../common/src/types/Selection.ts
var Selection = class extends Range {
  /**
   * Is true if active position is before anchor position.
   */
  get isReversed() {
    return this.active.isBefore(this.anchor);
  }
  constructor(...args2) {
    const [anchor, active] = (() => {
      if (args2.length === 2) {
        return args2;
      }
      return [new Position(args2[0], args2[1]), new Position(args2[2], args2[3])];
    })();
    super(anchor, active);
    this.anchor = anchor;
    this.active = active;
  }
  /**
   * Check if `other` equals this range.
   *
   * @param other A selection.
   * @return `true` when anchor and active are {@link Position.isEqual equal} to
   * anchor and active of this range.
   */
  isEqual(other) {
    return this.anchor.isEqual(other.anchor) && this.active.isEqual(other.active);
  }
  /**
   * Return a concise string representation of the selection. 0-based.
   * @returns concise representation
   **/
  concise() {
    return `${this.anchor.concise()}->${this.active.concise()}`;
  }
  /**
   * Return a concise string representation of the selection. 1-based.
   * @returns concise representation
   **/
  conciseOneBased() {
    return `${this.start.conciseOneBased()}->${this.end.conciseOneBased()}`;
  }
  toString() {
    return this.concise();
  }
};

// ../common/src/types/GeneralizedRange.ts
function toLineRange({ start: start2, end }) {
  return { type: "line", start: start2.line, end: end.line };
}
function toCharacterRange({ start: start2, end }) {
  return { type: "character", start: start2, end };
}

// ../common/src/util/toPlainObject.ts
function rangeToPlainObject(range3) {
  return {
    start: positionToPlainObject(range3.start),
    end: positionToPlainObject(range3.end)
  };
}
function positionToPlainObject({
  line,
  character
}) {
  return { line, character };
}

// ../../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject2(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat2(string2, count2) {
  var result = "", cycle;
  for (cycle = 0; cycle < count2; cycle += 1) {
    result += string2;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject2;
var toArray_1 = toArray;
var repeat_1 = repeat2;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString2(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string2, max) {
  return common.repeat(" ", max - string2.length) + string2;
}
function makeSnippet(mark, options2) {
  options2 = Object.create(options2 || null);
  if (!mark.buffer) return null;
  if (!options2.maxLength) options2.maxLength = 79;
  if (typeof options2.indent !== "number") options2.indent = 1;
  if (typeof options2.linesBefore !== "number") options2.linesBefore = 3;
  if (typeof options2.linesAfter !== "number") options2.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i2, line;
  var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options2.linesBefore; i2++) {
    if (foundLineNo - i2 < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i2],
      lineEnds[foundLineNo - i2],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
      maxLineLength
    );
    result = common.repeat(" ", options2.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i2 = 1; i2 <= options2.linesAfter; i2++) {
    if (foundLineNo + i2 >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i2],
      lineEnds[foundLineNo + i2],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
      maxLineLength
    );
    result += common.repeat(" ", options2.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map3) {
  var result = {};
  if (map3 !== null) {
    Object.keys(map3).forEach(function(style) {
      map3[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options2) {
  options2 = options2 || {};
  Object.keys(options2).forEach(function(name2) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
      throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options2;
  this.tag = tag;
  this.kind = options2["kind"] || null;
  this.resolve = options2["resolve"] || function() {
    return true;
  };
  this.construct = options2["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options2["instanceOf"] || null;
  this.predicate = options2["predicate"] || null;
  this.represent = options2["represent"] || null;
  this.representName = options2["representName"] || null;
  this.defaultStyle = options2["defaultStyle"] || null;
  this.multi = options2["multi"] || false;
  this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema3, name2) {
  var result = [];
  schema3[name2].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map3.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map3 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map3.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map3[bits >> 18 & 63];
      result += map3[bits >> 12 & 63];
      result += map3[bits >> 6 & 63];
      result += map3[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map3[bits >> 18 & 63];
    result += map3[bits >> 12 & 63];
    result += map3[bits >> 6 & 63];
    result += map3[bits & 63];
  } else if (tail === 2) {
    result += map3[bits >> 10 & 63];
    result += map3[bits >> 4 & 63];
    result += map3[bits << 2 & 63];
    result += map3[64];
  } else if (tail === 1) {
    result += map3[bits >> 2 & 63];
    result += map3[bits << 4 & 63];
    result += map3[64];
    result += map3[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary2 = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys2, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys2 = Object.keys(pair);
    if (keys2.length !== 1) return false;
    result[index] = [keys2[0], pair[keys2[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys2, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys2 = Object.keys(pair);
    result[index] = [keys2[0], pair[keys2[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary2,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i2 = 0; i2 < 256; i2++) {
  simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
  simpleEscapeMap[i2] = simpleEscapeSequence(i2);
}
var i2;
function State$1(input, options2) {
  this.input = input;
  this.filename = options2["filename"] || null;
  this.schema = options2["schema"] || _default;
  this.onWarning = options2["onWarning"] || null;
  this.legacy = options2["legacy"] || false;
  this.json = options2["json"] || false;
  this.listener = options2["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name2, args2) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args2.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args2[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args2[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name2, args2) {
    var handle2, prefix;
    if (args2.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle2 = args2[0];
    prefix = args2[1];
    if (!PATTERN_TAG_HANDLE.test(handle2)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle2)) {
      throwError(state, 'there is a previously declared suffix for "' + handle2 + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err2) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle2] = prefix;
  }
};
function captureSegment(state, start2, end, checkJson) {
  var _position, _length, _character, _result;
  if (start2 < end) {
    _result = state.input.slice(start2, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count2) {
  if (count2 === 1) {
    state.result += " ";
  } else if (count2 > 1) {
    state.result += common.repeat("\n", count2 - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err2) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options2) {
  input = String(input);
  options2 = options2 || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options2);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options2) {
  if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options2);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options2) {
  var documents = loadDocuments(input, options2);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema3, map3) {
  var result, keys2, index, length, tag, style, type2;
  if (map3 === null) return {};
  result = {};
  keys2 = Object.keys(map3);
  for (index = 0, length = keys2.length; index < length; index += 1) {
    tag = keys2[index];
    style = String(map3[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema3.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string2, handle2, length;
  string2 = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle2 = "x";
    length = 2;
  } else if (character <= 65535) {
    handle2 = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle2 = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle2 + common.repeat("0", length - string2.length) + string2;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options2) {
  this.schema = options2["schema"] || _default;
  this.indent = Math.max(1, options2["indent"] || 2);
  this.noArrayIndent = options2["noArrayIndent"] || false;
  this.skipInvalid = options2["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
  this.sortKeys = options2["sortKeys"] || false;
  this.lineWidth = options2["lineWidth"] || 80;
  this.noRefs = options2["noRefs"] || false;
  this.noCompatMode = options2["noCompatMode"] || false;
  this.condenseFlow = options2["condenseFlow"] || false;
  this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options2["forceQuotes"] || false;
  this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string2, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string2.length;
  while (position < length) {
    next = string2.indexOf("\n", position);
    if (next === -1) {
      line = string2.slice(position);
      position = length;
    } else {
      line = string2.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string2, pos) {
  var first = string2.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
    second = string2.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string2) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string2);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i2;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i2 = 0; i2 < string2.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string2, i2);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i2 = 0; i2 < string2.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string2, i2);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i2 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
          previousLineBreak = i2;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string2)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string2)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string2, level, iskey, inblock) {
  state.dump = function() {
    if (string2.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string3) {
      return testImplicitResolving(state, string3);
    }
    switch (chooseScalarStyle(
      string2,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string2;
      case STYLE_SINGLE:
        return "'" + string2.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string2) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string2, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
  var clip = string2[string2.length - 1] === "\n";
  var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string2) {
  return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
}
function foldString(string2, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string2.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string2.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string2.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string2)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start2 = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start2 > width) {
      end = curr > start2 ? curr : next;
      result += "\n" + line.slice(start2, end);
      start2 = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start2 > width && curr > start2) {
    result += line.slice(start2, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start2);
  }
  return result.slice(1);
}
function escapeString(string2) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i2 = 0; i2 < string2.length; char >= 65536 ? i2 += 2 : i2++) {
    char = codePointAt(string2, i2);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string2[i2];
      if (char >= 65536) result += string2[i2 + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options2) {
  options2 = options2 || {};
  var state = new State(options2);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// ../common/src/testUtil/serialize.ts
var CustomDump = class {
  constructor(data, opts) {
    this.data = data;
    this.opts = opts;
  }
  represent() {
    let result = dump(
      this.data,
      Object.assign({ replacer, schema: schema2 }, this.opts)
    );
    result = result.trim();
    if (result.includes("\n")) {
      result = "\n" + result;
    }
    return result;
  }
};
var customDumpType = new Type("!format", {
  kind: "scalar",
  resolve: () => false,
  instanceOf: CustomDump,
  represent: (d) => d.represent()
});
var schema2 = DEFAULT_SCHEMA.extend({ implicit: [customDumpType] });
var isObject3 = (value) => typeof value === "object" && value != null;
function hasSimpleChildren(value) {
  if (isObject3(value)) {
    return Object.values(value).every(
      (value2) => !isObject3(value2) && !Array.isArray(value2)
    );
  }
  if (Array.isArray(value)) {
    return value.every((value2) => !isObject3(value2) && !Array.isArray(value2));
  }
}
function replacer(key, value) {
  if (key === "") {
    return value;
  }
  if (hasSimpleChildren(value)) {
    return new CustomDump(value, { flowLevel: 0 });
  }
  return value;
}

// ../common/src/types/command/ActionDescriptor.ts
var simpleActionNames = [
  "addSelection",
  "addSelectionAfter",
  "addSelectionBefore",
  "breakLine",
  "clearAndSetSelection",
  "copyToClipboard",
  "cutToClipboard",
  "decrement",
  "deselect",
  "editNewLineAfter",
  "editNewLineBefore",
  "experimental.setInstanceReference",
  "extractVariable",
  "findInDocument",
  "findInWorkspace",
  "flashTargets",
  "foldRegion",
  "followLink",
  "followLinkAside",
  "gitAccept",
  "gitRevert",
  "gitStage",
  "gitUnstage",
  "increment",
  "indentLine",
  "insertCopyAfter",
  "insertCopyBefore",
  "insertEmptyLineAfter",
  "insertEmptyLineBefore",
  "insertEmptyLinesAround",
  "joinLines",
  "outdentLine",
  "randomizeTargets",
  "remove",
  "rename",
  "revealDefinition",
  "revealTypeDefinition",
  "reverseTargets",
  "scrollToBottom",
  "scrollToCenter",
  "scrollToTop",
  "setSelection",
  "setSelectionAfter",
  "setSelectionBefore",
  "showDebugHover",
  "showHover",
  "showQuickFix",
  "showReferences",
  "sortTargets",
  "toggleLineBreakpoint",
  "toggleLineComment",
  "unfoldRegion",
  "private.getTargets",
  "private.setKeyboardTarget",
  "private.showParseTree"
];
var complexActionNames = [
  "callAsFunction",
  "editNew",
  "executeCommand",
  "generateSnippet",
  "getText",
  "highlight",
  "insertSnippet",
  "moveToTarget",
  "pasteFromClipboard",
  "replace",
  "replaceWithTarget",
  "rewrapWithPairedDelimiter",
  "swapTargets",
  "wrapWithPairedDelimiter",
  "wrapWithSnippet",
  "parsed"
];
var actionNames = [
  ...simpleActionNames,
  ...complexActionNames
];

// ../common/src/types/command/command.types.ts
var LATEST_VERSION = 7;

// ../common/src/types/command/PartialTargetDescriptor.types.ts
var simpleSurroundingPairNames = [
  "angleBrackets",
  "backtickQuotes",
  "curlyBrackets",
  "doubleQuotes",
  "escapedDoubleQuotes",
  "escapedParentheses",
  "escapedSingleQuotes",
  "escapedSquareBrackets",
  "parentheses",
  "singleQuotes",
  "squareBrackets",
  "tripleBacktickQuotes",
  "tripleDoubleQuotes",
  "tripleSingleQuotes"
];
var complexSurroundingPairNames = [
  "string",
  "any",
  "collectionBoundary"
];
var surroundingPairNames = [
  ...simpleSurroundingPairNames,
  ...complexSurroundingPairNames
];
var simpleScopeTypeTypes = [
  "argumentOrParameter",
  "argumentList",
  "anonymousFunction",
  "attribute",
  "branch",
  "class",
  "className",
  "collectionItem",
  "collectionKey",
  "comment",
  "private.fieldAccess",
  "functionCall",
  "functionCallee",
  "functionName",
  "ifStatement",
  "instance",
  "list",
  "map",
  "name",
  "namedFunction",
  "regularExpression",
  "statement",
  "string",
  "type",
  "value",
  "condition",
  "section",
  "sectionLevelOne",
  "sectionLevelTwo",
  "sectionLevelThree",
  "sectionLevelFour",
  "sectionLevelFive",
  "sectionLevelSix",
  "selector",
  "private.switchStatementSubject",
  "unit",
  "xmlBothTags",
  "xmlElement",
  "xmlEndTag",
  "xmlStartTag",
  // Latex scope types
  "part",
  "chapter",
  "subSection",
  "subSubSection",
  "namedParagraph",
  "subParagraph",
  "environment",
  // Text based scopes
  "character",
  "word",
  "token",
  "identifier",
  "line",
  "sentence",
  "paragraph",
  "boundedParagraph",
  "document",
  "nonWhitespaceSequence",
  "boundedNonWhitespaceSequence",
  "url",
  "notebookCell",
  // Talon
  "command",
  // Private scope types
  "textFragment",
  "disqualifyDelimiter",
  "pairDelimiter"
];
function isSimpleScopeType(scopeType) {
  return simpleScopeTypeTypes.includes(scopeType.type);
}

// ../common/src/types/TalonSpokenForms.ts
var SUPPORTED_ENTRY_TYPES = [
  "simpleScopeTypeType",
  "complexScopeTypeType",
  "customRegex",
  "pairedDelimiter",
  "action",
  "customAction",
  "grapheme"
];
var NeedsInitialTalonUpdateError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NeedsInitialTalonUpdateError";
  }
};
var DisabledCustomSpokenFormsError = class extends Error {
  constructor() {
    super("Custom spoken forms are not currently supported in this ide");
    this.name = "DisabledCustomSpokenFormsError";
  }
};

// ../common/src/util/camelCaseToAllDown.ts
function camelCaseToAllDown(input) {
  return input.replace(/([A-Z])/g, " $1").split(" ").map((word) => word.toLowerCase()).join(" ");
}

// ../common/src/util/clientSupportsFallback.ts
function clientSupportsFallback(command) {
  return command.version >= 7;
}

// ../common/src/util/CompositeKeyMap.ts
var CompositeKeyMap = class {
  /**
   *
   * @param hashFunction A function that maps from a key to a list whose entries can be converted to string
   */
  constructor(hashFunction) {
    this.hashFunction = hashFunction;
    this.map = {};
  }
  hash(key) {
    return this.hashFunction(key).join("\0");
  }
  set(key, item) {
    this.map[this.hash(key)] = item;
    return this;
  }
  has(key) {
    return this.hash(key) in this.map;
  }
  get(key) {
    return this.map[this.hash(key)];
  }
  delete(key) {
    delete this.map[this.hash(key)];
    return this;
  }
  clear() {
    this.map = {};
    return this;
  }
};

// ../common/src/util/DefaultMap.ts
var DefaultMap = class extends Map {
  /**
   * @param getDefaultValue A function that returns the default value for a given key
   */
  constructor(getDefaultValue) {
    super();
    this.getDefaultValue = getDefaultValue;
  }
  get(key) {
    const currentValue = super.get(key);
    if (currentValue != null) {
      return currentValue;
    }
    const value = this.getDefaultValue(key);
    this.set(key, value);
    return value;
  }
};

// ../common/src/util/disposableFrom.ts
function disposableFrom(...disposables) {
  return {
    dispose() {
      disposables.forEach(({ dispose }) => {
        try {
          dispose();
        } catch (e) {
          console.error(e);
        }
      });
    }
  };
}

// ../common/src/util/type.ts
function isString(arg) {
  return typeof arg === "string" || arg instanceof String;
}

// ../common/src/util/ensureCommandShape.ts
function ensureCommandShape(args2) {
  const [spokenFormOrCommand, ...rest] = args2;
  return handleLegacyCommandShape(spokenFormOrCommand, rest);
}
function handleLegacyCommandShape(spokenFormOrCommand, rest) {
  let command;
  if (isString(spokenFormOrCommand)) {
    const spokenForm = spokenFormOrCommand;
    const [action, targets, ...extraArgs] = rest;
    command = {
      version: 0,
      spokenForm,
      action,
      targets,
      extraArgs,
      usePrePhraseSnapshot: false
    };
  } else {
    command = spokenFormOrCommand;
  }
  return command;
}

// ../common/src/util/itertools.ts
function groupBy(list, func2) {
  const map3 = /* @__PURE__ */ new Map();
  list.forEach((element) => {
    const key = func2(element);
    let group;
    if (map3.has(key)) {
      group = map3.get(key);
    } else {
      group = [];
      map3.set(key, group);
    }
    group.push(element);
  });
  return map3;
}
function isEmptyIterable(iterable) {
  for (const _ of iterable) {
    return false;
  }
  return true;
}

// ../common/src/util/object.ts
function unsafeKeys(o) {
  return Object.keys(o);
}

// ../common/src/util/selectionsEqual.ts
function selectionsEqual(a, b) {
  return a.length === b.length && a.every((selection, i2) => selection.isEqual(b[i2]));
}

// ../common/src/util/splitKey.ts
function getKey(hatStyle, character) {
  return `${hatStyle}.${character}`;
}

// ../common/src/util/uniqWithHash.ts
function uniqWithHash(array, isEqual2, hash) {
  if (array.length < 2) {
    return [...array];
  }
  if (array.length === 2) {
    if (isEqual2(array[0], array[1])) {
      return [array[0]];
    }
    return [...array];
  }
  const needsUniq = [];
  const hashToItems = array.reduce((acc, item) => {
    const key = hash(item);
    const items = acc.get(key);
    if (items == null) {
      acc.set(key, [item]);
      return acc;
    }
    acc.get(key).push(item);
    if (items.length === 2) {
      needsUniq.push(key);
    }
    return acc;
  }, /* @__PURE__ */ new Map());
  if (needsUniq.length === 0) {
    return [...array];
  }
  needsUniq.forEach((key) => {
    hashToItems.set(key, uniqWith_default(hashToItems.get(key), isEqual2));
  });
  return array.flatMap((item) => {
    const key = hash(item);
    const items = hashToItems.get(key);
    if (items == null || items.length === 0) {
      return [];
    }
    const first = items[0];
    if (!isEqual2(first, item)) {
      return [];
    }
    items.shift();
    return first;
  });
}

// ../common/src/util/zipStrict.ts
function zipStrict(list1, list2) {
  if (list1.length !== list2.length) {
    throw new Error("Lists must have the same length");
  }
  return list1.map((value, index) => [value, list2[index]]);
}

// src/ide/JetbrainsHats.ts
var JetbrainsHats = class {
  constructor(client) {
    this.isEnabledNotifier = new Notifier();
    this.hatStyleChangedNotifier = new Notifier();
    this.hatRanges = [];
    this.enabledHatShapes = ["default"];
    this.hatShapePenalties = /* @__PURE__ */ new Map([["default", 0]]);
    this.enabledHatColors = ["default"];
    this.hatColorPenalties = /* @__PURE__ */ new Map([["default", 0]]);
    this.isEnabled = true;
    this.client = client;
    this.enabledHatStyles = this.generateHatStyles();
  }
  setHatRanges(hatRanges) {
    this.hatRanges = hatRanges;
    const jbHatRanges = this.toJetbransHatRanges(hatRanges);
    const hatsJson = JSON.stringify(jbHatRanges);
    this.client.hatsUpdated(hatsJson);
    return Promise.resolve();
  }
  setEnabledHatShapes(enabledHatShapes) {
    this.enabledHatShapes = enabledHatShapes;
    this.enabledHatStyles = this.generateHatStyles();
    this.hatStyleChangedNotifier.notifyListeners(this.enabledHatStyles);
  }
  setHatShapePenalties(hatShapePenalties) {
    this.hatShapePenalties = new Map(
      Object.entries(hatShapePenalties)
    );
    this.enabledHatStyles = this.generateHatStyles();
    this.hatStyleChangedNotifier.notifyListeners(this.enabledHatStyles);
  }
  setEnabledHatColors(enabledHatColors) {
    this.enabledHatColors = enabledHatColors;
    this.enabledHatStyles = this.generateHatStyles();
    this.hatStyleChangedNotifier.notifyListeners(this.enabledHatStyles);
  }
  setHatColorPenalties(hatColorPenalties) {
    this.hatColorPenalties = new Map(
      Object.entries(hatColorPenalties)
    );
    this.enabledHatStyles = this.generateHatStyles();
    this.hatStyleChangedNotifier.notifyListeners(this.enabledHatStyles);
  }
  toJetbransHatRanges(hatRanges) {
    return hatRanges.map((range3) => {
      return {
        styleName: range3.styleName,
        editorId: range3.editor.id,
        range: range3.range
      };
    });
  }
  generateHatStyles() {
    const res = /* @__PURE__ */ new Map();
    for (const color of this.enabledHatColors) {
      const colorPenalty = this.getColorPenalty(color);
      for (const shape of this.enabledHatShapes) {
        const shapePenalty = this.getShapePenalty(shape);
        let styleName;
        if (shape === "default") {
          styleName = color;
        } else {
          styleName = `${color}-${shape}`;
        }
        res.set(styleName, { penalty: colorPenalty + shapePenalty });
      }
    }
    return Object.fromEntries(res);
  }
  getShapePenalty(shape) {
    let shapePenalty = this.hatShapePenalties.get(shape);
    if (shapePenalty == null) {
      shapePenalty = shape === "default" ? 0 : 2;
    } else {
      shapePenalty = shape === "default" ? shapePenalty : shapePenalty + 1;
    }
    return shapePenalty;
  }
  getColorPenalty(color) {
    let colorPenalty = this.hatColorPenalties.get(color);
    if (colorPenalty == null) {
      colorPenalty = color === "default" ? 0 : 1;
    }
    return colorPenalty;
  }
  onDidChangeEnabledHatStyles(listener) {
    return this.hatStyleChangedNotifier.registerListener(listener);
  }
  onDidChangeIsEnabled(listener) {
    return this.isEnabledNotifier.registerListener(listener);
  }
  toggle(isEnabled) {
    this.isEnabled = isEnabled ?? !this.isEnabled;
    this.isEnabledNotifier.notifyListeners(this.isEnabled);
  }
};

// src/ide/JetbrainsPlugin.ts
var JetbrainsPlugin = class {
  constructor(client, ide2, hats) {
    this.client = client;
    this.ide = ide2;
    this.hats = hats;
  }
};
function createPlugin(client, ide2) {
  const hats = new JetbrainsHats(client);
  return new JetbrainsPlugin(client, ide2, hats);
}

// src/ide/JetbrainsConfiguration.ts
var JetbrainsConfiguration = class {
  constructor(configuration) {
    this.notifier = new Notifier();
    this.configuration = CONFIGURATION_DEFAULTS;
    this.onDidChangeConfiguration = this.notifier.registerListener;
    this.configuration = configuration;
  }
  getOwnConfiguration(path, _scope) {
    return get_default(this.configuration, path);
  }
  updateConfiguration(configuration) {
    this.configuration = configuration;
    this.notifier.notifyListeners();
  }
};
function createJetbrainsConfiguration(configuration) {
  return new JetbrainsConfiguration(configuration);
}

// src/ide/JetbrainsCapabilities.ts
var COMMAND_CAPABILITIES = {
  clipboardCopy: { acceptsLocation: true },
  clipboardPaste: true,
  toggleLineComment: { acceptsLocation: true },
  indentLine: { acceptsLocation: true },
  outdentLine: { acceptsLocation: true },
  rename: { acceptsLocation: true },
  quickFix: { acceptsLocation: true },
  revealDefinition: { acceptsLocation: true },
  revealTypeDefinition: { acceptsLocation: true },
  showHover: void 0,
  showDebugHover: void 0,
  extractVariable: { acceptsLocation: true },
  fold: { acceptsLocation: true },
  highlight: { acceptsLocation: true },
  unfold: { acceptsLocation: true },
  showReferences: { acceptsLocation: true },
  insertLineAfter: { acceptsLocation: true },
  gitAccept: { acceptsLocation: false },
  gitRevert: { acceptsLocation: false },
  gitStage: { acceptsLocation: false },
  gitUnstage: { acceptsLocation: false }
};
var JetbrainsCapabilities = class {
  constructor() {
    this.commands = COMMAND_CAPABILITIES;
  }
};

// src/ide/JetbrainsEvents.ts
function fromJetbrainsContentChange(document2, firstLine, lastLine, linedata) {
  const result = [];
  const text = linedata.join("\n");
  const range3 = new Range(
    new Position(firstLine, 0),
    new Position(lastLine - 1, document2.lineAt(lastLine - 1).text.length)
  );
  const rangeOffset = document2.offsetAt(range3.start);
  const rangeLength = document2.offsetAt(range3.end) - rangeOffset;
  result.push({
    range: range3,
    rangeOffset,
    rangeLength,
    text
  });
  return result;
}

// src/ide/JetbrainsClipboard.ts
var JetbrainsClipboard = class {
  constructor(client) {
    this.client = client;
  }
  async readText() {
    return "";
  }
  async writeText(_value) {
    return;
  }
  async copy(editorId, ranges) {
    const rangesJson = JSON.stringify(ranges);
    this.client.clipboardCopy(editorId, rangesJson);
  }
  async paste(editorId) {
    this.client.clipboardPaste(editorId);
  }
};

// src/ide/JetbrainsMessages.ts
var JetbrainsMessages = class {
  async showMessage(_type, _id, _message, ..._options) {
    return void 0;
  }
};

// src/ide/JetbrainsKeyValueStore.ts
var JetbrainsKeyValueStore = class {
  constructor() {
    this.data = { ...KEY_VALUE_STORE_DEFAULTS };
  }
  get(key) {
    return this.data[key];
  }
  set(key, value) {
    this.data[key] = value;
    return Promise.resolve();
  }
};

// ../../node_modules/.pnpm/vscode-uri@3.1.0/node_modules/vscode-uri/lib/esm/index.mjs
var LIB;
(() => {
  "use strict";
  var t = { 975: (t2) => {
    function e2(t3) {
      if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", i3 = 0, o2 = -1, s2 = 0, h2 = 0; h2 <= t3.length; ++h2) {
        if (h2 < t3.length) r3 = t3.charCodeAt(h2);
        else {
          if (47 === r3) break;
          r3 = 47;
        }
        if (47 === r3) {
          if (o2 === h2 - 1 || 1 === s2) ;
          else if (o2 !== h2 - 1 && 2 === s2) {
            if (n3.length < 2 || 2 !== i3 || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
              if (n3.length > 2) {
                var a2 = n3.lastIndexOf("/");
                if (a2 !== n3.length - 1) {
                  -1 === a2 ? (n3 = "", i3 = 0) : i3 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), o2 = h2, s2 = 0;
                  continue;
                }
              } else if (2 === n3.length || 1 === n3.length) {
                n3 = "", i3 = 0, o2 = h2, s2 = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i3 = 2);
          } else n3.length > 0 ? n3 += "/" + t3.slice(o2 + 1, h2) : n3 = t3.slice(o2 + 1, h2), i3 = h2 - o2 - 1;
          o2 = h2, s2 = 0;
        } else 46 === r3 && -1 !== s2 ? ++s2 : s2 = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", i3 = false, o2 = arguments.length - 1; o2 >= -1 && !i3; o2--) {
        var s2;
        o2 >= 0 ? s2 = arguments[o2] : (void 0 === t3 && (t3 = process.cwd()), s2 = t3), e2(s2), 0 !== s2.length && (n3 = s2 + "/" + n3, i3 = 47 === s2.charCodeAt(0));
      }
      return n3 = r2(n3, !i3), i3 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      var n3 = 47 === t3.charCodeAt(0), i3 = 47 === t3.charCodeAt(t3.length - 1);
      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i3 && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
    }, join: function() {
      if (0 === arguments.length) return ".";
      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
        var i3 = arguments[r3];
        e2(i3), i3.length > 0 && (void 0 === t3 ? t3 = i3 : t3 += "/" + i3);
      }
      return void 0 === t3 ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3) return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
      for (var i3 = 1; i3 < t3.length && 47 === t3.charCodeAt(i3); ++i3) ;
      for (var o2 = t3.length, s2 = o2 - i3, h2 = 1; h2 < r3.length && 47 === r3.charCodeAt(h2); ++h2) ;
      for (var a2 = r3.length - h2, c2 = s2 < a2 ? s2 : a2, f2 = -1, u2 = 0; u2 <= c2; ++u2) {
        if (u2 === c2) {
          if (a2 > c2) {
            if (47 === r3.charCodeAt(h2 + u2)) return r3.slice(h2 + u2 + 1);
            if (0 === u2) return r3.slice(h2 + u2);
          } else s2 > c2 && (47 === t3.charCodeAt(i3 + u2) ? f2 = u2 : 0 === u2 && (f2 = 0));
          break;
        }
        var l2 = t3.charCodeAt(i3 + u2);
        if (l2 !== r3.charCodeAt(h2 + u2)) break;
        47 === l2 && (f2 = u2);
      }
      var g2 = "";
      for (u2 = i3 + f2 + 1; u2 <= o2; ++u2) u2 !== o2 && 47 !== t3.charCodeAt(u2) || (0 === g2.length ? g2 += ".." : g2 += "/..");
      return g2.length > 0 ? g2 + r3.slice(h2 + f2) : (h2 += f2, 47 === r3.charCodeAt(h2) && ++h2, r3.slice(h2));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i3 = -1, o2 = true, s2 = t3.length - 1; s2 >= 1; --s2) if (47 === (r3 = t3.charCodeAt(s2))) {
        if (!o2) {
          i3 = s2;
          break;
        }
      } else o2 = false;
      return -1 === i3 ? n3 ? "/" : "." : n3 && 1 === i3 ? "//" : t3.slice(0, i3);
    }, basename: function(t3, r3) {
      if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, i3 = 0, o2 = -1, s2 = true;
      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3) return "";
        var h2 = r3.length - 1, a2 = -1;
        for (n3 = t3.length - 1; n3 >= 0; --n3) {
          var c2 = t3.charCodeAt(n3);
          if (47 === c2) {
            if (!s2) {
              i3 = n3 + 1;
              break;
            }
          } else -1 === a2 && (s2 = false, a2 = n3 + 1), h2 >= 0 && (c2 === r3.charCodeAt(h2) ? -1 == --h2 && (o2 = n3) : (h2 = -1, o2 = a2));
        }
        return i3 === o2 ? o2 = a2 : -1 === o2 && (o2 = t3.length), t3.slice(i3, o2);
      }
      for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
        if (!s2) {
          i3 = n3 + 1;
          break;
        }
      } else -1 === o2 && (s2 = false, o2 = n3 + 1);
      return -1 === o2 ? "" : t3.slice(i3, o2);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, i3 = -1, o2 = true, s2 = 0, h2 = t3.length - 1; h2 >= 0; --h2) {
        var a2 = t3.charCodeAt(h2);
        if (47 !== a2) -1 === i3 && (o2 = false, i3 = h2 + 1), 46 === a2 ? -1 === r3 ? r3 = h2 : 1 !== s2 && (s2 = 1) : -1 !== r3 && (s2 = -1);
        else if (!o2) {
          n3 = h2 + 1;
          break;
        }
      }
      return -1 === r3 || -1 === i3 || 0 === s2 || 1 === s2 && r3 === i3 - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i3);
    }, format: function(t3) {
      if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      }(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (0 === t3.length) return r3;
      var n3, i3 = t3.charCodeAt(0), o2 = 47 === i3;
      o2 ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var s2 = -1, h2 = 0, a2 = -1, c2 = true, f2 = t3.length - 1, u2 = 0; f2 >= n3; --f2) if (47 !== (i3 = t3.charCodeAt(f2))) -1 === a2 && (c2 = false, a2 = f2 + 1), 46 === i3 ? -1 === s2 ? s2 = f2 : 1 !== u2 && (u2 = 1) : -1 !== s2 && (u2 = -1);
      else if (!c2) {
        h2 = f2 + 1;
        break;
      }
      return -1 === s2 || -1 === a2 || 0 === u2 || 1 === u2 && s2 === a2 - 1 && s2 === h2 + 1 ? -1 !== a2 && (r3.base = r3.name = 0 === h2 && o2 ? t3.slice(1, a2) : t3.slice(h2, a2)) : (0 === h2 && o2 ? (r3.name = t3.slice(1, s2), r3.base = t3.slice(1, a2)) : (r3.name = t3.slice(h2, s2), r3.base = t3.slice(h2, a2)), r3.ext = t3.slice(s2, a2)), h2 > 0 ? r3.dir = t3.slice(0, h2 - 1) : o2 && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  } }, e = {};
  function r(n2) {
    var i3 = e[n2];
    if (void 0 !== i3) return i3.exports;
    var o2 = e[n2] = { exports: {} };
    return t[n2](o2, o2.exports, r), o2.exports;
  }
  r.d = (t2, e2) => {
    for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  };
  var n = {};
  let i2;
  if (r.r(n), r.d(n, { URI: () => l, Utils: () => I }), "object" == typeof process) i2 = "win32" === process.platform;
  else if ("object" == typeof navigator) {
    let t2 = navigator.userAgent;
    i2 = t2.indexOf("Windows") >= 0;
  }
  const o = /^\w[\w\d+.-]*$/, s = /^\//, h = /^\/\//;
  function a(t2, e2) {
    if (!t2.scheme && e2) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t2.authority}", path: "${t2.path}", query: "${t2.query}", fragment: "${t2.fragment}"}`);
    if (t2.scheme && !o.test(t2.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
    if (t2.path) {
      if (t2.authority) {
        if (!s.test(t2.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      } else if (h.test(t2.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
    }
  }
  const c = "", f = "/", u = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  class l {
    constructor(t2, e2, r2, n2, i3, o2 = false) {
      __publicField(this, "scheme");
      __publicField(this, "authority");
      __publicField(this, "path");
      __publicField(this, "query");
      __publicField(this, "fragment");
      "object" == typeof t2 ? (this.scheme = t2.scheme || c, this.authority = t2.authority || c, this.path = t2.path || c, this.query = t2.query || c, this.fragment = t2.fragment || c) : (this.scheme = /* @__PURE__ */ function(t3, e3) {
        return t3 || e3 ? t3 : "file";
      }(t2, o2), this.authority = e2 || c, this.path = function(t3, e3) {
        switch (t3) {
          case "https":
          case "http":
          case "file":
            e3 ? e3[0] !== f && (e3 = f + e3) : e3 = f;
        }
        return e3;
      }(this.scheme, r2 || c), this.query = n2 || c, this.fragment = i3 || c, a(this, o2));
    }
    static isUri(t2) {
      return t2 instanceof l || !!t2 && "string" == typeof t2.authority && "string" == typeof t2.fragment && "string" == typeof t2.path && "string" == typeof t2.query && "string" == typeof t2.scheme && "string" == typeof t2.fsPath && "function" == typeof t2.with && "function" == typeof t2.toString;
    }
    get fsPath() {
      return v(this, false);
    }
    with(t2) {
      if (!t2) return this;
      let { scheme: e2, authority: r2, path: n2, query: i3, fragment: o2 } = t2;
      return void 0 === e2 ? e2 = this.scheme : null === e2 && (e2 = c), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = c), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = c), void 0 === i3 ? i3 = this.query : null === i3 && (i3 = c), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = c), e2 === this.scheme && r2 === this.authority && n2 === this.path && i3 === this.query && o2 === this.fragment ? this : new d(e2, r2, n2, i3, o2);
    }
    static parse(t2, e2 = false) {
      const r2 = u.exec(t2);
      return r2 ? new d(r2[2] || c, w(r2[4] || c), w(r2[5] || c), w(r2[7] || c), w(r2[9] || c), e2) : new d(c, c, c, c, c);
    }
    static file(t2) {
      let e2 = c;
      if (i2 && (t2 = t2.replace(/\\/g, f)), t2[0] === f && t2[1] === f) {
        const r2 = t2.indexOf(f, 2);
        -1 === r2 ? (e2 = t2.substring(2), t2 = f) : (e2 = t2.substring(2, r2), t2 = t2.substring(r2) || f);
      }
      return new d("file", e2, t2, c, c);
    }
    static from(t2) {
      const e2 = new d(t2.scheme, t2.authority, t2.path, t2.query, t2.fragment);
      return a(e2, true), e2;
    }
    toString(t2 = false) {
      return b(this, t2);
    }
    toJSON() {
      return this;
    }
    static revive(t2) {
      if (t2) {
        if (t2 instanceof l) return t2;
        {
          const e2 = new d(t2);
          return e2._formatted = t2.external, e2._fsPath = t2._sep === g ? t2.fsPath : null, e2;
        }
      }
      return t2;
    }
  }
  const g = i2 ? 1 : void 0;
  class d extends l {
    constructor() {
      super(...arguments);
      __publicField(this, "_formatted", null);
      __publicField(this, "_fsPath", null);
    }
    get fsPath() {
      return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
    }
    toString(t2 = false) {
      return t2 ? b(this, true) : (this._formatted || (this._formatted = b(this, false)), this._formatted);
    }
    toJSON() {
      const t2 = { $mid: 1 };
      return this._fsPath && (t2.fsPath = this._fsPath, t2._sep = g), this._formatted && (t2.external = this._formatted), this.path && (t2.path = this.path), this.scheme && (t2.scheme = this.scheme), this.authority && (t2.authority = this.authority), this.query && (t2.query = this.query), this.fragment && (t2.fragment = this.fragment), t2;
    }
  }
  const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
  function m(t2, e2, r2) {
    let n2, i3 = -1;
    for (let o2 = 0; o2 < t2.length; o2++) {
      const s2 = t2.charCodeAt(o2);
      if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e2 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i3 && (n2 += encodeURIComponent(t2.substring(i3, o2)), i3 = -1), void 0 !== n2 && (n2 += t2.charAt(o2));
      else {
        void 0 === n2 && (n2 = t2.substr(0, o2));
        const e3 = p[s2];
        void 0 !== e3 ? (-1 !== i3 && (n2 += encodeURIComponent(t2.substring(i3, o2)), i3 = -1), n2 += e3) : -1 === i3 && (i3 = o2);
      }
    }
    return -1 !== i3 && (n2 += encodeURIComponent(t2.substring(i3))), void 0 !== n2 ? n2 : t2;
  }
  function y(t2) {
    let e2;
    for (let r2 = 0; r2 < t2.length; r2++) {
      const n2 = t2.charCodeAt(r2);
      35 === n2 || 63 === n2 ? (void 0 === e2 && (e2 = t2.substr(0, r2)), e2 += p[n2]) : void 0 !== e2 && (e2 += t2[r2]);
    }
    return void 0 !== e2 ? e2 : t2;
  }
  function v(t2, e2) {
    let r2;
    return r2 = t2.authority && t2.path.length > 1 && "file" === t2.scheme ? `//${t2.authority}${t2.path}` : 47 === t2.path.charCodeAt(0) && (t2.path.charCodeAt(1) >= 65 && t2.path.charCodeAt(1) <= 90 || t2.path.charCodeAt(1) >= 97 && t2.path.charCodeAt(1) <= 122) && 58 === t2.path.charCodeAt(2) ? e2 ? t2.path.substr(1) : t2.path[1].toLowerCase() + t2.path.substr(2) : t2.path, i2 && (r2 = r2.replace(/\//g, "\\")), r2;
  }
  function b(t2, e2) {
    const r2 = e2 ? y : m;
    let n2 = "", { scheme: i3, authority: o2, path: s2, query: h2, fragment: a2 } = t2;
    if (i3 && (n2 += i3, n2 += ":"), (o2 || "file" === i3) && (n2 += f, n2 += f), o2) {
      let t3 = o2.indexOf("@");
      if (-1 !== t3) {
        const e3 = o2.substr(0, t3);
        o2 = o2.substr(t3 + 1), t3 = e3.lastIndexOf(":"), -1 === t3 ? n2 += r2(e3, false, false) : (n2 += r2(e3.substr(0, t3), false, false), n2 += ":", n2 += r2(e3.substr(t3 + 1), false, true)), n2 += "@";
      }
      o2 = o2.toLowerCase(), t3 = o2.lastIndexOf(":"), -1 === t3 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t3), false, true), n2 += o2.substr(t3));
    }
    if (s2) {
      if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
        const t3 = s2.charCodeAt(1);
        t3 >= 65 && t3 <= 90 && (s2 = `/${String.fromCharCode(t3 + 32)}:${s2.substr(3)}`);
      } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
        const t3 = s2.charCodeAt(0);
        t3 >= 65 && t3 <= 90 && (s2 = `${String.fromCharCode(t3 + 32)}:${s2.substr(2)}`);
      }
      n2 += r2(s2, true, false);
    }
    return h2 && (n2 += "?", n2 += r2(h2, false, false)), a2 && (n2 += "#", n2 += e2 ? a2 : m(a2, false, false)), n2;
  }
  function C2(t2) {
    try {
      return decodeURIComponent(t2);
    } catch {
      return t2.length > 3 ? t2.substr(0, 3) + C2(t2.substr(3)) : t2;
    }
  }
  const A = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function w(t2) {
    return t2.match(A) ? t2.replace(A, (t3) => C2(t3)) : t2;
  }
  var x = r(975);
  const P = x.posix || x, _ = "/";
  var I;
  !function(t2) {
    t2.joinPath = function(t3, ...e2) {
      return t3.with({ path: P.join(t3.path, ...e2) });
    }, t2.resolvePath = function(t3, ...e2) {
      let r2 = t3.path, n2 = false;
      r2[0] !== _ && (r2 = _ + r2, n2 = true);
      let i3 = P.resolve(r2, ...e2);
      return n2 && i3[0] === _ && !t3.authority && (i3 = i3.substring(1)), t3.with({ path: i3 });
    }, t2.dirname = function(t3) {
      if (0 === t3.path.length || t3.path === _) return t3;
      let e2 = P.dirname(t3.path);
      return 1 === e2.length && 46 === e2.charCodeAt(0) && (e2 = ""), t3.with({ path: e2 });
    }, t2.basename = function(t3) {
      return P.basename(t3.path);
    }, t2.extname = function(t3) {
      return P.extname(t3.path);
    };
  }(I || (I = {})), LIB = n;
})();
var { URI, Utils } = LIB;

// src/ide/setSelections.ts
function setSelections(client, document2, editorId, selections) {
  const selectionsJson = JSON.stringify(selections);
  client.setSelection(editorId, selectionsJson);
  return Promise.resolve();
}

// src/ide/jetbrainsPerformEdits.ts
function jetbrainsPerformEdits(client, ide2, document2, id2, edits) {
  const changes = document2.edit(edits);
  const editorEdit = {
    text: document2.text,
    changes: changes.map((change) => ({
      rangeOffset: change.rangeOffset,
      rangeLength: change.rangeLength,
      text: change.text
    }))
  };
  client.documentUpdated(id2, JSON.stringify(editorEdit));
  ide2.emitDidChangeTextDocument({
    document: document2,
    contentChanges: changes
  });
}

// src/ide/JetbrainsEditorCommand.ts
var JetbrainsEditorCommand = class {
  constructor(ranges, singleRange, restoreSelection, ideCommand) {
    this.ranges = ranges;
    this.singleRange = singleRange;
    this.restoreSelection = restoreSelection;
    this.ideCommand = ideCommand;
  }
};

// src/ide/JetbrainsEditor.ts
var JetbrainsEditor = class {
  constructor(client, ide2, id2, document2, visibleRanges, selections) {
    this.client = client;
    this.ide = ide2;
    this.id = id2;
    this.document = document2;
    this.visibleRanges = visibleRanges;
    this.selections = selections;
    this.options = {
      tabSize: 4,
      insertSpaces: true
    };
    this.isActive = true;
    this.isVisible = true;
    this.isEditable = true;
    this.isWritable = true;
  }
  isEqual(other) {
    return this.id === other.id;
  }
  async setSelections(selections, _opts) {
    if (!selectionsEqual(this.selections, selections)) {
      await setSelections(this.client, this.document, this.id, selections);
      this.selections = selections;
    }
  }
  edit(edits) {
    if (!this.isWritable) {
      return Promise.resolve(false);
    }
    jetbrainsPerformEdits(this.client, this.ide, this.document, this.id, edits);
    return Promise.resolve(true);
  }
  async clipboardCopy(ranges) {
    await this.ide.clipboard.copy(this.id, ranges);
  }
  async clipboardPaste() {
    await this.ide.clipboard.paste(this.id);
  }
  async indentLine(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      true,
      "EditorIndentSelection"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async outdentLine(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      true,
      "EditorUnindentSelection"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async insertLineAfter(ranges) {
    await this.client.insertLineAfter(this.id, JSON.stringify(ranges));
  }
  focus() {
    throw new Error("focus not implemented.");
  }
  revealRange(_range) {
    return Promise.resolve();
  }
  async revealLine(lineNumber, at) {
    await this.client.revealLine(this.id, lineNumber, at);
  }
  async openLink(range3, _options) {
    const command = new JetbrainsEditorCommand(
      [range3],
      true,
      false,
      "GotoDeclaration"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async fold(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      false,
      "CollapseRegion"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async unfold(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      false,
      "ExpandRegion"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async toggleBreakpoint(_ranges) {
    throw new Error("toggleBreakpoint not implemented.");
  }
  async toggleLineComment(ranges) {
    const command = new JetbrainsEditorCommand(
      ranges ? ranges : [],
      true,
      false,
      "CommentByLineComment"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  insertSnippet(_snippet, _ranges) {
    throw new Error("insertSnippet not implemented.");
  }
  async rename(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "RenameElement"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async showReferences(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "FindUsages"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async quickFix(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "ShowIntentionActions"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async revealDefinition(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "GotoDeclaration"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  async revealTypeDefinition(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "QuickImplementations"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  showHover(_range) {
    throw new Error("showHover not implemented.");
  }
  showDebugHover(_range) {
    throw new Error("showDebugHover not implemented.");
  }
  async extractVariable(range3) {
    const command = new JetbrainsEditorCommand(
      range3 ? [range3] : [],
      true,
      false,
      "IntroduceVariable"
    );
    await this.client.executeRangeCommand(this.id, JSON.stringify(command));
  }
  editNewNotebookCellAbove() {
    throw new Error("editNewNotebookCellAbove not implemented.");
  }
  editNewNotebookCellBelow() {
    throw new Error("editNewNotebookCellBelow not implemented.");
  }
  async gitAccept(_range) {
    throw new Error("gitAccept not implemented.");
  }
  async gitRevert(_range) {
    throw new Error("gitRevert not implemented.");
  }
  async gitStage(_range) {
    throw new Error("gitStage not implemented.");
  }
  async gitUnstage(_range) {
    throw new Error("gitUnstage not implemented.");
  }
};

// src/ide/createTextEditor.ts
function createTextEditor(client, ide2, editorState) {
  const id2 = editorState.id;
  const uri = URI.parse(`talon-jetbrains://${id2}`);
  const languageId = editorState.languageId ?? "plaintext";
  const document2 = new InMemoryTextDocument(uri, languageId, editorState.text);
  const visibleRanges = [
    new Range(editorState.firstVisibleLine, 0, editorState.lastVisibleLine, 0)
  ];
  const selections = editorState.selections.map(
    (selection) => createSelection(document2, selection)
  );
  const editor = new JetbrainsEditor(
    client,
    ide2,
    id2,
    document2,
    visibleRanges,
    selections
  );
  editor.isActive = editorState.active;
  editor.isVisible = editorState.visible;
  editor.isEditable = editorState.editable;
  editor.isWritable = editorState.writable;
  return editor;
}
function createSelection(document2, selection) {
  return new Selection(
    createPosition(selection.anchor),
    createPosition(selection.active)
  );
}
function createPosition(jbPosition) {
  return new Position(jbPosition.line, jbPosition.column);
}

// src/ide/JetbrainsIDE.ts
var JetbrainsIDE = class {
  constructor(client, configuration) {
    this.client = client;
    this.runMode = "production";
    this.visibleNotebookEditors = [];
    this.disposables = [];
    this.quickPickReturnValue = void 0;
    this.editors = /* @__PURE__ */ new Map();
    this.onDidChangeTextDocumentNotifier = new Notifier();
    this.onDidOpenTextDocumentNotifier = new Notifier();
    this.onDidChangeTextDocumentContentNotifier = new Notifier();
    this.onDidCloseTextDocument = dummyEvent;
    this.onDidChangeActiveTextEditor = dummyEvent;
    this.onDidChangeVisibleTextEditors = dummyEvent;
    this.onDidChangeTextEditorSelection = dummyEvent;
    this.onDidChangeTextEditorVisibleRanges = dummyEvent;
    this.configuration = configuration;
    this.keyValueStore = new JetbrainsKeyValueStore();
    this.messages = new JetbrainsMessages();
    this.clipboard = new JetbrainsClipboard(this.client);
    this.capabilities = new JetbrainsCapabilities();
    this.activeProject = void 0;
    this.activeEditor = void 0;
  }
  async init() {
  }
  async showQuickPick(_items, _options) {
    throw Error("showQuickPick Not implemented");
  }
  async setHighlightRanges(highlightId, editor, ranges) {
    this.client.setHighlightRanges(highlightId, editor.id, JSON.stringify(ranges));
  }
  async flashRanges(flashDescriptors) {
    console.log("flashRangeses");
    const jbfs = flashDescriptors.map((flashDescriptor) => {
      const jbf = {
        editorId: flashDescriptor.editor.id,
        range: flashDescriptor.range,
        style: flashDescriptor.style
      };
      return jbf;
    });
    this.client.flashRanges(JSON.stringify(jbfs));
  }
  get assetsRoot() {
    console.log("get assetsRoot");
    throw new Error("assetsRoot not implemented.");
  }
  get cursorlessVersion() {
    console.log("get cursorlessVersion");
    throw new Error("cursorlessVersion not implemented.");
  }
  get workspaceFolders() {
    console.log("get workspaceFolders");
    throw new Error("workspaceFolders not get implemented.");
  }
  get activeTextEditor() {
    return this.activeEditor;
  }
  get activeEditableTextEditor() {
    return this.activeEditor?.isEditable ? this.activeEditor : void 0;
  }
  get visibleTextEditors() {
    return [...this.editors.values()].filter((editor) => editor.isVisible);
  }
  getEditableTextEditor(editor) {
    if (editor instanceof JetbrainsEditor) {
      if (editor.isEditable) {
        return editor;
      } else {
        throw Error(`Editor is not editable: ${editor}`);
      }
    }
    throw Error(`Unsupported text editor type: ${editor}`);
  }
  async findInDocument(_query, _editor) {
    throw Error("findInDocument Not implemented");
  }
  async findInWorkspace(_query) {
    throw Error("findInWorkspace Not implemented");
  }
  async openTextDocument(_path) {
    throw Error("openTextDocument Not implemented");
  }
  async openUntitledTextDocument(_options) {
    throw Error("openUntitledTextDocument Not implemented");
  }
  async showInputBox(_options) {
    throw Error("showInputBox Not implemented");
  }
  async executeCommand(_command, ..._args) {
    throw new Error("executeCommand Method not implemented.");
  }
  onDidChangeTextDocument(listener) {
    return this.onDidChangeTextDocumentNotifier.registerListener(listener);
  }
  onDidOpenTextDocument(listener, _thisArgs, _disposables) {
    return this.onDidOpenTextDocumentNotifier.registerListener(listener);
  }
  handleCommandError(_err) {
  }
  disposeOnExit(...disposables) {
    this.disposables.push(...disposables);
    return () => pull_default(this.disposables, ...disposables);
  }
  documentClosed(editorId) {
    this.editors.delete(editorId);
  }
  documentCreated(editorStateJson) {
    this.documentChanged(editorStateJson);
    const editorState = editorStateJson;
    const editor = this.editors.get(editorState.id);
    if (editor) {
      this.onDidOpenTextDocumentNotifier.notifyListeners(editor.document);
    }
  }
  documentChanged(editorStateJson) {
    const editorState = editorStateJson;
    const editor = this.updateTextEditors(editorState);
    const linedata = getLines(
      editorState.text,
      editorState.firstVisibleLine,
      editorState.lastVisibleLine
    );
    const contentChangeEvents = fromJetbrainsContentChange(
      editor.document,
      editorState.firstVisibleLine,
      editorState.lastVisibleLine,
      linedata
    );
    const documentChangeEvent = {
      document: editor.document,
      contentChanges: contentChangeEvents
    };
    this.emitDidChangeTextDocument(documentChangeEvent);
  }
  emitDidChangeTextDocument(event) {
    this.onDidChangeTextDocumentNotifier.notifyListeners(event);
  }
  updateTextEditors(editorState) {
    let editor = this.editors.get(editorState.id);
    if (editor) {
      updateEditor(editor, editorState);
    } else {
      editor = createTextEditor(this.client, this, editorState);
      this.editors.set(editorState.id, editor);
    }
    if (editorState.active) {
      this.activeEditor = editor;
    }
    return editor;
  }
  readQuery(filename) {
    return this.client.readQuery(filename);
  }
};
function updateEditor(editor, editorState) {
  const oldDocument = editor.document;
  editor.document = new InMemoryTextDocument(
    oldDocument.uri,
    oldDocument.languageId,
    editorState.text
  );
  editor.visibleRanges = [
    new Range(
      editorState.firstVisibleLine,
      0,
      editorState.lastVisibleLine + 1,
      0
    )
  ];
  editor.selections = editorState.selections.map(
    (selection) => createSelection(editor.document, selection)
  );
  editor.isActive = editorState.active;
  editor.isVisible = editorState.visible;
  editor.isEditable = editorState.editable;
  editor.isWritable = editorState.writable;
}
function getLines(text, firstLine, lastLine) {
  const lines = text.split("\n");
  return lines.slice(firstLine, lastLine);
}
function dummyEvent() {
  return {
    dispose() {
    }
  };
}
function createIDE(client, configuration) {
  return new JetbrainsIDE(client, configuration);
}

// ../../node_modules/.pnpm/immer@10.1.1/node_modules/immer/dist/immer.mjs
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args2) {
  if (process.env.NODE_ENV !== "production") {
    const e = errors[error];
    const msg = typeof e === "function" ? e.apply(null, args2) : e;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter2) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter2(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter2(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set2(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2)
    thing.set(propOrOldValue, value);
  else if (t === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys2 = Reflect.ownKeys(descriptors);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    Object.entries(obj).forEach(([key, value]) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (process.env.NODE_ENV !== "production" && childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set2(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray2 = Array.isArray(base);
  const state = {
    type_: isArray2 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray2) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy: proxy2 } = Proxy.revocable(target, traps);
  state.draft_ = proxy2;
  state.revoke_ = revoke;
  return proxy2;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args2) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args2));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy2 = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy2);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args2) => this.produceWithPatches(state, (draft) => base(draft, ...args2));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config?.autoFreeze === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof config?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy2 = createProxy(base, void 0);
    proxy2[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy2;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i2;
    for (i2 = patches.length - 1; i2 >= 0; i2--) {
      const patch = patches[i2];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i2 > -1) {
      patches = patches.slice(i2 + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set2(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(
  immer
);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);

// ../cursorless-engine/src/core/indexArrayStrict.ts
function indexArrayStrict(arr, idx, name2) {
  if (idx >= arr.length) {
    throw Error(
      `Expected at least ${idx + 1} ${name2} but received only ${arr.length}`
    );
  }
  return arr[idx];
}

// ../cursorless-engine/src/customCommandGrammar/fillPlaceholders.ts
function fillPlaceholders(input, values2) {
  if (Array.isArray(input)) {
    return input.map((item) => fillPlaceholders(item, values2));
  }
  if (typeof input === "object" && input != null) {
    if (isPlaceholder(input)) {
      return indexArrayStrict(values2, input.index, "placeholder value");
    }
    const result = {};
    for (const key in input) {
      if (Object.prototype.hasOwnProperty.call(input, key)) {
        result[key] = fillPlaceholders(input[key], values2);
      }
    }
    return result;
  }
  return input;
}
function isPlaceholder(value) {
  return typeof value === "object" && value != null && "type" in value && value.type === "placeholder";
}

// ../cursorless-engine/src/customCommandGrammar/parseCommand.ts
var import_nearley = __toESM(require_nearley(), 1);

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/marks.ts
var hatColors = {
  blue: "blue",
  green: "green",
  red: "red",
  pink: "pink",
  yellow: "yellow",
  userColor1: "navy",
  userColor2: "apricot",
  default: null
};
var hatShapes = {
  ex: "ex",
  fox: "fox",
  wing: "wing",
  hole: "hole",
  frame: "frame",
  curve: "curve",
  eye: "eye",
  play: "play",
  crosshairs: "cross",
  bolt: "bolt",
  default: null
};
var marks = {
  cursor: "this",
  that: "that",
  source: "source",
  nothing: "nothing",
  keyboard: null,
  explicit: null,
  decoratedSymbol: null,
  lineNumber: null,
  range: null,
  target: null
};
var lineDirections = {
  modulo100: "row",
  relativeUp: "up",
  relativeDown: "down"
};
function hatColorToSpokenForm(color) {
  const result = hatColors[color];
  if (result == null) {
    throw Error(`Unknown hat color '${color}'`);
  }
  return result;
}
function hatShapeToSpokenForm(shape) {
  const result = hatShapes[shape];
  if (result == null) {
    throw Error(`Unknown hat shape '${shape}'`);
  }
  return result;
}

// ../cursorless-engine/src/spokenForms/SpokenFormMap.ts
function mapSpokenForms(input, mapper) {
  return Object.fromEntries(
    Object.entries(input).map(([spokenFormType, map3]) => [
      spokenFormType,
      Object.fromEntries(
        Object.entries(map3).map(([id2, inputValue]) => [
          id2,
          mapper(inputValue, spokenFormType, id2)
        ])
      )
    ])
    // FIXME: Don't cast here; need to make our own mapValues with stronger typing
    // using tricks from our object.d.ts
  );
}

// ../cursorless-engine/src/spokenForms/graphemes.ts
var alphabet = Object.fromEntries(
  "air bat cap drum each fine gust harp sit jury crunch look made near odd pit quench red sun trap urge vest whale plex yank zip".split(" ").map((word, index) => [
    String.fromCharCode("a".charCodeAt(0) + index),
    word
  ])
);
var digits = Object.fromEntries(
  "zero one two three four five six seven eight nine".split(" ").map((word, index) => [index.toString(), word])
);
var symbols = {
  ".": "dot",
  ",": "comma",
  ";": "semicolon",
  ":": "colon",
  "!": "bang",
  "*": "asterisk",
  "@": "at sign",
  "&": "ampersand",
  "?": "question",
  "/": "slash",
  "\\": "backslash",
  "-": "dash",
  "=": "equals",
  "+": "plus",
  "~": "tilde",
  _: "underscore",
  "#": "hash",
  "%": "percent",
  "^": "caret",
  "|": "pipe",
  $: "dollar",
  "\xA3": "pound",
  "'": "quote",
  '"': "double quote",
  "`": "back tick",
  "(": "paren",
  ")": "right paren",
  "{": "brace",
  "}": "right brace",
  "[": "square",
  "]": "right square",
  "<": "angle",
  ">": "right angle",
  "\uFFFD": "special"
};
var graphemeDefaultSpokenForms = {
  ...alphabet,
  ...digits,
  ...symbols
};

// ../cursorless-engine/src/spokenForms/spokenFormMapUtil.ts
function isDisabledByDefault(...spokenForms) {
  return {
    defaultSpokenForms: spokenForms,
    isDisabledByDefault: true,
    isPrivate: false
  };
}
function isPrivate(...spokenForms) {
  return {
    defaultSpokenForms: spokenForms,
    isDisabledByDefault: true,
    isPrivate: true
  };
}

// ../cursorless-engine/src/spokenForms/defaultSpokenFormMapCore.ts
var defaultSpokenFormMapCore = {
  pairedDelimiter: {
    curlyBrackets: "curly",
    angleBrackets: "diamond",
    escapedDoubleQuotes: "escaped quad",
    escapedSingleQuotes: "escaped twin",
    escapedParentheses: "escaped round",
    escapedSquareBrackets: "escaped box",
    doubleQuotes: "quad",
    parentheses: "round",
    backtickQuotes: "skis",
    squareBrackets: "box",
    singleQuotes: "twin",
    tripleDoubleQuotes: isPrivate("triple quad"),
    tripleSingleQuotes: isPrivate("triple twin"),
    tripleBacktickQuotes: isPrivate("triple skis"),
    any: "pair",
    string: "string",
    whitespace: "void",
    collectionBoundary: isPrivate("collection boundary")
  },
  simpleScopeTypeType: {
    argumentOrParameter: "arg",
    argumentList: "arg list",
    attribute: "attribute",
    functionCall: "call",
    functionCallee: "callee",
    className: "class name",
    class: "class",
    comment: "comment",
    functionName: "funk name",
    namedFunction: "funk",
    ifStatement: "if state",
    instance: "instance",
    collectionItem: "item",
    collectionKey: "key",
    anonymousFunction: "lambda",
    list: "list",
    map: "map",
    name: "name",
    regularExpression: "regex",
    section: "section",
    sectionLevelOne: isDisabledByDefault("one section"),
    sectionLevelTwo: isDisabledByDefault("two section"),
    sectionLevelThree: isDisabledByDefault("three section"),
    sectionLevelFour: isDisabledByDefault("four section"),
    sectionLevelFive: isDisabledByDefault("five section"),
    sectionLevelSix: isDisabledByDefault("six section"),
    selector: "selector",
    statement: "state",
    branch: "branch",
    type: "type",
    value: "value",
    condition: "condition",
    unit: "unit",
    //  XML, JSX
    xmlElement: "element",
    xmlBothTags: "tags",
    xmlStartTag: "start tag",
    xmlEndTag: "end tag",
    // LaTeX
    part: "part",
    chapter: "chapter",
    subSection: "subsection",
    subSubSection: "subsubsection",
    namedParagraph: "paragraph",
    subParagraph: "subparagraph",
    environment: "environment",
    // Talon
    command: "command",
    // Text-based scope types
    character: "char",
    word: "sub",
    token: "token",
    identifier: "identifier",
    line: "line",
    sentence: "sentence",
    paragraph: "block",
    boundedParagraph: "short block",
    document: "file",
    nonWhitespaceSequence: "paint",
    boundedNonWhitespaceSequence: "short paint",
    url: "link",
    notebookCell: "cell",
    string: isPrivate("parse tree string"),
    textFragment: isPrivate("text fragment"),
    disqualifyDelimiter: isPrivate("disqualify delimiter"),
    pairDelimiter: isPrivate("pair delimiter"),
    ["private.fieldAccess"]: isPrivate("access"),
    ["private.switchStatementSubject"]: isPrivate("subject")
  },
  complexScopeTypeType: {
    glyph: "glyph"
  },
  surroundingPairForceDirection: {
    left: "left",
    right: "right"
  },
  simpleModifier: {
    excludeInterior: "bounds",
    toRawSelection: "just",
    leading: "leading",
    trailing: "trailing",
    keepContentFilter: "content",
    keepEmptyFilter: "empty",
    inferPreviousMark: "its",
    startOf: "start of",
    endOf: "end of",
    interiorOnly: "inside",
    visible: "visible",
    extendThroughStartOf: "head",
    extendThroughEndOf: "tail",
    everyScope: "every"
  },
  modifierExtra: {
    first: "first",
    last: "last",
    previous: "previous",
    next: "next",
    forward: "forward",
    backward: "backward",
    ancestor: "grand"
  },
  customRegex: {},
  action: {
    addSelection: "append",
    addSelectionAfter: "append post",
    addSelectionBefore: "append pre",
    breakLine: "break",
    scrollToBottom: "bottom",
    toggleLineBreakpoint: "break point",
    cutToClipboard: "carve",
    scrollToCenter: "center",
    clearAndSetSelection: "change",
    remove: "chuck",
    insertCopyBefore: "clone up",
    insertCopyAfter: "clone",
    toggleLineComment: "comment",
    copyToClipboard: "copy",
    scrollToTop: "crown",
    outdentLine: "dedent",
    revealDefinition: "define",
    editNewLineBefore: "drink",
    insertEmptyLineBefore: "drop",
    extractVariable: "extract",
    insertEmptyLineAfter: "float",
    foldRegion: "fold",
    followLink: "follow",
    followLinkAside: "follow split",
    flashTargets: "flash",
    deselect: "give",
    highlight: "highlight",
    showHover: "hover",
    increment: "increment",
    decrement: "decrement",
    indentLine: "indent",
    showDebugHover: "inspect",
    setSelectionAfter: "post",
    editNewLineAfter: "pour",
    setSelectionBefore: "pre",
    insertEmptyLinesAround: "puff",
    showQuickFix: "quick fix",
    showReferences: "reference",
    rename: "rename",
    reverseTargets: "reverse",
    findInDocument: "scout",
    findInWorkspace: "scout all",
    randomizeTargets: "shuffle",
    generateSnippet: "snippet make",
    sortTargets: "sort",
    setSelection: "take",
    revealTypeDefinition: "type deaf",
    unfoldRegion: "unfold",
    callAsFunction: "call",
    swapTargets: "swap",
    replaceWithTarget: "bring",
    moveToTarget: "move",
    wrapWithPairedDelimiter: "wrap",
    wrapWithSnippet: "wrap",
    rewrapWithPairedDelimiter: "repack",
    insertSnippet: "snippet",
    pasteFromClipboard: "paste",
    joinLines: "join",
    gitAccept: "git accept",
    gitRevert: "git revert",
    gitStage: "git stage",
    gitUnstage: "git unstage",
    ["private.showParseTree"]: isPrivate("parse tree"),
    ["experimental.setInstanceReference"]: isDisabledByDefault("from"),
    editNew: isPrivate("edit new"),
    executeCommand: isPrivate("execute command"),
    parsed: isPrivate("parsed"),
    getText: isPrivate("get text"),
    replace: isPrivate("replace"),
    ["private.getTargets"]: isPrivate("get targets"),
    ["private.setKeyboardTarget"]: isPrivate("set keyboard target")
    // These actions are implemented talon-side, usually using `getText` followed
    // by some other action.
    // applyFormatter: "format",
    // nextHomophone: "phones",
  },
  customAction: {},
  grapheme: graphemeDefaultSpokenForms
};

// ../cursorless-engine/src/spokenForms/defaultSpokenFormMap.ts
var defaultSpokenFormInfoMap = mapSpokenForms(
  defaultSpokenFormMapCore,
  (value) => typeof value === "string" ? {
    defaultSpokenForms: [value],
    isDisabledByDefault: false,
    isPrivate: false
  } : value
);
var defaultSpokenFormMap = mapSpokenForms(
  defaultSpokenFormInfoMap,
  ({ defaultSpokenForms, isDisabledByDefault: isDisabledByDefault2, isPrivate: isPrivate2 }) => ({
    spokenForms: isDisabledByDefault2 ? [] : defaultSpokenForms,
    isCustom: false,
    defaultSpokenForms,
    requiresTalonUpdate: false,
    isPrivate: isPrivate2
  })
);

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/connectives.ts
var connectives = {
  rangeExclusive: "between",
  rangeInclusive: "past",
  // Note: rangeExcludingStart has no default spoken form
  rangeExcludingStart: null,
  rangeExcludingEnd: "until",
  listConnective: "and",
  swapConnective: "with",
  sourceDestinationConnective: "to",
  before: "before",
  after: "after",
  verticalRange: "slice",
  previous: "previous",
  next: "next",
  forward: "forward",
  backward: "backward"
};

// ../cursorless-engine/src/customCommandGrammar/CommandLexer.ts
var import_moo = __toESM(require_moo(), 1);
var CommandLexer = class {
  constructor(rules) {
    this.mooLexer = import_moo.default.compile(rules);
  }
  reset(chunk, state) {
    const { mooState } = state ?? {};
    this.mooLexer.reset(chunk, mooState);
    return this;
  }
  formatError(token, message) {
    return this.mooLexer.formatError(token, message);
  }
  has(tokenType) {
    return this.mooLexer.has(tokenType);
  }
  save() {
    return {
      mooState: this.mooLexer.save()
    };
  }
  next() {
    const token = this.mooLexer.next();
    if (this.skipToken(token)) {
      return this.next();
    }
    return token;
  }
  transform({ value }) {
    return value;
  }
  skipToken(token) {
    return token?.type === "ws";
  }
};

// ../cursorless-engine/src/customCommandGrammar/lexer.ts
var tokens = {};
for (const simpleActionName2 of simpleActionNames) {
  const { spokenForms } = defaultSpokenFormMap.action[simpleActionName2];
  for (const spokenForm of spokenForms) {
    tokens[spokenForm] = {
      type: "simpleActionName",
      value: simpleActionName2
    };
  }
}
var bringMoveActionNames = [
  "replaceWithTarget",
  "moveToTarget"
];
for (const bringMoveActionName of bringMoveActionNames) {
  const { spokenForms } = defaultSpokenFormMap.action[bringMoveActionName];
  for (const spokenForm of spokenForms) {
    tokens[spokenForm] = {
      type: "bringMove",
      value: bringMoveActionName
    };
  }
}
var insertionModes = ["before", "after", "to"];
for (const insertionMode2 of insertionModes) {
  const spokenForm = connectives[insertionMode2 === "to" ? "sourceDestinationConnective" : insertionMode2];
  tokens[spokenForm] = {
    type: "insertionMode",
    value: insertionMode2
  };
}
for (const simpleScopeTypeType2 of simpleScopeTypeTypes) {
  const { spokenForms } = defaultSpokenFormMap.simpleScopeTypeType[simpleScopeTypeType2];
  for (const spokenForm of spokenForms) {
    tokens[spokenForm] = {
      type: "simpleScopeTypeType",
      value: simpleScopeTypeType2
    };
  }
}
for (const pairedDelimiter2 of surroundingPairNames) {
  const { spokenForms } = defaultSpokenFormMap.pairedDelimiter[pairedDelimiter2];
  for (const spokenForm of spokenForms) {
    tokens[spokenForm] = {
      type: "pairedDelimiter",
      value: pairedDelimiter2
    };
  }
}
for (const [mark, spokenForm] of Object.entries(marks)) {
  if (spokenForm != null) {
    tokens[spokenForm] = {
      type: "simpleMarkType",
      value: mark
    };
  }
}
defaultSpokenFormMap.modifierExtra.next.spokenForms.forEach((spokenForm) => {
  tokens[spokenForm] = {
    type: "direction",
    value: "forward"
  };
});
defaultSpokenFormMap.modifierExtra.previous.spokenForms.forEach(
  (spokenForm) => {
    tokens[spokenForm] = {
      type: "direction",
      value: "backward"
    };
  }
);
var lexer = new CommandLexer({
  ws: /[ \t]+/,
  placeholderTarget: {
    match: /<target\d*>/,
    value: (text) => text.slice(7, -1)
  },
  token: {
    match: Object.keys(tokens),
    type: (text) => tokens[text].type,
    value: (text) => tokens[text].value
  }
});

// ../cursorless-engine/src/customCommandGrammar/grammarUtil.ts
function simpleActionDescriptor(name2, target) {
  return { name: name2, target };
}
function bringMoveActionDescriptor(name2, source, destination) {
  return { name: name2, source, destination };
}
function partialPrimitiveTargetDescriptor(modifiers, mark) {
  const target = {
    type: "primitive"
  };
  if (modifiers != null) {
    target.modifiers = modifiers;
  }
  if (mark != null) {
    target.mark = mark;
  }
  return target;
}
function primitiveDestinationDescriptor(insertionMode2, target) {
  return { type: "primitive", insertionMode: insertionMode2, target };
}
function containingScopeModifier(scopeType) {
  return {
    type: "containingScope",
    scopeType
  };
}
function relativeScopeModifier(scopeType, direction2) {
  return {
    type: "relativeScope",
    scopeType,
    offset: 1,
    length: 1,
    direction: direction2
  };
}
function simpleScopeType(type2) {
  return { type: type2 };
}
function surroundingPairScopeType(delimiter) {
  return { type: "surroundingPair", delimiter };
}
function simplePartialMark(type2) {
  return { type: type2 };
}
function createPlaceholderTarget(index) {
  return {
    type: "target",
    target: {
      type: "placeholder",
      index: index.length === 0 ? 0 : parseInt(index) - 1
    }
  };
}

// ../cursorless-engine/src/customCommandGrammar/generated/grammar.ts
function id(d) {
  return d[0];
}
var grammar = {
  Lexer: lexer,
  ParserRules: [
    { "name": "main", "symbols": ["action"], "postprocess": id },
    {
      "name": "action",
      "symbols": [lexer.has("simpleActionName") ? { type: "simpleActionName" } : simpleActionName, "target"],
      "postprocess": ([simpleActionName2, target]) => simpleActionDescriptor(simpleActionName2, target)
    },
    {
      "name": "action",
      "symbols": [lexer.has("bringMove") ? { type: "bringMove" } : bringMove, "target", "destination"],
      "postprocess": ([bringMove2, target, destination]) => bringMoveActionDescriptor(bringMove2, target, destination)
    },
    { "name": "destination", "symbols": ["primitiveDestination"], "postprocess": id },
    {
      "name": "destination",
      "symbols": [lexer.has("insertionMode") ? { type: "insertionMode" } : insertionMode, "target"],
      "postprocess": ([insertionMode2, target]) => primitiveDestinationDescriptor(insertionMode2, target)
    },
    { "name": "target", "symbols": ["primitiveTarget"], "postprocess": id },
    { "name": "primitiveTarget$ebnf$1", "symbols": ["modifier"] },
    { "name": "primitiveTarget$ebnf$1", "symbols": ["primitiveTarget$ebnf$1", "modifier"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "primitiveTarget",
      "symbols": ["primitiveTarget$ebnf$1"],
      "postprocess": ([modifiers]) => partialPrimitiveTargetDescriptor(modifiers, void 0)
    },
    {
      "name": "primitiveTarget",
      "symbols": ["mark"],
      "postprocess": ([mark]) => partialPrimitiveTargetDescriptor(void 0, mark)
    },
    { "name": "primitiveTarget$ebnf$2", "symbols": ["modifier"] },
    { "name": "primitiveTarget$ebnf$2", "symbols": ["primitiveTarget$ebnf$2", "modifier"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "primitiveTarget",
      "symbols": ["primitiveTarget$ebnf$2", "mark"],
      "postprocess": ([modifiers, mark]) => partialPrimitiveTargetDescriptor(modifiers, mark)
    },
    {
      "name": "modifier",
      "symbols": ["scopeType"],
      "postprocess": ([scopeType]) => containingScopeModifier(scopeType)
    },
    {
      "name": "modifier",
      "symbols": [lexer.has("direction") ? { type: "direction" } : direction, "scopeType"],
      "postprocess": ([direction2, scopeType]) => relativeScopeModifier(scopeType, direction2)
    },
    {
      "name": "scopeType",
      "symbols": [lexer.has("simpleScopeTypeType") ? { type: "simpleScopeTypeType" } : simpleScopeTypeType],
      "postprocess": ([simpleScopeTypeType2]) => simpleScopeType(simpleScopeTypeType2)
    },
    {
      "name": "scopeType",
      "symbols": [lexer.has("pairedDelimiter") ? { type: "pairedDelimiter" } : pairedDelimiter],
      "postprocess": ([delimiter]) => surroundingPairScopeType(delimiter)
    },
    {
      "name": "mark",
      "symbols": [lexer.has("simpleMarkType") ? { type: "simpleMarkType" } : simpleMarkType],
      "postprocess": ([simpleMarkType2]) => simplePartialMark(simpleMarkType2)
    },
    {
      "name": "mark",
      "symbols": [lexer.has("placeholderTarget") ? { type: "placeholderTarget" } : placeholderTarget],
      "postprocess": ([placeholderTarget2]) => createPlaceholderTarget(placeholderTarget2)
    }
  ],
  ParserStart: "main"
};
var grammar_default = grammar;

// ../cursorless-engine/src/customCommandGrammar/parseCommand.ts
function getActionParser() {
  return new import_nearley.Parser(import_nearley.Grammar.fromCompiled(grammar_default));
}
function parseAction(input) {
  const parser = getActionParser();
  parser.feed(input);
  if (parser.results.length !== 1) {
    throw new Error(
      `Expected exactly one result, got ${parser.results.length}`
    );
  }
  return parser.results[0];
}

// ../cursorless-engine/src/customCommandGrammar/parseAndFillOutAction.ts
function parseAndFillOutAction(content, args2) {
  const parsed = parseAction(content);
  return fillPlaceholders(parsed, args2);
}

// ../cursorless-engine/src/util/getPartialTargetDescriptors.ts
function getPartialTargetDescriptors(action) {
  switch (action.name) {
    case "callAsFunction":
      return [action.callee, action.argument];
    case "replaceWithTarget":
    case "moveToTarget":
      return [
        action.source,
        ...getPartialTargetDescriptorsFromDestination(action.destination)
      ];
    case "swapTargets":
      return [action.target1, action.target2];
    case "pasteFromClipboard":
    case "insertSnippet":
    case "replace":
    case "editNew":
      return getPartialTargetDescriptorsFromDestination(action.destination);
    case "parsed":
      return getPartialTargetDescriptors(
        parseAndFillOutAction(action.content, action.arguments)
      );
    default:
      return [action.target];
  }
}
function getPartialTargetDescriptorsFromDestination(destination) {
  switch (destination.type) {
    case "list":
      return destination.destinations.map(({ target }) => target);
    case "primitive":
      return [destination.target];
    case "implicit":
      return [];
  }
}

// ../cursorless-engine/src/util/getPrimitiveTargets.ts
function getPartialPrimitiveTargets(targets) {
  return targets.flatMap(getPartialPrimitiveTargetsHelper);
}
function getPartialPrimitiveTargetsHelper(target) {
  switch (target.type) {
    case "primitive":
      return [target];
    case "list":
      return target.elements.flatMap(getPartialPrimitiveTargetsHelper);
    case "range":
      return [target.anchor, target.active].flatMap(
        getPartialPrimitiveTargetsHelper
      );
    case "implicit":
      return [];
  }
}

// ../cursorless-engine/src/core/commandVersionUpgrades/canonicalizeTargetsInPlace.ts
var SCOPE_TYPE_CANONICALIZATION_MAPPING = {
  arrowFunction: "anonymousFunction",
  dictionary: "map",
  regex: "regularExpression"
};
var COLOR_CANONICALIZATION_MAPPING = {
  purple: "pink"
};
function canonicalizeScopeTypesInPlace(target) {
  target.modifiers?.forEach((mod) => {
    if (mod.type === "containingScope" || mod.type === "everyScope") {
      mod.scopeType.type = SCOPE_TYPE_CANONICALIZATION_MAPPING[mod.scopeType.type] ?? mod.scopeType.type;
    }
  });
}
function canonicalizeColorsInPlace(target) {
  if (target.mark?.type === "decoratedSymbol") {
    target.mark.symbolColor = COLOR_CANONICALIZATION_MAPPING[target.mark.symbolColor] ?? target.mark.symbolColor;
  }
}
function canonicalizeTargetsInPlace(partialTargets) {
  getPartialPrimitiveTargets(partialTargets).forEach((target) => {
    canonicalizeScopeTypesInPlace(target);
    canonicalizeColorsInPlace(target);
  });
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV0ToV1/upgradeV0ToV1.ts
function upgradeV0ToV1(command) {
  return { ...command, version: 1 };
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV1ToV2/upgradeStrictHere.ts
var STRICT_HERE = {
  type: "primitive",
  mark: { type: "cursor" },
  selectionType: "token",
  position: "contents",
  modifier: { type: "identity" },
  insideOutsideType: "inside"
};
var IMPLICIT_TARGET = {
  type: "primitive",
  isImplicit: true
};
var upgradeStrictHere = (target) => isEqual_default(target, STRICT_HERE) ? IMPLICIT_TARGET : target;

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV1ToV2/upgradeV1ToV2.ts
function upgradeV1ToV2(command) {
  const actionName = command.action;
  return {
    spokenForm: command.spokenForm,
    action: {
      name: actionName,
      args: command.extraArgs
    },
    targets: upgradeTargets(command.targets, actionName),
    usePrePhraseSnapshot: command.usePrePhraseSnapshot ?? false,
    version: 2
  };
}
function upgradeModifier(modifier) {
  switch (modifier.type) {
    case "identity":
      return [];
    case "containingScope": {
      const { includeSiblings, scopeType, type: type2, ...rest } = modifier;
      return [
        {
          type: includeSiblings ? "everyScope" : "containingScope",
          scopeType: {
            type: scopeType
          },
          ...rest
        }
      ];
    }
    case "surroundingPair": {
      const { delimiterInclusion, ...rest } = modifier;
      const surroundingPairModifier = {
        type: "containingScope",
        scopeType: rest
      };
      if (delimiterInclusion === "interiorOnly" || delimiterInclusion === "excludeInterior") {
        if (surroundingPairModifier.scopeType.delimiter === "any") {
          return [{ type: delimiterInclusion }];
        }
        return [{ type: delimiterInclusion }, surroundingPairModifier];
      }
      return [surroundingPairModifier];
    }
    case "subpiece": {
      const { type: type2, pieceType, ...rest } = modifier;
      return [
        {
          type: "ordinalRange",
          scopeType: { type: pieceType },
          ...rest
        }
      ];
    }
    case "head":
      return [{ type: "extendThroughStartOf" }];
    case "tail":
      return [{ type: "extendThroughEndOf" }];
    default:
      return [modifier];
  }
}
function upgradePrimitiveTarget(target, action) {
  const {
    type: type2,
    isImplicit,
    mark,
    insideOutsideType,
    modifier,
    selectionType,
    position
  } = target;
  const modifiers = [];
  if (position && position !== "contents") {
    if (position === "before") {
      if (insideOutsideType === "inside") {
        modifiers.push({ type: "position", position: "start" });
      } else if (action === "remove") {
        modifiers.push({ type: "leading" });
      } else {
        modifiers.push({ type: "position", position: "before" });
      }
    } else {
      if (insideOutsideType === "inside") {
        modifiers.push({ type: "position", position: "end" });
      } else if (action === "remove") {
        modifiers.push({ type: "trailing" });
      } else {
        modifiers.push({ type: "position", position: "after" });
      }
    }
  }
  if (selectionType) {
    switch (selectionType) {
      case "token":
        if (modifier?.type === "subpiece") {
          break;
        }
      // fallthrough
      case "line":
        if (mark?.type === "lineNumber") {
          break;
        }
      // fallthrough
      default:
        modifiers.push({
          type: "containingScope",
          scopeType: { type: selectionType }
        });
    }
  }
  if (modifier) {
    modifiers.push(...upgradeModifier(modifier));
  }
  return {
    type: type2,
    isImplicit,
    // Empty array of modifiers is not allowed
    modifiers: modifiers.length > 0 ? modifiers : void 0,
    // Cursor token is just cursor position but treated as a token. This is done in the pipeline for normal cursor now
    mark: mark?.type === "cursorToken" ? void 0 : mark
  };
}
function upgradeTarget(target, action) {
  switch (target.type) {
    case "list":
      return {
        ...target,
        elements: target.elements.map(
          (target2) => upgradeTarget(target2, action)
        )
      };
    case "range": {
      const { type: type2, rangeType, start: start2, end, excludeStart, excludeEnd } = target;
      return {
        type: type2,
        rangeType,
        anchor: upgradePrimitiveTarget(start2, action),
        active: upgradePrimitiveTarget(end, action),
        excludeAnchor: excludeStart ?? false,
        excludeActive: excludeEnd ?? false
      };
    }
    case "primitive":
      return upgradePrimitiveTarget(target, action);
  }
}
function upgradeTargets(partialTargets, action) {
  return partialTargets.map((target) => upgradeTarget(target, action)).map(
    (target) => target.type === "primitive" ? upgradeStrictHere(target) : target
  );
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV2ToV3/upgradeV2ToV3.ts
function upgradeV2ToV3(command) {
  return {
    ...command,
    version: 3,
    targets: command.targets.map(upgradeTarget2)
  };
}
function upgradeTarget2(target) {
  switch (target.type) {
    case "list":
      return {
        ...target,
        elements: target.elements.map(
          (target2) => upgradeTarget2(target2)
        )
      };
    case "range": {
      const { anchor, active, ...rest } = target;
      return {
        anchor: upgradePrimitiveTarget2(
          anchor
        ),
        active: upgradePrimitiveTarget2(
          active
        ),
        ...rest
      };
    }
    case "primitive":
      return upgradePrimitiveTarget2(target);
  }
}
function upgradePrimitiveTarget2(target) {
  const modifiers = target.modifiers != null ? target.modifiers.map(updateModifier) : void 0;
  if (target.mark?.type === "lineNumber") {
    const { anchor, active } = target.mark;
    if (anchor.type !== active.type || anchor.lineNumber < 0 !== active.lineNumber < 0) {
      return {
        type: "range",
        anchor: {
          type: "primitive",
          mark: createLineNumberMarkFromPos(anchor),
          modifiers
        },
        active: {
          type: "primitive",
          mark: createLineNumberMarkFromPos(active)
        },
        excludeAnchor: false,
        excludeActive: false
      };
    }
  }
  return {
    ...target,
    mark: target.mark != null ? updateMark(target.mark) : void 0,
    modifiers
  };
}
function updateMark(mark) {
  switch (mark.type) {
    case "lineNumber":
      return createLineNumberMark(mark);
    default:
      return mark;
  }
}
function updateModifier(modifier) {
  switch (modifier.type) {
    case "ordinalRange":
      return createOrdinalModifier(modifier);
    default:
      return modifier;
  }
}
function createLineNumberMark(mark) {
  if (isEqual_default(mark.anchor, mark.active)) {
    return createLineNumberMarkFromPos(mark.anchor);
  }
  return {
    type: "range",
    anchor: createLineNumberMarkFromPos(mark.anchor),
    active: createLineNumberMarkFromPos(mark.active)
  };
}
function createOrdinalModifier(modifier) {
  if (modifier.anchor === modifier.active) {
    return createAbsoluteOrdinalModifier(modifier.scopeType, modifier.anchor);
  }
  if (modifier.anchor === 0 && modifier.active > modifier.anchor) {
    return createAbsoluteOrdinalModifier(
      modifier.scopeType,
      modifier.anchor,
      modifier.active - modifier.anchor + 1
    );
  }
  if (modifier.anchor < 0 && modifier.active === -1) {
    return createAbsoluteOrdinalModifier(
      modifier.scopeType,
      modifier.anchor,
      -modifier.anchor
    );
  }
  return {
    type: "range",
    anchor: createAbsoluteOrdinalModifier(modifier.scopeType, modifier.anchor),
    active: createAbsoluteOrdinalModifier(modifier.scopeType, modifier.active),
    excludeAnchor: modifier.excludeAnchor,
    excludeActive: modifier.excludeActive
  };
}
function createLineNumberMarkFromPos(position) {
  return {
    type: "lineNumber",
    lineNumberType: position.type,
    lineNumber: position.lineNumber
  };
}
function createAbsoluteOrdinalModifier(scopeType, start2, length = 1) {
  return {
    type: "ordinalScope",
    scopeType,
    start: start2,
    length
  };
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV3ToV4/upgradeV3ToV4.ts
function upgradeV3ToV4(command) {
  return {
    ...command,
    version: 4,
    targets: command.targets.map(upgradeTarget3)
  };
}
function upgradeTarget3(target) {
  switch (target.type) {
    case "primitive":
      return upgradePrimitiveTarget3(target);
    case "range": {
      const { anchor, ...rest } = target;
      return {
        ...rest,
        anchor: upgradePrimitiveTarget3(anchor)
      };
    }
    case "list": {
      const { elements, ...rest } = target;
      return {
        ...rest,
        elements: elements.map(upgradeTarget3)
      };
    }
  }
}
function upgradePrimitiveTarget3(target) {
  if (target.mark == null && target.modifiers == null || target.isImplicit) {
    return { type: "implicit" };
  }
  return target;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV4ToV5/upgradeV4ToV5.ts
function upgradeV4ToV5(command) {
  return {
    ...command,
    version: 5,
    action: upgradeAction(command.action),
    targets: command.targets.map(upgradeTarget4)
  };
}
function upgradeAction(action) {
  switch (action.name) {
    case "wrapWithSnippet": {
      const [name2, variableName] = parseSnippetLocation(
        action.args[0]
      );
      return {
        name: "wrapWithSnippet",
        args: [
          {
            type: "named",
            name: name2,
            variableName
          }
        ]
      };
    }
    case "insertSnippet": {
      const [name2, substitutions] = action.args;
      const snippetDescription = {
        type: "named",
        name: name2
      };
      if (substitutions != null) {
        snippetDescription.substitutions = substitutions;
      }
      return {
        name: "insertSnippet",
        args: [snippetDescription]
      };
    }
    default:
      return action;
  }
}
function parseSnippetLocation(snippetLocation) {
  const [snippetName, placeholderName] = snippetLocation.split(".");
  if (snippetName == null || placeholderName == null) {
    throw new Error("Snippet location missing '.'");
  }
  return [snippetName, placeholderName];
}
function upgradeTarget4(target) {
  switch (target.type) {
    case "implicit":
      return target;
    case "list":
      return {
        ...target,
        elements: target.elements.map(
          upgradeTarget4
        )
      };
    case "range":
      return {
        ...target,
        anchor: upgradeTarget4(
          target.anchor
        ),
        active: upgradeTarget4(
          target.active
        )
      };
    case "primitive":
      return {
        ...target,
        mark: target.mark != null ? upgradeMark(target.mark) : void 0,
        modifiers: target.modifiers != null && target.modifiers.length > 0 ? target.modifiers.map(upgradeModifier2) : void 0
      };
  }
}
function upgradeMark(mark) {
  if (mark.type === "range") {
    return {
      ...mark,
      anchor: upgradeMark(mark.anchor),
      active: upgradeMark(mark.active),
      excludeAnchor: mark.excludeAnchor ?? false,
      excludeActive: mark.excludeActive ?? false
    };
  }
  return mark;
}
function upgradeModifier2(modifier) {
  if (modifier.type === "range") {
    return {
      ...modifier,
      anchor: upgradeModifier2(modifier.anchor),
      active: upgradeModifier2(modifier.active),
      excludeAnchor: modifier.excludeAnchor ?? false,
      excludeActive: modifier.excludeActive ?? false
    };
  }
  return modifier;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV5ToV6/canonicalizeActionName.ts
var actionAliasToCanonicalName = {
  bring: "replaceWithTarget",
  call: "callAsFunction",
  clear: "clearAndSetSelection",
  commentLines: "toggleLineComment",
  copy: "copyToClipboard",
  cut: "cutToClipboard",
  delete: "remove",
  editNewLineAbove: "editNewLineBefore",
  editNewLineBelow: "editNewLineAfter",
  findInFiles: "findInWorkspace",
  fold: "foldRegion",
  indentLines: "indentLine",
  insertEmptyLineAbove: "insertEmptyLineBefore",
  insertEmptyLineBelow: "insertEmptyLineAfter",
  insertLineAfter: "editNewLineAfter",
  insertLineBefore: "editNewLineBefore",
  move: "moveToTarget",
  outdentLines: "outdentLine",
  paste: "pasteFromClipboard",
  reverse: "reverseTargets",
  setBreakpoint: "toggleLineBreakpoint",
  sort: "sortTargets",
  swap: "swapTargets",
  unfold: "unfoldRegion",
  use: "replaceWithTarget",
  wrap: "wrapWithPairedDelimiter"
};
function canonicalizeActionName(actionName) {
  const canonicalName = actionAliasToCanonicalName[actionName] ?? actionName;
  if (!actionNames.includes(canonicalName)) {
    throw new Error(`Unknown action name: ${canonicalName}`);
  }
  return canonicalName;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV5ToV6/upgradeV5ToV6.ts
function upgradeV5ToV6(command) {
  return {
    version: 6,
    spokenForm: command.spokenForm,
    usePrePhraseSnapshot: command.usePrePhraseSnapshot,
    action: upgradeAction2(command.action, command.targets)
  };
}
function upgradeAction2(action, targets) {
  const name2 = canonicalizeActionName(action.name);
  switch (name2) {
    case "replaceWithTarget":
    case "moveToTarget":
      return {
        name: name2,
        source: upgradeTarget5(targets[0]),
        destination: targetToDestination(targets[1])
      };
    case "swapTargets":
      return {
        name: name2,
        target1: upgradeTarget5(targets[0]),
        target2: upgradeTarget5(targets[1])
      };
    case "callAsFunction":
      return {
        name: name2,
        callee: upgradeTarget5(targets[0]),
        argument: upgradeTarget5(targets[1])
      };
    case "pasteFromClipboard":
      return {
        name: name2,
        destination: targetToDestination(targets[0])
      };
    case "wrapWithPairedDelimiter":
    case "rewrapWithPairedDelimiter":
      return {
        name: name2,
        left: action.args[0],
        right: action.args[1],
        target: upgradeTarget5(targets[0])
      };
    case "generateSnippet":
      return {
        name: name2,
        snippetName: action.args?.[0],
        target: upgradeTarget5(targets[0])
      };
    case "insertSnippet":
      return {
        name: name2,
        snippetDescription: action.args[0],
        destination: targetToDestination(targets[0])
      };
    case "wrapWithSnippet":
      return {
        name: name2,
        snippetDescription: action.args[0],
        target: upgradeTarget5(targets[0])
      };
    case "executeCommand":
      return {
        name: name2,
        commandId: action.args[0],
        options: action.args?.[1],
        target: upgradeTarget5(targets[0])
      };
    case "replace":
      return {
        name: name2,
        replaceWith: action.args[0],
        destination: targetToDestination(targets[0])
      };
    case "highlight": {
      const result = {
        name: name2,
        target: upgradeTarget5(targets[0])
      };
      if (action.args?.[0] != null) {
        result.highlightId = action.args?.[0];
      }
      return result;
    }
    case "editNew":
      return {
        name: name2,
        destination: targetToDestination(targets[0])
      };
    case "getText":
      return {
        name: name2,
        options: action.args?.[0],
        target: upgradeTarget5(targets[0])
      };
    case "parsed":
      throw Error("Parsed action should not be present in V5");
    default:
      return {
        name: name2,
        target: upgradeTarget5(targets[0])
      };
  }
}
function upgradeTarget5(target) {
  switch (target.type) {
    case "list":
    case "range":
    case "primitive":
      return upgradeNonImplicitTarget(target);
    case "implicit":
      return target;
  }
}
function upgradeNonImplicitTarget(target) {
  switch (target.type) {
    case "list":
      return upgradeListTarget(target);
    case "range":
    case "primitive":
      return upgradeRangeOrPrimitiveTarget(target);
  }
}
function upgradeListTarget(target) {
  return {
    ...target,
    elements: target.elements.map(upgradeRangeOrPrimitiveTarget)
  };
}
function upgradeRangeOrPrimitiveTarget(target) {
  switch (target.type) {
    case "range":
      return upgradeRangeTarget(target);
    case "primitive":
      return upgradePrimitiveTarget4(target);
  }
}
function upgradeRangeTarget(target) {
  const { anchor, active } = target;
  const result = {
    type: "range",
    anchor: anchor.type === "implicit" ? anchor : upgradePrimitiveTarget4(anchor),
    active: upgradePrimitiveTarget4(active),
    excludeAnchor: target.excludeAnchor,
    excludeActive: target.excludeActive
  };
  if (target.rangeType != null) {
    result.rangeType = target.rangeType;
  }
  return result;
}
function upgradePrimitiveTarget4(target) {
  const result = {
    type: "primitive"
  };
  const modifiers = upgradeModifiers(target.modifiers);
  if (modifiers != null) {
    result.modifiers = modifiers;
  }
  if (target.mark != null) {
    result.mark = target.mark;
  }
  return result;
}
function targetToDestination(target) {
  switch (target.type) {
    case "list":
      return listTargetToDestination(target);
    case "range":
      return rangeTargetToDestination(target);
    case "primitive":
      return primitiveTargetToDestination(target);
    case "implicit":
      return implicitTargetToDestination();
  }
}
function listTargetToDestination(target) {
  const destinations = [];
  let currentElements = [];
  let currentInsertionMode = void 0;
  const potentiallyAddDestination = () => {
    if (currentElements.length > 0) {
      destinations.push({
        type: "primitive",
        insertionMode: currentInsertionMode ?? "to",
        target: currentElements.length === 1 ? currentElements[0] : {
          type: "list",
          elements: currentElements
        }
      });
    }
  };
  target.elements.forEach((element) => {
    const insertionMode2 = getInsertionMode(element);
    if (insertionMode2 != null) {
      potentiallyAddDestination();
      currentElements = [upgradeRangeOrPrimitiveTarget(element)];
      currentInsertionMode = insertionMode2;
    } else {
      currentElements.push(upgradeRangeOrPrimitiveTarget(element));
    }
  });
  potentiallyAddDestination();
  if (destinations.length > 1) {
    return {
      type: "list",
      destinations
    };
  }
  return destinations[0];
}
function rangeTargetToDestination(target) {
  return {
    type: "primitive",
    insertionMode: getInsertionMode(target.anchor) ?? "to",
    target: upgradeRangeTarget(target)
  };
}
function primitiveTargetToDestination(target) {
  return {
    type: "primitive",
    insertionMode: getInsertionMode(target) ?? "to",
    target: upgradePrimitiveTarget4(target)
  };
}
function implicitTargetToDestination() {
  return { type: "implicit" };
}
function getInsertionMode(target) {
  switch (target.type) {
    case "implicit":
      return "to";
    case "primitive":
      return getInsertionModeFromPrimitive(target);
    case "range":
      return getInsertionMode(target.anchor);
  }
}
function getInsertionModeFromPrimitive(target) {
  const positionModifier = target.modifiers?.find(
    (m) => m.type === "position"
  );
  if (positionModifier != null) {
    if (target.modifiers.indexOf(positionModifier) !== 0) {
      throw Error("Position modifier has to be at first index");
    }
    if (positionModifier?.position === "before" || positionModifier?.position === "after") {
      return positionModifier.position;
    }
  }
  return void 0;
}
function upgradeModifiers(modifiers) {
  const result = [];
  if (modifiers != null) {
    for (const modifier of modifiers) {
      if (modifier.type === "position") {
        if (modifier.position === "start") {
          result.push({ type: "startOf" });
        } else if (modifier.position === "end") {
          result.push({ type: "endOf" });
        }
      } else {
        result.push(modifier);
      }
    }
  }
  return result.length > 0 ? result : void 0;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV6ToV7.ts
function upgradeV6ToV7(command) {
  return { ...command, version: 7 };
}

// ../cursorless-engine/src/core/commandVersionUpgrades/canonicalizeAndValidateCommand.ts
function canonicalizeAndValidateCommand(command) {
  const commandUpgraded = upgradeCommand(command, LATEST_VERSION);
  const { action, usePrePhraseSnapshot = false, spokenForm } = commandUpgraded;
  return {
    version: LATEST_VERSION,
    spokenForm,
    action: produce(action, (draft) => {
      const partialTargets = getPartialTargetDescriptors(draft);
      canonicalizeTargetsInPlace(partialTargets);
      validateCommand(action.name, partialTargets);
    }),
    usePrePhraseSnapshot
  };
}
function upgradeCommand(command, minimumVersion) {
  if (command.version > LATEST_VERSION) {
    throw new OutdatedExtensionError();
  }
  while (command.version < minimumVersion) {
    switch (command.version) {
      case 0:
        command = upgradeV0ToV1(command);
        break;
      case 1:
        command = upgradeV1ToV2(command);
        break;
      case 2:
        command = upgradeV2ToV3(command);
        break;
      case 3:
        command = upgradeV3ToV4(command);
        break;
      case 4:
        command = upgradeV4ToV5(command);
        break;
      case 5:
        command = upgradeV5ToV6(command);
        break;
      case 6:
        command = upgradeV6ToV7(command);
        break;
      default:
        throw new Error(
          `Can't upgrade from unknown version ${command.version}`
        );
    }
  }
  return command;
}
function validateCommand(_actionName, _partialTargets) {
}

// ../cursorless-engine/src/singletons/ide.singleton.ts
var ide_;
function injectIde(ide2) {
  ide_ = ide2;
}
function ide() {
  if (ide_ == null) {
    throw Error("Tried to access ide before it was injected");
  }
  return ide_;
}

// ../cursorless-engine/src/core/UndoStack.ts
var UndoStack = class {
  constructor(maxLength) {
    this.maxLength = maxLength;
    this.stack = [];
    this.index = void 0;
  }
  /**
   * Push a new state onto the stack. If {@link undo} has been called, the
   * future states will be dropped and the new state will be pushed onto the
   * stack.
   *
   * @param item The new state to push onto the stack
   */
  push(item) {
    if (this.index != null) {
      this.stack.splice(
        this.index + 1,
        this.stack.length - this.index - 1,
        item
      );
    } else {
      this.stack.push(item);
    }
    if (this.stack.length > this.maxLength) {
      this.stack.shift();
    }
    this.index = this.stack.length - 1;
  }
  /**
   * Undo to the previous state.
   *
   * @returns The previous state, or `undefined` if there are no previous states
   */
  undo() {
    if (this.index != null && this.index > 0) {
      this.index--;
      return this.stack[this.index];
    }
    return void 0;
  }
  /**
   * Redo to the next state.
   *
   * @returns The next state, or `undefined` if there are no future states
   */
  redo() {
    if (this.index != null && this.index < this.stack.length - 1) {
      this.index++;
      return this.stack[this.index];
    }
    return void 0;
  }
};

// ../cursorless-engine/src/core/StoredTargets.ts
var MAX_HISTORY_LENGTH = 25;
var StoredTargetMap = class {
  constructor() {
    this.targetMap = /* @__PURE__ */ new Map();
    // FIXME: Keep these targets up to date as document changes
    this.targetHistory = new DefaultMap(() => new UndoStack(MAX_HISTORY_LENGTH));
    this.notifier = new Notifier();
  }
  set(key, targets, { history = false } = {}) {
    this.targetMap.set(key, targets);
    if (history && targets != null) {
      this.targetHistory.get(key).push(targets);
    }
    this.notifier.notifyListeners(key, targets);
  }
  get(key) {
    return this.targetMap.get(key);
  }
  undo(key) {
    const targets = this.targetHistory.get(key).undo();
    if (targets != null) {
      this.set(key, targets, { history: false });
    }
  }
  redo(key) {
    const targets = this.targetHistory.get(key).redo();
    if (targets != null) {
      this.set(key, targets, { history: false });
    }
  }
  onStoredTargets(callback2) {
    for (const key of storedTargetKeys) {
      callback2(key, this.get(key));
    }
    return this.notifier.registerListener(callback2);
  }
};

// ../cursorless-engine/src/util/targetUtils.ts
function ensureSingleEditor(targets) {
  if (targets.length === 0) {
    throw new Error("Require at least one target with this action");
  }
  const editors = targets.map((target) => target.editor);
  if (new Set(editors).size > 1) {
    throw new Error("Can only have one editor with this action");
  }
  return editors[0];
}
function ensureSingleTarget(targets) {
  if (targets.length !== 1) {
    throw new Error("Can only have one target with this action");
  }
  return targets[0];
}
async function runForEachEditor(targets, getEditor2, func2) {
  return Promise.all(
    groupForEachEditor(targets, getEditor2).map(
      ([editor, editorTargets]) => func2(editor, editorTargets)
    )
  );
}
async function runOnTargetsForEachEditor(targets, func2) {
  return runForEachEditor(targets, (target) => target.editor, func2);
}
async function runOnTargetsForEachEditorSequentially(targets, func2) {
  const editorGroups = groupForEachEditor(targets, (target) => target.editor);
  const result = [];
  for (const [editor, targets2] of editorGroups) {
    result.push(await func2(editor, targets2));
  }
  return result;
}
function groupTargetsForEachEditor(targets) {
  return groupForEachEditor(targets, (target) => target.editor);
}
function groupForEachEditor(targets, getEditor2) {
  const getDocumentUri = (target) => getEditor2(target).document.uri;
  const editorMap = groupBy(targets, getDocumentUri);
  return Array.from(editorMap.values(), (editorTargets) => {
    const editor = getEditor2(editorTargets[0]);
    return [editor, editorTargets];
  });
}
function createThatMark(targets, ranges) {
  const thatMark = ranges != null ? zip_default(targets, ranges).map(([target, range3]) => ({
    editor: target.editor,
    selection: target?.isReversed ? new Selection(range3.end, range3.start) : new Selection(range3.start, range3.end)
  })) : targets.map((target) => ({
    editor: target.editor,
    selection: target.contentSelection
  }));
  return thatMark;
}
function toGeneralizedRange(target, range3) {
  return target.textualType === "line" ? toLineRange(range3) : toCharacterRange(range3);
}
function toGeneralizedContentRange(target) {
  return toGeneralizedRange(target, target.contentRange);
}
function flashTargets(ide2, targets, style, getRange = toGeneralizedContentRange) {
  return ide2.flashRanges(
    targets.map((target) => ({
      editor: target.editor,
      range: getRange(target),
      style
    }))
  );
}

// ../cursorless-engine/src/util/rangeUtils.ts
function expandToFullLine(editor, range3) {
  return new Range(
    new Position(range3.start.line, 0),
    editor.document.lineAt(range3.end).range.end
  );
}
function getRangeLength(editor, range3) {
  return range3.isEmpty ? 0 : editor.document.offsetAt(range3.end) - editor.document.offsetAt(range3.start);
}
function strictlyContains(range1, rangeOrPosition) {
  const [start2, end] = rangeOrPosition instanceof Position ? [rangeOrPosition, rangeOrPosition] : [rangeOrPosition.start, rangeOrPosition.end];
  return range1.start.isBefore(start2) && range1.end.isAfter(end);
}
function union(range3, ...unionWith) {
  for (const r of unionWith) {
    if (r != null) {
      range3 = range3.union(r);
    }
  }
  return range3;
}

// ../cursorless-engine/src/processTargets/targets/DestinationImpl.ts
var DestinationImpl = class _DestinationImpl {
  constructor(target, insertionMode2, indentationString) {
    this.target = target;
    this.insertionMode = insertionMode2;
    this.contentRange = getContentRange(target.contentRange, insertionMode2);
    this.isBefore = insertionMode2 === "before";
    this.isLineDelimiter = target.insertionDelimiter.includes("\n");
    this.indentationString = indentationString ?? this.isLineDelimiter ? getIndentationString(target.editor, target.contentRange) : "";
    this.insertionPrefix = target.prefixRange != null ? target.editor.document.getText(target.prefixRange) : void 0;
  }
  get contentSelection() {
    return this.contentRange.toSelection(this.target.isReversed);
  }
  get editor() {
    return this.target.editor;
  }
  get insertionDelimiter() {
    return this.target.insertionDelimiter;
  }
  get isRaw() {
    return this.target.isRaw;
  }
  /**
   * Creates a new destination with the given target while preserving insertion
   * mode and indentation string from this destination. This is important
   * because our "edit new" code updates the content range of the target when
   * multiple edits are performed in the same document, but we want to insert
   * the original indentation.
   */
  withTarget(target) {
    return new _DestinationImpl(
      target,
      this.insertionMode,
      this.indentationString
    );
  }
  getEditNewActionType() {
    if (this.insertionMode === "after" && this.target.contentRange.isSingleLine && this.insertionDelimiter === "\n" && this.insertionPrefix == null) {
      return "insertLineAfter";
    }
    return "edit";
  }
  constructChangeEdit(text, skipIndentation = false) {
    return this.insertionMode === "before" || this.insertionMode === "after" ? this.constructEditWithDelimiters(text, skipIndentation) : this.constructEditWithoutDelimiters(text);
  }
  constructEditWithDelimiters(text, skipIndentation) {
    const range3 = this.getEditRange();
    const editText2 = this.getEditText(text, skipIndentation);
    const updateRange = (range4) => {
      return this.updateRange(range4, text, skipIndentation);
    };
    return {
      range: range3,
      text: editText2,
      isReplace: this.insertionMode === "after",
      updateRange
    };
  }
  constructEditWithoutDelimiters(text) {
    return {
      range: this.contentRange,
      text,
      updateRange: (range3) => range3
    };
  }
  getEditRange() {
    const position = (() => {
      const insertionPosition = this.isBefore ? union(this.target.contentRange, this.target.prefixRange).start : this.target.contentRange.end;
      if (this.isLineDelimiter) {
        const line = this.editor.document.lineAt(insertionPosition);
        const trimmedPosition = this.isBefore ? line.rangeTrimmed?.start ?? line.range.start : line.rangeTrimmed?.end ?? line.range.end;
        if (insertionPosition.isEqual(trimmedPosition)) {
          return this.isBefore ? line.range.start : line.range.end;
        }
      }
      return insertionPosition;
    })();
    return new Range(position, position);
  }
  getEditText(text, skipIndentation) {
    const indentationString = skipIndentation ? "" : this.indentationString;
    const insertionText = indentationString + (this.insertionPrefix ?? "") + text;
    return this.isBefore ? insertionText + this.insertionDelimiter : this.insertionDelimiter + insertionText;
  }
  updateRange(range3, text, skipIndentation) {
    const baseStartOffset = this.editor.document.offsetAt(range3.start) + (skipIndentation ? 0 : this.indentationString.length) + (this.insertionPrefix?.length ?? 0);
    const startIndex = this.isBefore ? baseStartOffset : baseStartOffset + this.getLengthOfInsertionDelimiter();
    const endIndex = startIndex + text.length;
    return new Range(
      this.editor.document.positionAt(startIndex),
      this.editor.document.positionAt(endIndex)
    );
  }
  getLengthOfInsertionDelimiter() {
    if (this.editor.document.eol === "CRLF") {
      const matches = this.insertionDelimiter.match(/\n/g);
      if (matches != null) {
        return this.insertionDelimiter.length + matches.length;
      }
    }
    return this.insertionDelimiter.length;
  }
};
function getIndentationString(editor, range3) {
  let length = Number.MAX_SAFE_INTEGER;
  let indentationString = "";
  for (let i2 = range3.start.line; i2 <= range3.end.line; ++i2) {
    const line = editor.document.lineAt(i2);
    if (line.range.isEmpty || line.isEmptyOrWhitespace && !range3.isSingleLine) {
      continue;
    }
    const trimmedPosition = line.rangeTrimmed?.start ?? line.range.end;
    if (trimmedPosition.character < length) {
      length = trimmedPosition.character;
      indentationString = line.text.slice(0, length);
    }
  }
  return indentationString;
}
function getContentRange(contentRange, insertionMode2) {
  switch (insertionMode2) {
    case "before":
      return contentRange.start.toEmptyRange();
    case "after":
      return contentRange.end.toEmptyRange();
    case "to":
      return contentRange;
  }
}

// ../cursorless-engine/src/processTargets/targets/util/createContinuousRange.ts
function createContinuousRange(startTarget, endTarget, includeStart, includeEnd) {
  return createContinuousRangeFromRanges(
    startTarget.contentRange,
    endTarget.contentRange,
    includeStart,
    includeEnd
  );
}
function createContinuousRangeFromRanges(startRange, endRange, includeStart, includeEnd) {
  return new Range(
    includeStart ? startRange.start : startRange.end,
    includeEnd ? endRange.end : endRange.start
  );
}
function createContinuousLineRange(startTarget, endTarget, includeStart, includeEnd) {
  const start2 = includeStart ? startTarget.contentRange.start : new Position(startTarget.contentRange.end.line + 1, 0);
  const end = includeEnd ? endTarget.contentRange.end : endTarget.editor.document.lineAt(endTarget.contentRange.start.line - 1).range.end;
  return new Range(start2, end);
}

// ../cursorless-engine/src/processTargets/targets/BaseTarget.ts
var BaseTarget = class _BaseTarget {
  constructor(parameters) {
    this.hasExplicitScopeType = true;
    this.hasExplicitRange = true;
    this.isRaw = false;
    this.isImplicit = false;
    this.isNotebookCell = false;
    this.textualType = "token";
    this.state = {
      editor: parameters.editor,
      isReversed: parameters.isReversed,
      contentRange: parameters.contentRange,
      thatTarget: parameters.thatTarget
    };
  }
  get editor() {
    return this.state.editor;
  }
  get isReversed() {
    return this.state.isReversed;
  }
  get thatTarget() {
    return this.state.thatTarget != null ? this.state.thatTarget.thatTarget : this;
  }
  get contentText() {
    return this.editor.document.getText(this.contentRange);
  }
  get contentSelection() {
    return this.contentRange.toSelection(this.isReversed);
  }
  get contentRange() {
    return this.state.contentRange;
  }
  constructRemovalEdit() {
    return {
      range: this.getRemovalRange(),
      text: "",
      updateRange: (range3) => range3
    };
  }
  getRemovalHighlightRange() {
    return toGeneralizedRange(this, this.getRemovalRange());
  }
  withThatTarget(thatTarget) {
    return this.cloneWith({ thatTarget });
  }
  withContentRange(contentRange) {
    return this.cloneWith({ contentRange });
  }
  getInterior() {
    return void 0;
  }
  getBoundary() {
    return void 0;
  }
  cloneWith(parameters) {
    const constructor = Object.getPrototypeOf(this).constructor;
    return new constructor({
      ...this.getCloneParameters(),
      ...parameters
    });
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    const { constructor } = Object.getPrototypeOf(this);
    return new constructor({
      ...this.getCloneParameters(),
      isReversed,
      contentRange: createContinuousRange(this, endTarget, true, true)
    });
  }
  isEqual(otherTarget) {
    return otherTarget instanceof _BaseTarget && isEqual_default(this.getEqualityParameters(), otherTarget.getEqualityParameters());
  }
  /**
   * Constructs an object that can be used for determining equality between two
   * {@link BaseTarget} objects. We proceed by just getting the objects clone
   * parameters and removing the `thatTarget`.
   *
   * We would prefer to instead merge the `thatTarget`s into a list. See #780
   * for more details.
   *
   * @returns The object to be used for determining equality
   */
  getEqualityParameters() {
    const { thatTarget, ...otherCloneParameters } = this.getCloneParameters();
    return {
      ...otherCloneParameters
    };
  }
  toDestination(insertionMode2) {
    return new DestinationImpl(this, insertionMode2);
  }
  /**
   * Converts the target to a plain object representation.
   *
   * Note that this implementation is quite incomplete, but is suitable for
   * round-tripping {@link UntypedTarget} objects and capturing the fact that an
   * object is not an un typed target if it is not, via the {@link type}
   * attribute.  In the future, we should override this method in subclasses to
   * provide a more complete representation.
   * @returns A plain object representation of the target
   */
  toPlainObject() {
    return {
      type: this.type,
      contentRange: rangeToPlainObject(this.contentRange),
      isReversed: this.isReversed,
      hasExplicitRange: this.hasExplicitRange
    };
  }
};

// ../cursorless-engine/src/util/selectionUtils.ts
function shrinkRangeToFitContent(editor, range3) {
  const { document: document2 } = editor;
  const text = document2.getText(range3);
  const startDelta = text.length - text.trimStart().length;
  const endDelta = text.length - text.trimEnd().length;
  const startOffset = document2.offsetAt(range3.start) + startDelta;
  const endOffset = document2.offsetAt(range3.end) - endDelta;
  const start2 = document2.positionAt(startOffset);
  const end = document2.positionAt(endOffset);
  return new Range(start2, end);
}

// ../cursorless-engine/src/util/tryConstructTarget.ts
function tryConstructTarget(constructor, editor, range3, isReversed) {
  return range3 == null ? void 0 : new constructor({
    editor,
    isReversed,
    contentRange: range3
  });
}

// ../cursorless-engine/src/processTargets/targets/PlainTarget.ts
var PlainTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "PlainTarget";
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.contentRange;
    this.textualType = parameters.textualType ?? "token";
    this.insertionDelimiter = parameters.insertionDelimiter ?? "";
  }
  getCloneParameters() {
    return {
      ...this.state,
      textualType: this.textualType,
      insertionDelimiter: this.insertionDelimiter
    };
  }
};
function tryConstructPlainTarget(editor, range3, isReversed) {
  return tryConstructTarget(PlainTarget, editor, range3, isReversed);
}

// ../cursorless-engine/src/processTargets/targets/DocumentTarget.ts
var DocumentTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "DocumentTarget";
    this.textualType = "line";
    this.insertionDelimiter = "\n\n";
  }
  getInterior() {
    return [
      // Use plain target instead of interior target since we want the same content and removal range for a document interior.
      new PlainTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange: shrinkRangeToFitContent(this.editor, this.contentRange)
      })
    ];
  }
  getRemovalRange() {
    return this.contentRange;
  }
  getLeadingDelimiterTarget() {
    return void 0;
  }
  getTrailingDelimiterTarget() {
    return void 0;
  }
  getCloneParameters() {
    return this.state;
  }
};

// ../cursorless-engine/src/processTargets/targets/LineTarget.ts
var LineTarget = class _LineTarget extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "LineTarget";
    this.textualType = "line";
    this.insertionDelimiter = "\n";
    this.getRemovalHighlightRange = () => {
      return toLineRange(this.fullLineContentRange);
    };
  }
  get fullLineContentRange() {
    return expandToFullLine(this.editor, this.contentRange);
  }
  getLeadingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      getLeadingDelimiterRange(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getTrailingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      getTrailingDelimiterRange(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getRemovalRange() {
    const contentRemovalRange = this.fullLineContentRange;
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    return delimiterTarget == null ? contentRemovalRange : contentRemovalRange.union(delimiterTarget.contentRange);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _LineTarget({
      editor: this.editor,
      isReversed,
      contentRange: createContinuousLineRange(this, endTarget, true, true)
    });
  }
  getCloneParameters() {
    return this.state;
  }
};
function getLeadingDelimiterRange(editor, range3) {
  const { start: start2 } = range3;
  return start2.line > 0 ? new Range(editor.document.lineAt(start2.line - 1).range.end, range3.start) : void 0;
}
function getTrailingDelimiterRange(editor, range3) {
  const { end } = range3;
  return end.line + 1 < editor.document.lineCount ? new Range(range3.end, new Position(end.line + 1, 0)) : void 0;
}
function constructLineTarget(editor, range3, isReversed) {
  return tryConstructTarget(LineTarget, editor, range3, isReversed);
}

// ../cursorless-engine/src/processTargets/targets/NotebookCellDestination.ts
var NotebookCellDestination = class _NotebookCellDestination {
  constructor(target, insertionMode2) {
    this.target = target;
    this.insertionMode = insertionMode2;
  }
  get editor() {
    return this.target.editor;
  }
  get contentRange() {
    return this.target.contentRange;
  }
  get contentSelection() {
    return this.target.contentSelection;
  }
  get insertionDelimiter() {
    return this.target.insertionDelimiter;
  }
  get isRaw() {
    return this.target.isRaw;
  }
  withTarget(target) {
    return new _NotebookCellDestination(target, this.insertionMode);
  }
  getEditNewActionType() {
    throw new Error("Method not implemented.");
  }
  constructChangeEdit(_text) {
    throw new Error("Method not implemented.");
  }
};

// ../cursorless-engine/src/processTargets/targets/NotebookCellTarget.ts
var NotebookCellTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "NotebookCellTarget";
    this.insertionDelimiter = "\n";
    this.isNotebookCell = true;
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.contentRange;
  }
  getCloneParameters() {
    return this.state;
  }
  toDestination(insertionMode2) {
    return new NotebookCellDestination(this, insertionMode2);
  }
};

// ../cursorless-engine/src/processTargets/targets/ParagraphTarget.ts
var ParagraphTarget = class _ParagraphTarget extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "ParagraphTarget";
    this.textualType = "line";
    this.insertionDelimiter = "\n\n";
  }
  getLeadingDelimiterTarget() {
    return constructLineTarget(
      this.editor,
      getLeadingDelimiterRange2(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getTrailingDelimiterTarget() {
    return constructLineTarget(
      this.editor,
      getTrailingDelimiterRange2(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getRemovalRange() {
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    const removalContentRange = delimiterTarget != null ? this.contentRange.union(delimiterTarget.contentRange) : this.contentRange;
    return new LineTarget({
      contentRange: removalContentRange,
      editor: this.editor,
      isReversed: this.isReversed
    }).getRemovalRange();
  }
  get fullLineContentRange() {
    return expandToFullLine(this.editor, this.contentRange);
  }
  getRemovalHighlightRange() {
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    const range3 = delimiterTarget != null ? this.fullLineContentRange.union(delimiterTarget.contentRange) : this.fullLineContentRange;
    return toLineRange(range3);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _ParagraphTarget({
      ...this.getCloneParameters(),
      isReversed,
      contentRange: createContinuousLineRange(this, endTarget, true, true)
    });
  }
  getCloneParameters() {
    return this.state;
  }
};
function getLeadingDelimiterRange2(editor, contentRange) {
  const { document: document2 } = editor;
  const startLine = document2.lineAt(contentRange.start);
  const leadingLine = getPreviousNonEmptyLine(document2, startLine);
  if (leadingLine != null) {
    if (leadingLine.lineNumber + 1 === startLine.lineNumber) {
      return void 0;
    }
    return new Range(
      new Position(leadingLine.lineNumber + 1, 0),
      document2.lineAt(startLine.lineNumber - 1).range.end
    );
  }
  if (startLine.lineNumber > 0) {
    return new Range(
      new Position(0, 0),
      document2.lineAt(startLine.lineNumber - 1).range.end
    );
  }
  return void 0;
}
function getTrailingDelimiterRange2(editor, contentRange) {
  const { document: document2 } = editor;
  const endLine = document2.lineAt(contentRange.end);
  const trailingLine = getNextNonEmptyLine(document2, endLine);
  if (trailingLine != null) {
    if (trailingLine.lineNumber - 1 === endLine.lineNumber) {
      return void 0;
    }
    return new Range(
      new Position(endLine.lineNumber + 1, 0),
      document2.lineAt(trailingLine.lineNumber - 1).range.end
    );
  }
  if (endLine.lineNumber < document2.lineCount - 1) {
    return new Range(
      new Position(endLine.lineNumber + 1, 0),
      document2.lineAt(document2.lineCount - 1).range.end
    );
  }
  return void 0;
}
function getPreviousNonEmptyLine(document2, line) {
  while (line.lineNumber > 0) {
    const previousLine = document2.lineAt(line.lineNumber - 1);
    if (!previousLine.isEmptyOrWhitespace) {
      return previousLine;
    }
    line = previousLine;
  }
  return null;
}
function getNextNonEmptyLine(document2, line) {
  while (line.lineNumber + 1 < document2.lineCount) {
    const nextLine = document2.lineAt(line.lineNumber + 1);
    if (!nextLine.isEmptyOrWhitespace) {
      return nextLine;
    }
    line = nextLine;
  }
  return null;
}

// ../cursorless-engine/src/processTargets/targets/RawSelectionTarget.ts
var RawSelectionTarget = class extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "RawSelectionTarget";
    this.textualType = "character";
    this.insertionDelimiter = "";
    this.isRaw = true;
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.contentRange;
    this.getCloneParameters = () => this.state;
  }
};

// ../cursorless-engine/src/processTargets/targets/util/insertionRemovalBehaviors/DelimitedSequenceInsertionRemovalBehavior.ts
function getDelimitedSequenceRemovalRange(target) {
  const contentRange = union(target.contentRange, target.prefixRange);
  const delimiterTarget = target.getTrailingDelimiterTarget() ?? target.getLeadingDelimiterTarget();
  return delimiterTarget != null ? contentRange.union(delimiterTarget.contentRange) : contentRange;
}

// ../cursorless-engine/src/processTargets/targets/util/insertionRemovalBehaviors/TokenInsertionRemovalBehavior.ts
var leadingDelimiters = ['"', "'", "(", "[", "{", "<"];
var trailingDelimiters = ['"', "'", ")", "]", "}", ">", ",", ";", ":"];
function getTokenLeadingDelimiterTarget(target) {
  const { editor } = target;
  const { start: start2 } = union(target.contentRange, target.prefixRange);
  const startLine = editor.document.lineAt(start2);
  const leadingText = startLine.text.slice(0, start2.character);
  const leadingDelimiters2 = leadingText.match(/\s+$/);
  return leadingDelimiters2 == null ? void 0 : new PlainTarget({
    contentRange: new Range(
      start2.line,
      start2.character - leadingDelimiters2[0].length,
      start2.line,
      start2.character
    ),
    editor,
    isReversed: target.isReversed
  });
}
function getTokenTrailingDelimiterTarget(target) {
  const { editor } = target;
  const { end } = target.contentRange;
  const endLine = editor.document.lineAt(end);
  const trailingText = endLine.text.slice(end.character);
  const trailingDelimiters2 = trailingText.match(/^\s+/);
  return trailingDelimiters2 == null ? void 0 : new PlainTarget({
    contentRange: new Range(
      end.line,
      end.character,
      end.line,
      end.character + trailingDelimiters2[0].length
    ),
    editor,
    isReversed: target.isReversed
  });
}
function getTokenRemovalRange(target) {
  const { editor } = target;
  const contentRange = union(target.contentRange, target.prefixRange);
  const { start: start2, end } = contentRange;
  const leadingWhitespaceRange = target.getLeadingDelimiterTarget()?.contentRange ?? start2.toEmptyRange();
  const trailingWhitespaceRange = target.getTrailingDelimiterTarget()?.contentRange ?? end.toEmptyRange();
  const fullLineRange = expandToFullLine(editor, contentRange);
  if (leadingWhitespaceRange.union(trailingWhitespaceRange).isRangeEqual(fullLineRange)) {
    return fullLineRange;
  }
  if (!trailingWhitespaceRange.isEmpty) {
    if (!leadingWhitespaceRange.isEmpty || contentRange.start.isEqual(fullLineRange.start) || leadingDelimiters.includes(getLeadingCharacter(editor, contentRange))) {
      return contentRange.union(trailingWhitespaceRange);
    }
  }
  if (!leadingWhitespaceRange.isEmpty) {
    if (contentRange.end.isEqual(fullLineRange.end) || trailingDelimiters.includes(getTrailingCharacter(editor, contentRange))) {
      return contentRange.union(leadingWhitespaceRange);
    }
  }
  return contentRange;
}
function getLeadingCharacter(editor, contentRange) {
  const { start: start2 } = contentRange;
  const line = editor.document.lineAt(start2);
  return start2.isAfter(line.range.start) ? editor.document.getText(new Range(start2.translate(void 0, -1), start2)) : "";
}
function getTrailingCharacter(editor, contentRange) {
  const { end } = contentRange;
  const line = editor.document.lineAt(end);
  return end.isBefore(line.range.end) ? editor.document.getText(new Range(end.translate(void 0, 1), end)) : "";
}

// ../cursorless-engine/src/processTargets/targets/TokenTarget.ts
var TokenTarget = class extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "TokenTarget";
    this.textualType = "token";
    this.insertionDelimiter = " ";
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return getTokenRemovalRange(this);
  }
  getCloneParameters() {
    return this.state;
  }
};

// ../cursorless-engine/src/processTargets/targets/util/insertionRemovalBehaviors/getSmartRemovalTarget.ts
function getSmartRemovalTarget(target) {
  const { editor, isReversed } = target;
  const { document: document2 } = editor;
  const contentRange = union(target.contentRange, target.prefixRange);
  if (isWholeLines(document2, contentRange)) {
    if (hasLeadingAndTrailingEmptyLines(document2, contentRange)) {
      return new ParagraphTarget({
        editor,
        isReversed,
        contentRange
      });
    }
    return new LineTarget({
      editor,
      isReversed,
      contentRange
    });
  }
  return new TokenTarget({
    editor,
    isReversed,
    contentRange
  });
}
function isWholeLines(document2, contentRange) {
  const start2 = document2.lineAt(contentRange.start).rangeTrimmed?.start;
  const end = document2.lineAt(contentRange.end).rangeTrimmed?.end;
  return start2 != null && end != null && start2.isEqual(contentRange.start) && end.isEqual(contentRange.end);
}
function hasLeadingAndTrailingEmptyLines(document2, contentRange) {
  const { start: start2, end } = contentRange;
  return (start2.line === 0 || document2.lineAt(start2.line - 1).isEmptyOrWhitespace) && (end.line === document2.lineCount - 1 || document2.lineAt(end.line + 1).isEmptyOrWhitespace);
}

// ../cursorless-engine/src/processTargets/targets/ScopeTypeTarget.ts
var ScopeTypeTarget = class _ScopeTypeTarget extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "ScopeTypeTarget";
    this.scopeTypeType_ = parameters.scopeTypeType;
    this.removalRange_ = parameters.removalRange;
    this.leadingDelimiterRange_ = parameters.leadingDelimiterRange;
    this.trailingDelimiterRange_ = parameters.trailingDelimiterRange;
    this.prefixRange = parameters.prefixRange;
    this.insertionDelimiter = parameters.insertionDelimiter ?? getInsertionDelimiter(parameters.scopeTypeType);
    this.hasDelimiterRange_ = !!this.leadingDelimiterRange_ || !!this.trailingDelimiterRange_;
  }
  getLeadingDelimiterTarget() {
    if (this.leadingDelimiterRange_ != null) {
      return new PlainTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange: this.leadingDelimiterRange_
      });
    }
    if (!this.hasDelimiterRange_) {
      return getTokenLeadingDelimiterTarget(this);
    }
    return void 0;
  }
  getTrailingDelimiterTarget() {
    if (this.trailingDelimiterRange_ != null) {
      return new PlainTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange: this.trailingDelimiterRange_
      });
    }
    if (!this.hasDelimiterRange_) {
      return getTokenTrailingDelimiterTarget(this);
    }
    return void 0;
  }
  getRemovalRange() {
    if (this.removalRange_ != null) {
      return this.removalRange_;
    }
    if (this.hasDelimiterRange_) {
      return getDelimitedSequenceRemovalRange(this);
    }
    return getSmartRemovalTarget(this).getRemovalRange();
  }
  getRemovalHighlightRange() {
    if (this.removalRange_ != null) {
      return toGeneralizedRange(this, this.removalRange_);
    }
    if (this.hasDelimiterRange_) {
      return toGeneralizedRange(this, getDelimitedSequenceRemovalRange(this));
    }
    return getSmartRemovalTarget(this).getRemovalHighlightRange();
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    if (this.scopeTypeType_ !== endTarget.scopeTypeType_) {
      return null;
    }
    const contentRemovalRange = this.removalRange_ != null || endTarget.removalRange_ != null ? (this.removalRange_ ?? this.contentRange).union(
      endTarget.removalRange_ ?? endTarget.contentRange
    ) : void 0;
    return new _ScopeTypeTarget({
      ...this.getCloneParameters(),
      isReversed,
      leadingDelimiterRange: this.leadingDelimiterRange_,
      trailingDelimiterRange: endTarget.trailingDelimiterRange_,
      removalRange: contentRemovalRange,
      contentRange: this.contentRange.union(endTarget.contentRange)
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      insertionDelimiter: this.insertionDelimiter,
      prefixRange: this.prefixRange,
      removalRange: void 0,
      interiorRange: void 0,
      scopeTypeType: this.scopeTypeType_,
      leadingDelimiterRange: this.leadingDelimiterRange_,
      trailingDelimiterRange: this.trailingDelimiterRange_
    };
  }
};
function getInsertionDelimiter(scopeType) {
  switch (scopeType) {
    case "class":
    case "namedFunction":
    case "section":
    case "sectionLevelOne":
    case "sectionLevelTwo":
    case "sectionLevelThree":
    case "sectionLevelFour":
    case "sectionLevelFive":
    case "sectionLevelSix":
    case "part":
    case "chapter":
    case "subSection":
    case "subSubSection":
    case "namedParagraph":
    case "subParagraph":
      return "\n\n";
    case "anonymousFunction":
    case "statement":
    case "ifStatement":
    case "comment":
    case "xmlElement":
    case "collectionItem":
    case "branch":
    case "environment":
      return "\n";
    default:
      return " ";
  }
}

// ../cursorless-engine/src/processTargets/targets/SubTokenWordTarget.ts
var SubTokenWordTarget = class _SubTokenWordTarget extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "SubTokenWordTarget";
    this.textualType = "word";
    this.leadingDelimiterRange_ = parameters.leadingDelimiterRange;
    this.trailingDelimiterRange_ = parameters.trailingDelimiterRange;
    this.insertionDelimiter = parameters.insertionDelimiter;
  }
  getLeadingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      this.leadingDelimiterRange_,
      this.isReversed
    );
  }
  getTrailingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      this.trailingDelimiterRange_,
      this.isReversed
    );
  }
  getRemovalRange() {
    return getDelimitedSequenceRemovalRange(this);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _SubTokenWordTarget({
      ...this.getCloneParameters(),
      isReversed,
      contentRange: createContinuousRange(this, endTarget, true, true),
      trailingDelimiterRange: endTarget.trailingDelimiterRange_
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      leadingDelimiterRange: this.leadingDelimiterRange_,
      trailingDelimiterRange: this.trailingDelimiterRange_,
      insertionDelimiter: this.insertionDelimiter
    };
  }
};

// ../cursorless-engine/src/processTargets/targets/InteriorTarget.ts
var InteriorTarget = class _InteriorTarget extends BaseTarget {
  constructor(parameters) {
    super({
      ...parameters,
      contentRange: shrinkRangeToFitContent(
        parameters.editor,
        parameters.fullInteriorRange
      )
    });
    this.type = "InteriorTarget";
    this.insertionDelimiter = " ";
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.fullInteriorRange;
    this.fullInteriorRange = parameters.fullInteriorRange;
  }
  getCloneParameters() {
    return {
      ...this.state,
      fullInteriorRange: this.fullInteriorRange
    };
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _InteriorTarget({
      ...this.getCloneParameters(),
      isReversed,
      fullInteriorRange: this.fullInteriorRange.union(
        endTarget.fullInteriorRange
      )
    });
  }
};

// ../cursorless-engine/src/processTargets/targets/SurroundingPairTarget.ts
var SurroundingPairTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "SurroundingPairTarget";
    this.insertionDelimiter = " ";
    this.boundary_ = parameters.boundary;
    this.interiorRange_ = parameters.interiorRange;
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return getTokenRemovalRange(this);
  }
  getInterior() {
    return [
      new InteriorTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        fullInteriorRange: this.interiorRange_
      })
    ];
  }
  getBoundary() {
    return this.boundary_.map(
      (contentRange) => new TokenTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange
      })
    );
  }
  getCloneParameters() {
    return {
      ...this.state,
      interiorRange: this.interiorRange_,
      boundary: this.boundary_
    };
  }
};

// ../cursorless-engine/src/processTargets/targets/UntypedTarget.ts
var UntypedTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "UntypedTarget";
    this.insertionDelimiter = " ";
    this.hasExplicitScopeType = false;
    this.hasExplicitRange = parameters.hasExplicitRange;
    this.textualType = parameters.textualType ?? "token";
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return this.editor.document.getText(this.contentRange).trim().length === 0 ? this.contentRange : getTokenRemovalRange(this);
  }
  maybeCreateRichRangeTarget() {
    return null;
  }
  getCloneParameters() {
    return {
      ...this.state,
      textualType: this.textualType,
      hasExplicitRange: this.hasExplicitRange
    };
  }
};

// ../cursorless-engine/src/processTargets/targets/ImplicitTarget.ts
var ImplicitTarget = class extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "ImplicitTarget";
    this.textualType = "character";
    this.insertionDelimiter = "";
    this.isRaw = true;
    this.hasExplicitScopeType = false;
    this.isImplicit = true;
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.contentRange;
    this.getCloneParameters = () => this.state;
  }
};

// ../cursorless-engine/src/processTargets/targets/HeadTailTarget.ts
var HeadTailTarget = class extends BaseTarget {
  constructor(parameters) {
    const { inputTarget, modifiedTarget, isHead } = parameters;
    super({
      ...parameters,
      contentRange: constructRange(
        inputTarget.contentRange,
        modifiedTarget.contentRange,
        isHead
      )
    });
    this.type = "HeadTailTarget";
    this.insertionDelimiter = " ";
    this.inputTarget = inputTarget;
    this.modifiedTarget = modifiedTarget;
    this.isHead = isHead;
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return getTokenRemovalRange(this);
  }
  getInterior() {
    const modifiedInterior = this.modifiedTarget.getInterior();
    if (modifiedInterior == null) {
      return void 0;
    }
    return modifiedInterior.map((target) => {
      return new PlainTarget({
        editor: this.editor,
        contentRange: constructRange(
          this.inputTarget.contentRange,
          target.contentRange,
          this.isHead
        ),
        isReversed: this.isReversed
      });
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      inputTarget: this.inputTarget,
      modifiedTarget: this.modifiedTarget,
      isHead: this.isHead
    };
  }
};
function constructRange(originalRange, modifiedRange, isHead) {
  return isHead ? new Range(modifiedRange.start, originalRange.end) : new Range(originalRange.start, modifiedRange.end);
}

// ../cursorless-engine/src/processTargets/targets/BoundedParagraphTarget.ts
var BoundedParagraphTarget = class _BoundedParagraphTarget extends BaseTarget {
  constructor(parameters) {
    super({
      ...parameters,
      contentRange: getIntersectionStrict(
        parameters.paragraphTarget.contentRange,
        parameters.containingInterior.contentRange
      )
    });
    this.type = "BoundedParagraphTarget";
    this.textualType = "line";
    this.insertionDelimiter = "\n\n";
    this.containingInterior = parameters.containingInterior;
    this.paragraphTarget = parameters.paragraphTarget;
    this.startLineGap = this.contentRange.start.line - this.containingInterior.fullInteriorRange.start.line;
    this.endLineGap = this.containingInterior.fullInteriorRange.end.line - this.contentRange.end.line;
  }
  getLeadingDelimiterTarget() {
    return this.startLineGap > 1 ? this.paragraphTarget.getLeadingDelimiterTarget() : void 0;
  }
  getTrailingDelimiterTarget() {
    return this.endLineGap > 1 ? this.paragraphTarget.getTrailingDelimiterTarget() : void 0;
  }
  getRemovalRange() {
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    const removalContentRange = delimiterTarget != null ? this.contentRange.union(delimiterTarget.contentRange) : this.contentRange;
    if (this.startLineGap <= 0 || this.endLineGap <= 0) {
      return removalContentRange;
    }
    return new LineTarget({
      contentRange: removalContentRange,
      editor: this.editor,
      isReversed: this.isReversed
    }).getRemovalRange();
  }
  get fullLineContentRange() {
    return expandToFullLine(this.editor, this.contentRange);
  }
  getRemovalHighlightRange() {
    const range3 = (() => {
      if (this.startLineGap < 1 || this.endLineGap < 1) {
        return this.getRemovalRange();
      }
      const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
      return delimiterTarget != null ? this.fullLineContentRange.union(delimiterTarget.contentRange) : this.fullLineContentRange;
    })();
    return toLineRange(range3);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _BoundedParagraphTarget({
      ...this.getCloneParameters(),
      isReversed,
      containingInterior: this.containingInterior.maybeCreateRichRangeTarget(
        isReversed,
        endTarget.containingInterior
      ),
      paragraphTarget: this.paragraphTarget.maybeCreateRichRangeTarget(
        isReversed,
        endTarget.paragraphTarget
      )
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      paragraphTarget: this.paragraphTarget,
      containingInterior: this.containingInterior
    };
  }
};
function getIntersectionStrict(range1, range22) {
  const intersection = range1.intersection(range22);
  if (intersection == null || intersection.isEmpty) {
    throw new Error("Ranges do not intersect");
  }
  return intersection;
}

// ../cursorless-engine/src/processTargets/marks/getActiveSelections.ts
function getActiveSelections(ide2) {
  return ide2.activeTextEditor?.selections.map((selection) => ({
    selection,
    editor: ide2.activeTextEditor
  })) ?? [];
}

// ../cursorless-engine/src/processTargets/marks/CursorStage.ts
var CursorStage = class {
  run() {
    return getActiveSelections(ide()).map(
      (selection) => new UntypedTarget({
        editor: selection.editor,
        isReversed: selection.selection.isReversed,
        contentRange: selection.selection,
        hasExplicitRange: !selection.selection.isEmpty,
        textualType: "character"
      })
    );
  }
};

// ../cursorless-engine/src/util/DecorationDebouncer.ts
var DecorationDebouncer = class {
  constructor(configuration, callback2) {
    this.debouncer = new Debouncer(
      callback2,
      configuration.getOwnConfiguration("decorationDebounceDelayMs")
    );
    this.run = this.run.bind(this);
  }
  run() {
    this.debouncer.run();
  }
  dispose() {
    this.debouncer.dispose();
  }
};

// ../cursorless-engine/src/KeyboardTargetUpdater.ts
var KeyboardTargetUpdater = class {
  constructor(ide2, storedTargets) {
    this.ide = ide2;
    this.storedTargets = storedTargets;
    this.disposables = [];
    this.debouncer = new DecorationDebouncer(
      ide2.configuration,
      () => this.updateKeyboardTarget()
    );
    this.disposables.push(
      ide2.configuration.onDidChangeConfiguration(() => this.maybeActivate()),
      this.debouncer
    );
    this.maybeActivate();
  }
  maybeActivate() {
    const isActive = this.ide.configuration.getOwnConfiguration(
      "experimental.keyboardTargetFollowsSelection"
    );
    if (isActive) {
      if (this.selectionWatcherDisposable == null) {
        this.selectionWatcherDisposable = this.ide.onDidChangeTextEditorSelection(this.debouncer.run);
      }
      return;
    }
    if (this.selectionWatcherDisposable != null) {
      this.selectionWatcherDisposable.dispose();
      this.selectionWatcherDisposable = void 0;
    }
  }
  updateKeyboardTarget() {
    const activeEditor = this.ide.activeTextEditor;
    if (activeEditor == null || this.storedTargets.get("keyboard") == null) {
      return;
    }
    this.storedTargets.set("keyboard", new CursorStage().run());
  }
  dispose() {
    this.disposables.forEach((disposable) => disposable.dispose());
    this.selectionWatcherDisposable?.dispose();
  }
};

// ../cursorless-engine/src/core/Debug.ts
var Debug = class {
  constructor(ide2) {
    this.ide = ide2;
    ide2.disposeOnExit(this);
    this.evaluateSetting = this.evaluateSetting.bind(this);
    this.active = true;
    switch (ide2.runMode) {
      // Development mode. Always enable.
      case "development":
        this.enableDebugLog();
        break;
      // Test mode. Always disable.
      case "test":
        this.disableDebugLog();
        break;
      // Production mode. Enable based on user setting.
      case "production":
        this.evaluateSetting();
        this.disposableConfiguration = ide2.configuration.onDidChangeConfiguration(this.evaluateSetting);
        break;
    }
  }
  log(...args2) {
    if (this.active) {
      console.log(...args2);
    }
  }
  dispose() {
    if (this.disposableConfiguration) {
      this.disposableConfiguration.dispose();
    }
  }
  enableDebugLog() {
    this.active = true;
  }
  disableDebugLog() {
    this.active = false;
  }
  evaluateSetting() {
    const debugEnabled = this.ide.configuration.getOwnConfiguration("debug");
    if (debugEnabled) {
      this.enableDebugLog();
    } else {
      this.disableDebugLog();
    }
  }
};

// ../cursorless-engine/src/tokenGraphemeSplitter/tokenGraphemeSplitter.ts
var KNOWN_SYMBOLS = [
  "!",
  "#",
  "$",
  "%",
  "&",
  "'",
  "(",
  ")",
  "*",
  "+",
  ",",
  "-",
  ".",
  "/",
  ":",
  ";",
  "<",
  "=",
  ">",
  "?",
  "@",
  "[",
  "\\",
  "]",
  "^",
  "_",
  "`",
  "{",
  "|",
  "}",
  "~",
  "\xA3",
  '"'
];
var KNOWN_SYMBOL_REGEXP_STR = KNOWN_SYMBOLS.map(escapeRegExp_default).join("|");
var KNOWN_GRAPHEME_REGEXP_STR = ["[a-zA-Z0-9]", KNOWN_SYMBOL_REGEXP_STR].join(
  "|"
);
var KNOWN_GRAPHEME_MATCHER = new RegExp(
  `^(${KNOWN_GRAPHEME_REGEXP_STR})$`,
  "u"
);
var UNKNOWN = "[unk]";
var GRAPHEME_SPLIT_REGEX = /\p{L}\p{M}*|[\p{N}\p{P}\p{S}]/gu;
var TokenGraphemeSplitter = class {
  constructor() {
    this.disposables = [];
    this.algorithmChangeNotifier = new Notifier();
    /**
     * Splits {@link token} into a list of graphemes, normalised as per
     * {@link normalizeGrapheme}.
     * @param token The token to split
     * @returns A list of normalised graphemes in {@link token}
     */
    this.getTokenGraphemes = (token) => matchAll(token, GRAPHEME_SPLIT_REGEX, (match) => ({
      text: this.normalizeGrapheme(match[0]),
      tokenStartOffset: match.index,
      tokenEndOffset: match.index + match[0].length
    }));
    /**
     * Register to be notified when the graphing splitting algorithm changes, for example if
     * the user changes the setting to enable preserving case
     * @param listener A function to be called when graphing splitting algorithm changes
     * @returns A function that can be called to unsubscribe from notifications
     */
    this.registerAlgorithmChangeListener = this.algorithmChangeNotifier.registerListener;
    ide().disposeOnExit(this);
    this.updateTokenHatSplittingMode = this.updateTokenHatSplittingMode.bind(this);
    this.getTokenGraphemes = this.getTokenGraphemes.bind(this);
    this.updateTokenHatSplittingMode();
    this.disposables.push(
      // Notify listeners in case the user changed their token hat splitting
      // setting.
      ide().configuration.onDidChangeConfiguration(
        this.updateTokenHatSplittingMode
      )
    );
  }
  updateTokenHatSplittingMode() {
    const { lettersToPreserve, symbolsToPreserve, ...rest } = ide().configuration.getOwnConfiguration("tokenHatSplittingMode");
    this.tokenHatSplittingMode = {
      lettersToPreserve: lettersToPreserve.map(
        (grapheme) => grapheme.toLowerCase().normalize("NFC")
      ),
      symbolsToPreserve: symbolsToPreserve.map(
        (grapheme) => grapheme.normalize("NFC")
      ),
      ...rest
    };
    this.algorithmChangeNotifier.notifyListeners();
  }
  /**
   * Normalizes the grapheme {@link rawGraphemeText} based on user
   * configuration.  Proceeds as follows:
   *
   * 1. Runs text through Unicode NFC normalization to ensure that characters
   *    that look identical are handled the same (eg whether they use combining
   *    mark or single codepoint for diacritics).
   * 2. If the grapheme is a known grapheme, returns it.
   * 3. Transforms grapheme to lowercase if
   *    {@link TokenHatSplittingMode.preserveCase} is `false`
   * 3. Returns the (possibly case-normalised) grapheme if it appears in
   *    {@link TokenHatSplittingMode.lettersToPreserve}
   * 4. Strips diacritics from the grapheme
   * 5. If the grapheme doesn't match {@link KNOWN_GRAPHEME_MATCHER}, maps the
   *    grapheme to the constant {@link UNKNOWN}, so that it can be referred to
   *    using "special", "red special", etc.
   * 6. Returns the grapheme.
   *
   * @param rawGraphemeText The raw grapheme text to normalise
   * @returns The normalised grapheme
   */
  normalizeGrapheme(rawGraphemeText) {
    const { preserveCase, lettersToPreserve, symbolsToPreserve } = this.tokenHatSplittingMode;
    let returnValue = rawGraphemeText.normalize("NFC");
    if (symbolsToPreserve.includes(returnValue)) {
      return returnValue;
    }
    if (!preserveCase) {
      returnValue = returnValue.toLowerCase();
    }
    if (lettersToPreserve.includes(returnValue.toLowerCase())) {
      return returnValue;
    }
    returnValue = deburr_default(returnValue);
    if (!KNOWN_GRAPHEME_MATCHER.test(returnValue)) {
      returnValue = UNKNOWN;
    }
    return returnValue;
  }
  dispose() {
    this.disposables.forEach(({ dispose }) => dispose());
  }
};

// ../cursorless-engine/src/singletons/tokenGraphemeSplitter.singleton.ts
function tokenGraphemeSplitter() {
  if (tokenGraphemeSplitter_ == null) {
    tokenGraphemeSplitter_ = new TokenGraphemeSplitter();
  }
  return tokenGraphemeSplitter_;
}
var tokenGraphemeSplitter_;

// ../cursorless-engine/src/tokenizer/tokenizer.ts
var REPEATABLE_SYMBOLS = [
  "-",
  "+",
  "*",
  "/",
  "=",
  "<",
  ">",
  "_",
  "#",
  ".",
  "|",
  "&",
  ":"
];
var FIXED_TOKENS = [
  "!==",
  "!=",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "<=",
  ">=",
  "=>",
  "->",
  "??",
  '"""',
  "```",
  "/*",
  "*/",
  "<!--",
  "-->"
];
var IDENTIFIER_WORD_REGEXES = ["\\p{L}", "\\p{M}", "\\p{N}"];
var SINGLE_SYMBOLS_REGEX = "[^\\s\\w]";
var NUMBERS_REGEX = "(?<![.\\d])\\d+\\.\\d+(?![.\\d])";
function generateMatcher(languageComponents) {
  const {
    fixedTokens,
    repeatableSymbols,
    identifierWordRegexes,
    identifierWordDelimiters,
    numbersRegex,
    singleSymbolsRegex
  } = languageComponents;
  const repeatableSymbolsRegex = repeatableSymbols.map(escapeRegExp_default).map((s) => `${s}+`).join("|");
  const fixedTokensRegex = fixedTokens.map(escapeRegExp_default).join("|");
  const identifierComponents = identifierWordRegexes.concat(
    identifierWordDelimiters.map(escapeRegExp_default)
  );
  const identifiersRegex = `(${identifierComponents.join("|")})+`;
  const wordRegex = `(${identifierWordRegexes.join("|")})+`;
  const regex = [
    fixedTokensRegex,
    numbersRegex,
    identifiersRegex,
    repeatableSymbolsRegex,
    singleSymbolsRegex
  ].join("|");
  return {
    identifierMatcher: new RegExp(identifiersRegex, "gu"),
    wordMatcher: new RegExp(wordRegex, "gu"),
    tokenMatcher: new RegExp(regex, "gu")
  };
}
var matchers = /* @__PURE__ */ new Map();
function getMatcher(languageId) {
  const wordSeparators = ide().configuration.getOwnConfiguration(
    "wordSeparators",
    {
      languageId
    }
  );
  const key = wordSeparators.join("\0");
  if (!matchers.has(key)) {
    const components = {
      fixedTokens: FIXED_TOKENS,
      repeatableSymbols: REPEATABLE_SYMBOLS,
      identifierWordRegexes: IDENTIFIER_WORD_REGEXES,
      identifierWordDelimiters: wordSeparators,
      numbersRegex: NUMBERS_REGEX,
      singleSymbolsRegex: SINGLE_SYMBOLS_REGEX
    };
    matchers.set(key, generateMatcher(components));
  }
  return matchers.get(key);
}
function tokenize(text, languageId, mapfn) {
  return matchAll(text, getMatcher(languageId).tokenMatcher, mapfn);
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/WordScopeHandler/WordTokenizer.ts
var CAMEL_REGEX = /\p{Lu}?\p{Ll}+|\p{Lu}+(?!\p{Ll})|\p{N}+/gu;
var WordTokenizer = class {
  constructor(languageId) {
    this.wordRegex = getMatcher(languageId).wordMatcher;
  }
  splitIdentifier(text) {
    const wordMatches = matchText(text, this.wordRegex);
    return wordMatches.length > 1 ? wordMatches : (
      // Secondly try split on camel case
      matchText(text, CAMEL_REGEX)
    );
  }
};

// ../cursorless-engine/src/util/allocateHats/HatMetrics.ts
var negativePenalty = ({ penalty }) => -penalty;
var avoidFirstLetter = ({ isFirstLetter }) => isFirstLetter ? -1 : 0;
function hatOldTokenRank(hatOldTokenRanks) {
  return ({ grapheme: { text: grapheme }, style }) => {
    const hatOldTokenRank2 = hatOldTokenRanks.get({
      grapheme,
      hatStyle: style
    });
    return hatOldTokenRank2 == null ? Infinity : -hatOldTokenRank2;
  };
}
function minimumTokenRankContainingGrapheme(tokenRank, graphemeTokenRanks) {
  const coreMetric = memoize_default((graphemeText) => {
    return min_default(graphemeTokenRanks[graphemeText].filter((r) => r > tokenRank)) ?? Infinity;
  });
  return ({ grapheme: { text } }) => coreMetric(text);
}
function isOldTokenHat(oldTokenHat) {
  return (hat) => hat.grapheme.text === oldTokenHat?.grapheme && hat.style === oldTokenHat?.hatStyle ? 1 : 0;
}
function penaltyEquivalenceClass(hatStability) {
  switch (hatStability) {
    case "greedy" /* greedy */:
      return ({ penalty }) => -penalty;
    case "balanced" /* balanced */:
      return ({ penalty }) => -(penalty < 2 ? 0 : 1);
    case "stable" /* stable */:
      return (_) => 0;
  }
}

// ../cursorless-engine/src/util/allocateHats/maxByFirstDiffering.ts
function maxByFirstDiffering(arr, fns) {
  if (arr.length === 0) {
    return void 0;
  }
  let remainingValues = arr;
  for (const fn of fns) {
    if (remainingValues.length === 1) {
      return remainingValues[0];
    }
    remainingValues = maxByAllowingTies(remainingValues, fn);
  }
  return remainingValues[0];
}
function maxByAllowingTies(arr, fn) {
  let best = -Infinity;
  const keep = [];
  for (const item of arr) {
    const value = fn(item);
    if (value < best) {
      continue;
    }
    if (value > best) {
      best = value;
      keep.length = 0;
    }
    keep.push(item);
  }
  return keep;
}

// ../cursorless-engine/src/util/allocateHats/chooseTokenHat.ts
function chooseTokenHat({ hatOldTokenRanks, graphemeTokenRanks }, hatStability, tokenRank, forcedTokenHat, oldTokenHat, candidates) {
  return maxByFirstDiffering(candidates, [
    // Use forced hat
    isOldTokenHat(forcedTokenHat),
    // Discard any hats that are sufficiently worse than the best hat that we
    // wouldn't use them even if they were our old hat
    penaltyEquivalenceClass(hatStability),
    // Use our old hat if it's still in the running
    isOldTokenHat(oldTokenHat),
    // Use a free hat if possible; if not, steal the hat of the token with
    // lowest rank
    hatOldTokenRank(hatOldTokenRanks),
    // Narrow to the hats with the lowest penalty
    negativePenalty,
    // Avoid the first grapheme of the token if possible
    avoidFirstLetter,
    // Prefer hats that sit on a grapheme that doesn't appear in any highly
    // ranked token
    minimumTokenRankContainingGrapheme(tokenRank, graphemeTokenRanks)
  ]);
}

// ../cursorless-engine/src/util/allocateHats/getHatRankingContext.ts
function getHatRankingContext(tokens2, oldTokenHatMap, tokenGraphemeSplitter2) {
  const graphemeTokenRanks = {};
  const hatOldTokenRanks = new CompositeKeyMap(({ grapheme, hatStyle }) => [grapheme, hatStyle]);
  tokens2.forEach(({ token, rank }) => {
    const existingTokenHat = oldTokenHatMap.get(token);
    if (existingTokenHat != null) {
      hatOldTokenRanks.set(existingTokenHat, rank);
    }
    tokenGraphemeSplitter2.getTokenGraphemes(token.text).forEach(({ text: graphemeText }) => {
      let tokenRanksForGrapheme;
      if (graphemeText in graphemeTokenRanks) {
        tokenRanksForGrapheme = graphemeTokenRanks[graphemeText];
      } else {
        tokenRanksForGrapheme = [];
        graphemeTokenRanks[graphemeText] = tokenRanksForGrapheme;
      }
      tokenRanksForGrapheme.push(rank);
    });
  });
  return {
    hatOldTokenRanks,
    graphemeTokenRanks
  };
}

// ../cursorless-engine/src/util/allocateHats/getDisplayLineMap.ts
function getDisplayLineMap(editor, extraLines = []) {
  return new Map(
    flow_default(
      flatten_default,
      uniq_default
    )(
      concat_default(
        [extraLines],
        editor.visibleRanges.map(
          (visibleRange) => range_default(visibleRange.start.line, visibleRange.end.line + 1)
        )
      )
    ).sort((a, b) => a - b).map((value, index) => [value, index])
  );
}

// ../cursorless-engine/src/util/allocateHats/getTokenComparator.ts
function getTokenComparator(selectionDisplayLine, selectionCharacterIndex) {
  return (token1, token2) => {
    const token1LineDiff = Math.abs(token1.displayLine - selectionDisplayLine);
    const token2LineDiff = Math.abs(token2.displayLine - selectionDisplayLine);
    if (token1LineDiff < token2LineDiff) {
      return -1;
    }
    if (token1LineDiff > token2LineDiff) {
      return 1;
    }
    const token1CharacterDiff = Math.abs(
      token1.range.start.character - selectionCharacterIndex
    );
    const token2CharacterDiff = Math.abs(
      token2.range.start.character - selectionCharacterIndex
    );
    return token1CharacterDiff - token2CharacterDiff;
  };
}

// ../cursorless-engine/src/util/allocateHats/getTokensInRange.ts
function getTokensInRange(editor, range3) {
  const languageId = editor.document.languageId;
  const text = editor.document.getText(range3);
  const rangeOffset = editor.document.offsetAt(range3.start);
  return tokenize(text, languageId, (match) => {
    const startOffset = rangeOffset + match.index;
    const endOffset = rangeOffset + match.index + match[0].length;
    const range4 = new Range(
      editor.document.positionAt(startOffset),
      editor.document.positionAt(endOffset)
    );
    return {
      editor,
      text: match[0],
      range: range4,
      offsets: { start: startOffset, end: endOffset }
    };
  });
}

// ../cursorless-engine/src/util/allocateHats/getRankedTokens.ts
function getRankedTokens(activeTextEditor, visibleTextEditors, forcedHatMap) {
  const editors = getRankedEditors(
    activeTextEditor,
    visibleTextEditors
  );
  const tokens2 = editors.flatMap((editor) => {
    const referencePosition = editor.selections[0].active;
    const displayLineMap = getDisplayLineMap(editor, [referencePosition.line]);
    const tokens3 = flatten_default(
      editor.visibleRanges.map(
        (range3) => getTokensInRange(editor, range3).map((partialToken) => ({
          ...partialToken,
          displayLine: displayLineMap.get(partialToken.range.start.line)
        }))
      )
    );
    tokens3.sort(
      getTokenComparator(
        displayLineMap.get(referencePosition.line),
        referencePosition.character
      )
    );
    return tokens3;
  });
  return moveForcedHatsToFront(forcedHatMap, tokens2).map((token, index) => ({
    token,
    rank: -index
  }));
}
function moveForcedHatsToFront(forcedHatMap, tokens2) {
  if (forcedHatMap == null) {
    return tokens2;
  }
  return tokens2.sort((a, b) => {
    const aIsForced = forcedHatMap.has(a);
    const bIsForced = forcedHatMap.has(b);
    if (aIsForced && !bIsForced) {
      return -1;
    }
    if (!aIsForced && bIsForced) {
      return 1;
    }
    return 0;
  });
}
function getRankedEditors(activeTextEditor, visibleTextEditors) {
  let editors;
  if (activeTextEditor == null) {
    editors = visibleTextEditors;
  } else {
    editors = [
      activeTextEditor,
      ...visibleTextEditors.filter((editor) => editor !== activeTextEditor)
    ];
  }
  return editors;
}

// ../cursorless-engine/src/util/allocateHats/allocateHats.ts
function allocateHats({
  tokenGraphemeSplitter: tokenGraphemeSplitter2,
  enabledHatStyles,
  forceTokenHats,
  oldTokenHats,
  hatStability,
  activeTextEditor,
  visibleTextEditors
}) {
  const forcedHatMap = forceTokenHats == null ? void 0 : getTokenOldHatMap(forceTokenHats);
  const tokenOldHatMap = getTokenOldHatMap(oldTokenHats);
  const rankedTokens = getRankedTokens(
    activeTextEditor,
    visibleTextEditors,
    forcedHatMap
  );
  const context = getHatRankingContext(
    rankedTokens,
    tokenOldHatMap,
    tokenGraphemeSplitter2
  );
  const enabledHatStyleNames = Object.keys(enabledHatStyles);
  const graphemeRemainingHatCandidates = new DefaultMap(
    () => [...enabledHatStyleNames]
  );
  return rankedTokens.map(({ token, rank: tokenRank }) => {
    const tokenRemainingHatCandidates = getTokenRemainingHatCandidates(
      tokenGraphemeSplitter2,
      token,
      graphemeRemainingHatCandidates,
      enabledHatStyles
    );
    const chosenHat = chooseTokenHat(
      context,
      hatStability,
      tokenRank,
      forcedHatMap?.get(token),
      tokenOldHatMap.get(token),
      tokenRemainingHatCandidates
    );
    if (chosenHat == null) {
      return void 0;
    }
    graphemeRemainingHatCandidates.set(
      chosenHat.grapheme.text,
      graphemeRemainingHatCandidates.get(chosenHat.grapheme.text).filter((style) => style !== chosenHat.style)
    );
    return constructHatRangeDescriptor(token, chosenHat);
  }).filter((value) => value != null);
}
function getTokenOldHatMap(oldTokenHats) {
  const tokenOldHatMap = new CompositeKeyMap(
    ({ editor, offsets }) => [editor.id, offsets.start, offsets.end]
  );
  oldTokenHats.forEach(
    (descriptor) => tokenOldHatMap.set(descriptor.token, descriptor)
  );
  return tokenOldHatMap;
}
function getTokenRemainingHatCandidates(tokenGraphemeSplitter2, token, graphemeRemainingHatCandidates, enabledHatStyles) {
  const candidates = [];
  const graphemes = tokenGraphemeSplitter2.getTokenGraphemes(token.text);
  const firstLetterOffsets = new Set(
    new WordTokenizer(token.editor.document.languageId).splitIdentifier(token.text).map((word) => word.index)
  );
  for (const grapheme of graphemes) {
    const isFirstLetter = firstLetterOffsets.has(grapheme.tokenStartOffset);
    for (const style of graphemeRemainingHatCandidates.get(grapheme.text)) {
      candidates.push({
        grapheme,
        style,
        penalty: enabledHatStyles[style].penalty,
        isFirstLetter
      });
    }
  }
  return candidates;
}
function constructHatRangeDescriptor(token, chosenHat) {
  return {
    hatStyle: chosenHat.style,
    grapheme: chosenHat.grapheme.text,
    token,
    hatRange: new Range(
      token.range.start.translate(
        void 0,
        chosenHat.grapheme.tokenStartOffset
      ),
      token.range.start.translate(void 0, chosenHat.grapheme.tokenEndOffset)
    )
  };
}

// ../cursorless-engine/src/core/HatAllocator.ts
var HatAllocator = class {
  constructor(hats, context) {
    this.hats = hats;
    this.context = context;
    this.disposables = [];
    ide().disposeOnExit(this);
    const debouncer = new DecorationDebouncer(
      ide().configuration,
      () => this.allocateHats()
    );
    this.disposables.push(
      this.hats.onDidChangeEnabledHatStyles(debouncer.run),
      this.hats.onDidChangeIsEnabled(debouncer.run),
      // An event that fires when a text document opens
      ide().onDidOpenTextDocument(debouncer.run),
      // An event that fires when a text document closes
      ide().onDidCloseTextDocument(debouncer.run),
      // An Event which fires when the active editor has changed. Note that the event also fires when the active editor changes to undefined.
      ide().onDidChangeActiveTextEditor(debouncer.run),
      // An Event which fires when the array of visible editors has changed.
      ide().onDidChangeVisibleTextEditors(debouncer.run),
      // An event that is emitted when a text document is changed. This usually happens when the contents changes but also when other things like the dirty-state changes.
      ide().onDidChangeTextDocument(debouncer.run),
      // An Event which fires when the selection in an editor has changed.
      ide().onDidChangeTextEditorSelection(debouncer.run),
      // An Event which fires when the visible ranges of an editor has changed.
      ide().onDidChangeTextEditorVisibleRanges(debouncer.run),
      // Re-draw hats on grapheme splitting algorithm change in case they
      // changed their token hat splitting setting.
      tokenGraphemeSplitter().registerAlgorithmChangeListener(debouncer.run),
      debouncer
    );
  }
  /**
   * Allocate hats to the visible tokens.
   *
   * @param forceTokenHats If supplied, force the allocator to use these hats
   * for the given tokens. This is used for the tutorial, and for testing.
   */
  async allocateHats(forceTokenHats) {
    const activeMap = await this.context.getActiveMap();
    forceTokenHats = forceTokenHats?.map((tokenHat) => ({
      ...tokenHat,
      grapheme: tokenGraphemeSplitter().normalizeGrapheme(tokenHat.grapheme)
    }));
    const tokenHats = this.hats.isEnabled ? allocateHats({
      tokenGraphemeSplitter: tokenGraphemeSplitter(),
      enabledHatStyles: this.hats.enabledHatStyles,
      forceTokenHats,
      oldTokenHats: activeMap.tokenHats,
      hatStability: ide().configuration.getOwnConfiguration(
        "experimental.hatStability"
      ),
      activeTextEditor: ide().activeTextEditor,
      visibleTextEditors: ide().visibleTextEditors
    }) : [];
    activeMap.setTokenHats(tokenHats);
    await this.hats.setHatRanges(
      tokenHats.map(({ hatStyle, hatRange, token: { editor } }) => ({
        editor,
        range: hatRange,
        styleName: hatStyle
      }))
    );
  }
  dispose() {
    this.disposables.forEach(({ dispose }) => dispose());
  }
};

// ../cursorless-engine/src/core/IndividualHatMap.ts
var IndividualHatMap = class _IndividualHatMap {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.isExpired = false;
    this.documentTokenLists = /* @__PURE__ */ new Map();
    this.deregisterFunctions = [];
    this.map = {};
    this._tokenHats = [];
  }
  get tokenHats() {
    return this._tokenHats;
  }
  getDocumentTokenList(document2) {
    const key = document2.uri.toString();
    let currentValue = this.documentTokenLists.get(key);
    if (currentValue == null) {
      currentValue = [];
      this.documentTokenLists.set(key, currentValue);
      this.deregisterFunctions.push(
        this.rangeUpdater.registerRangeInfoList(document2, currentValue)
      );
    }
    return currentValue;
  }
  clone() {
    const ret = new _IndividualHatMap(this.rangeUpdater);
    ret.setTokenHats(this._tokenHats);
    return ret;
  }
  /**
   * Overwrites the hat assignment for this hat token map.
   *
   * @param tokenHats The new hat assignments
   */
  setTokenHats(tokenHats) {
    this.map = {};
    this.documentTokenLists = /* @__PURE__ */ new Map();
    this.deregisterFunctions.forEach((func2) => func2());
    const liveTokenHats = tokenHats.map((tokenHat) => {
      const { hatStyle, grapheme, token } = tokenHat;
      const liveToken = this.makeTokenLive(token);
      this.map[getKey(hatStyle, grapheme)] = liveToken;
      return { ...tokenHat, token: liveToken };
    });
    this._tokenHats = liveTokenHats;
  }
  makeTokenLive(token) {
    const { tokenMatcher } = getMatcher(token.editor.document.languageId);
    const liveToken = {
      ...token,
      expansionBehavior: {
        start: {
          type: "regex",
          regex: tokenMatcher
        },
        end: {
          type: "regex",
          regex: tokenMatcher
        }
      }
    };
    this.getDocumentTokenList(token.editor.document).push(liveToken);
    return liveToken;
  }
  getEntries() {
    this.checkExpired();
    return Object.entries(this.map);
  }
  getToken(hatStyle, character) {
    this.checkExpired();
    return this.map[getKey(hatStyle, tokenGraphemeSplitter().normalizeGrapheme(character))];
  }
  checkExpired() {
    if (this.isExpired) {
      throw Error("Map snapshot has expired");
    }
  }
  dispose() {
    this.isExpired = true;
    this.deregisterFunctions.forEach((func2) => func2());
  }
};

// ../cursorless-engine/src/core/HatTokenMapImpl.ts
var PRE_PHRASE_SNAPSHOT_MAX_AGE_MS = 6e4;
var HatTokenMapImpl = class {
  constructor(rangeUpdater, debug, hats, commandServerApi) {
    this.debug = debug;
    this.commandServerApi = commandServerApi;
    this.prePhraseMapsSnapshotTimestamp = null;
    this.lastSignalVersion = null;
    ide().disposeOnExit(this);
    this.activeMap = new IndividualHatMap(rangeUpdater);
    this.getActiveMap = this.getActiveMap.bind(this);
    this.allocateHats = this.allocateHats.bind(this);
    this.hatAllocator = new HatAllocator(hats, {
      getActiveMap: this.getActiveMap
    });
  }
  /**
   * Allocate hats to the visible tokens.
   *
   * @param forceTokenHats If supplied, force the allocator to use these hats
   * for the given tokens. This is used for the tutorial, and for testing.
   */
  allocateHats(forceTokenHats) {
    return this.hatAllocator.allocateHats(forceTokenHats);
  }
  async getActiveMap() {
    await this.maybeTakePrePhraseSnapshot();
    return this.activeMap;
  }
  /**
   * Returns a transient, read-only hat map for use during the course of a
   * single command.
   *
   * Please do not hold onto this copy beyond the lifetime of a single command,
   * because it will get stale.
   * @param usePrePhraseSnapshot Whether to use pre-phrase snapshot
   * @returns A readable snapshot of the map
   */
  async getReadableMap(usePrePhraseSnapshot) {
    await this.maybeTakePrePhraseSnapshot();
    if (usePrePhraseSnapshot) {
      if (this.lastSignalVersion == null) {
        console.error(
          "Pre phrase snapshot requested but no signal was present; please upgrade command client"
        );
        return this.activeMap;
      }
      if (this.prePhraseMapSnapshot == null) {
        console.error(
          "Navigation map pre-phrase snapshot requested, but no snapshot has been taken"
        );
        return this.activeMap;
      }
      if (performance.now() - this.prePhraseMapsSnapshotTimestamp > PRE_PHRASE_SNAPSHOT_MAX_AGE_MS) {
        console.error(
          "Navigation map pre-phrase snapshot requested, but snapshot is more than a minute old"
        );
        return this.activeMap;
      }
      return this.prePhraseMapSnapshot;
    }
    return this.activeMap;
  }
  dispose() {
    this.activeMap.dispose();
    if (this.prePhraseMapSnapshot != null) {
      this.prePhraseMapSnapshot.dispose();
    }
  }
  async maybeTakePrePhraseSnapshot() {
    const newSignalVersion = await this.commandServerApi.signals.prePhrase.getVersion();
    if (newSignalVersion !== this.lastSignalVersion) {
      this.debug.log("taking snapshot");
      this.lastSignalVersion = newSignalVersion;
      if (newSignalVersion != null) {
        this.takePrePhraseSnapshot();
      }
    }
  }
  takePrePhraseSnapshot() {
    if (this.prePhraseMapSnapshot != null) {
      this.prePhraseMapSnapshot.dispose();
    }
    this.prePhraseMapSnapshot = this.activeMap.clone();
    this.prePhraseMapsSnapshotTimestamp = performance.now();
  }
};

// ../cursorless-engine/src/util/map.ts
function getDefault(map3, key, factory) {
  let currentValue = map3.get(key);
  if (currentValue == null) {
    currentValue = factory();
    map3.set(key, currentValue);
  }
  return currentValue;
}

// ../cursorless-engine/src/core/updateSelections/getOffsetsForDeleteOrReplace.ts
var import_immutability_helper = __toESM(require_immutability_helper(), 1);
function getOffsetsForDeleteOrReplace(changeEventInfo, rangeInfo) {
  const {
    originalOffsets: {
      start: changeOriginalStartOffset,
      end: changeOriginalEndOffset
    },
    finalOffsets: { end: changeFinalEndOffset },
    displacement
  } = changeEventInfo;
  const {
    offsets: { start: rangeStart, end: rangeEnd }
  } = rangeInfo;
  (0, import_immutability_helper.invariant)(
    changeOriginalEndOffset > changeOriginalStartOffset,
    () => "Change range expected to be nonempty"
  );
  (0, import_immutability_helper.invariant)(
    changeOriginalEndOffset >= rangeStart && changeOriginalStartOffset <= rangeEnd,
    () => "Change range expected to intersect with selection range"
  );
  return {
    start: changeOriginalEndOffset <= rangeStart ? rangeStart + displacement : Math.min(rangeStart, changeFinalEndOffset),
    end: changeOriginalEndOffset <= rangeEnd ? rangeEnd + displacement : Math.min(rangeEnd, changeFinalEndOffset)
  };
}

// ../cursorless-engine/src/core/updateSelections/getOffsetsForEmptyRangeInsert.ts
var import_immutability_helper2 = __toESM(require_immutability_helper(), 1);
function getOffsetsForEmptyRangeInsert(changeEventInfo, rangeInfo) {
  const {
    event: { text, isReplace: isReplace2 },
    finalOffsets: { start: start2, end }
  } = changeEventInfo;
  (0, import_immutability_helper2.invariant)(
    start2 === changeEventInfo.originalOffsets.end && start2 === rangeInfo.offsets.start && start2 === rangeInfo.offsets.end,
    () => "Selection range and change range expected to be same empty range"
  );
  if (isReplace2) {
    const expansionBehavior = rangeInfo.expansionBehavior.end;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: start2,
          end: start2
        };
      case "open":
        return { start: start2, end };
      case "regex": {
        const matches = text.match(leftAnchored(expansionBehavior.regex));
        return matches == null ? {
          start: start2,
          end: start2
        } : {
          start: start2,
          end: start2 + matches[0].length
        };
      }
    }
  } else {
    const expansionBehavior = rangeInfo.expansionBehavior.start;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: end,
          end
        };
      case "open":
        return { start: start2, end };
      case "regex": {
        const index = text.search(rightAnchored(expansionBehavior.regex));
        return index === -1 ? {
          start: end,
          end
        } : {
          start: start2 + index,
          end
        };
      }
    }
  }
}

// ../cursorless-engine/src/core/updateSelections/getOffsetsForNonEmptyRangeInsert.ts
var import_immutability_helper3 = __toESM(require_immutability_helper(), 1);
function getOffsetsForNonEmptyRangeInsert(changeEventInfo, rangeInfo) {
  const {
    event: { text: insertedText },
    originalOffsets: { start: insertOffset },
    displacement
  } = changeEventInfo;
  const {
    offsets: { start: rangeStart, end: rangeEnd },
    text: originalRangeText
  } = rangeInfo;
  (0, import_immutability_helper3.invariant)(
    rangeEnd > rangeStart,
    () => "Selection range expected to be nonempty"
  );
  (0, import_immutability_helper3.invariant)(
    insertOffset >= rangeStart && insertOffset <= rangeEnd,
    () => "Insertion offset expected to intersect with selection range"
  );
  if (insertOffset > rangeStart && insertOffset < rangeEnd) {
    return { start: rangeStart, end: rangeEnd + displacement };
  }
  if (insertOffset === rangeStart) {
    const expansionBehavior = rangeInfo.expansionBehavior.start;
    const newRangeEnd = rangeEnd + displacement;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: rangeStart + displacement,
          end: newRangeEnd
        };
      case "open":
        return {
          start: rangeStart,
          end: newRangeEnd
        };
      case "regex": {
        let text = insertedText + originalRangeText;
        const regex = rightAnchored(expansionBehavior.regex);
        let index = text.search(regex);
        while (index > insertedText.length) {
          text = text.slice(0, index);
          index = text.search(regex);
        }
        return index === -1 ? {
          start: rangeStart,
          end: newRangeEnd
        } : {
          start: rangeStart + index,
          end: newRangeEnd
        };
      }
    }
  } else {
    const expansionBehavior = rangeInfo.expansionBehavior.end;
    const newRangeStart = rangeStart;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: newRangeStart,
          end: rangeEnd
        };
      case "open":
        return {
          start: newRangeStart,
          end: rangeEnd + displacement
        };
      case "regex": {
        let text = originalRangeText + insertedText;
        const regex = leftAnchored(expansionBehavior.regex);
        let matches = text.match(regex);
        let matchLength = matches == null ? 0 : matches[0].length;
        while (matchLength !== 0 && matchLength < originalRangeText.length) {
          text = originalRangeText.slice(matchLength) + insertedText;
          matches = text.match(regex);
          matchLength = matches == null ? 0 : matchLength + matches[0].length;
        }
        return matchLength === 0 ? {
          start: newRangeStart,
          end: rangeEnd
        } : {
          start: newRangeStart,
          end: rangeStart + matchLength
        };
      }
    }
  }
}

// ../cursorless-engine/src/core/updateSelections/getUpdatedText.ts
function getUpdatedText(changeEventInfo, rangeInfo, newOffsets) {
  const { start: changeOriginalOffsetsStart, end: changeOriginalOffsetsEnd } = changeEventInfo.originalOffsets;
  const { start: rangeOriginalOffsetsStart, end: rangeOriginalOffsetsEnd } = rangeInfo.offsets;
  const newTextStartOffset = Math.min(
    changeOriginalOffsetsStart,
    rangeOriginalOffsetsStart
  );
  let result = "";
  if (rangeOriginalOffsetsStart < changeOriginalOffsetsStart) {
    result += rangeInfo.text.substring(
      0,
      changeOriginalOffsetsStart - rangeOriginalOffsetsStart
    );
  }
  result += changeEventInfo.event.text;
  if (changeOriginalOffsetsEnd < rangeOriginalOffsetsEnd) {
    result += rangeInfo.text.substring(
      rangeOriginalOffsetsEnd - changeOriginalOffsetsEnd,
      rangeInfo.text.length
    );
  }
  return result.substring(
    newOffsets.start - newTextStartOffset,
    newOffsets.end - newTextStartOffset
  );
}

// ../cursorless-engine/src/core/updateSelections/updateRangeInfos.ts
function updateRangeInfos(changeEvent, rangeInfoGenerator) {
  const { document: document2, contentChanges } = changeEvent;
  const changeEventInfos = contentChanges.map((change) => {
    const changeDisplacement = change.text.length - change.rangeLength;
    const changeOriginalStartOffset = change.rangeOffset;
    const changeOriginalEndOffset = changeOriginalStartOffset + change.rangeLength;
    const changeFinalStartOffset = changeOriginalStartOffset;
    const changeFinalEndOffset = changeOriginalEndOffset + changeDisplacement;
    return {
      displacement: changeDisplacement,
      event: change,
      originalOffsets: {
        start: changeOriginalStartOffset,
        end: changeOriginalEndOffset
      },
      finalOffsets: {
        start: changeFinalStartOffset,
        end: changeFinalEndOffset
      }
    };
  });
  for (const rangeInfo of rangeInfoGenerator) {
    const originalOffsets = rangeInfo.offsets;
    const displacements = changeEventInfos.map((changeEventInfo) => {
      let newOffsets2;
      if (changeEventInfo.originalOffsets.start > originalOffsets.end) {
        return {
          start: 0,
          end: 0
        };
      }
      if (changeEventInfo.originalOffsets.end < originalOffsets.start) {
        return {
          start: changeEventInfo.displacement,
          end: changeEventInfo.displacement
        };
      }
      if (changeEventInfo.event.rangeLength === 0) {
        if (rangeInfo.range.isEmpty) {
          newOffsets2 = getOffsetsForEmptyRangeInsert(
            changeEventInfo,
            rangeInfo
          );
        } else {
          newOffsets2 = getOffsetsForNonEmptyRangeInsert(
            changeEventInfo,
            rangeInfo
          );
        }
      } else {
        newOffsets2 = getOffsetsForDeleteOrReplace(changeEventInfo, rangeInfo);
      }
      rangeInfo.text = getUpdatedText(changeEventInfo, rangeInfo, newOffsets2);
      return {
        start: newOffsets2.start - originalOffsets.start,
        end: newOffsets2.end - originalOffsets.end
      };
    });
    const newOffsets = {
      start: originalOffsets.start + sumBy_default(displacements, ({ start: start2 }) => start2),
      end: originalOffsets.end + sumBy_default(displacements, ({ end }) => end)
    };
    rangeInfo.range = rangeInfo.range.with(
      document2.positionAt(newOffsets.start),
      document2.positionAt(newOffsets.end)
    );
    rangeInfo.offsets = newOffsets;
  }
}

// ../cursorless-engine/src/core/updateSelections/RangeUpdater.ts
var RangeUpdater = class {
  constructor() {
    this.rangeInfoLists = /* @__PURE__ */ new Map();
    this.replaceEditLists = /* @__PURE__ */ new Map();
    this.listenForDocumentChanges();
  }
  getDocumentRangeInfoLists(document2) {
    return getDefault(this.rangeInfoLists, document2.uri.toString(), () => []);
  }
  getDocumentReplaceEditLists(document2) {
    return getDefault(this.replaceEditLists, document2.uri.toString(), () => []);
  }
  /**
   * Registers a list of range infos to be kept up to date.  It is ok to
   * add to this list after registering it; any items in the list at the time of
   * a document change will be kept up to date.  Please be sure to call the
   * returned deregister function when you no longer need the ranges
   * updated.
   * @param document The document containing the ranges
   * @param rangeInfoList The ranges to keep up to date; it is ok to add to this list after the fact
   * @returns A function that can be used to deregister the list
   */
  registerRangeInfoList(document2, rangeInfoList) {
    const documentRangeInfoLists = this.getDocumentRangeInfoLists(document2);
    documentRangeInfoLists.push(rangeInfoList);
    return () => pull_default(documentRangeInfoLists, rangeInfoList);
  }
  /**
   * Registers a list of edits to treat as replace edits. These edits are
   * insertions that will not shift an empty selection to the right. Call this
   * function before applying your edits to the document
   *
   * Note that if you make two edits at the same location with the same text,
   * it is not possible to mark only one of them as replace edit.
   *
   * It is ok to add to this list after registering it; any items in the list
   * at the time of a document change will be treated as replace edits.  Please
   * be sure to call the returned deregister function after you have waited for
   * your edits to be applied.
   * @param document The document containing the ranges
   * @param replaceEditList A list of edits to treat as replace edits; it is ok to add to this list after the fact
   * @returns A function that can be used to deregister the list
   */
  registerReplaceEditList(document2, replaceEditList) {
    const documentReplaceEditLists = this.getDocumentReplaceEditLists(document2);
    documentReplaceEditLists.push(replaceEditList);
    return () => pull_default(documentReplaceEditLists, replaceEditList);
  }
  *documentRangeInfoGenerator(document2) {
    const documentRangeInfoLists = this.getDocumentRangeInfoLists(document2);
    for (const rangeInfoLists of documentRangeInfoLists) {
      for (const rangeInfo of rangeInfoLists) {
        yield rangeInfo;
      }
    }
  }
  listenForDocumentChanges() {
    this.disposable = ide().onDidChangeTextDocument(
      (event) => {
        const documentReplaceEditLists = this.getDocumentReplaceEditLists(
          event.document
        );
        const extendedEvent = {
          ...event,
          contentChanges: event.contentChanges.map(
            (change) => isReplace(documentReplaceEditLists, change) ? {
              ...change,
              isReplace: true
            } : change
          )
        };
        updateRangeInfos(
          extendedEvent,
          this.documentRangeInfoGenerator(event.document)
        );
      }
    );
  }
  dispose() {
    this.disposable.dispose();
  }
};
function isReplace(documentReplaceEditLists, change) {
  for (const replaceEditLists of documentReplaceEditLists) {
    for (const replaceEdit of replaceEditLists) {
      if (replaceEdit.range.isRangeEqual(change.range) && replaceEdit.text === change.text) {
        return true;
      }
    }
  }
  return false;
}

// ../cursorless-engine/src/disabledComponents/DisabledCommandServerApi.ts
var DisabledCommandServerApi = class {
  constructor() {
    this.signals = {
      prePhrase: {
        getVersion() {
          return Promise.resolve(null);
        }
      }
    };
  }
  getFocusedElementType() {
    return Promise.resolve(void 0);
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledHatTokenMap.ts
var DisabledHatTokenMap = class {
  async allocateHats() {
  }
  async getReadableMap() {
    return {
      getEntries() {
        return [];
      },
      getToken() {
        throw new Error("Hat map is disabled");
      }
    };
  }
  dispose() {
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledLanguageDefinitions.ts
var DisabledLanguageDefinitions = class {
  onDidChangeDefinition(_listener) {
    return { dispose: () => {
    } };
  }
  loadLanguage(_languageId) {
    return Promise.resolve();
  }
  get(_languageId) {
    return void 0;
  }
  getNodeAtLocation(_document, _range) {
    return void 0;
  }
  dispose() {
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledSnippets.ts
var DisabledSnippets = class {
  getSnippetStrict(_snippetName) {
    throw new Error("Snippets are not implemented.");
  }
  openNewSnippetFile(_snippetName, _directory) {
    throw new Error("Snippets are not implemented.");
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledTalonSpokenForms.ts
var DisabledTalonSpokenForms = class {
  getSpokenFormEntries() {
    throw new DisabledCustomSpokenFormsError();
  }
  onDidChange() {
    return { dispose: () => {
    } };
  }
};

// ../cursorless-engine/src/disabledComponents/DisabledTreeSitter.ts
var DisabledTreeSitter = class {
  getTree(_document) {
    throw new Error("Tree sitter not provided");
  }
  loadLanguage(_languageId) {
    return Promise.resolve(false);
  }
  getNodeAtLocation(_document, _range) {
    throw new Error("Tree sitter not provided");
  }
  createQuery(_languageId, _source) {
    throw new Error("Tree sitter not provided");
  }
};

// ../cursorless-engine/src/generateSpokenForm/NoSpokenFormError.ts
var NoSpokenFormError = class extends Error {
  constructor(reason, requiresTalonUpdate = false, isPrivate2 = false) {
    super(`No spoken form for: ${reason}`);
    this.reason = reason;
    this.requiresTalonUpdate = requiresTalonUpdate;
    this.isPrivate = isPrivate2;
  }
};

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/surroundingPairsDelimiters.ts
var surroundingPairsDelimiters = {
  curlyBrackets: ["{", "}"],
  angleBrackets: ["<", ">"],
  escapedDoubleQuotes: ['\\"', '\\"'],
  escapedSingleQuotes: ["\\'", "\\'"],
  escapedParentheses: ["\\(", "\\)"],
  escapedSquareBrackets: ["\\[", "\\]"],
  doubleQuotes: ['"', '"'],
  parentheses: ["(", ")"],
  backtickQuotes: ["`", "`"],
  squareBrackets: ["[", "]"],
  singleQuotes: ["'", "'"],
  tripleBacktickQuotes: ["```", "```"],
  tripleDoubleQuotes: ['"""', '"""'],
  tripleSingleQuotes: ["'''", "'''"],
  whitespace: [" ", " "],
  any: null,
  string: null,
  collectionBoundary: null
};

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/modifiers.ts
var surroundingPairDelimiterToName = new CompositeKeyMap((pair) => pair);
for (const [name2, pair] of Object.entries(surroundingPairsDelimiters)) {
  if (pair != null) {
    surroundingPairDelimiterToName.set(
      pair,
      name2
    );
  }
}
function surroundingPairDelimitersToSpokenForm(spokenFormMap, left, right) {
  const pairName = surroundingPairDelimiterToName.get([left, right]);
  if (pairName == null) {
    throw Error(`Unknown surrounding pair delimiters '${left} ${right}'`);
  }
  return spokenFormMap.pairedDelimiter[pairName];
}

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/snippets.ts
function insertionSnippetToSpokenForm(snippetDescription) {
  throw new NoSpokenFormError(`${snippetDescription.type} insertion snippet`);
}
function wrapperSnippetToSpokenForm(snippetDescription) {
  throw new NoSpokenFormError(`${snippetDescription.type} wrap with snippet`);
}

// ../cursorless-engine/src/generateSpokenForm/getRangeConnective.ts
function getRangeConnective(excludeAnchor, excludeActive, type2) {
  const prefix = type2 === "vertical" ? `${connectives.verticalRange} ` : "";
  if (excludeAnchor && excludeActive) {
    return prefix + connectives.rangeExclusive;
  }
  if (excludeAnchor) {
    throw new NoSpokenFormError("Range exclude anchor");
  }
  if (excludeActive) {
    return prefix + connectives.rangeExcludingEnd;
  }
  if (type2 === "vertical") {
    return connectives.verticalRange;
  }
  return connectives.rangeInclusive;
}

// ../cursorless-engine/src/generateSpokenForm/getSpokenFormComponentMap.ts
function getSpokenFormComponentMap(spokenFormMap) {
  return Object.fromEntries(
    Object.entries(spokenFormMap).map(([spokenFormType, map3]) => [
      spokenFormType,
      Object.fromEntries(
        Object.entries(map3).map(([id2, spokenForms]) => [
          id2,
          {
            type: "customizable",
            spokenForms,
            spokenFormType,
            id: id2
          }
        ])
      )
    ])
    // FIXME: Don't cast here; need to make our own mapValues with stronger typing
    // using tricks from our object.d.ts
  );
}

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/numbers.ts
var numbers = [
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen",
  "twenty",
  "twenty one",
  "twenty two",
  "twenty three",
  "twenty four",
  "twenty five",
  "twenty six",
  "twenty seven",
  "twenty eight",
  "twenty nine",
  "thirty",
  "thirty one",
  "thirty two",
  "thirty three",
  "thirty four",
  "thirty five",
  "thirty six",
  "thirty seven",
  "thirty eight",
  "thirty nine",
  "forty",
  "forty one",
  "forty two",
  "forty three",
  "forty four",
  "forty five",
  "forty six",
  "forty seven",
  "forty eight",
  "forty nine",
  "fifty",
  "fifty one",
  "fifty two",
  "fifty three",
  "fifty four",
  "fifty five",
  "fifty six",
  "fifty seven",
  "fifty eight",
  "fifty nine",
  "sixty",
  "sixty one",
  "sixty two",
  "sixty three",
  "sixty four",
  "sixty five",
  "sixty six",
  "sixty seven",
  "sixty eight",
  "sixty nine",
  "seventy",
  "seventy one",
  "seventy two",
  "seventy three",
  "seventy four",
  "seventy five",
  "seventy six",
  "seventy seven",
  "seventy eight",
  "seventy nine",
  "eighty",
  "eighty one",
  "eighty two",
  "eighty three",
  "eighty four",
  "eighty five",
  "eighty six",
  "eighty seven",
  "eighty eight",
  "eighty nine",
  "ninety",
  "ninety one",
  "ninety two",
  "ninety three",
  "ninety four",
  "ninety five",
  "ninety six",
  "ninety seven",
  "ninety eight",
  "ninety nine"
];
var ordinals = [
  "zeroth",
  "first",
  "second",
  "third",
  "fourth",
  "fifth",
  "sixth",
  "seventh",
  "eighth",
  "ninth",
  "tenth",
  "eleventh",
  "twelfth",
  "thirteenth",
  "fourteenth",
  "fifteenth",
  "sixteenth",
  "seventeenth",
  "eighteenth",
  "nineteenth",
  "twentieth"
];
function numberToSpokenForm(number) {
  const result = numbers[number];
  if (result == null) {
    throw Error(`Unknown number '${number}'`);
  }
  return result;
}
function ordinalToSpokenForm(ordinal) {
  const result = ordinals[ordinal];
  if (result == null) {
    throw Error(`Unknown ordinal '${ordinal}'`);
  }
  return result;
}

// ../cursorless-engine/src/generateSpokenForm/primitiveTargetToSpokenForm.ts
var PrimitiveTargetSpokenFormGenerator = class {
  constructor(spokenFormMap) {
    this.spokenFormMap = spokenFormMap;
    this.handleModifier = this.handleModifier.bind(this);
  }
  handlePrimitiveTarget(target) {
    const components = [];
    if (target.modifiers != null) {
      components.push(target.modifiers.map(this.handleModifier));
    }
    if (target.mark != null) {
      components.push(this.handleMark(target.mark));
    }
    return components;
  }
  handleModifier(modifier) {
    switch (modifier.type) {
      case "cascading":
      case "modifyIfUntyped":
      case "preferredScope":
        throw new NoSpokenFormError(`Modifier '${modifier.type}'`);
      case "containingScope":
        if (modifier.ancestorIndex == null || modifier.ancestorIndex === 0) {
          return this.handleScopeType(modifier.scopeType);
        }
        return [
          new Array(modifier.ancestorIndex).fill(
            this.spokenFormMap.modifierExtra.ancestor
          ),
          this.handleScopeType(modifier.scopeType)
        ];
      case "everyScope":
        return [
          this.spokenFormMap.simpleModifier.everyScope,
          this.handleScopeType(modifier.scopeType)
        ];
      case "extendThroughStartOf":
      case "extendThroughEndOf": {
        const type2 = this.spokenFormMap.simpleModifier[modifier.type];
        return modifier.modifiers != null ? [type2, modifier.modifiers.map(this.handleModifier)] : [type2];
      }
      case "relativeScope":
        return modifier.offset === 0 ? this.handleRelativeScopeInclusive(modifier) : this.handleRelativeScopeExclusive(modifier);
      case "ordinalScope": {
        const scope = this.handleScopeType(modifier.scopeType);
        const isEvery = modifier.isEvery ? this.spokenFormMap.simpleModifier.everyScope : [];
        if (modifier.length === 1) {
          if (modifier.start === -1) {
            return [isEvery, this.spokenFormMap.modifierExtra.last, scope];
          }
          if (modifier.start === 0) {
            return [isEvery, this.spokenFormMap.modifierExtra.first, scope];
          }
          if (modifier.start < 0) {
            return [
              isEvery,
              ordinalToSpokenForm(Math.abs(modifier.start)),
              this.spokenFormMap.modifierExtra.last,
              scope
            ];
          }
          return [isEvery, ordinalToSpokenForm(modifier.start + 1), scope];
        }
        const number = numberToSpokenForm(modifier.length);
        if (modifier.start === 0) {
          return [
            isEvery,
            this.spokenFormMap.modifierExtra.first,
            number,
            pluralize(scope)
          ];
        }
        if (modifier.start === -modifier.length) {
          return [
            isEvery,
            this.spokenFormMap.modifierExtra.last,
            number,
            pluralize(scope)
          ];
        }
        throw new NoSpokenFormError(
          `'${modifier.type}' with count > 1 and offset away from start / end`
        );
      }
      case "range": {
        if (modifier.anchor.type === "ordinalScope" && modifier.active.type === "ordinalScope" && modifier.anchor.length === 1 && modifier.active.length === 1 && modifier.anchor.scopeType.type === modifier.active.scopeType.type) {
          const anchor = modifier.anchor.start === -1 ? this.spokenFormMap.modifierExtra.last : ordinalToSpokenForm(modifier.anchor.start + 1);
          const active = this.handleModifier(modifier.active);
          const connective = getRangeConnective(
            modifier.excludeAnchor,
            modifier.excludeActive
          );
          return [anchor, connective, active];
        }
        throw Error(`Modifier '${modifier.type}' is not fully implemented`);
      }
      default:
        return [this.spokenFormMap.simpleModifier[modifier.type]];
    }
  }
  handleRelativeScopeInclusive(modifier) {
    const scope = this.handleScopeType(modifier.scopeType);
    const isEvery = modifier.isEvery ? this.spokenFormMap.simpleModifier.everyScope : [];
    if (modifier.length === 1) {
      const direction2 = modifier.direction === "forward" ? connectives.forward : connectives.backward;
      return [isEvery, scope, direction2];
    }
    const length = numberToSpokenForm(modifier.length);
    const scopePlural = pluralize(scope);
    if (modifier.direction === "forward") {
      return [isEvery, length, scopePlural];
    }
    return [isEvery, length, scopePlural, connectives.backward];
  }
  handleRelativeScopeExclusive(modifier) {
    const scope = this.handleScopeType(modifier.scopeType);
    const direction2 = modifier.direction === "forward" ? connectives.next : connectives.previous;
    const isEvery = modifier.isEvery ? this.spokenFormMap.simpleModifier.everyScope : [];
    if (modifier.offset === 1) {
      const number = numberToSpokenForm(modifier.length);
      if (modifier.length === 1) {
        return [isEvery, direction2, scope];
      }
      const scopePlural = pluralize(scope);
      return [isEvery, direction2, number, scopePlural];
    }
    if (modifier.length === 1) {
      const ordinal = ordinalToSpokenForm(modifier.offset);
      return [isEvery, ordinal, direction2, scope];
    }
    throw new NoSpokenFormError(
      `${modifier.type} modifier with offset > 1 and length > 1`
    );
  }
  handleScopeType(scopeType) {
    switch (scopeType.type) {
      case "oneOf":
      case "surroundingPairInterior":
        throw new NoSpokenFormError(`Scope type '${scopeType.type}'`);
      case "glyph":
        return [
          this.spokenFormMap.complexScopeTypeType.glyph,
          getSpokenFormStrict(
            this.spokenFormMap.grapheme,
            "grapheme",
            scopeType.character
          )
        ];
      case "surroundingPair": {
        const pair = this.spokenFormMap.pairedDelimiter[scopeType.delimiter];
        if (scopeType.forceDirection != null) {
          return [
            this.spokenFormMap.surroundingPairForceDirection[scopeType.forceDirection],
            pair
          ];
        }
        return pair;
      }
      case "customRegex":
        return this.spokenFormMap.customRegex[scopeType.regex] ?? {
          type: "customizable",
          spokenForms: {
            spokenForms: [],
            isCustom: true,
            defaultSpokenForms: [],
            requiresTalonUpdate: false,
            isPrivate: false
          },
          spokenFormType: "customRegex",
          id: scopeType.regex
        };
      case "interior":
        return this.spokenFormMap.simpleModifier.interiorOnly;
      default:
        return this.spokenFormMap.simpleScopeTypeType[scopeType.type];
    }
  }
  handleMark(mark) {
    switch (mark.type) {
      case "decoratedSymbol": {
        const [color, shape] = mark.symbolColor.split("-");
        const components = [];
        if (color !== "default") {
          components.push(hatColorToSpokenForm(color));
        }
        if (shape != null) {
          components.push(hatShapeToSpokenForm(shape));
        }
        components.push(
          getSpokenFormStrict(
            this.spokenFormMap.grapheme,
            "grapheme",
            mark.character
          )
        );
        return components;
      }
      case "lineNumber": {
        return this.handleLineNumberMark(mark);
      }
      case "range": {
        if (mark.anchor.type === "lineNumber" && mark.active.type === "lineNumber") {
          const [typeAnchor, numberAnchor] = this.handleLineNumberMark(
            mark.anchor
          );
          const [typeActive, numberActive] = this.handleLineNumberMark(
            mark.active
          );
          if (typeAnchor === typeActive) {
            const connective = getRangeConnective(
              mark.excludeAnchor,
              mark.excludeActive
            );
            return [typeAnchor, numberAnchor, connective, numberActive];
          }
        }
        throw Error(`Mark '${mark.type}' is not fully implemented`);
      }
      case "explicit":
      case "keyboard":
      case "target":
        throw new NoSpokenFormError(`Mark '${mark.type}'`);
      default:
        return [marks[mark.type]];
    }
  }
  handleLineNumberMark(mark) {
    switch (mark.lineNumberType) {
      case "absolute":
        throw new NoSpokenFormError("Absolute line numbers");
      case "modulo100": {
        return [
          lineDirections.modulo100,
          numberToSpokenForm(mark.lineNumber + 1)
        ];
      }
      case "relative": {
        return [
          mark.lineNumber < 0 ? lineDirections.relativeUp : lineDirections.relativeDown,
          numberToSpokenForm(Math.abs(mark.lineNumber))
        ];
      }
    }
  }
};
function pluralize(name2) {
  if (typeof name2 === "string") {
    return pluralizeString(name2);
  }
  if (Array.isArray(name2)) {
    if (name2.length === 0) {
      return name2;
    }
    const last2 = name2[name2.length - 1];
    return [...name2.slice(0, -1), pluralize(last2)];
  }
  return {
    ...name2,
    spokenForms: {
      ...name2.spokenForms,
      spokenForms: name2.spokenForms.spokenForms.map(pluralizeString)
    }
  };
}
function pluralizeString(name2) {
  return `${name2}s`;
}
function getSpokenFormStrict(map3, typeName, key) {
  const spokenForm = map3[key];
  if (spokenForm == null) {
    throw new NoSpokenFormError(`${typeName} '${key}'`);
  }
  return spokenForm;
}

// ../cursorless-engine/src/generateSpokenForm/generateSpokenForm.ts
var SpokenFormGenerator = class {
  constructor(spokenFormMap) {
    this.spokenFormMap = getSpokenFormComponentMap(spokenFormMap);
    this.primitiveGenerator = new PrimitiveTargetSpokenFormGenerator(
      this.spokenFormMap
    );
  }
  getSpokenFormForSingleTerm(type2, id2) {
    return this.componentsToSpokenForm(() => {
      const value = this.spokenFormMap[type2][id2];
      if (value == null) {
        throw new NoSpokenFormError(`${type2} with id ${id2}`);
      }
      return value;
    });
  }
  /**
   * Given a command, generates its spoken form.
   * @param command The command to generate a spoken form for
   * @returns The spoken form of the command
   */
  processCommand(command) {
    return this.componentsToSpokenForm(() => this.handleAction(command.action));
  }
  /**
   * Given a scope type, generates its spoken form.
   * @param scopeType The scope type to generate a spoken form for
   * @returns The spoken form of the scope type
   */
  processScopeType(scopeType) {
    return this.componentsToSpokenForm(() => [
      this.primitiveGenerator.handleScopeType(scopeType)
    ]);
  }
  /**
   * Given a function that returns a spoken form component, generates a spoken
   * form for that component by flattening the component and performing a
   * cartesian product over any elements that have multiple ways to be spoken.
   * Note that this spoken form object can correspond to multiple actual spoken
   * forms, consisting of a preferred spoken form and a list of alternative
   * spoken forms.
   *
   * Note that today, we arbitrarily choose the first spoken form as the
   * preferred spoken form, and the rest as alternative spoken forms.
   *
   * If the function throws a {@link NoSpokenFormError}, returns an error spoken
   * form object instead.
   *
   * @param getComponents A function that returns the components to generate a
   * spoken form for
   * @returns A spoken form for the given components
   */
  componentsToSpokenForm(getComponents) {
    try {
      return {
        type: "success",
        spokenForms: constructSpokenForms(getComponents())
      };
    } catch (e) {
      if (e instanceof NoSpokenFormError) {
        return {
          type: "error",
          reason: e.reason,
          requiresTalonUpdate: e.requiresTalonUpdate,
          isPrivate: e.isPrivate
        };
      }
      throw e;
    }
  }
  handleAction(action) {
    switch (action.name) {
      case "editNew":
      case "getText":
      case "replace":
      case "executeCommand":
      case "parsed":
      case "private.getTargets":
      case "private.setKeyboardTarget":
        throw new NoSpokenFormError(`Action '${action.name}'`);
      case "replaceWithTarget":
      case "moveToTarget":
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.source),
          this.handleDestination(action.destination)
        ];
      case "swapTargets":
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target1),
          connectives.swapConnective,
          this.handleTarget(action.target2)
        ];
      case "callAsFunction":
        if (action.argument.type === "implicit") {
          return [
            this.spokenFormMap.action[action.name],
            this.handleTarget(action.callee)
          ];
        }
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.callee),
          "on",
          this.handleTarget(action.argument)
        ];
      case "wrapWithPairedDelimiter":
      case "rewrapWithPairedDelimiter":
        return [
          surroundingPairDelimitersToSpokenForm(
            this.spokenFormMap,
            action.left,
            action.right
          ),
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      case "pasteFromClipboard":
        return [
          this.spokenFormMap.action[action.name],
          this.handleDestination(action.destination)
        ];
      case "insertSnippet":
        return [
          this.spokenFormMap.action[action.name],
          insertionSnippetToSpokenForm(action.snippetDescription),
          this.handleDestination(action.destination)
        ];
      case "generateSnippet":
        if (action.snippetName != null) {
          throw new NoSpokenFormError(`${action.name}.snippetName`);
        }
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      case "wrapWithSnippet":
        return [
          wrapperSnippetToSpokenForm(action.snippetDescription),
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      case "highlight": {
        if (action.highlightId != null) {
          throw new NoSpokenFormError(`${action.name}.highlightId`);
        }
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      }
      default: {
        return [
          this.spokenFormMap.action[action.name],
          this.handleTarget(action.target)
        ];
      }
    }
  }
  handleTarget(target) {
    switch (target.type) {
      case "list":
        if (target.elements.length < 2) {
          throw new NoSpokenFormError("List target with < 2 elements");
        }
        return target.elements.map(
          (element, i2) => i2 === 0 ? this.handleTarget(element) : [connectives.listConnective, this.handleTarget(element)]
        );
      case "range": {
        const anchor = this.handleTarget(target.anchor);
        const active = this.handleTarget(target.active);
        const connective = getRangeConnective(
          target.excludeAnchor,
          target.excludeActive,
          target.rangeType
        );
        return [anchor, connective, active];
      }
      case "primitive":
        return this.primitiveGenerator.handlePrimitiveTarget(target);
      case "implicit":
        return [];
    }
  }
  handleDestination(destination) {
    switch (destination.type) {
      case "list":
        if (destination.destinations.length < 2) {
          throw new NoSpokenFormError("List destination with < 2 elements");
        }
        return destination.destinations.map(
          (destination2, i2) => i2 === 0 ? this.handleDestination(destination2) : [connectives.listConnective, this.handleDestination(destination2)]
        );
      case "primitive":
        return [
          this.handleInsertionMode(destination.insertionMode),
          this.handleTarget(destination.target)
        ];
      case "implicit":
        return [];
    }
  }
  handleInsertionMode(insertionMode2) {
    switch (insertionMode2) {
      case "to":
        return connectives.sourceDestinationConnective;
      case "before":
        return connectives.before;
      case "after":
        return connectives.after;
    }
  }
};
function constructSpokenForms(component) {
  if (typeof component === "string") {
    return [component];
  }
  if (Array.isArray(component)) {
    if (component.length === 0) {
      return [""];
    }
    return cartesianProduct(component.map(constructSpokenForms)).map(
      (words) => words.filter((word) => word.length !== 0).join(" ")
    );
  }
  if (component.spokenForms.spokenForms.length === 0) {
    const componentInfo = `${camelCaseToAllDown(
      component.spokenFormType
    )} with id ${component.id}`;
    let helpInfo;
    if (component.spokenForms.isPrivate) {
      helpInfo = "this is a private spoken form currently only for internal experimentation";
    } else if (component.spokenForms.requiresTalonUpdate) {
      helpInfo = "please update talon to the latest version (see https://www.cursorless.org/docs/user/updating/)";
    } else {
      helpInfo = "please see https://www.cursorless.org/docs/user/customization/ for more information";
    }
    throw new NoSpokenFormError(
      `${componentInfo}; ${helpInfo}`,
      component.spokenForms.requiresTalonUpdate,
      component.spokenForms.isPrivate
    );
  }
  return component.spokenForms.spokenForms;
}
function cartesianProduct(arrays) {
  if (arrays.length === 0) {
    return [];
  }
  if (arrays.length === 1) {
    return arrays[0].map((element) => [element]);
  }
  const [first, ...rest] = arrays;
  const restCartesianProduct = cartesianProduct(rest);
  return first.flatMap(
    (element) => restCartesianProduct.map((restElement) => [element, ...restElement])
  );
}

// ../cursorless-engine/src/spokenForms/CustomSpokenForms.ts
var CustomSpokenForms = class {
  constructor(talonSpokenForms) {
    this.talonSpokenForms = talonSpokenForms;
    this.notifier = new Notifier();
    this.spokenFormMap_ = { ...defaultSpokenFormMap };
    /**
     * Registers a callback to be run when the custom spoken forms change.
     * @param callback The callback to run when the scope ranges change
     * @returns A {@link Disposable} which will stop the callback from running
     */
    this.onDidChangeCustomSpokenForms = this.notifier.registerListener;
    this.disposable = talonSpokenForms.onDidChange(
      () => this.updateSpokenFormMaps()
    );
    this.customSpokenFormsInitialized = this.updateSpokenFormMaps();
  }
  get spokenFormMap() {
    return this.spokenFormMap_;
  }
  /**
   * If `true`, indicates they need to update their Talon files to get the
   * machinery used to share spoken forms from Talon to the VSCode extension.
   */
  get needsInitialTalonUpdate() {
    return this.needsInitialTalonUpdate_;
  }
  async updateSpokenFormMaps() {
    let allCustomEntries;
    try {
      allCustomEntries = await this.talonSpokenForms.getSpokenFormEntries();
      if (allCustomEntries.length === 0) {
        throw new Error("Custom spoken forms list empty");
      }
    } catch (err2) {
      if (err2 instanceof NeedsInitialTalonUpdateError) {
        this.needsInitialTalonUpdate_ = true;
      } else if (err2 instanceof DisabledCustomSpokenFormsError) {
      } else {
        console.error("Error loading custom spoken forms", err2);
        const msg = err2.message.replace(/\.$/, "");
        void showError(
          ide().messages,
          "CustomSpokenForms.updateSpokenFormMaps",
          `Error loading custom spoken forms: ${msg}. Falling back to default spoken forms.`
        );
      }
      this.spokenFormMap_ = { ...defaultSpokenFormMap };
      this.notifier.notifyListeners();
      return;
    }
    for (const entryType of SUPPORTED_ENTRY_TYPES) {
      updateEntriesForType(
        this.spokenFormMap_,
        entryType,
        defaultSpokenFormInfoMap[entryType],
        Object.fromEntries(
          allCustomEntries.filter((entry) => entry.type === entryType).map(({ id: id2, spokenForms }) => [id2, spokenForms])
        )
      );
    }
    this.notifier.notifyListeners();
  }
  getCustomRegexScopeTypes() {
    return Object.keys(this.spokenFormMap_.customRegex).map((regex) => ({
      type: "customRegex",
      regex
    }));
  }
  dispose() {
    this.disposable.dispose();
  }
};
function updateEntriesForType(spokenFormMapToUpdate, key, defaultEntries, customEntries) {
  const ids = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(defaultEntries), ...Object.keys(customEntries)])
  );
  const obj = {};
  for (const id2 of ids) {
    const { defaultSpokenForms = [], isPrivate: isPrivate2 = false } = defaultEntries[id2] ?? {};
    const customSpokenForms = customEntries[id2];
    obj[id2] = customSpokenForms == null ? (
      // No entry for the given id. This either means that the user needs to
      // update Talon, or it's a private spoken form.
      {
        defaultSpokenForms,
        spokenForms: [],
        // If it's not a private spoken form, then it's a new scope type
        requiresTalonUpdate: !isPrivate2,
        isCustom: false,
        isPrivate: isPrivate2
      }
    ) : (
      // We have an entry for the given id
      {
        defaultSpokenForms,
        spokenForms: customSpokenForms,
        requiresTalonUpdate: false,
        isCustom: !isEqual_default(defaultSpokenForms, customSpokenForms),
        isPrivate: isPrivate2
      }
    );
  }
  spokenFormMapToUpdate[key] = obj;
}

// ../cursorless-engine/src/generateSpokenForm/CustomSpokenFormGeneratorImpl.ts
var CustomSpokenFormGeneratorImpl = class {
  constructor(talonSpokenForms) {
    this.customSpokenForms = new CustomSpokenForms(talonSpokenForms);
    this.customSpokenFormsInitialized = this.customSpokenForms.customSpokenFormsInitialized;
    this.spokenFormGenerator = new SpokenFormGenerator(
      this.customSpokenForms.spokenFormMap
    );
    this.disposable = this.customSpokenForms.onDidChangeCustomSpokenForms(
      () => {
        this.spokenFormGenerator = new SpokenFormGenerator(
          this.customSpokenForms.spokenFormMap
        );
      }
    );
  }
  onDidChangeCustomSpokenForms(listener) {
    return this.customSpokenForms.onDidChangeCustomSpokenForms(listener);
  }
  commandToSpokenForm(command) {
    return this.spokenFormGenerator.processCommand(command);
  }
  scopeTypeToSpokenForm(scopeType) {
    return this.spokenFormGenerator.processScopeType(scopeType);
  }
  actionIdToSpokenForm(actionId) {
    return this.spokenFormGenerator.getSpokenFormForSingleTerm(
      "action",
      actionId
    );
  }
  graphemeToSpokenForm(grapheme) {
    return this.spokenFormGenerator.getSpokenFormForSingleTerm(
      "grapheme",
      grapheme
    );
  }
  getCustomRegexScopeTypes() {
    return this.customSpokenForms.getCustomRegexScopeTypes();
  }
  get needsInitialTalonUpdate() {
    return this.customSpokenForms.needsInitialTalonUpdate;
  }
  dispose() {
    this.disposable.dispose();
  }
};

// ../../node_modules/.pnpm/itertools@2.4.1/node_modules/itertools/dist/index.js
function* flatten2(iterableOfIterables) {
  for (const iterable of iterableOfIterables) {
    for (const item of iterable) {
      yield item;
    }
  }
}
function* itake(n, iterable) {
  const it = iter(iterable);
  let count2 = n;
  while (count2-- > 0) {
    const s = it.next();
    if (!s.done) {
      yield s.value;
    } else {
      return;
    }
  }
}
function* pairwise(iterable) {
  const it = iter(iterable);
  const first2 = it.next();
  if (first2.done) {
    return;
  }
  let r1 = first2.value;
  for (const r2 of it) {
    yield [r1, r2];
    r1 = r2;
  }
}
var SENTINEL = Symbol();
function* count(start2 = 0, step = 1) {
  let n = start2;
  for (; ; ) {
    yield n;
    n += step;
  }
}
function* ifilter(iterable, predicate) {
  let index = 0;
  for (const value of iterable) {
    if (predicate(value, index++)) {
      yield value;
    }
  }
}
function* imap(iterable, mapper) {
  for (const value of iterable) {
    yield mapper(value);
  }
}
function* islice(iterable, stopOrStart, possiblyStop, step = 1) {
  let start2, stop2;
  if (possiblyStop !== void 0) {
    start2 = stopOrStart;
    stop2 = possiblyStop;
  } else {
    start2 = 0;
    stop2 = stopOrStart;
  }
  if (start2 < 0) throw new Error("start cannot be negative");
  if (stop2 !== null && stop2 < 0) throw new Error("stop cannot be negative");
  if (step <= 0) throw new Error("step cannot be negative");
  let i2 = -1;
  const it = iter(iterable);
  let res;
  while (true) {
    i2++;
    if (stop2 !== null && i2 >= stop2) return;
    res = it.next();
    if (res.done) return;
    if (i2 < start2) continue;
    if ((i2 - start2) % step === 0) {
      yield res.value;
    }
  }
}
function* takewhile(iterable, predicate) {
  let index = 0;
  const it = iter(iterable);
  let res;
  while (!(res = it.next()).done) {
    const value = res.value;
    if (!predicate(value, index++)) return;
    yield value;
  }
}
function iter(iterable) {
  return iterable[Symbol.iterator]();
}
function map2(iterable, mapper) {
  return Array.from(imap(iterable, mapper));
}
function range_(start2, stop2, step) {
  const counter = count(start2, step);
  const pred = step >= 0 ? (n) => n < stop2 : (n) => n > stop2;
  return takewhile(counter, pred);
}
function range2(startOrStop, definitelyStop, step = 1) {
  if (definitelyStop !== void 0) {
    return range_(startOrStop, definitelyStop, step);
  } else {
    return range_(0, startOrStop, step);
  }
}
function flatmap(iterable, mapper) {
  return flatten2(imap(iterable, mapper));
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/compareTargetScopes.ts
function compareTargetScopes(direction2, position, { domain: a }, { domain: b }) {
  return direction2 === "forward" ? compareTargetScopesForward(position, a, b) : compareTargetScopesBackward(position, a, b);
}
function compareTargetScopesForward(position, a, b) {
  const aIsStartVisible = a.start.isAfterOrEqual(position);
  const bIsStartVisible = b.start.isAfterOrEqual(position);
  if (aIsStartVisible && bIsStartVisible) {
    const value2 = a.start.compareTo(b.start);
    return value2 === 0 ? a.end.compareTo(b.end) : value2;
  }
  if (!aIsStartVisible && !bIsStartVisible) {
    const value2 = a.end.compareTo(b.end);
    return value2 === 0 ? -a.start.compareTo(b.start) : value2;
  }
  if (!aIsStartVisible && bIsStartVisible) {
    const value2 = a.end.compareTo(b.start);
    return value2 !== 0 ? value2 : b.isEmpty ? 1 : -1;
  }
  const value = a.start.compareTo(b.end);
  return value !== 0 ? value : a.isEmpty ? -1 : 1;
}
function compareTargetScopesBackward(position, a, b) {
  const aIsEndVisible = a.end.isBeforeOrEqual(position);
  const bIsEndVisible = b.end.isBeforeOrEqual(position);
  if (aIsEndVisible && bIsEndVisible) {
    const value2 = -a.end.compareTo(b.end);
    return value2 === 0 ? -a.start.compareTo(b.start) : value2;
  }
  if (!aIsEndVisible && !bIsEndVisible) {
    const value2 = -a.start.compareTo(b.start);
    return value2 === 0 ? a.end.compareTo(b.end) : value2;
  }
  if (!aIsEndVisible && bIsEndVisible) {
    const value2 = -a.start.compareTo(b.end);
    return value2 !== 0 ? value2 : b.isEmpty ? 1 : -1;
  }
  const value = -a.end.compareTo(b.start);
  return value !== 0 ? value : a.isEmpty ? -1 : 1;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/shouldYieldScope.ts
function shouldYieldScope(initialPosition, currentPosition, direction2, requirements, previousScope, scope) {
  return checkRequirements(initialPosition, requirements, previousScope, scope) && // Note that we're using `currentPosition` instead of `initialPosition`
  // below, because we want to filter out scopes that are strictly contained
  // by previous scopes.  However, if we want to include descendant scopes,
  // then we do use the initial position
  (previousScope == null || compareTargetScopes(
    direction2,
    requirements.includeDescendantScopes ? initialPosition : currentPosition,
    previousScope,
    scope
  ) < 0);
}
function checkRequirements(position, requirements, previousScope, scope) {
  const {
    containment,
    distalPosition,
    allowAdjacentScopes,
    skipAncestorScopes
  } = requirements;
  const { domain } = scope;
  switch (containment) {
    case "disallowed":
      if (domain.contains(position)) {
        return false;
      }
      break;
    case "disallowedIfStrict":
      if (strictlyContains(domain, position)) {
        return false;
      }
      break;
    case "required":
      if (!domain.contains(position)) {
        return false;
      }
      break;
  }
  if (skipAncestorScopes && previousScope != null && domain.contains(previousScope.domain)) {
    return false;
  }
  return partiallyContains(
    new Range(position, distalPosition),
    domain,
    allowAdjacentScopes
  );
}
function partiallyContains(range1, range22, allowAdjacent) {
  const intersection = range1.intersection(range22);
  if (intersection == null) {
    return false;
  }
  return !intersection.isEmpty || allowAdjacent || range22.isEmpty;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/BaseScopeHandler.ts
var DEFAULT_REQUIREMENTS = {
  containment: null,
  allowAdjacentScopes: false,
  skipAncestorScopes: false,
  includeDescendantScopes: false
};
var BaseScopeHandler = class {
  constructor() {
    this.includeAdjacentInEvery = false;
  }
  *generateScopes(editor, position, direction2, requirements = {}) {
    const hints = {
      ...DEFAULT_REQUIREMENTS,
      ...requirements,
      distalPosition: requirements.distalPosition ?? (direction2 === "forward" ? editor.document.range.end : editor.document.range.start)
    };
    let previousScope = void 0;
    let currentPosition = position;
    for (const scope of this.generateScopeCandidates(
      editor,
      position,
      direction2,
      hints
    )) {
      if (shouldYieldScope(
        position,
        currentPosition,
        direction2,
        hints,
        previousScope,
        scope
      )) {
        yield scope;
        previousScope = scope;
        currentPosition = direction2 === "forward" ? scope.domain.end : scope.domain.start;
      }
      if (this.canStopEarly(position, direction2, hints, previousScope, scope)) {
        return;
      }
    }
  }
  canStopEarly(position, direction2, requirements, previousScope, scope) {
    const { containment, distalPosition, skipAncestorScopes } = requirements;
    if (this.isHierarchical && !skipAncestorScopes) {
      return false;
    }
    const scopeToCheck = this.isHierarchical && skipAncestorScopes ? previousScope : scope;
    if (scopeToCheck == null) {
      return false;
    }
    if (containment === "required" && (direction2 === "forward" ? scopeToCheck.domain.end.isAfter(position) : scopeToCheck.domain.start.isBefore(position))) {
      return true;
    }
    if (direction2 === "forward" ? scopeToCheck.domain.end.isAfterOrEqual(distalPosition) : scopeToCheck.domain.start.isBeforeOrEqual(distalPosition)) {
      return true;
    }
    return false;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/NestedScopeHandler.ts
var NestedScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.scopeType = scopeType;
    this.languageId = languageId;
    this.isHierarchical = false;
  }
  /**
   * We expand to this scope type before looking for instances of the scope type
   * handled by this scope handler.  In most cases the iteration scope will
   * suffice, but in some cases you want them to diverge.  For example, you
   * might want the default iteration scope to be `"file"`, but you don't need
   * to expand to the file just to find instances of the given scope type.
   */
  get searchScopeType() {
    return this.iterationScopeType;
  }
  get searchScopeHandler() {
    if (this._searchScopeHandler == null) {
      this._searchScopeHandler = this.scopeHandlerFactory.create(
        this.searchScopeType,
        this.languageId
      );
    }
    return this._searchScopeHandler;
  }
  generateScopeCandidates(editor, position, direction2, hints) {
    const { containment, ...rest } = hints;
    const generator = this.searchScopeHandler.generateScopes(
      editor,
      position,
      direction2,
      // If containment is disallowed, we need to unset that for the search
      // scope, because the search scope could contain position but nested
      // scopes do not.
      {
        containment: containment === "required" ? "required" : void 0,
        ...rest
      }
    );
    return flatmap(
      generator,
      (searchScope) => this.generateScopesInSearchScope(direction2, searchScope)
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/LineScopeHandler.ts
var LineScopeHandler = class extends BaseScopeHandler {
  constructor(_scopeType, _languageId) {
    super();
    this.scopeType = { type: "line" };
    this.iterationScopeType = {
      type: "paragraph"
    };
    this.isHierarchical = false;
    this.includeAdjacentInEvery = true;
  }
  *generateScopeCandidates(editor, position, direction2) {
    if (direction2 === "forward") {
      for (let i2 = position.line; i2 < editor.document.lineCount; i2++) {
        yield lineNumberToScope(editor, i2);
      }
    } else {
      for (let i2 = position.line; i2 >= 0; i2--) {
        yield lineNumberToScope(editor, i2);
      }
    }
  }
};
function lineNumberToScope(editor, lineNumber) {
  const { range: range3 } = editor.document.lineAt(lineNumber);
  return {
    editor,
    domain: range3,
    getTargets: (isReversed) => [createLineTarget(editor, isReversed, range3)]
  };
}
function createLineTarget(editor, isReversed, range3) {
  return new LineTarget({
    editor,
    isReversed,
    contentRange: fitRangeToLineContent(editor, range3)
  });
}
function fitRangeToLineContent(editor, range3) {
  const startLine = editor.document.lineAt(range3.start);
  const endLine = editor.document.lineAt(range3.end);
  return new Range(
    startLine.rangeTrimmed?.start ?? startLine.range.start,
    endLine.rangeTrimmed?.end ?? endLine.range.end
  );
}

// ../cursorless-engine/src/util/getMatchesInRange.ts
function generateMatchesInRange(regex, editor, range3, direction2) {
  const offset = editor.document.offsetAt(range3.start);
  const text = editor.document.getText(range3);
  const matchToRange = (match) => new Range(
    editor.document.positionAt(offset + match.index),
    editor.document.positionAt(offset + match.index + match[0].length)
  );
  regex.lastIndex = 0;
  return direction2 === "forward" ? imap(text.matchAll(regex), matchToRange) : Array.from(text.matchAll(regex), matchToRange).reverse();
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/IdentifierScopeHandler.ts
var IdentifierScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "identifier" };
    this.iterationScopeType = { type: "line" };
    this.regex = getMatcher(this.languageId).identifierMatcher;
  }
  generateScopesInSearchScope(direction2, { editor, domain }) {
    return imap(
      generateMatchesInRange(this.regex, editor, domain, direction2),
      (range3) => ({
        editor,
        domain: range3,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange: range3,
            isReversed
          })
        ]
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/isPreferredOverHelper.ts
function isPreferredOverHelper(scopeA, scopeB, matchers2) {
  const textA = scopeA.editor.document.getText(scopeA.domain);
  const textB = scopeB.editor.document.getText(scopeB.domain);
  for (const matcher of matchers2) {
    const aMatchesRegex = testRegex(matcher, textA);
    const bMatchesRegex = testRegex(matcher, textB);
    if (aMatchesRegex && !bMatchesRegex) {
      return true;
    }
    if (bMatchesRegex && !aMatchesRegex) {
      return false;
    }
  }
  return void 0;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CharacterScopeHandler.ts
var SPLIT_REGEX = /\p{L}\p{M}*|[\p{N}\p{P}\p{S}\p{Z}\p{C}]/gu;
var PREFERRED_SYMBOLS_REGEX = /[$]/g;
var NONWHITESPACE_REGEX = /\p{L}\p{M}*|[\p{N}\p{P}\p{S}]/gu;
var CharacterScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "character" };
    this.iterationScopeType = { type: "token" };
  }
  get searchScopeType() {
    return { type: "line" };
  }
  generateScopesInSearchScope(direction2, { editor, domain }) {
    return imap(
      generateMatchesInRange(SPLIT_REGEX, editor, domain, direction2),
      (range3) => ({
        editor,
        domain: range3,
        getTargets: (isReversed) => [
          new PlainTarget({
            editor,
            contentRange: range3,
            isReversed,
            textualType: "character"
          })
        ]
      })
    );
  }
  isPreferredOver(scopeA, scopeB) {
    const { identifierMatcher } = getMatcher(this.languageId);
    return isPreferredOverHelper(scopeA, scopeB, [
      identifierMatcher,
      PREFERRED_SYMBOLS_REGEX,
      NONWHITESPACE_REGEX
    ]);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/WordScopeHandler/WordScopeHandler.ts
var WordScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "word" };
    this.iterationScopeType = { type: "identifier" };
    this.wordTokenizer = new WordTokenizer(this.languageId);
  }
  getScopesInSearchScope({
    editor,
    domain
  }) {
    const { document: document2 } = editor;
    const offset = document2.offsetAt(domain.start);
    const matches = this.wordTokenizer.splitIdentifier(
      document2.getText(domain)
    );
    const contentRanges = matches.map(
      (match) => new Range(
        document2.positionAt(offset + match.index),
        document2.positionAt(offset + match.index + match.text.length)
      )
    );
    return contentRanges.map((range3, i2) => ({
      editor,
      domain: range3,
      getTargets: (isReversed) => {
        const previousContentRange = i2 > 0 ? contentRanges[i2 - 1] : null;
        const nextContentRange = i2 + 1 < contentRanges.length ? contentRanges[i2 + 1] : null;
        return [
          constructTarget(
            isReversed,
            editor,
            previousContentRange,
            range3,
            nextContentRange
          )
        ];
      }
    }));
  }
  generateScopesInSearchScope(direction2, searchScope) {
    const scopes = this.getScopesInSearchScope(searchScope);
    if (direction2 === "backward") {
      scopes.reverse();
    }
    return scopes;
  }
};
function constructTarget(isReversed, editor, previousContentRange, contentRange, nextContentRange) {
  const leadingDelimiterRange = previousContentRange != null && contentRange.start.isAfter(previousContentRange.end) ? new Range(previousContentRange.end, contentRange.start) : void 0;
  const trailingDelimiterRange = nextContentRange != null && nextContentRange.start.isAfter(contentRange.end) ? new Range(contentRange.end, nextContentRange.start) : void 0;
  const isInDelimitedList = leadingDelimiterRange != null || trailingDelimiterRange != null;
  const insertionDelimiter = isInDelimitedList ? editor.document.getText(leadingDelimiterRange ?? trailingDelimiterRange) : "";
  return new SubTokenWordTarget({
    editor,
    isReversed,
    contentRange,
    insertionDelimiter,
    leadingDelimiterRange,
    trailingDelimiterRange
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TokenScopeHandler.ts
var PREFERRED_SYMBOLS_REGEX2 = /[$]/g;
var TokenScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "token" };
    this.iterationScopeType = { type: "line" };
    this.regex = getMatcher(this.languageId).tokenMatcher;
  }
  generateScopesInSearchScope(direction2, { editor, domain }) {
    return imap(
      generateMatchesInRange(this.regex, editor, domain, direction2),
      (range3) => ({
        editor,
        domain: range3,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange: range3,
            isReversed
          })
        ]
      })
    );
  }
  isPreferredOver(scopeA, scopeB) {
    const { identifierMatcher } = getMatcher(this.languageId);
    return isPreferredOverHelper(scopeA, scopeB, [
      identifierMatcher,
      PREFERRED_SYMBOLS_REGEX2
    ]);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/DocumentScopeHandler.ts
var DocumentScopeHandler = class extends BaseScopeHandler {
  constructor(_scopeType, _languageId) {
    super();
    this.scopeType = { type: "document" };
    this.iterationScopeType = { type: "document" };
    this.isHierarchical = false;
  }
  *generateScopeCandidates(editor, _position, _direction) {
    const contentRange = editor.document.range;
    yield {
      editor,
      domain: contentRange,
      getTargets: (isReversed) => [
        new DocumentTarget({
          editor,
          isReversed,
          contentRange
        })
      ]
    };
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/util/getCollectionItemRemovalRange.ts
function getCollectionItemRemovalRange(isEveryScope, editor, contentRange, leadingDelimiterRange, trailingDelimiterRange) {
  if (isEveryScope) {
    return void 0;
  }
  if (leadingDelimiterRange != null && trailingDelimiterRange != null && getRangeLength(editor, leadingDelimiterRange) > getRangeLength(editor, trailingDelimiterRange)) {
    return contentRange.union(leadingDelimiterRange);
  }
  return void 0;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/util/isHintsEveryScope.ts
function isEveryScopeModifier(hints) {
  return hints.containment == null && hints.skipAncestorScopes;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/getQuerySearchRange.ts
function getQuerySearchRange(document2, position, direction2, {
  containment,
  distalPosition,
  allowAdjacentScopes
}) {
  const { start: start2, end } = getQuerySearchRangeCore(
    document2.offsetAt(position),
    document2.offsetAt(distalPosition),
    direction2,
    containment,
    allowAdjacentScopes
  );
  return {
    start: document2.positionAt(start2),
    end: document2.positionAt(end)
  };
}
function getQuerySearchRangeCore(offset, distalOffset, direction2, containment, allowAdjacentScopes) {
  const adjacentShift = allowAdjacentScopes ? 1 : 0;
  if (containment === "required") {
    return direction2 === "forward" ? {
      start: offset - adjacentShift,
      end: offset + 1
    } : {
      start: offset - 1,
      end: offset + adjacentShift
    };
  }
  const proximalShift = containment === "disallowed" ? 1 : -adjacentShift;
  return direction2 === "forward" ? {
    start: offset + proximalShift,
    end: distalOffset + adjacentShift
  } : {
    start: distalOffset - adjacentShift,
    end: offset - proximalShift
  };
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/mergeAdjacentBy.ts
function mergeAdjacentBy(input, isEqual2, merge2) {
  const result = [];
  let current2 = [];
  for (const elem of input) {
    if (current2.length === 0 || isEqual2(current2[current2.length - 1], elem)) {
      current2.push(elem);
    } else {
      result.push(merge2(current2));
      current2 = [elem];
    }
  }
  if (current2.length > 0) {
    result.push(merge2(current2));
  }
  return result;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/BaseTreeSitterScopeHandler.ts
var BaseTreeSitterScopeHandler = class extends BaseScopeHandler {
  constructor(query) {
    super();
    this.query = query;
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const { document: document2 } = editor;
    const isEveryScope = isEveryScopeModifier(hints);
    const { start: start2, end } = getQuerySearchRange(
      document2,
      position,
      direction2,
      hints
    );
    const scopes = this.query.matches(document2, start2, end).map((match) => this.matchToScope(editor, match, isEveryScope)).filter((scope) => scope != null).sort((a, b) => compareTargetScopes(direction2, position, a, b));
    yield* mergeAdjacentBy(
      scopes,
      (a, b) => a.domain.isRangeEqual(b.domain),
      (equivalentScopes) => {
        if (equivalentScopes.length === 1) {
          return equivalentScopes[0];
        }
        return {
          ...equivalentScopes[0],
          getTargets(isReversed) {
            const targets = uniqWith_default(
              equivalentScopes.flatMap((scope) => scope.getTargets(isReversed)),
              (a, b) => a.isEqual(b)
            );
            if (targets.length > 1 && !equivalentScopes.every((scope) => scope.allowMultiple)) {
              const message = "Please use #allow-multiple! predicate in your query to allow multiple matches for this scope type";
              void showError(
                ide().messages,
                "BaseTreeSitterScopeHandler.allow-multiple",
                message
              );
              if (ide().runMode === "test") {
                throw Error(message);
              }
            }
            return targets;
          }
        };
      }
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/captureUtils.ts
function getRelatedCapture(match, scopeTypeType, relationship, matchHasScopeType) {
  if (matchHasScopeType) {
    return findCaptureByName(
      match,
      `${scopeTypeType}.${relationship}`,
      `_.${relationship}`
    );
  }
  return findCaptureByName(match, `${scopeTypeType}.${relationship}`) ?? (findCaptureByName(match, scopeTypeType) != null ? findCaptureByName(match, `_.${relationship}`) : void 0);
}
function getRelatedRange(match, scopeTypeType, relationship, matchHasScopeType) {
  return getRelatedCapture(
    match,
    scopeTypeType,
    relationship,
    matchHasScopeType
  )?.range;
}
function findCaptureByName(match, ...names) {
  return match.captures.find(
    (capture) => names.some((name2) => capture.name === name2)
  );
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/TreeSitterIterationScopeHandler.ts
var TreeSitterIterationScopeHandler = class extends BaseTreeSitterScopeHandler {
  constructor(query, iterateeScopeType) {
    super(query);
    this.iterateeScopeType = iterateeScopeType;
    this.isHierarchical = true;
    // Doesn't correspond to any scope type
    this.scopeType = void 0;
  }
  // Doesn't have any iteration scope type itself; that would correspond to
  // something like "every every"
  get iterationScopeType() {
    throw Error("Not implemented");
  }
  matchToScope(editor, match, _isEveryScope) {
    const scopeTypeType = this.iterateeScopeType.type;
    const capture = getRelatedCapture(match, scopeTypeType, "iteration", false);
    if (capture == null) {
      return void 0;
    }
    const { range: contentRange, allowMultiple } = capture;
    if (contentRange.isEmpty) {
      return void 0;
    }
    const domain = getRelatedRange(match, scopeTypeType, "iteration.domain", false) ?? contentRange;
    return {
      editor,
      domain,
      allowMultiple,
      getTargets: (isReversed) => [
        new PlainTarget({
          editor,
          isReversed,
          contentRange
        })
      ]
    };
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/TreeSitterScopeHandler.ts
var TreeSitterScopeHandler = class extends BaseTreeSitterScopeHandler {
  constructor(query, scopeType) {
    super(query);
    this.scopeType = scopeType;
    this.isHierarchical = true;
  }
  // We just create a custom scope handler that doesn't necessarily correspond
  // to any well-defined scope type
  get iterationScopeType() {
    return {
      type: "custom",
      scopeHandler: new TreeSitterIterationScopeHandler(
        this.query,
        this.scopeType
      )
    };
  }
  matchToScope(editor, match, isEveryScope) {
    const scopeTypeType = this.scopeType.type;
    const capture = findCaptureByName(match, scopeTypeType);
    if (capture == null) {
      return void 0;
    }
    const { range: contentRange, allowMultiple, insertionDelimiter } = capture;
    const domain = getRelatedRange(match, scopeTypeType, "domain", true) ?? contentRange;
    const prefixRange = getRelatedRange(
      match,
      scopeTypeType,
      "prefix",
      true
    )?.with(void 0, contentRange.start);
    const leadingDelimiterRange = getRelatedRange(
      match,
      scopeTypeType,
      "leading",
      true
    )?.with(void 0, prefixRange?.start ?? contentRange.start);
    const trailingDelimiterRange = getRelatedRange(
      match,
      scopeTypeType,
      "trailing",
      true
    )?.with(contentRange.end);
    let removalRange = getRelatedRange(match, scopeTypeType, "removal", true);
    if (removalRange == null && (scopeTypeType === "collectionItem" || scopeTypeType === "argumentOrParameter")) {
      removalRange = getCollectionItemRemovalRange(
        isEveryScope,
        editor,
        contentRange,
        leadingDelimiterRange,
        trailingDelimiterRange
      );
    }
    return {
      editor,
      domain,
      allowMultiple,
      getTargets: (isReversed) => [
        new ScopeTypeTarget({
          scopeTypeType,
          editor,
          isReversed,
          contentRange,
          prefixRange,
          removalRange,
          leadingDelimiterRange,
          trailingDelimiterRange,
          insertionDelimiter
        })
      ]
    };
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/IteratorInfo.ts
function getInitialIteratorInfos(iterators) {
  return iterators.flatMap((iterator, i2) => {
    const { value, done } = iterator.next();
    return done ? [] : [
      {
        iterator,
        value,
        index: i2
      }
    ];
  });
}
function advanceIteratorsUntil(iteratorInfos, criterion) {
  return iteratorInfos.flatMap((iteratorInfo) => {
    const { iterator, index } = iteratorInfo;
    let { value } = iteratorInfo;
    let done = false;
    while (!done && !criterion(value)) {
      ({ value, done } = iterator.next());
    }
    if (done) {
      return [];
    }
    return [{ iterator, value, index }];
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SortedScopeHandler.ts
var SortedScopeHandler = class _SortedScopeHandler extends BaseScopeHandler {
  constructor(scopeHandlers, getIterationScopeHandler) {
    super();
    this.scopeHandlers = scopeHandlers;
    this.getIterationScopeHandler = getIterationScopeHandler;
    this.isHierarchical = true;
    this.scopeType = void 0;
  }
  static create(scopeHandlerFactory, scopeType, languageId) {
    const scopeHandlers = scopeType.scopeTypes.map(
      (scopeType2) => scopeHandlerFactory.create(scopeType2, languageId)
    );
    return this.createFromScopeHandlers(
      scopeHandlerFactory,
      languageId,
      scopeHandlers
    );
  }
  static createFromScopeHandlers(scopeHandlerFactory, languageId, scopeHandlers) {
    const getIterationScopeHandler = () => new _SortedScopeHandler(
      scopeHandlers.map(
        (scopeHandler) => scopeHandlerFactory.create(
          scopeHandler.iterationScopeType,
          languageId
        )
      ),
      () => {
        throw new Error("Not implemented");
      }
    );
    return new _SortedScopeHandler(scopeHandlers, getIterationScopeHandler);
  }
  get iterationScopeType() {
    if (this.iterationScopeHandler == null) {
      this.iterationScopeHandler = this.getIterationScopeHandler();
    }
    return {
      type: "custom",
      scopeHandler: this.iterationScopeHandler
    };
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    if (this.iterationScopeHandler?.lastYieldedIndex != null) {
      const handlerIndex = this.iterationScopeHandler.lastYieldedIndex;
      const handler = this.scopeHandlers[handlerIndex];
      yield* handler.generateScopes(editor, position, direction2, hints);
      return;
    }
    const iterators = this.scopeHandlers.map(
      (scopeHandler) => scopeHandler.generateScopes(editor, position, direction2, hints)[Symbol.iterator]()
    );
    let iteratorInfos = getInitialIteratorInfos(iterators);
    while (iteratorInfos.length > 0) {
      iteratorInfos.sort(
        (a, b) => compareTargetScopes(direction2, position, a.value, b.value)
      );
      const iteratorInfo = iteratorInfos[0];
      const currentScope2 = iteratorInfo.value;
      this.lastYieldedIndex = iteratorInfo.index;
      yield currentScope2;
      iteratorInfos = advanceIteratorsUntil(
        iteratorInfos,
        (scope) => compareTargetScopes(direction2, position, currentScope2, scope) < 0
      );
    }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/ParagraphScopeHandler.ts
var ParagraphScopeHandler = class extends BaseScopeHandler {
  constructor(_scopeType, _languageId) {
    super();
    this.scopeType = { type: "paragraph" };
    this.iterationScopeType = { type: "document" };
    this.isHierarchical = false;
  }
  *generateScopeCandidates(editor, position, direction2) {
    const { document: document2 } = editor;
    const offset = direction2 === "forward" ? 1 : -1;
    const stop2 = direction2 === "forward" ? document2.lineCount : -1;
    let startLine = getStartLine(document2, position, direction2);
    let previousLine = editor.document.lineAt(position);
    for (let i2 = position.line + offset; i2 !== stop2; i2 += offset) {
      const currentLine = editor.document.lineAt(i2);
      if (currentLine.isEmptyOrWhitespace) {
        if (startLine != null) {
          yield createScope2(editor, startLine.range.union(previousLine.range));
          startLine = void 0;
        }
      } else if (startLine == null) {
        startLine = currentLine;
      }
      previousLine = currentLine;
    }
    if (startLine != null) {
      yield createScope2(editor, startLine.range.union(previousLine.range));
    }
  }
};
function getStartLine(document2, position, direction2) {
  const offset = direction2 === "forward" ? -1 : 1;
  const stop2 = direction2 === "forward" ? -1 : document2.lineCount;
  let startLine = document2.lineAt(position);
  if (startLine.isEmptyOrWhitespace) {
    return void 0;
  }
  for (let i2 = position.line + offset; i2 !== stop2; i2 += offset) {
    const line = document2.lineAt(i2);
    if (line.isEmptyOrWhitespace) {
      break;
    }
    startLine = line;
  }
  return startLine;
}
function createScope2(editor, domain) {
  return {
    editor,
    domain,
    getTargets: (isReversed) => [
      new ParagraphTarget({
        editor,
        isReversed,
        contentRange: fitRangeToLineContent(editor, domain)
      })
    ]
  };
}

// ../sentence-parser/src/stringHelper.ts
function endsWithChar(word, c) {
  if (c.length > 1) {
    return c.indexOf(word.slice(-1)) > -1;
  }
  return word.slice(-1) === c;
}
function endsWith(word, end) {
  return word.slice(word.length - end.length) === end;
}

// ../sentence-parser/src/Match.ts
var abbreviations;
var englishAbbreviations = [
  "al",
  "adj",
  "assn",
  "Ave",
  "BSc",
  "MSc",
  "Cell",
  "Ch",
  "Co",
  "cc",
  "Corp",
  "Dem",
  "Dept",
  "ed",
  "eg",
  "Eq",
  "Eqs",
  "est",
  "est",
  "etc",
  "Ex",
  "ext",
  // + number?
  "Fig",
  "fig",
  "Figs",
  "figs",
  "i.e",
  "ie",
  "Inc",
  "inc",
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Sept",
  "Oct",
  "Nov",
  "Dec",
  "jr",
  "mi",
  "Miss",
  "Mrs",
  "Mr",
  "Ms",
  "Mol",
  "mt",
  "mts",
  "no",
  "Nos",
  "PhD",
  "MD",
  "BA",
  "MA",
  "MM",
  "pl",
  "pop",
  "pp",
  "Prof",
  "Dr",
  "pt",
  "Ref",
  "Refs",
  "Rep",
  "repr",
  "rev",
  "Sec",
  "Secs",
  "Sgt",
  "Col",
  "Gen",
  "Rep",
  "Sen",
  "Gov",
  "Lt",
  "Maj",
  "Capt",
  "St",
  "Sr",
  "sr",
  "Jr",
  "jr",
  "Rev",
  "Sun",
  "Mon",
  "Tu",
  "Tue",
  "Tues",
  "Wed",
  "Th",
  "Thu",
  "Thur",
  "Thurs",
  "Fri",
  "Sat",
  "trans",
  "Univ",
  "Viz",
  "Vol",
  "vs",
  "v"
];
function setAbbreviations(abbr) {
  if (abbr) {
    abbreviations = abbr;
  } else {
    abbreviations = englishAbbreviations;
  }
}
function isCapitalized(str2) {
  return /^[A-Z][a-z].*/.test(str2) || isNumber(str2);
}
function isSentenceStarter(str2) {
  return isCapitalized(str2) || /``|"|'/.test(str2.substring(0, 2));
}
function isCommonAbbreviation(str2) {
  const noSymbols = str2.replace(/[-'`~!@#$%^&*()_|+=?;:'",.<>{}[\]\\/]/gi, "");
  return ~abbreviations.indexOf(noSymbols);
}
function isTimeAbbreviation(word, next) {
  if (word === "a.m." || word === "p.m.") {
    const tmp = next.replace(/\W+/g, "").slice(-3).toLowerCase();
    if (tmp === "day") {
      return true;
    }
  }
  return false;
}
function isDottedAbbreviation(word) {
  const matches = word.replace(/[()[]{}]/g, "").match(/(.\.)*/);
  return matches && matches[0].length > 0;
}
function isCustomAbbreviation(str2) {
  if (str2.length <= 3) {
    return true;
  }
  return isCapitalized(str2);
}
function isNameAbbreviation(wordCount, words) {
  if (words.length > 0) {
    if (wordCount < 5 && words[0].length < 6 && isCapitalized(words[0])) {
      return true;
    }
    const capitalized = words.filter(function(str2) {
      return /[A-Z]/.test(str2.charAt(0));
    });
    return capitalized.length >= 3;
  }
  return false;
}
function isNumber(str2, dotPos) {
  if (dotPos) {
    str2 = str2.slice(dotPos - 1, dotPos + 2);
  }
  return !isNaN(str2);
}
function isPhoneNr(str2) {
  return str2.match(
    /^(?:(?:\+?1\s*(?:[.-]\s*)?)?(?:\(\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\s*\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\s*(?:[.-]\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\s*(?:[.-]\s*)?([0-9]{4})(?:\s*(?:#|x\.?|ext\.?|extension)\s*(\d+))?$/
  );
}
function isURL(str2) {
  return str2.match(
    /[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/
  );
}
function isConcatenated(word) {
  let i2 = 0;
  if ((i2 = word.indexOf(".")) > -1 || (i2 = word.indexOf("!")) > -1 || (i2 = word.indexOf("?")) > -1) {
    const c = word.charAt(i2 + 1);
    if (c.match(/[a-zA-Z].*/)) {
      return [word.slice(0, i2), word.slice(i2 + 1)];
    }
  }
  return false;
}
function isBoundaryChar(word) {
  return word === "." || word === "!" || word === "?";
}

// ../sentence-parser/src/sbd.ts
var newline_placeholder = " @~@ ";
var newline_placeholder_t = newline_placeholder.trim();
var whiteSpaceCheck = new RegExp("\\S", "");
var addNewLineBoundaries = new RegExp("\\n+|[-#=_+*]{4,}", "g");
var splitIntoWords = new RegExp("\\S+|\\n", "g");
var defaultOptions = {
  newlineBoundaries: false,
  preserveWhitespace: false,
  abbreviations: void 0
};
function getSentences(text, userOptions) {
  if (!text) {
    return [];
  }
  if (!whiteSpaceCheck.test(text)) {
    return [];
  }
  const options2 = {
    ...defaultOptions,
    ...userOptions
  };
  setAbbreviations(options2.abbreviations);
  if (options2.newlineBoundaries) {
    text = text.replace(addNewLineBoundaries, newline_placeholder);
  }
  let words;
  let tokens2;
  if (options2.preserveWhitespace) {
    tokens2 = text.split(/(<br\s*\/?>|\S+|\n+)/);
    words = tokens2.filter(function(token, ii) {
      return ii % 2;
    });
  } else {
    words = text.trim().match(splitIntoWords) ?? [];
  }
  let wordCount = 0;
  let index = 0;
  let temp = [];
  let sentences = [];
  let current2 = [];
  if (!words || !words.length) {
    return [];
  }
  for (let i2 = 0, L = words.length; i2 < L; i2++) {
    wordCount++;
    current2.push(words[i2]);
    if (~words[i2].indexOf(",")) {
      wordCount = 0;
    }
    if (isBoundaryChar(words[i2]) || endsWithChar(words[i2], "?!") || words[i2] === newline_placeholder_t) {
      if (options2.newlineBoundaries && words[i2] === newline_placeholder_t) {
        current2.pop();
      }
      sentences.push(current2);
      wordCount = 0;
      current2 = [];
      continue;
    }
    if (endsWithChar(words[i2], '"') || endsWithChar(words[i2], "\u201D")) {
      words[i2] = words[i2].slice(0, -1);
    }
    if (endsWithChar(words[i2], ".")) {
      if (i2 + 1 < L) {
        if (words[i2].length === 2 && isNaN(words[i2].charAt(0))) {
          continue;
        }
        if (isCommonAbbreviation(words[i2])) {
          continue;
        }
        if (isSentenceStarter(words[i2 + 1])) {
          if (isTimeAbbreviation(words[i2], words[i2 + 1])) {
            continue;
          }
          if (isNameAbbreviation(wordCount, words.slice(i2, 6))) {
            continue;
          }
          if (isNumber(words[i2 + 1])) {
            if (isCustomAbbreviation(words[i2])) {
              continue;
            }
          }
        } else {
          if (endsWith(words[i2], "..")) {
            continue;
          }
          if (isDottedAbbreviation(words[i2])) {
            continue;
          }
          if (isNameAbbreviation(wordCount, words.slice(i2, 5))) {
            continue;
          }
        }
      }
      sentences.push(current2);
      current2 = [];
      wordCount = 0;
      continue;
    }
    if ((index = words[i2].indexOf(".")) > -1) {
      if (isNumber(words[i2], index)) {
        continue;
      }
      if (isDottedAbbreviation(words[i2])) {
        continue;
      }
      if (isURL(words[i2]) || isPhoneNr(words[i2])) {
        continue;
      }
    }
    if (temp = isConcatenated(words[i2])) {
      current2.pop();
      current2.push(temp[0]);
      sentences.push(current2);
      current2 = [];
      wordCount = 0;
      current2.push(temp[1]);
    }
  }
  if (current2.length) {
    sentences.push(current2);
  }
  sentences = sentences.filter(function(s) {
    return s.length > 0;
  });
  const result = sentences.slice(1).reduce(
    function(out2, sentence) {
      const lastSentence = out2[out2.length - 1];
      if (lastSentence.length === 1 && /^.{1,2}[.]$/.test(lastSentence[0])) {
        if (!/[.]/.test(sentence[0])) {
          out2.pop();
          out2.push(lastSentence.concat(sentence));
          return out2;
        }
      }
      out2.push(sentence);
      return out2;
    },
    [sentences[0]]
  );
  return result.map(function(sentence, ii) {
    if (options2.preserveWhitespace && !options2.newlineBoundaries) {
      let tokenCount = sentence.length * 2;
      if (ii === 0) {
        tokenCount += 1;
      }
      return tokens2.splice(0, tokenCount).join("");
    }
    return sentence.join(" ");
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SentenceScopeHandler/SentenceSegmenter.ts
var leadingOffsetRegex = /\S*\p{L}/u;
var skipPartRegex = /(\r?\n[^\p{L}]*\r?\n)|(?<=[.!?])(\s*\r?\n)/gu;
var options = {
  newlineBoundaries: false,
  preserveWhitespace: true
};
var SentenceSegmenter = class {
  *segment(text) {
    const sentences = getSentences(text, options);
    let index = 0;
    for (const sentence of sentences) {
      const parts2 = sentence.split(skipPartRegex).filter((p) => p != null);
      for (const part of parts2) {
        if (!skipPart(part)) {
          const segment = createSegment(part, index);
          if (segment != null) {
            yield segment;
          }
        }
        index += part.length;
      }
    }
  }
};
function createSegment(sentence, index) {
  const leadingOffsetMatch = matchRegex(leadingOffsetRegex, sentence);
  if (leadingOffsetMatch == null) {
    return void 0;
  }
  const leadingOffset = leadingOffsetMatch.index;
  if (leadingOffset !== 0) {
    index += leadingOffset;
    sentence = sentence.slice(leadingOffset);
  }
  return {
    text: sentence.trimEnd(),
    index
  };
}
function skipPart(text) {
  return testRegex(skipPartRegex, text);
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SentenceScopeHandler/SentenceScopeHandler.ts
var SentenceScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "sentence" };
    this.iterationScopeType = { type: "paragraph" };
    this.segmenter = new SentenceSegmenter();
  }
  generateScopesInSearchScope(direction2, { editor, domain }) {
    const offset = editor.document.offsetAt(domain.start);
    const text = editor.document.getText(domain);
    const sentenceToScope = (sentence) => {
      const contentRange = new Range(
        editor.document.positionAt(offset + sentence.index),
        editor.document.positionAt(
          offset + sentence.index + sentence.text.length
        )
      );
      return {
        editor,
        domain: contentRange,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange,
            isReversed
          })
        ]
      };
    };
    const sentences = this.segmenter.segment(text);
    return direction2 === "forward" ? imap(sentences, sentenceToScope) : Array.from(sentences, sentenceToScope).reverse();
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/RegexScopeHandler.ts
var RegexStageBase = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.iterationScopeType = { type: "line" };
  }
  generateScopesInSearchScope(direction2, { editor, domain }) {
    return imap(
      generateMatchesInRange(this.regex, editor, domain, direction2),
      (range3) => ({
        editor,
        domain: range3,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange: range3,
            isReversed
          })
        ]
      })
    );
  }
};
var NonWhitespaceSequenceScopeHandler = class extends RegexStageBase {
  constructor() {
    super(...arguments);
    this.regex = /\S+/g;
  }
};
var UrlScopeHandler = class extends RegexStageBase {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, scopeType, languageId);
    this.scopeType = scopeType;
    // taken from https://regexr.com/3e6m0
    this.regex = /(http(s)?:\/\/.)?(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/g;
  }
};
var CustomRegexScopeHandler = class extends RegexStageBase {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, scopeType, languageId);
    this.scopeType = scopeType;
  }
  get regex() {
    return new RegExp(this.scopeType.regex, this.scopeType.flags ?? "gu");
  }
};
var GlyphScopeHandler = class extends RegexStageBase {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, scopeType, languageId);
    this.scopeType = scopeType;
  }
  get regex() {
    return new RegExp(escapeRegExp_default(this.scopeType.character), "gui");
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/BoundedScopeHandler.ts
var BoundedBaseScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, languageId, targetScopeType) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.languageId = languageId;
    this.targetScopeType = targetScopeType;
    this.isHierarchical = true;
    this.targetScopeHandler = this.scopeHandlerFactory.create(
      this.targetScopeType,
      this.languageId
    );
    this.surroundingPairInteriorScopeHandler = this.scopeHandlerFactory.create(
      {
        type: "surroundingPairInterior",
        delimiter: "any"
      },
      this.languageId
    );
  }
  get iterationScopeType() {
    switch (this.targetScopeHandler.iterationScopeType.type) {
      case "custom":
      case "fallback":
      case "conditional":
        throw Error(
          `Iteration scope type can't be '${this.targetScopeHandler.iterationScopeType.type}' for BoundedBaseScopeHandler`
        );
    }
    return {
      type: "oneOf",
      scopeTypes: [
        this.targetScopeHandler.iterationScopeType,
        {
          type: "surroundingPairInterior",
          delimiter: "any"
        }
      ]
    };
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const targetScopes = this.targetScopeHandler.generateScopes(
      editor,
      position,
      direction2,
      {
        ...hints,
        // Don't skip containing paint since it might have non contained nested scopes.
        containment: hints.containment !== "disallowed" ? hints.containment : void 0
      }
    );
    const interiorScopes = Array.from(
      this.surroundingPairInteriorScopeHandler.generateScopes(
        editor,
        position,
        direction2,
        {
          ...hints,
          // For the every scope, we don't want to go outside of the surrounding pair
          containment: isEveryScopeModifier(hints) ? "required" : hints.containment
        }
      )
    );
    for (const targetScope of targetScopes) {
      const allScopes = [];
      for (const interiorScope of interiorScopes) {
        const domain = targetScope.domain.intersection(interiorScope.domain);
        if (domain != null && !domain.isEmpty) {
          allScopes.push({
            editor,
            domain,
            getTargets: (isReversed) => {
              return [
                this.getTargets(
                  ensureSingleTarget2(targetScope, isReversed),
                  ensureSingleTarget2(interiorScope, isReversed)
                )
              ];
            }
          });
        }
      }
      allScopes.push(targetScope);
      allScopes.sort((a, b) => compareTargetScopes(direction2, position, a, b));
      yield* allScopes;
    }
  }
};
function ensureSingleTarget2(scope, isReversed) {
  const targets = scope.getTargets(isReversed);
  if (targets.length !== 1) {
    throw Error(`Expected one target but got ${targets.length}`);
  }
  return targets[0];
}
var BoundedNonWhitespaceSequenceScopeHandler = class extends BoundedBaseScopeHandler {
  constructor(scopeHandlerFactory, _scopeType, languageId) {
    super(scopeHandlerFactory, languageId, { type: "nonWhitespaceSequence" });
    this.scopeType = { type: "boundedNonWhitespaceSequence" };
  }
  getTargets(target, interior) {
    const contentRange = target.contentRange.intersection(
      interior.contentRange
    );
    if (contentRange == null || contentRange.isEmpty) {
      throw Error("Expected non empty intersection");
    }
    return new TokenTarget({
      editor: target.editor,
      isReversed: target.isReversed,
      contentRange
    });
  }
};
var BoundedParagraphScopeHandler = class extends BoundedBaseScopeHandler {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, languageId, { type: "paragraph" });
    this.scopeType = { type: "boundedParagraph" };
  }
  getTargets(target, interior) {
    if (!(target instanceof ParagraphTarget)) {
      throw Error("Expected ParagraphTarget");
    }
    return new BoundedParagraphTarget({
      editor: target.editor,
      isReversed: target.isReversed,
      paragraphTarget: target,
      containingInterior: interior
    });
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/util/OneWayRangeFinder.ts
var OneWayRangeFinder = class {
  /**
   * @param items The items to search in. Must be sorted in document order.
   */
  constructor(items) {
    this.items = items;
    this.index = 0;
  }
  add(item) {
    this.items.push(item);
  }
  contains(searchItem) {
    return this.advance(searchItem);
  }
  getContaining(searchItem) {
    if (this.advance(searchItem)) {
      return this.items[this.index];
    }
    return void 0;
  }
  advance(searchItem) {
    while (this.index < this.items.length) {
      const range3 = this.items[this.index].range;
      if (range3.contains(searchItem)) {
        return true;
      }
      if (searchItem.end.isBeforeOrEqual(range3.start)) {
        return false;
      }
      this.index++;
    }
    return false;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/util/OneWayNestedRangeFinder.ts
var OneWayNestedRangeFinder = class {
  /**
   * @param items The items to search in. Must be sorted in document order.
   */
  constructor(items) {
    this.children = createNodes(items);
  }
  getSmallestContaining(separator2) {
    return this.children.getContaining(separator2)?.getSmallestContaining(separator2);
  }
};
function createNodes(items) {
  const results = [];
  const parents = [];
  for (const item of items) {
    const node = new RangeLookupTreeNode(item);
    while (parents.length > 0 && !parents[parents.length - 1].range.contains(item.range)) {
      parents.pop();
    }
    const parent = parents[parents.length - 1];
    if (parent != null) {
      parent.children.add(node);
    } else {
      results.push(node);
    }
    parents.push(node);
  }
  return new OneWayRangeFinder(results);
}
var RangeLookupTreeNode = class {
  constructor(item) {
    this.item = item;
    this.children = new OneWayRangeFinder([]);
  }
  get range() {
    return this.item.range;
  }
  getSmallestContaining(range3) {
    const child = this.children.getContaining(range3)?.getSmallestContaining(range3);
    return child ?? this.item;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/getSeparatorOccurrences.ts
var separator = ",";
var separatorRegex = new RegExp(separator, "g");
function getSeparatorOccurrences(document2) {
  const text = document2.getText();
  return matchAll(text, separatorRegex, (match) => {
    return new Range(
      document2.positionAt(match.index),
      document2.positionAt(match.index + match[0].length)
    );
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/collectionItemTextualIterationScopeHandler.ts
var collectionItemTextualIterationScopeHandler = {
  type: "fallback",
  scopeTypes: [
    {
      type: "conditional",
      scopeType: {
        type: "surroundingPairInterior",
        delimiter: "collectionBoundary"
      },
      predicate: (scope) => !scope.domain.isEmpty
    },
    {
      type: "conditional",
      scopeType: {
        type: "line"
      },
      predicate: (scope) => {
        const text = scope.editor.document.getText(scope.domain);
        return testRegex(separatorRegex, text);
      }
    }
  ]
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/createTargetScope.ts
function createTargetScope(isEveryScope, editor, iterationRange, contentRange, previousRange, nextRange) {
  const leadingDelimiterRange = previousRange != null ? new Range(previousRange.end, contentRange.start) : void 0;
  const trailingDelimiterRange = nextRange != null ? new Range(contentRange.end, nextRange.start) : void 0;
  const removalRange = getCollectionItemRemovalRange(
    isEveryScope,
    editor,
    contentRange,
    leadingDelimiterRange,
    trailingDelimiterRange
  );
  const insertionDelimiter = iterationRange.isSingleLine ? ", " : ",\n";
  return {
    editor,
    domain: contentRange,
    getTargets(isReversed) {
      return [
        new ScopeTypeTarget({
          scopeTypeType: "collectionItem",
          editor,
          isReversed,
          contentRange,
          insertionDelimiter,
          leadingDelimiterRange,
          trailingDelimiterRange,
          removalRange
        })
      ];
    }
  };
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/getInteriorRanges.ts
function getInteriorRanges(scopeHandlerFactory, languageId, editor, delimiter) {
  const scopeHandler = scopeHandlerFactory.create(
    {
      type: "surroundingPairInterior",
      delimiter
    },
    languageId
  );
  return Array.from(
    scopeHandler.generateScopes(editor, new Position(0, 0), "forward", {
      containment: void 0,
      skipAncestorScopes: false,
      includeDescendantScopes: true
    }),
    (scope) => ({ range: scope.domain })
  );
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/CollectionItemTextualScopeHandler.ts
var CollectionItemTextualScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.languageId = languageId;
    this.scopeType = { type: "collectionItem" };
    this.isHierarchical = true;
  }
  get iterationScopeType() {
    return collectionItemTextualIterationScopeHandler;
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const isEveryScope = isEveryScopeModifier(hints);
    const separatorRanges = getSeparatorOccurrences(editor.document);
    const interiorRanges = getInteriorRanges(
      this.scopeHandlerFactory,
      this.languageId,
      editor,
      "collectionBoundary"
    );
    const interiorRangeFinder = new OneWayNestedRangeFinder(interiorRanges);
    const stringRanges = getInteriorRanges(
      this.scopeHandlerFactory,
      this.languageId,
      editor,
      "string"
    );
    const stringRangeFinder = new OneWayRangeFinder(stringRanges);
    const scopes = [];
    const usedInteriors = /* @__PURE__ */ new Set();
    const iterationStatesStack = [];
    for (const separator2 of separatorRanges) {
      if (stringRangeFinder.contains(separator2)) {
        continue;
      }
      let currentIterationState;
      while (iterationStatesStack.length > 0) {
        const lastState = iterationStatesStack[iterationStatesStack.length - 1];
        if (lastState.iterationRange.contains(separator2)) {
          currentIterationState = lastState;
          break;
        }
        this.addScopes(scopes, lastState);
        iterationStatesStack.pop();
      }
      const containingInteriorRange = interiorRangeFinder.getSmallestContaining(separator2)?.range;
      const containingIterationRange = containingInteriorRange ?? editor.document.lineAt(separator2.start.line).range;
      if (currentIterationState != null && currentIterationState.iterationRange.isRangeEqual(
        containingIterationRange
      )) {
        currentIterationState.delimiters.push(separator2);
        continue;
      }
      if (containingInteriorRange != null) {
        usedInteriors.add(containingInteriorRange);
      }
      iterationStatesStack.push({
        editor,
        isEveryScope,
        iterationRange: containingIterationRange,
        delimiters: [separator2]
      });
    }
    for (const state of iterationStatesStack) {
      this.addScopes(scopes, state);
    }
    for (const interior of interiorRanges) {
      if (!usedInteriors.has(interior.range) && !interior.range.isEmpty) {
        const range3 = shrinkRangeToFitContent(editor, interior.range);
        if (!range3.isEmpty) {
          scopes.push(
            createTargetScope(isEveryScope, editor, interior.range, range3)
          );
        }
      }
    }
    scopes.sort((a, b) => compareTargetScopes(direction2, position, a, b));
    yield* scopes;
  }
  addScopes(scopes, state) {
    const { editor, iterationRange, isEveryScope, delimiters } = state;
    if (delimiters.length === 0) {
      return;
    }
    const itemRanges = [];
    for (let i2 = 0; i2 < delimiters.length; ++i2) {
      const current2 = delimiters[i2];
      const previous = delimiters[i2 - 1]?.end ?? iterationRange.start;
      itemRanges.push(new Range(previous, current2.start));
    }
    const lastDelimiter = delimiters[delimiters.length - 1];
    itemRanges.push(new Range(lastDelimiter.end, iterationRange.end));
    const trimmedRanges = itemRanges.map(
      (range3) => shrinkRangeToFitContent(editor, range3)
    );
    for (let i2 = 0; i2 < trimmedRanges.length; ++i2) {
      if (i2 === trimmedRanges.length - 1 && editor.document.getText(trimmedRanges[i2]).trim() === "") {
        continue;
      }
      scopes.push(
        createTargetScope(
          isEveryScope,
          editor,
          iterationRange,
          trimmedRanges[i2],
          trimmedRanges[i2 - 1],
          trimmedRanges[i2 + 1]
        )
      );
    }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CollectionItemScopeHandler/CollectionItemScopeHandler.ts
var CollectionItemScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, languageDefinitions, languageId) {
    super();
    this.scopeType = { type: "collectionItem" };
    this.isHierarchical = true;
    this.scopeHandler = (() => {
      const textualScopeHandler = new CollectionItemTextualScopeHandler(
        scopeHandlerFactory,
        languageId
      );
      const languageScopeHandler = languageDefinitions.get(languageId)?.getScopeHandler(this.scopeType);
      if (languageScopeHandler == null) {
        return textualScopeHandler;
      }
      return SortedScopeHandler.createFromScopeHandlers(
        scopeHandlerFactory,
        languageId,
        [languageScopeHandler, textualScopeHandler]
      );
    })();
  }
  get iterationScopeType() {
    return this.scopeHandler.iterationScopeType;
  }
  generateScopeCandidates(editor, position, direction2, hints) {
    return this.scopeHandler.generateScopes(editor, position, direction2, hints);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/ConditionalScopeHandler.ts
var ConditionalScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, conditionalScopeType, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.conditionalScopeType = conditionalScopeType;
    this.languageId = languageId;
    this.scopeType = void 0;
    this.isHierarchical = true;
  }
  get iterationScopeType() {
    throw new NoContainingScopeError(
      "Iteration scope for ConditionalScopeHandler"
    );
  }
  generateScopeCandidates(editor, position, direction2, hints) {
    const scopeHandler = this.scopeHandlerFactory.create(
      this.conditionalScopeType.scopeType,
      this.languageId
    );
    return ifilter(
      scopeHandler.generateScopes(editor, position, direction2, hints),
      this.conditionalScopeType.predicate
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/FallbackScopeHandler.ts
var FallbackScopeHandler = class _FallbackScopeHandler extends BaseScopeHandler {
  constructor(scopeHandlers) {
    super();
    this.scopeHandlers = scopeHandlers;
    this.scopeType = void 0;
    this.isHierarchical = true;
  }
  static create(scopeHandlerFactory, scopeType, languageId) {
    const scopeHandlers = scopeType.scopeTypes.map(
      (scopeType2) => scopeHandlerFactory.create(scopeType2, languageId)
    );
    return this.createFromScopeHandlers(scopeHandlers);
  }
  static createFromScopeHandlers(scopeHandlers) {
    return new _FallbackScopeHandler(scopeHandlers);
  }
  get iterationScopeType() {
    throw new NoContainingScopeError(
      "Iteration scope for FallbackScopeHandler"
    );
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    for (const scopeHandler of this.scopeHandlers) {
      yield* scopeHandler.generateScopes(editor, position, direction2, hints);
    }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/NotebookCellApiScopeHandler.ts
var NotebookCellApiScopeHandler = class extends BaseScopeHandler {
  constructor() {
    super();
    this.scopeType = { type: "notebookCell" };
    this.iterationScopeType = { type: "document" };
    this.isHierarchical = false;
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const cells = getNotebookCells(editor, position, direction2, hints);
    for (const cell of cells) {
      yield createTargetScope2(cell);
    }
  }
};
function getNotebookCells(editor, position, direction2, hints) {
  const nb = getNotebook(editor);
  if (nb == null) {
    return [];
  }
  const { notebook, cell } = nb;
  if (hints.containment === "required") {
    return [cell];
  }
  if (hints.containment === "disallowed" || hints.containment === "disallowedIfStrict") {
    return direction2 === "forward" ? notebook.cells.slice(cell.index + 1) : notebook.cells.slice(0, cell.index).reverse();
  }
  if (hints.distalPosition != null) {
    const searchRange = new Range(position, hints.distalPosition);
    if (searchRange.isRangeEqual(editor.document.range)) {
      return notebook.cells;
    }
  }
  return direction2 === "forward" ? notebook.cells.slice(cell.index) : notebook.cells.slice(0, cell.index + 1).reverse();
}
function getNotebook(editor) {
  const uri = editor.document.uri.toString();
  for (const notebook of ide().visibleNotebookEditors) {
    for (const cell of notebook.cells) {
      if (cell.document.uri.toString() === uri) {
        return { notebook, cell };
      }
    }
  }
  return void 0;
}
function createTargetScope2(cell) {
  const editor = getEditor(cell);
  const contentRange = editor.document.range;
  return {
    editor,
    domain: contentRange,
    getTargets: (isReversed) => [
      new NotebookCellTarget({
        editor,
        isReversed,
        contentRange
      })
    ]
  };
}
function getEditor(cell) {
  const uri = cell.document.uri.toString();
  for (const editor of ide().visibleTextEditors) {
    if (editor.document.uri.toString() === uri) {
      return editor;
    }
  }
  throw new Error("Editor not found notebook cell");
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/NotebookCellScopeHandler.ts
var NotebookCellScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, languageDefinitions, _scopeType, languageId) {
    super();
    this.scopeType = { type: "notebookCell" };
    this.isHierarchical = false;
    this.scopeHandler = (() => {
      const apiScopeHandler = new NotebookCellApiScopeHandler();
      const languageScopeHandler = languageDefinitions.get(languageId)?.getScopeHandler(this.scopeType);
      if (languageScopeHandler == null) {
        return apiScopeHandler;
      }
      return SortedScopeHandler.createFromScopeHandlers(
        scopeHandlerFactory,
        languageId,
        [languageScopeHandler, apiScopeHandler]
      );
    })();
  }
  get iterationScopeType() {
    return this.scopeHandler.iterationScopeType;
  }
  generateScopeCandidates(editor, position, direction2, hints) {
    return this.scopeHandler.generateScopes(editor, position, direction2, hints);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/SurroundingPairInteriorScopeHandler.ts
var SurroundingPairInteriorScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.scopeType = scopeType;
    this.languageId = languageId;
    this.isHierarchical = true;
    this.surroundingPairScopeHandler = this.scopeHandlerFactory.create(
      {
        type: "surroundingPair",
        delimiter: this.scopeType.delimiter,
        requireStrongContainment: true
      },
      this.languageId
    );
  }
  get iterationScopeType() {
    return this.surroundingPairScopeHandler.iterationScopeType;
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const scopes = this.surroundingPairScopeHandler.generateScopes(
      editor,
      position,
      direction2,
      hints
    );
    for (const scope of scopes) {
      yield {
        editor,
        domain: scope.domain,
        getTargets(isReversed) {
          return scope.getTargets(isReversed).flatMap((target) => target.getInterior());
        }
      };
    }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/createTargetScope.ts
function createTargetScope3(editor, { openingDelimiterRange, closingDelimiterRange }, requireStrongContainment) {
  const fullRange = openingDelimiterRange.union(closingDelimiterRange);
  const interiorRange = new Range(
    openingDelimiterRange.end,
    closingDelimiterRange.start
  );
  return {
    editor,
    domain: requireStrongContainment ? interiorRange : fullRange,
    getTargets: (isReversed) => [
      new SurroundingPairTarget({
        editor,
        isReversed,
        contentRange: fullRange,
        interiorRange,
        boundary: [openingDelimiterRange, closingDelimiterRange]
      })
    ]
  };
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/getDelimiterRegex.ts
function getDelimiterRegex(individualDelimiters) {
  const individualDelimiterDisjunct = uniq_default(
    individualDelimiters.map(({ text }) => text)
  ).map(escapeRegExp_default).join("|");
  return new RegExp(`(?<!\\\\)(${individualDelimiterDisjunct})`, "gu");
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/getDelimiterOccurrences.ts
function getDelimiterOccurrences(languageDefinition, document2, individualDelimiters) {
  if (individualDelimiters.length === 0) {
    return [];
  }
  const capturesMap = languageDefinition?.getCapturesMap(document2) ?? {};
  const disqualifyDelimiters = new OneWayRangeFinder(
    getSortedCaptures(capturesMap.disqualifyDelimiter)
  );
  const pairDelimiters = new OneWayRangeFinder(
    getSortedCaptures(capturesMap.pairDelimiter)
  );
  const textFragments = new OneWayNestedRangeFinder(
    getSortedCaptures(capturesMap.textFragment)
  );
  const delimiterTextToDelimiterInfoMap = Object.fromEntries(
    individualDelimiters.map((individualDelimiter) => [
      individualDelimiter.text,
      individualDelimiter
    ])
  );
  const regexMatches = matchAllIterator(
    document2.getText(),
    getDelimiterRegex(individualDelimiters)
  );
  const results = [];
  for (const match of regexMatches) {
    const text = match[0];
    const matchRange = new Range(
      document2.positionAt(match.index),
      document2.positionAt(match.index + text.length)
    );
    const disqualifiedDelimiter = ifNoErrors(
      disqualifyDelimiters.getContaining(matchRange)
    );
    if (disqualifiedDelimiter != null) {
      continue;
    }
    results.push({
      delimiterInfo: delimiterTextToDelimiterInfoMap[text],
      textFragmentRange: textFragments.getSmallestContaining(matchRange)?.range,
      range: ifNoErrors(pairDelimiters.getContaining(matchRange))?.range ?? matchRange
    });
  }
  return results;
}
function ifNoErrors(capture) {
  return capture != null && !capture.hasError() ? capture : void 0;
}
function getSortedCaptures(items) {
  if (items == null) {
    return [];
  }
  items.sort((a, b) => a.range.start.compareTo(b.range.start));
  return items;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/delimiterMaps.ts
var delimiterToText = Object.freeze({
  angleBrackets: [
    ["</", "<"],
    [">", "/>"]
  ],
  curlyBrackets: [["{", "${"], "}"],
  tripleBacktickQuotes: [[], []],
  tripleDoubleQuotes: [[], []],
  tripleSingleQuotes: [[], []],
  doubleQuotes: ['"', '"', { isSingleLine: true }],
  escapedDoubleQuotes: ['\\"', '\\"', { isSingleLine: true }],
  escapedParentheses: ["\\(", "\\)"],
  escapedSquareBrackets: ["\\[", "\\]"],
  escapedSingleQuotes: ["\\'", "\\'", { isSingleLine: true }],
  parentheses: [["(", "$("], ")"],
  backtickQuotes: ["`", "`"],
  singleQuotes: ["'", "'", { isSingleLine: true }],
  squareBrackets: ["[", "]"]
});
var delimiterToTextOverrides = {
  nix: {
    singleQuotes: ["''", "''"]
  },
  lua: {
    // FIXME: Add special double square brackets
    // see https://github.com/cursorless-dev/cursorless/pull/2012#issuecomment-1808214409
    // see also https://github.com/cursorless-dev/cursorless/issues/1812#issuecomment-1691493746
    doubleQuotes: [
      ['"', "[["],
      ['"', "]]"]
    ]
  },
  python: {
    tripleSingleQuotes: ["'''", "'''"],
    tripleDoubleQuotes: ['"""', '"""']
  },
  markdown: {
    tripleBacktickQuotes: ["```", "```"]
  },
  ruby: {
    tripleDoubleQuotes: ["%Q(", ")"]
  },
  csharp: {
    doubleQuotes: [
      ['@"', '"'],
      ['"', '"']
    ]
  }
};
var leftToRightMap = Object.fromEntries(
  Object.values(delimiterToText)
);
var complexDelimiterMap = {
  any: unsafeKeys(delimiterToText),
  string: [
    "tripleDoubleQuotes",
    "tripleSingleQuotes",
    "tripleBacktickQuotes",
    "doubleQuotes",
    "singleQuotes",
    "backtickQuotes"
  ],
  collectionBoundary: [
    "parentheses",
    "squareBrackets",
    "curlyBrackets",
    "angleBrackets"
  ]
};
function getSimpleDelimiterMap(languageId) {
  if (languageId != null && languageId in delimiterToTextOverrides) {
    return {
      ...delimiterToText,
      ...delimiterToTextOverrides[languageId]
    };
  }
  return delimiterToText;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/getIndividualDelimiters.ts
function getIndividualDelimiters(delimiter, languageId) {
  const delimiters = complexDelimiterMap[delimiter] ?? [delimiter];
  return getSimpleIndividualDelimiters(languageId, delimiters);
}
function getSimpleIndividualDelimiters(languageId, delimiters) {
  const delimiterToText2 = getSimpleDelimiterMap(languageId);
  return delimiters.flatMap((delimiterName) => {
    const [leftDelimiter, rightDelimiter, options2] = delimiterToText2[delimiterName];
    const { isSingleLine = false } = options2 ?? {};
    const leftDelimiters = isString(leftDelimiter) ? [leftDelimiter] : leftDelimiter;
    const rightDelimiters = isString(rightDelimiter) ? [rightDelimiter] : rightDelimiter;
    const allDelimiterTexts = uniq_default(concat_default(leftDelimiters, rightDelimiters));
    return allDelimiterTexts.map((text) => {
      const isLeft = leftDelimiters.includes(text);
      const isRight = rightDelimiters.includes(text);
      const side = (() => {
        if (isLeft && !isRight) {
          return "left";
        }
        if (!isLeft && isRight) {
          return "right";
        }
        return "unknown";
      })();
      return {
        text,
        side,
        delimiterName,
        isSingleLine
      };
    });
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/getSurroundingPairOccurrences.ts
function getSurroundingPairOccurrences(delimiterOccurrences) {
  const result = [];
  const openingDelimitersStack = [];
  for (const occurrence of delimiterOccurrences) {
    const {
      delimiterInfo: { delimiterName, side, isSingleLine },
      textFragmentRange,
      range: range3
    } = occurrence;
    if (side === "left") {
      openingDelimitersStack.push(occurrence);
    } else {
      const openingDelimiterIndex = findLastIndex_default(
        openingDelimitersStack,
        (o) => o.delimiterInfo.delimiterName === delimiterName && isSameTextFragment(o.textFragmentRange, textFragmentRange) && isValidLine(isSingleLine, o.range, range3)
      );
      if (openingDelimiterIndex === -1) {
        if (side === "unknown") {
          openingDelimitersStack.push(occurrence);
        }
        continue;
      }
      const openingDelimiter = openingDelimitersStack[openingDelimiterIndex];
      openingDelimitersStack.length = openingDelimiterIndex;
      result.push({
        delimiterName,
        openingDelimiterRange: openingDelimiter.range,
        closingDelimiterRange: range3
      });
    }
  }
  return result;
}
function isSameTextFragment(a, b) {
  if (a == null || b == null) {
    return a === b;
  }
  return a.isRangeEqual(b);
}
function isValidLine(isSingleLine, a, b) {
  return !isSingleLine || a.start.line === b.start.line;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/SurroundingPairScopeHandler.ts
var SurroundingPairScopeHandler = class extends BaseScopeHandler {
  constructor(languageDefinitions, scopeType, languageId) {
    super();
    this.languageDefinitions = languageDefinitions;
    this.scopeType = scopeType;
    this.languageId = languageId;
    this.iterationScopeType = {
      type: "conditional",
      scopeType: { type: "line" },
      predicate: (scope) => !scope.domain.isEmpty
    };
    this.isHierarchical = true;
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    if (this.scopeType.forceDirection != null) {
      void showError(
        ide().messages,
        "deprecatedForceDirection",
        "forceDirection is deprecated. If this is important to you please file an issue on the cursorless repo."
      );
      return;
    }
    const delimiterOccurrences = getDelimiterOccurrences(
      this.languageDefinitions.get(this.languageId),
      editor.document,
      getIndividualDelimiters(this.scopeType.delimiter, this.languageId)
    );
    let surroundingPairs = getSurroundingPairOccurrences(delimiterOccurrences);
    surroundingPairs = maybeApplyEmptyTargetHack(
      direction2,
      hints,
      position,
      surroundingPairs
    );
    yield* surroundingPairs.map(
      (pair) => createTargetScope3(
        editor,
        pair,
        this.scopeType.requireStrongContainment ?? false
      )
    ).sort((a, b) => compareTargetScopes(direction2, position, a, b));
  }
};
function maybeApplyEmptyTargetHack(direction2, hints, position, surroundingPairs) {
  if (direction2 === "forward" && hints.containment === "required" && hints.allowAdjacentScopes && hints.skipAncestorScopes) {
    return surroundingPairs.filter(
      (pair, i2) => !(pair.closingDelimiterRange.end.isEqual(position) && surroundingPairs[i2 + 1]?.closingDelimiterRange.start.isEqual(position))
    );
  }
  return surroundingPairs;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SurroundingPairScopeHandler/InteriorScopeHandler.ts
var InteriorScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, languageDefinitions, scopeType, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.languageDefinitions = languageDefinitions;
    this.scopeType = scopeType;
    this.languageId = languageId;
    this.isHierarchical = true;
  }
  get iterationScopeType() {
    throw new NoContainingScopeError(
      "Iteration scope for InteriorScopeHandler"
    );
  }
  *generateScopeCandidates(editor, position, direction2, hints) {
    const targetDomain = new Range(position, hints.distalPosition);
    const scopeHandler = this.getScopeHandler();
    if (scopeHandler == null) {
      return;
    }
    const scopes = scopeHandler.generateScopes(
      editor,
      position,
      direction2,
      hints
    );
    for (const scope of scopes) {
      if (this.shouldYield(targetDomain, scope)) {
        yield createInteriorScope(scope);
      }
    }
  }
  getScopeHandler() {
    const languageScopeHandler = this.languageDefinitions.get(this.languageId)?.getScopeHandler(this.scopeType);
    const pairScopeHandler = this.scopeHandlerFactory.create(
      {
        type: "surroundingPair",
        delimiter: "any"
      },
      this.languageId
    );
    if (this.scopeType.explicitScopeType) {
      if (languageScopeHandler == null) {
        return pairScopeHandler;
      }
      return FallbackScopeHandler.createFromScopeHandlers([
        languageScopeHandler,
        pairScopeHandler
      ]);
    }
    if (languageScopeHandler == null) {
      return pairScopeHandler;
    }
    return SortedScopeHandler.createFromScopeHandlers(
      this.scopeHandlerFactory,
      this.languageId,
      [languageScopeHandler, pairScopeHandler]
    );
  }
  shouldYield(targetDomain, scope) {
    return !this.scopeType.explicitScopeType || targetDomain.contains(scope.domain);
  }
};
function createInteriorScope(scope) {
  return {
    editor: scope.editor,
    domain: scope.domain,
    getTargets(isReversed) {
      return scope.getTargets(isReversed).flatMap(createInteriorTargets);
    }
  };
}
function createInteriorTargets(target) {
  const interior = target.getInterior();
  if (interior != null) {
    return interior;
  }
  return [
    new InteriorTarget({
      editor: target.editor,
      isReversed: target.isReversed,
      fullInteriorRange: target.contentRange
    })
  ];
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/ScopeHandlerFactoryImpl.ts
var ScopeHandlerFactoryImpl = class {
  constructor(languageDefinitions) {
    this.languageDefinitions = languageDefinitions;
    this.maybeCreate = this.maybeCreate.bind(this);
    this.create = this.create.bind(this);
  }
  maybeCreate(scopeType, languageId) {
    switch (scopeType.type) {
      case "character":
        return new CharacterScopeHandler(this, scopeType, languageId);
      case "word":
        return new WordScopeHandler(this, scopeType, languageId);
      case "token":
        return new TokenScopeHandler(this, scopeType, languageId);
      case "identifier":
        return new IdentifierScopeHandler(this, scopeType, languageId);
      case "line":
        return new LineScopeHandler(scopeType, languageId);
      case "sentence":
        return new SentenceScopeHandler(this, scopeType, languageId);
      case "paragraph":
        return new ParagraphScopeHandler(scopeType, languageId);
      case "boundedParagraph":
        return new BoundedParagraphScopeHandler(this, scopeType, languageId);
      case "document":
        return new DocumentScopeHandler(scopeType, languageId);
      case "nonWhitespaceSequence":
        return new NonWhitespaceSequenceScopeHandler(
          this,
          scopeType,
          languageId
        );
      case "boundedNonWhitespaceSequence":
        return new BoundedNonWhitespaceSequenceScopeHandler(
          this,
          scopeType,
          languageId
        );
      case "url":
        return new UrlScopeHandler(this, scopeType, languageId);
      case "customRegex":
        return new CustomRegexScopeHandler(this, scopeType, languageId);
      case "glyph":
        return new GlyphScopeHandler(this, scopeType, languageId);
      case "collectionItem":
        return new CollectionItemScopeHandler(
          this,
          this.languageDefinitions,
          languageId
        );
      case "surroundingPair":
        return new SurroundingPairScopeHandler(
          this.languageDefinitions,
          scopeType,
          languageId
        );
      case "surroundingPairInterior":
        return new SurroundingPairInteriorScopeHandler(
          this,
          scopeType,
          languageId
        );
      case "notebookCell":
        return new NotebookCellScopeHandler(
          this,
          this.languageDefinitions,
          scopeType,
          languageId
        );
      case "interior":
        return new InteriorScopeHandler(
          this,
          this.languageDefinitions,
          scopeType,
          languageId
        );
      case "custom":
        return scopeType.scopeHandler;
      case "oneOf":
        return SortedScopeHandler.create(this, scopeType, languageId);
      case "fallback":
        return FallbackScopeHandler.create(this, scopeType, languageId);
      case "conditional":
        return new ConditionalScopeHandler(this, scopeType, languageId);
      case "instance":
        throw Error("Unexpected scope type 'instance'");
      default:
        return this.languageDefinitions.get(languageId)?.getScopeHandler(scopeType);
    }
  }
  create(scopeType, languageId) {
    const handler = this.maybeCreate(scopeType, languageId);
    if (handler == null) {
      throw new Error(`Couldn't create scope handler for '${scopeType.type}'`);
    }
    return handler;
  }
};

// ../cursorless-engine/src/languages/TreeSitterQuery/getNodeRange.ts
function getNodeRange(node) {
  return new Range(
    node.startPosition.row,
    node.startPosition.column,
    node.endPosition.row,
    node.endPosition.column
  );
}

// ../cursorless-engine/src/languages/TreeSitterQuery/checkCaptureStartEnd.ts
function checkCaptureStartEnd(captures, messages) {
  if (captures.length === 1) {
    return true;
  }
  let shownError = false;
  const lastStart = captures.filter(({ name: name2 }) => name2.endsWith(".start")).map(({ range: { end } }) => end).sort((a, b) => a.compareTo(b)).at(-1);
  const firstEnd = captures.filter(({ name: name2 }) => name2.endsWith(".end")).map(({ range: { start: start2 } }) => start2).sort((a, b) => a.compareTo(b)).at(0);
  if (lastStart != null && firstEnd != null) {
    if (lastStart.isAfter(firstEnd)) {
      void showError(
        messages,
        "TreeSitterQuery.checkCaptures.badOrder",
        `Start capture must be before end capture: ${captures.map((c) => c.name)}`
      );
      shownError = true;
    }
  }
  const startCount = captures.filter(
    ({ name: name2 }) => name2.endsWith(".start")
  ).length;
  const endCount = captures.filter(({ name: name2 }) => name2.endsWith(".end")).length;
  const regularCount = captures.length - startCount - endCount;
  if (regularCount > 0 && (startCount > 0 || endCount > 0)) {
    void showError(
      messages,
      "TreeSitterQuery.checkCaptures.mixRegularStartEnd",
      `Please do not mix regular captures and start/end captures: ${captures.map(
        ({ name: name2, range: range3 }) => name2 + " " + range3.toString()
      )}`
    );
    shownError = true;
  }
  if (regularCount > 1) {
    void showError(
      messages,
      "TreeSitterQuery.checkCaptures.duplicate",
      `A capture with the same name may only appear once in a single pattern: ${captures.map(
        ({ name: name2, range: range3 }) => name2 + " " + range3.toString()
      )}`
    );
    shownError = true;
  }
  return !shownError;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/isContainedInErrorNode.ts
function isContainedInErrorNode(node) {
  if (node.hasError) {
    return true;
  }
  let ancestorNode = node.parent;
  while (ancestorNode != null) {
    if (ancestorNode.isError) {
      return true;
    }
    if (ancestorNode.hasError) {
      return false;
    }
    if (ancestorNode.previousSibling?.isError || ancestorNode.nextSibling?.isError) {
      return true;
    }
    ancestorNode = ancestorNode.parent;
  }
  return false;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/normalizeCaptureName.ts
function normalizeCaptureName(name2) {
  return name2.replace(/(\.(start|end))?(\.(startOf|endOf))?$/, "");
}

// ../../node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});

// ../../node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator2 = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator2);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// ../../node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// ../../node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// ../../node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map3) {
  overrideErrorMap = map3;
}
function getErrorMap() {
  return overrideErrorMap;
}

// ../../node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map3 of maps) {
    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

// ../../node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// ../../node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err2) {
        if (err2?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args2) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args2.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args2.precision}}`;
  } else if (args2.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args2.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args2) {
  return new RegExp(`^${timeRegexSource(args2)}$`);
}
function datetimeRegex(args2) {
  let regex = `${dateRegexSource}T${timeRegexSource(args2)}`;
  const opts = [];
  opts.push(args2.local ? `Z?` : `Z`);
  if (args2.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options2) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  cidr(options2) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      offset: options2?.offset ?? false,
      local: options2?.local ?? false,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options2
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2?.position,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema3, params) => {
  return new ZodArray({
    type: schema3,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema3) {
  if (schema3 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema3.shape) {
      const fieldSchema = schema3.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema3._def,
      shape: () => newShape
    });
  } else if (schema3 instanceof ZodArray) {
    return new ZodArray({
      ...schema3._def,
      type: deepPartialify(schema3.element)
    });
  } else if (schema3 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodTuple) {
    return ZodTuple.create(schema3.items.map((item) => deepPartialify(item)));
  } else {
    return schema3;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    this._cached = { shape, keys: keys2 };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema3) {
    return this.augment({ [key]: schema3 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return util.objectValues(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else if (type2 instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodNullable) {
    return [null, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodBranded) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodReadonly) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodCatch) {
    return getDiscriminator(type2._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options2, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options2) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type2);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema3 = this._def.items[itemIndex] || this._def.rest;
      if (!schema3)
        return null;
      return schema3._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args2, error) {
      return makeIssue({
        data: args2,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args2) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args2, params).catch((e) => {
          error.addIssue(makeArgsIssue(args2, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args2) {
        const parsedArgs = me._def.args.safeParse(args2, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args2, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  strictImplement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  static create(args2, returns, params) {
    return new _ZodFunction({
      args: args2 ? args2 : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2, newDef = this._def) {
    return _ZodEnum.create(values2, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values2, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema3, params) => {
  return new ZodPromise({
    type: schema3,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema3, effect, params) => {
  return new ZodEffects({
    schema: schema3,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema3, params) => {
  return new ZodEffects({
    schema: schema3,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze2 = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze2(data)) : freeze2(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;

// ../cursorless-engine/src/languages/TreeSitterQuery/makeRangeFromPositions.ts
function makeRangeFromPositions(startPosition, endPosition) {
  return new Range(
    startPosition.row,
    startPosition.column,
    endPosition.row,
    endPosition.column
  );
}

// ../cursorless-engine/src/languages/TreeSitterQuery/predicateToString.ts
function predicateToString(predicateDescriptor) {
  const operandList = predicateDescriptor.operands.map(operandToString).join(" ");
  return `(#${predicateDescriptor.operator} ${operandList})`;
}
function operandToString(value) {
  return value.type === "capture" ? `@${value.name}` : value.value;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/constructZodErrorMessages.ts
function constructZodErrorMessages(inputOperands, error) {
  return error.errors.filter(
    // If the user has supplied a capture instead of a string, or vice versa,
    // we'll get two errors instead of one; we prefer to show the more helpful
    // one.
    (error2) => !(error2.code === "invalid_type" && error2.path.length === 2 && (error2.path[1] === "name" || error2.path[1] === "value"))
  ).map((error2) => getErrorMessage(inputOperands, error2));
}
function getErrorMessage(inputOperands, error) {
  if (error.path.length === 0) {
    if (error.code === "too_small") {
      return "Too few arguments";
    } else if (error.code === "too_big") {
      return "Too many arguments";
    }
    return error.message;
  }
  let message = error.message;
  if (error.code === "invalid_literal" && error.path[1] === "type") {
    message = error.expected === "capture" ? "Capture names must be prefixed with @" : "Expected string, but received capture";
  }
  const argIndex = error.path[0];
  const operandString = operandToString(inputOperands[argIndex]);
  return `Error on argument ${argIndex} (\`${operandString}\`): ${message}`;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/QueryPredicateOperator.ts
var QueryPredicateOperator = class {
  /**
   * Whether it is ok for a node argument to be missing.  If true, then the
   * operator will just accept the pattern if the given node is missing.  If
   * false, then the operator will throw an error if the node is missing.
   *
   * This is useful if we want to set some flag on a node, but only if it's
   * present.
   *
   * @returns A boolean indicating whether it is ok for a node argument to be
   * missing.
   */
  allowMissingNode() {
    return false;
  }
  /**
   * Given a list of operands, return a predicate function that can be used to
   * test whether a given match satisfies the predicate.
   *
   * @param inputOperands The operands to the operator, as returned directly
   * from tree-sitter when parse the query file.
   * @returns Either a predicate function, or a list of error messages if the operands
   * were invalid.
   */
  createPredicate(inputOperands) {
    const result = this.schema.safeParse(inputOperands);
    return result.success ? {
      success: true,
      predicate: (match) => {
        try {
          const acceptArgs = this.constructAcceptArgs(result.data, match);
          return this.run(...acceptArgs);
        } catch (err2) {
          if (err2 instanceof CaptureNotFoundError && this.allowMissingNode()) {
            return true;
          }
          throw err2;
        }
      }
    } : {
      success: false,
      errors: constructZodErrorMessages(inputOperands, result.error)
    };
  }
  /**
   * Given the output of the schema and a match, construct the arguments to pass
   * to the `accept` function.
   * @param rawOutput The output of the schema.
   * @param match The match to use to convert captures to nodes.
   * @returns The arguments to pass to the `accept` function.
   */
  constructAcceptArgs(rawOutput, match) {
    return rawOutput.map((operand) => {
      if (operand.type === "capture") {
        const capture = match.captures.find(
          (capture2) => capture2.name === operand.name
        );
        if (capture == null) {
          throw new CaptureNotFoundError(operand.name);
        }
        return capture;
      } else {
        return operand.value;
      }
    });
  }
};
var CaptureNotFoundError = class extends Error {
  constructor(operandName) {
    super(`Could not find capture ${operandName}`);
  }
};

// ../cursorless-engine/src/languages/TreeSitterQuery/isEven.ts
function isEven(node, fieldName) {
  if (node.parent == null) {
    throw Error("Node has no parent");
  }
  const treeCursor = node.parent.walk();
  let hasNext = treeCursor.gotoFirstChild();
  let even = true;
  while (hasNext) {
    if (treeCursor.currentFieldName === fieldName) {
      if (treeCursor.currentNode.id === node.id) {
        return even;
      }
      even = !even;
    }
    hasNext = treeCursor.gotoNextSibling();
  }
  throw Error(`Node not found in parent for field: ${fieldName}`);
}

// ../cursorless-engine/src/languages/TreeSitterQuery/operatorArgumentSchemaTypes.ts
var string = external_exports.object({ type: external_exports.literal("string"), value: external_exports.string() });
var q = {
  /**
   * Expect a capture, eg @foo.  The operator will receive the node referenced
   * by the capture
   */
  node: external_exports.object({ type: external_exports.literal("capture"), name: external_exports.string() }),
  /** Expect a string */
  string,
  /** Expect an integer */
  integer: string.transform((val, ctx) => {
    const parsedValue = parseInt(val.value);
    if (isNaN(parsedValue)) {
      ctx.addIssue({
        code: external_exports.ZodIssueCode.custom,
        message: "Expected an integer"
      });
      return external_exports.NEVER;
    }
    return { type: "integer", value: parsedValue };
  }),
  /** Expect a boolean */
  boolean: string.transform((val, ctx) => {
    if (val.value === "true") {
      return { type: "boolean", value: true };
    }
    if (val.value === "false") {
      return { type: "boolean", value: false };
    }
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      message: "Expected true or false"
    });
    return external_exports.NEVER;
  })
};

// ../cursorless-engine/src/languages/TreeSitterQuery/queryPredicateOperators.ts
var Even = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "even?";
    this.schema = external_exports.tuple([q.node, q.string]);
  }
  run({ node }, fieldName) {
    return isEven(node, fieldName);
  }
};
var Odd = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "odd?";
    this.schema = external_exports.tuple([q.node, q.string]);
  }
  run({ node }, fieldName) {
    return !isEven(node, fieldName);
  }
};
var Text = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "text?";
    this.schema = external_exports.tuple([q.node, q.string]).rest(q.string);
  }
  run({ document: document2, range: range3 }, ...texts) {
    return texts.includes(document2.getText(range3));
  }
};
var Type2 = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "type?";
    this.schema = external_exports.tuple([q.node, q.string]).rest(q.string);
  }
  run({ node }, ...types) {
    return types.includes(node.type);
  }
};
var NotType = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "not-type?";
    this.schema = external_exports.tuple([q.node, q.string]).rest(q.string);
  }
  run({ node }, ...types) {
    return !types.includes(node.type);
  }
};
var NotParentType = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "not-parent-type?";
    this.schema = external_exports.tuple([q.node, q.string]).rest(q.string);
  }
  run({ node }, ...types) {
    return node.parent == null || !types.includes(node.parent.type);
  }
};
var IsNthChild = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "is-nth-child?";
    this.schema = external_exports.tuple([q.node, q.integer]);
  }
  run({ node }, n) {
    return node.parent?.children.findIndex((n2) => n2.id === node.id) === n;
  }
};
var HasMultipleChildrenOfType = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "has-multiple-children-of-type?";
    this.schema = external_exports.tuple([q.node, q.string]);
  }
  run({ node }, type2) {
    const count2 = node.children.filter((n) => n.type === type2).length;
    return count2 > 1;
  }
};
var ChildRange = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "child-range!";
    this.schema = external_exports.union([
      external_exports.tuple([q.node, q.integer]),
      external_exports.tuple([q.node, q.integer, q.integer]),
      external_exports.tuple([q.node, q.integer, q.integer, q.boolean]),
      external_exports.tuple([q.node, q.integer, q.integer, q.boolean, q.boolean])
    ]);
  }
  run(nodeInfo, startIndex, endIndex, excludeStart, excludeEnd) {
    const {
      node: { children }
    } = nodeInfo;
    startIndex = startIndex < 0 ? children.length + startIndex : startIndex;
    endIndex = endIndex == null ? -1 : endIndex;
    endIndex = endIndex < 0 ? children.length + endIndex : endIndex;
    const start2 = children[startIndex];
    const end = children[endIndex];
    nodeInfo.range = makeRangeFromPositions(
      excludeStart ? start2.endPosition : start2.startPosition,
      excludeEnd ? end.startPosition : end.endPosition
    );
    return true;
  }
};
var CharacterRange = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "character-range!";
    this.schema = external_exports.union([
      external_exports.tuple([q.node, q.integer]),
      external_exports.tuple([q.node, q.integer, q.integer])
    ]);
  }
  run(nodeInfo, startOffset, endOffset) {
    nodeInfo.range = new Range(
      nodeInfo.range.start.translate(void 0, startOffset),
      nodeInfo.range.end.translate(void 0, endOffset ?? 0)
    );
    return true;
  }
};
var ShrinkToMatch = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "shrink-to-match!";
    this.schema = external_exports.tuple([q.node, q.string]);
  }
  run(nodeInfo, pattern) {
    const { document: document2, range: range3 } = nodeInfo;
    const text = document2.getText(range3);
    const match = text.match(new RegExp(pattern, "ds"));
    if (match?.index == null) {
      throw Error(`No match for pattern '${pattern}'`);
    }
    const [startOffset, endOffset] = match.indices?.groups?.keep ?? match.indices[0];
    const baseOffset = document2.offsetAt(range3.start);
    nodeInfo.range = new Range(
      document2.positionAt(baseOffset + startOffset),
      document2.positionAt(baseOffset + endOffset)
    );
    return true;
  }
};
var GrowToNamedSiblings = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "grow-to-named-siblings!";
    this.schema = external_exports.union([external_exports.tuple([q.node]), external_exports.tuple([q.node, q.string])]);
  }
  run(nodeInfo, notText) {
    const { node, range: range3, document: document2 } = nodeInfo;
    if (node.parent == null) {
      throw Error("Node has no parent");
    }
    const { children } = node.parent;
    const nodeIndex = children.findIndex((n) => n.id === node.id);
    let endPosition = null;
    if (nodeIndex === -1) {
      throw Error("Node not found in parent");
    }
    for (let i2 = nodeIndex + 1; i2 < children.length; ++i2) {
      const child = children[i2];
      if (!child.isNamed) {
        break;
      }
      const childRange = makeRangeFromPositions(
        child.startPosition,
        child.endPosition
      );
      if (notText != null && notText === document2.getText(childRange)) {
        break;
      }
      endPosition = childRange.end;
    }
    if (endPosition != null) {
      nodeInfo.range = new Range(range3.start, endPosition);
    }
    return true;
  }
};
var TrimEnd = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "trim-end!";
    this.schema = external_exports.tuple([q.node]);
  }
  run(nodeInfo) {
    const { document: document2, range: range3 } = nodeInfo;
    const text = document2.getText(range3);
    const whitespaceLength = text.length - text.trimEnd().length;
    if (whitespaceLength > 0) {
      nodeInfo.range = new Range(
        range3.start,
        adjustPosition(document2, range3.end, -whitespaceLength)
      );
    }
    return true;
  }
};
var DocumentRange = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "document-range!";
    this.schema = external_exports.tuple([q.node]).rest(q.node);
  }
  run(...nodeInfos) {
    for (const nodeInfo of nodeInfos) {
      nodeInfo.range = nodeInfo.document.range;
    }
    return true;
  }
};
var AllowMultiple = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "allow-multiple!";
    this.schema = external_exports.tuple([q.node]).rest(q.node);
  }
  allowMissingNode() {
    return true;
  }
  run(...nodeInfos) {
    for (const nodeInfo of nodeInfos) {
      nodeInfo.allowMultiple = true;
    }
    return true;
  }
};
var Log = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "log!";
    this.schema = external_exports.tuple([q.node]);
  }
  run(nodeInfo) {
    console.log(`#log!: ${nodeInfo.name}@${nodeInfo.range}`);
    return true;
  }
};
var InsertionDelimiter = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "insertion-delimiter!";
    this.schema = external_exports.tuple([q.node, q.string]);
  }
  run(nodeInfo, insertionDelimiter) {
    nodeInfo.insertionDelimiter = insertionDelimiter;
    return true;
  }
};
var SingleOrMultilineDelimiter = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "single-or-multi-line-delimiter!";
    this.schema = external_exports.tuple([q.node, q.node, q.string, q.string]);
  }
  run(nodeInfo, conditionNodeInfo, insertionDelimiterConsequence, insertionDelimiterAlternative) {
    nodeInfo.insertionDelimiter = conditionNodeInfo.range.isSingleLine ? insertionDelimiterConsequence : insertionDelimiterAlternative;
    return true;
  }
};
var EmptySingleMultiDelimiter = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "empty-single-multi-delimiter!";
    this.schema = external_exports.tuple([q.node, q.node, q.string, q.string, q.string]);
  }
  run(nodeInfo, conditionNodeInfo, insertionDelimiterEmpty, insertionDelimiterSingleLine, insertionDelimiterMultiline) {
    const isEmpty = !conditionNodeInfo.node.children.some(
      (child) => child.isNamed
    );
    nodeInfo.insertionDelimiter = isEmpty ? insertionDelimiterEmpty : conditionNodeInfo.range.isSingleLine ? insertionDelimiterSingleLine : insertionDelimiterMultiline;
    return true;
  }
};
var queryPredicateOperators = [
  new Log(),
  new Even(),
  new Odd(),
  new Text(),
  new Type2(),
  new NotType(),
  new TrimEnd(),
  new DocumentRange(),
  new NotParentType(),
  new IsNthChild(),
  new ChildRange(),
  new CharacterRange(),
  new ShrinkToMatch(),
  new GrowToNamedSiblings(),
  new AllowMultiple(),
  new InsertionDelimiter(),
  new SingleOrMultilineDelimiter(),
  new EmptySingleMultiDelimiter(),
  new HasMultipleChildrenOfType()
];

// ../cursorless-engine/src/languages/TreeSitterQuery/parsePredicates.ts
function parsePredicates(predicateDescriptors) {
  const errors2 = [];
  const predicates = [];
  predicateDescriptors.forEach((patternPredicateDescriptors, patternIdx) => {
    const patternPredicates = [];
    patternPredicateDescriptors.forEach((predicateDescriptor, predicateIdx) => {
      const operator = queryPredicateOperators.find(
        ({ name: name2 }) => name2 === predicateDescriptor.operator
      );
      if (operator == null) {
        errors2.push({
          patternIdx,
          predicateIdx,
          error: `Unknown predicate operator "${predicateDescriptor.operator}"`
        });
        return;
      }
      const result = operator.createPredicate(predicateDescriptor.operands);
      if (!result.success) {
        errors2.push(
          ...result.errors.map((error) => ({
            patternIdx,
            predicateIdx,
            error
          }))
        );
        return;
      }
      patternPredicates.push(result.predicate);
    });
    predicates.push(patternPredicates);
  });
  return { errors: errors2, predicates };
}

// ../cursorless-engine/src/languages/TreeSitterQuery/parsePredicatesWithErrorHandling.ts
function parsePredicatesWithErrorHandling(languageId, query) {
  const { errors: errors2, predicates } = parsePredicates(query.predicates);
  if (errors2.length > 0) {
    for (const error of errors2) {
      const context = [
        `language ${languageId}`,
        `pattern ${error.patternIdx}`,
        `predicate \`${predicateToString(
          query.predicates[error.patternIdx][error.predicateIdx]
        )}\``
      ].join(", ");
      void showError(
        ide().messages,
        "TreeSitterQuery.parsePredicates",
        `Error parsing predicate for ${context}: ${error.error}`
      );
    }
    if (ide().runMode === "test") {
      throw new Error("Invalid predicates");
    }
  }
  return predicates;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/positionToPoint.ts
function positionToPoint(start2) {
  return { row: start2.line, column: start2.character };
}

// ../cursorless-engine/src/languages/TreeSitterQuery/rewriteStartOfEndOf.ts
function rewriteStartOfEndOf(captures) {
  return captures.map((capture) => ({
    ...capture,
    range: getStartOfEndOfRange(capture),
    name: getStartOfEndOfName(capture)
  }));
}
function getStartOfEndOfRange(capture) {
  if (capture.name.endsWith(".startOf")) {
    return capture.range.start.toEmptyRange();
  }
  if (capture.name.endsWith(".endOf")) {
    return capture.range.end.toEmptyRange();
  }
  return capture.range;
}
function getStartOfEndOfName(capture) {
  if (capture.name.endsWith(".startOf")) {
    return capture.name.slice(0, -8);
  }
  if (capture.name.endsWith(".endOf")) {
    return capture.name.slice(0, -6);
  }
  return capture.name;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/treeSitterQueryCache.ts
var Cache = class {
  constructor() {
    this.documentVersion = -1;
    this.documentUri = "";
    this.documentLanguageId = "";
    this.matches = [];
  }
  clear() {
    this.documentUri = "";
    this.documentVersion = -1;
    this.documentLanguageId = "";
    this.startPosition = void 0;
    this.endPosition = void 0;
    this.matches = [];
  }
  isValid(document2, startPosition, endPosition) {
    return this.documentVersion === document2.version && this.documentUri === document2.uri.toString() && this.documentLanguageId === document2.languageId && positionsEqual(this.startPosition, startPosition) && positionsEqual(this.endPosition, endPosition);
  }
  update(document2, startPosition, endPosition, matches) {
    this.documentVersion = document2.version;
    this.documentUri = document2.uri.toString();
    this.documentLanguageId = document2.languageId;
    this.startPosition = startPosition;
    this.endPosition = endPosition;
    this.matches = matches;
  }
  get() {
    return this.matches;
  }
};
function positionsEqual(a, b) {
  if (a == null || b == null) {
    return a === b;
  }
  return a.isEqual(b);
}
var treeSitterQueryCache = new Cache();

// ../cursorless-engine/src/languages/TreeSitterQuery/TreeSitterQuery.ts
var TreeSitterQuery = class _TreeSitterQuery {
  constructor(treeSitter, query, patternPredicates) {
    this.treeSitter = treeSitter;
    this.query = query;
    this.patternPredicates = patternPredicates;
    this.shouldCheckCaptures = ide().runMode !== "production";
  }
  static create(languageId, treeSitter, query) {
    const predicates = parsePredicatesWithErrorHandling(languageId, query);
    return new _TreeSitterQuery(treeSitter, query, predicates);
  }
  hasCapture(name2) {
    return this.query.captureNames.some(
      (n) => normalizeCaptureName(n) === name2
    );
  }
  matches(document2, start2, end) {
    if (!treeSitterQueryCache.isValid(document2, start2, end)) {
      const matches = this.getAllMatches(document2, start2, end);
      treeSitterQueryCache.update(document2, start2, end, matches);
    }
    return treeSitterQueryCache.get();
  }
  getAllMatches(document2, start2, end) {
    const matches = this.getTreeMatches(document2, start2, end);
    const results = [];
    for (const match of matches) {
      const mutableMatch = this.createMutableQueryMatch(document2, match);
      if (!this.runPredicates(mutableMatch)) {
        continue;
      }
      results.push(this.createQueryMatch(mutableMatch));
    }
    return results;
  }
  getTreeMatches(document2, start2, end) {
    const { rootNode } = this.treeSitter.getTree(document2);
    return this.query.matches(rootNode, {
      startPosition: start2 != null ? positionToPoint(start2) : void 0,
      endPosition: end != null ? positionToPoint(end) : void 0
    });
  }
  createMutableQueryMatch(document2, match) {
    return {
      patternIdx: match.patternIndex,
      captures: match.captures.map(({ name: name2, node }) => ({
        name: name2,
        node,
        document: document2,
        range: getNodeRange(node),
        insertionDelimiter: void 0,
        allowMultiple: false,
        hasError: () => isContainedInErrorNode(node)
      }))
    };
  }
  runPredicates(match) {
    for (const predicate of this.patternPredicates[match.patternIdx]) {
      if (!predicate(match)) {
        return false;
      }
    }
    return true;
  }
  createQueryMatch(match) {
    const result = [];
    const map3 = /* @__PURE__ */ new Map();
    for (const capture of match.captures) {
      const name2 = normalizeCaptureName(capture.name);
      const range3 = getStartOfEndOfRange(capture);
      const existing = map3.get(name2);
      if (existing == null) {
        const captures = [capture];
        const acc = {
          ...capture,
          name: name2,
          range: range3,
          hasError: () => captures.some((c) => c.hasError())
        };
        result.push(acc);
        map3.set(name2, { acc, captures });
      } else {
        existing.acc.range = existing.acc.range.union(range3);
        existing.acc.allowMultiple = existing.acc.allowMultiple || capture.allowMultiple;
        existing.acc.insertionDelimiter = existing.acc.insertionDelimiter ?? capture.insertionDelimiter;
        existing.captures.push(capture);
      }
    }
    if (this.shouldCheckCaptures) {
      this.checkCaptures(Array.from(map3.values()));
    }
    return { captures: result };
  }
  checkCaptures(matches) {
    for (const match of matches) {
      const capturesAreValid = checkCaptureStartEnd(
        rewriteStartOfEndOf(match.captures),
        ide().messages
      );
      if (!capturesAreValid && ide().runMode === "test") {
        throw new Error("Invalid captures");
      }
    }
  }
};

// ../cursorless-engine/src/languages/TreeSitterQuery/validateQueryCaptures.ts
var wildcard = "_";
var captureNames = [wildcard, "interior", ...simpleScopeTypeTypes];
var positionRelationships = ["prefix", "leading", "trailing"];
var positionSuffixes = [
  "startOf",
  "endOf",
  "start.startOf",
  "start.endOf",
  "end.startOf",
  "end.endOf"
];
var rangeRelationships = [
  "domain",
  "removal",
  "iteration",
  "iteration.domain"
];
var rangeSuffixes = [
  "start",
  "end",
  "start.startOf",
  "start.endOf",
  "end.startOf",
  "end.endOf"
];
var allowedCaptures = /* @__PURE__ */ new Set();
for (const captureName of captureNames) {
  if (captureName !== wildcard) {
    allowedCaptures.add(captureName);
    for (const suffix of rangeSuffixes) {
      allowedCaptures.add(`${captureName}.${suffix}`);
    }
  }
  for (const relationship of positionRelationships) {
    allowedCaptures.add(`${captureName}.${relationship}`);
    for (const suffix of positionSuffixes) {
      allowedCaptures.add(`${captureName}.${relationship}.${suffix}`);
    }
  }
  for (const relationship of rangeRelationships) {
    allowedCaptures.add(`${captureName}.${relationship}`);
    for (const suffix of rangeSuffixes) {
      allowedCaptures.add(`${captureName}.${relationship}.${suffix}`);
    }
  }
}
var capturePattern = /^(?!;;).*(?<!"\w*)@([\w.]*)/gm;
function validateQueryCaptures(file, rawQuery) {
  const matches = rawQuery.matchAll(capturePattern);
  const errors2 = [];
  for (const match of matches) {
    const captureName = match[1];
    if (captureName.length > 1 && !captureName.includes(".") && captureName.startsWith("_")) {
      continue;
    }
    if (!allowedCaptures.has(captureName)) {
      const lineNumber = match.input.slice(0, match.index).split("\n").length;
      errors2.push(`${file}(${lineNumber}) invalid capture '@${captureName}'.`);
    }
  }
  if (errors2.length === 0) {
    return;
  }
  const message = errors2.join("\n");
  void showError(
    ide().messages,
    "validateQueryCaptures.invalidCaptureName",
    message
  );
  if (ide().runMode === "test") {
    throw new Error(message);
  }
}

// ../cursorless-engine/src/languages/LanguageDefinition.ts
var LanguageDefinition = class _LanguageDefinition {
  constructor(query) {
    this.query = query;
  }
  /**
   * Construct a language definition for the given language id, if the language
   * has a new-style query definition, or return undefined if the language doesn't
   *
   * @param treeSitter The tree-sitter instance to use for parsing
   * @param languageId The language id for which to create a language definition
   * @returns A language definition for the given language id, or undefined if the given language
   * id doesn't have a new-style query definition
   */
  static async create(ide2, treeSitterQueryProvider, treeSitter, languageId) {
    const rawLanguageQueryString = await readQueryFileAndImports(
      ide2,
      treeSitterQueryProvider,
      `${languageId}.scm`
    );
    if (rawLanguageQueryString == null) {
      return void 0;
    }
    if (!await treeSitter.loadLanguage(languageId)) {
      return void 0;
    }
    const rawQuery = treeSitter.createQuery(languageId, rawLanguageQueryString);
    if (rawQuery == null) {
      throw Error(
        `Could not create Tree sitter query for language ${languageId}`
      );
    }
    const query = TreeSitterQuery.create(languageId, treeSitter, rawQuery);
    return new _LanguageDefinition(query);
  }
  /**
   * @param scopeType The scope type for which to get a scope handler
   * @returns A scope handler for the given scope type and language id, or
   * undefined if the given scope type / language id combination is still using
   * legacy pathways
   */
  getScopeHandler(scopeType) {
    if (!this.query.hasCapture(scopeType.type)) {
      return void 0;
    }
    return new TreeSitterScopeHandler(this.query, scopeType);
  }
  /**
   * This is a low-level function that just returns a map of all captures in the
   * document. We use this in our surrounding pair code.
   *
   * @param document The document to search
   * @param captureName The name of a capture to search for
   * @returns A map of captures in the document
   */
  getCapturesMap(document2) {
    const matches = this.query.matches(document2);
    const result = {};
    for (const match of matches) {
      for (const capture of match.captures) {
        const name2 = capture.name;
        if (result[name2] == null) {
          result[name2] = [];
        }
        result[name2].push(capture);
      }
    }
    return result;
  }
};
async function readQueryFileAndImports(ide2, provider, languageQueryName) {
  const rawQueryStrings = {
    [languageQueryName]: null
  };
  const doValidation = ide2.runMode !== "production";
  while (Object.values(rawQueryStrings).some((v) => v == null)) {
    for (const [queryName, rawQueryString] of Object.entries(rawQueryStrings)) {
      if (rawQueryString != null) {
        continue;
      }
      let rawQuery = await provider.readQuery(queryName);
      if (rawQuery == null) {
        if (queryName === languageQueryName) {
          return void 0;
        }
        void showError(
          ide2.messages,
          "LanguageDefinition.readQueryFileAndImports.queryNotFound",
          `Could not find imported query file ${queryName}`
        );
        if (ide2.runMode === "test") {
          throw new Error("Invalid import statement");
        }
        rawQuery = "";
      }
      if (doValidation) {
        validateQueryCaptures(queryName, rawQuery);
      }
      rawQueryStrings[queryName] = rawQuery;
      matchAll(
        rawQuery,
        // Matches lines like:
        //
        // ;; import path/to/query.scm
        //
        // but is very lenient about whitespace and quotes, and also allows
        // include instead of import, so that we can throw a nice error message
        // if the developer uses the wrong syntax
        /^[^\S\r\n]*;;?[^\S\r\n]*(?:import|include)[^\S\r\n]+['"]?([\w|/\\.]+)['"]?[^\S\r\n]*$/gm,
        (match) => {
          const importName = match[1];
          if (doValidation) {
            validateImportSyntax(ide2, queryName, importName, match[0]);
          }
          rawQueryStrings[importName] = rawQueryStrings[importName] ?? null;
        }
      );
    }
  }
  return Object.values(rawQueryStrings).join("\n");
}
function validateImportSyntax(ide2, file, importName, actual) {
  let isError = false;
  if (/[/\\]/g.test(importName)) {
    void showError(
      ide2.messages,
      "LanguageDefinition.readQueryFileAndImports.invalidImport",
      `Invalid import statement in ${file}: "${actual}". Relative import paths not supported`
    );
    isError = true;
  }
  const canonicalSyntax = `;; import ${importName}`;
  if (actual !== canonicalSyntax) {
    void showError(
      ide2.messages,
      "LanguageDefinition.readQueryFileAndImports.malformedImport",
      `Malformed import statement in ${file}: "${actual}". Import statements must be of the form "${canonicalSyntax}"`
    );
    isError = true;
  }
  if (isError && ide2.runMode === "test") {
    throw new Error("Invalid import statement");
  }
}

// ../cursorless-engine/src/languages/LanguageDefinitions.ts
var LANGUAGE_UNDEFINED = Symbol("LANGUAGE_UNDEFINED");
var LanguageDefinitionsImpl = class _LanguageDefinitionsImpl {
  constructor(ide2, treeSitter, treeSitterQueryProvider) {
    this.ide = ide2;
    this.treeSitter = treeSitter;
    this.treeSitterQueryProvider = treeSitterQueryProvider;
    this.notifier = new Notifier();
    /**
     * Maps from language id to {@link LanguageDefinition} or
     * {@link LANGUAGE_UNDEFINED} if language doesn't have new-style definitions.
     * We use a sentinel value instead of undefined so that we can distinguish
     * between a situation where we haven't yet checked whether a language has a
     * new-style query definition and a situation where we've checked and found
     * that it doesn't.  The former case is represented by `undefined` (due to the
     * semantics of {@link Map.get}), while the latter is represented by the
     * sentinel value.
     */
    this.languageDefinitions = /* @__PURE__ */ new Map();
    this.disposables = [];
    this.onDidChangeDefinition = this.notifier.registerListener;
    const isTesting = ide2.runMode === "test";
    ide2.onDidOpenTextDocument((document2) => {
      if (isTesting) {
        treeSitterQueryCache.clear();
      }
      void this.loadLanguage(document2.languageId);
    });
    ide2.onDidChangeVisibleTextEditors((editors) => {
      editors.forEach(({ document: document2 }) => this.loadLanguage(document2.languageId));
    });
    this.disposables.push(
      treeSitterQueryProvider.onChanges(() => this.reloadLanguageDefinitions())
    );
  }
  static async create(ide2, treeSitter, treeSitterQueryProvider) {
    const instance2 = new _LanguageDefinitionsImpl(
      ide2,
      treeSitter,
      treeSitterQueryProvider
    );
    await instance2.loadAllLanguages();
    return instance2;
  }
  async loadAllLanguages() {
    const languageIds = this.ide.visibleTextEditors.map(
      ({ document: document2 }) => document2.languageId
    );
    try {
      await Promise.all(
        languageIds.map((languageId) => this.loadLanguage(languageId))
      );
    } catch (err2) {
      void showError(
        this.ide.messages,
        "Failed to load language definitions",
        toString_default(err2)
      );
      if (this.ide.runMode === "test") {
        throw err2;
      }
    }
  }
  async loadLanguage(languageId) {
    if (this.languageDefinitions.has(languageId)) {
      return;
    }
    const definition = await LanguageDefinition.create(
      this.ide,
      this.treeSitterQueryProvider,
      this.treeSitter,
      languageId
    ) ?? LANGUAGE_UNDEFINED;
    this.languageDefinitions.set(languageId, definition);
  }
  async reloadLanguageDefinitions() {
    this.languageDefinitions.clear();
    await this.loadAllLanguages();
    treeSitterQueryCache.clear();
    this.notifier.notifyListeners();
  }
  get(languageId) {
    const definition = this.languageDefinitions.get(languageId);
    if (definition == null) {
      throw new Error(
        "Expected language definition entry is missing for languageId " + languageId
      );
    }
    return definition === LANGUAGE_UNDEFINED ? void 0 : definition;
  }
  getNodeAtLocation(document2, range3) {
    return this.treeSitter.getNodeAtLocation(document2, range3);
  }
  dispose() {
    this.disposables.forEach((disposable) => disposable.dispose());
  }
};

// ../cursorless-engine/src/processTargets/modifiers/CascadingStage.ts
var CascadingStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  get nestedStages() {
    if (this.nestedStages_ == null) {
      this.nestedStages_ = this.modifier.modifiers.map(
        this.modifierStageFactory.create
      );
    }
    return this.nestedStages_;
  }
  run(target, options2) {
    for (const nestedStage of this.nestedStages) {
      try {
        return nestedStage.run(target, options2);
      } catch (_error) {
        continue;
      }
    }
    throw new Error("No modifier could be applied");
  }
};

// ../cursorless-engine/src/processTargets/modifiers/ConditionalModifierStages.ts
var ConditionalModifierBaseStage = class {
  constructor(modifierStageFactory, nestedModifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.nestedModifier = nestedModifier;
    this.suppressErrors = false;
  }
  run(target, options2) {
    if (this.shouldModify(target)) {
      try {
        return this.nestedStage.run(target, options2).map((newTarget) => newTarget.withThatTarget(target));
      } catch (ex) {
        if (!this.suppressErrors) {
          throw ex;
        }
      }
    }
    return [target];
  }
  get nestedStage() {
    if (this.nestedStage_ == null) {
      this.nestedStage_ = this.modifierStageFactory.create(this.nestedModifier);
    }
    return this.nestedStage_;
  }
};
var ModifyIfUntypedStage = class extends ConditionalModifierBaseStage {
  constructor(modifierStageFactory, modifier) {
    super(modifierStageFactory, modifier.modifier);
  }
  shouldModify(target) {
    return !target.hasExplicitScopeType;
  }
};
var ModifyIfConditionStage = class extends ConditionalModifierBaseStage {
  constructor(modifierStageFactory, nestedModifier, modificationCondition) {
    super(modifierStageFactory, nestedModifier);
    this.modificationCondition = modificationCondition;
  }
  shouldModify(target) {
    return this.modificationCondition(target);
  }
};
var ModifyIfUntypedExplicitStage = class extends ConditionalModifierBaseStage {
  shouldModify(target) {
    return !target.hasExplicitScopeType && !target.isImplicit;
  }
};
var ContainingTokenIfUntypedEmptyStage = class extends ConditionalModifierBaseStage {
  constructor(modifierStageFactory) {
    super(modifierStageFactory, {
      type: "containingScope",
      scopeType: { type: "token" }
    });
    this.suppressErrors = true;
  }
  shouldModify(target) {
    return !target.hasExplicitScopeType && !target.hasExplicitRange && target.contentRange.isEmpty;
  }
};

// ../cursorless-engine/src/util/typeUtils.ts
function isSameType(a, b) {
  return Object.getPrototypeOf(a).constructor === Object.getPrototypeOf(b).constructor;
}

// ../cursorless-engine/src/processTargets/createContinuousRangeTarget.ts
function createContinuousRangeTarget(isReversed, startTarget, endTarget, includeStart, includeEnd) {
  if (startTarget.editor !== endTarget.editor) {
    throw Error("Continuous targets must be in the same editor");
  }
  if (includeStart && includeEnd && isSameType(startTarget, endTarget)) {
    const richTarget = startTarget.maybeCreateRichRangeTarget(
      isReversed,
      endTarget
    );
    if (richTarget != null) {
      return richTarget;
    }
  }
  if (startTarget.textualType === "line" && endTarget.textualType === "line") {
    return new LineTarget({
      editor: startTarget.editor,
      isReversed,
      contentRange: createContinuousLineRange(
        startTarget,
        endTarget,
        includeStart,
        includeEnd
      )
    });
  }
  return new UntypedTarget({
    editor: startTarget.editor,
    isReversed,
    hasExplicitRange: true,
    contentRange: createContinuousRange(
      startTarget,
      endTarget,
      includeStart,
      includeEnd
    ),
    textualType: includeStart && includeEnd && startTarget.textualType === "token" && endTarget.textualType === "token" ? "token" : "character"
  });
}

// ../cursorless-engine/src/processTargets/modifiers/constructScopeRangeTarget.ts
function constructScopeRangeTarget(isReversed, scope1, scope2) {
  if (scope1 === scope2) {
    return scope1.getTargets(isReversed);
  }
  const targets1 = scope1.getTargets(isReversed);
  const targets2 = scope2.getTargets(isReversed);
  if (targets1.length !== 1 || targets2.length !== 1) {
    throw Error("Scope range targets must be single-target");
  }
  const [target1] = targets1;
  const [target2] = targets2;
  const isScope2After = target2.contentRange.start.isAfterOrEqual(
    target1.contentRange.start
  );
  const [startTarget, endTarget] = isScope2After ? [target1, target2] : [target2, target1];
  return [
    createContinuousRangeTarget(isReversed, startTarget, endTarget, true, true)
  ];
}

// ../cursorless-engine/src/processTargets/modifiers/getPreferredScopeTouchingPosition.ts
function getPreferredScopeTouchingPosition(scopeHandler, editor, position, forceDirection) {
  const candidates = Array.from(
    scopeHandler.generateScopes(editor, position, "forward", {
      containment: "required",
      allowAdjacentScopes: true,
      skipAncestorScopes: true
    })
  );
  switch (candidates.length) {
    case 0:
      return void 0;
    case 1:
      return candidates[0];
    case 2: {
      const [backwardScope, forwardScope] = candidates;
      if (forceDirection === "forward") {
        return forwardScope;
      }
      if (forceDirection === "backward") {
        return backwardScope;
      }
      if (scopeHandler.isPreferredOver?.(backwardScope, forwardScope) ?? false) {
        return backwardScope;
      }
      return forwardScope;
    }
    default:
      throw new Error("Expected no more than 2 scope candidates");
  }
}

// ../cursorless-engine/src/processTargets/modifiers/getContainingScopeTarget.ts
function getContainingScopeTarget(target, scopeHandler, ancestorIndex = 0) {
  const {
    isReversed,
    editor,
    contentRange: { start: start2, end }
  } = target;
  if (end.isEqual(start2)) {
    let scope = getPreferredScopeTouchingPosition(scopeHandler, editor, start2);
    if (scope == null) {
      return void 0;
    }
    if (ancestorIndex > 0) {
      scope = expandFromPosition(
        scopeHandler,
        editor,
        scope.domain.end,
        "forward",
        ancestorIndex,
        true
      );
    }
    if (scope == null) {
      return void 0;
    }
    return scope.getTargets(isReversed);
  }
  const startScope = expandFromPosition(
    scopeHandler,
    editor,
    start2,
    "forward",
    ancestorIndex
  );
  if (startScope == null) {
    return void 0;
  }
  if (startScope.domain.contains(end)) {
    return startScope.getTargets(isReversed);
  }
  const endScope = expandFromPosition(
    scopeHandler,
    editor,
    end,
    "backward",
    ancestorIndex
  );
  if (endScope == null) {
    return void 0;
  }
  return constructScopeRangeTarget(isReversed, startScope, endScope);
}
function expandFromPosition(scopeHandler, editor, position, direction2, ancestorIndex, allowAdjacentScopes = false) {
  let nextAncestorIndex = 0;
  for (const scope of scopeHandler.generateScopes(editor, position, direction2, {
    containment: "required",
    allowAdjacentScopes
  })) {
    if (nextAncestorIndex === ancestorIndex) {
      return scope;
    }
    nextAncestorIndex += 1;
  }
  return void 0;
}

// ../cursorless-engine/src/processTargets/modifiers/ContainingScopeStage.ts
var ContainingScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target) {
    const { scopeType, ancestorIndex = 0 } = this.modifier;
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      target.editor.document.languageId
    );
    if (scopeHandler == null) {
      throw new NoContainingScopeError(scopeType.type);
    }
    const containingScopes = getContainingScopeTarget(
      target,
      scopeHandler,
      ancestorIndex
    );
    if (containingScopes == null) {
      throw new NoContainingScopeError(scopeType.type);
    }
    return containingScopes;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/EveryScopeStage.ts
var EveryScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const { scopeType } = this.modifier;
    const { editor, isReversed } = target;
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      editor.document.languageId
    );
    if (scopeHandler == null) {
      throw new NoContainingScopeError(scopeType.type);
    }
    let scopes;
    if (target.hasExplicitRange) {
      scopes = getScopesOverlappingRange(
        scopeHandler,
        editor,
        target.contentRange
      );
      if (scopes.length === 1 && scopes[0].domain.contains(target.contentRange) && !target.hasExplicitScopeType && !options2.multipleTargets) {
        scopes = void 0;
      }
    }
    if (scopes == null) {
      scopes = this.getDefaultIterationRange(
        scopeHandler,
        this.scopeHandlerFactory,
        target
      ).flatMap(
        (iterationRange) => getScopesOverlappingRange(scopeHandler, editor, iterationRange)
      );
    }
    if (scopes.length === 0) {
      throw new NoContainingScopeError(scopeType.type);
    }
    return scopes.flatMap((scope) => scope.getTargets(isReversed));
  }
  getDefaultIterationRange(scopeHandler, scopeHandlerFactory, target) {
    const iterationScopeHandler = scopeHandlerFactory.maybeCreate(
      scopeHandler.iterationScopeType,
      target.editor.document.languageId
    );
    if (iterationScopeHandler == null) {
      throw Error("Could not find iteration scope handler");
    }
    const iterationScopeTarget = getContainingScopeTarget(
      target,
      iterationScopeHandler
    );
    if (iterationScopeTarget == null) {
      throw new NoContainingScopeError(
        `iteration scope for ${scopeHandler.scopeType.type}`
      );
    }
    return iterationScopeTarget.map((target2) => target2.contentRange);
  }
};
function getScopesOverlappingRange(scopeHandler, editor, { start: start2, end }) {
  return Array.from(
    scopeHandler.generateScopes(editor, start2, "forward", {
      distalPosition: end,
      skipAncestorScopes: true,
      allowAdjacentScopes: scopeHandler.includeAdjacentInEvery
    })
  );
}

// ../cursorless-engine/src/processTargets/modifiers/FilterStages.ts
var KeepContentFilterStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return target.contentText.trim() !== "" ? [target] : [];
  }
};
var KeepEmptyFilterStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return target.contentText.trim() === "" ? [target] : [];
  }
};

// ../cursorless-engine/src/processTargets/marks/ImplicitStage.ts
var ImplicitStage = class {
  run() {
    return getActiveSelections(ide()).map(
      (selection) => new ImplicitTarget({
        editor: selection.editor,
        isReversed: selection.selection.isReversed,
        contentRange: selection.selection
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/TargetPipelineRunner.ts
var TargetPipelineRunner = class {
  constructor(modifierStageFactory, markStageFactory) {
    this.modifierStageFactory = modifierStageFactory;
    this.markStageFactory = markStageFactory;
  }
  /**
   * Converts the abstract target descriptions provided by the user to a
   * concrete representation usable by actions. Conceptually, the input will be
   * something like "the function call argument containing the cursor" and the
   * output will be something like "line 3, characters 5 through 10".
   * @param target The abstract target representations provided by the user
   * @param actionFinalStages Modifier stages contributed by the action that
   * should run at the end of the modifier pipeline
   * @returns A list of lists of typed selections, one list per input target.
   * Each typed selection includes the selection, as well the uri of the
   * document containing it, and potentially rich context information such as
   * how to remove the target
   */
  run(target, {
    actionFinalStages = [],
    noAutomaticTokenExpansion = false
  } = {}) {
    return new TargetPipeline(
      this.modifierStageFactory,
      this.markStageFactory,
      target,
      { actionFinalStages, noAutomaticTokenExpansion }
    ).run();
  }
};
var TargetPipeline = class {
  constructor(modifierStageFactory, markStageFactory, target, opts) {
    this.modifierStageFactory = modifierStageFactory;
    this.markStageFactory = markStageFactory;
    this.target = target;
    this.opts = opts;
  }
  /**
   * Converts the abstract target descriptions provided by the user to a concrete
   * representation usable by actions. Conceptually, the input will be something
   * like "the function call argument containing the cursor" and the output will be something
   * like "line 3, characters 5 through 10".
   * @param context Captures the environment needed to convert the abstract target
   *    description given by the user to a concrete representation usable by
   *    actions
   * @param targets The abstract target representations provided by the user
   * @returns A list of lists of typed selections, one list per input target. Each
   * typed selection includes the selection, as well the uri of the document
   * containing it, and potentially rich context information such as how to remove
   * the target
   */
  run() {
    return uniqTargets(this.processTarget(this.target));
  }
  processTarget(target) {
    switch (target.type) {
      case "list":
        return target.elements.flatMap(
          (element) => this.processTarget(element)
        );
      case "range":
        return this.processRangeTarget(target);
      case "primitive":
      case "implicit":
        return this.processPrimitiveTarget(target);
    }
  }
  processRangeTarget(targetDesc) {
    const anchorTargets = this.processPrimitiveTarget(targetDesc.anchor);
    const activeTargets = this.processPrimitiveTarget(targetDesc.active);
    return zip_default(anchorTargets, activeTargets).flatMap(
      ([anchorTarget, activeTarget]) => {
        if (anchorTarget == null || activeTarget == null) {
          throw new Error(
            "AnchorTargets and activeTargets lengths don't match"
          );
        }
        switch (targetDesc.rangeType) {
          case "continuous":
            return this.processContinuousRangeTarget(
              anchorTarget,
              activeTarget,
              targetDesc
            );
          case "vertical":
            return targetsToVerticalTarget(
              anchorTarget,
              activeTarget,
              targetDesc.excludeAnchor,
              targetDesc.excludeActive
            );
        }
      }
    );
  }
  processContinuousRangeTarget(anchorTarget, activeTarget, { excludeAnchor, excludeActive, exclusionScopeType }) {
    if (exclusionScopeType == null) {
      return [
        targetsToContinuousTarget(
          anchorTarget,
          activeTarget,
          excludeAnchor,
          excludeActive
        )
      ];
    }
    const isReversed = calcIsReversed(anchorTarget, activeTarget);
    return [
      targetsToContinuousTarget(
        excludeAnchor ? getExcludedScope(
          this.modifierStageFactory,
          anchorTarget,
          exclusionScopeType,
          isReversed ? "backward" : "forward"
        ) : anchorTarget,
        excludeActive ? getExcludedScope(
          this.modifierStageFactory,
          activeTarget,
          exclusionScopeType,
          isReversed ? "forward" : "backward"
        ) : activeTarget,
        false,
        false
      )
    ];
  }
  /**
   * This function implements the modifier pipeline that is at the core of Cursorless target processing.
   * It proceeds as follows:
   *
   * 1. It begins by getting the output from the {@link markStage} (eg "air", "this", etc).
   * This output is a list of zero or more targets.
   * 2. It then constructs a pipeline from the modifiers on the {@link targetDescriptor}
   * 3. It then runs each pipeline stage in turn, feeding the first stage with
   * the list of targets output from the {@link markStage}.  For each pipeline
   * stage, it passes the targets from the previous stage to the pipeline stage
   * one by one.  For each target, the stage will output a list of zero or more output
   * targets.  It then concatenates all of these lists into the list of targets
   * that will be passed to the next pipeline stage.  This process is similar to
   * the way that [jq](https://stedolan.github.io/jq/) processes its inputs.
   *
   * @param targetDescriptor The description of the target, consisting of a mark
   * and zero or more modifiers
   * @returns The output of running the modifier pipeline on the output from the mark
   */
  processPrimitiveTarget(targetDescriptor) {
    let markStage;
    let targetModifierStages;
    let automaticTokenExpansionBefore = false;
    if (targetDescriptor.type === "implicit") {
      markStage = new ImplicitStage();
      targetModifierStages = [];
    } else {
      markStage = this.markStageFactory.create(targetDescriptor.mark);
      targetModifierStages = getModifierStagesFromTargetModifiers(
        this.modifierStageFactory,
        targetDescriptor.modifiers
      );
      automaticTokenExpansionBefore = doAutomaticTokenExpansionBefore(targetDescriptor);
    }
    const markOutputTargets = markStage.run();
    const [preStages, postStages] = this.getPreAndPostStages(
      automaticTokenExpansionBefore
    );
    const modifierStages = [
      ...preStages,
      ...targetModifierStages,
      ...this.opts.actionFinalStages,
      ...postStages
    ];
    return processModifierStages(modifierStages, markOutputTargets);
  }
  getPreAndPostStages(automaticTokenExpansionBefore) {
    if (this.opts.noAutomaticTokenExpansion) {
      return [[], []];
    }
    const stage = new ContainingTokenIfUntypedEmptyStage(
      this.modifierStageFactory
    );
    if (automaticTokenExpansionBefore) {
      return [[stage], []];
    }
    return [[], [stage]];
  }
};
function doAutomaticTokenExpansionBefore(targetDescriptor) {
  return targetDescriptor.modifiers.length > 0 && targetDescriptor.modifiers.every(
    ({ type: type2 }) => type2 === "startOf" || type2 === "endOf"
  );
}
function getModifierStagesFromTargetModifiers(modifierStageFactory, targetModifiers) {
  return targetModifiers.map(modifierStageFactory.create).reverse();
}
function processModifierStages(modifierStages, targets) {
  modifierStages.forEach((stage) => {
    const options2 = {
      multipleTargets: targets.length > 1
    };
    targets = targets.flatMap((target) => stage.run(target, options2));
  });
  return targets;
}
function getExcludedScope(modifierStageFactory, target, scopeType, direction2) {
  const options2 = {
    multipleTargets: false
  };
  return modifierStageFactory.create({
    type: "relativeScope",
    scopeType,
    direction: direction2,
    length: 1,
    offset: 1
  }).run(target, options2)[0];
}
function calcIsReversed(anchor, active) {
  if (anchor.contentRange.start.isAfter(active.contentRange.start)) {
    return true;
  }
  if (anchor.contentRange.start.isBefore(active.contentRange.start)) {
    return false;
  }
  return anchor.contentRange.end.isAfter(active.contentRange.end);
}
function uniqTargets(array) {
  return uniqWithHash(
    array,
    (a, b) => a.isEqual(b),
    (a) => a.contentRange.concise()
  );
}
function ensureSingleEditor2(anchorTarget, activeTarget) {
  if (anchorTarget.editor !== activeTarget.editor) {
    throw new Error("Cannot form range between targets in different editors");
  }
}
function targetsToContinuousTarget(anchorTarget, activeTarget, excludeAnchor = false, excludeActive = false) {
  ensureSingleEditor2(anchorTarget, activeTarget);
  const isReversed = calcIsReversed(anchorTarget, activeTarget);
  const startTarget = isReversed ? activeTarget : anchorTarget;
  const endTarget = isReversed ? anchorTarget : activeTarget;
  const excludeStart = isReversed ? excludeActive : excludeAnchor;
  const excludeEnd = isReversed ? excludeAnchor : excludeActive;
  return createContinuousRangeTarget(
    isReversed,
    startTarget,
    endTarget,
    !excludeStart,
    !excludeEnd
  );
}
function targetsToVerticalTarget(anchorTarget, activeTarget, excludeAnchor, excludeActive) {
  ensureSingleEditor2(anchorTarget, activeTarget);
  const isReversed = calcIsReversed(anchorTarget, activeTarget);
  const delta = isReversed ? -1 : 1;
  const anchorPosition = isReversed ? anchorTarget.contentRange.start : anchorTarget.contentRange.end;
  const anchorLine = anchorPosition.line + (excludeAnchor ? delta : 0);
  const activePosition = isReversed ? activeTarget.contentRange.start : activeTarget.contentRange.end;
  const activeLine = activePosition.line - (excludeActive ? delta : 0);
  const results = [];
  for (let i2 = anchorLine; true; i2 += delta) {
    const contentRange = new Range(
      i2,
      anchorTarget.contentRange.start.character,
      i2,
      anchorTarget.contentRange.end.character
    );
    results.push(
      new PlainTarget({
        editor: anchorTarget.editor,
        isReversed: anchorTarget.isReversed,
        contentRange,
        insertionDelimiter: anchorTarget.insertionDelimiter
      })
    );
    if (i2 === activeLine) {
      return results;
    }
  }
}

// ../cursorless-engine/src/processTargets/modifiers/HeadTailStage.ts
var HeadTailStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target) {
    const modifierStages = this.getModifierStages();
    const modifiedTargets = processModifierStages(modifierStages, [target]);
    const isHead = this.modifier.type === "extendThroughStartOf";
    return modifiedTargets.map((modifiedTarget) => {
      return new HeadTailTarget({
        editor: target.editor,
        isReversed: isHead,
        inputTarget: target,
        modifiedTarget,
        isHead
      });
    });
  }
  getModifierStages() {
    if (this.modifier.modifiers != null) {
      return getModifierStagesFromTargetModifiers(
        this.modifierStageFactory,
        this.modifier.modifiers
      );
    }
    return [new BoundedLineStage(this.modifierStageFactory, this.modifier)];
  }
};
var BoundedLineStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const line = this.getContainingLine(target, options2);
    const pairInterior = this.getContainingPairInterior(target, options2);
    const intersection = pairInterior != null ? line.contentRange.intersection(pairInterior.contentRange) : null;
    if (intersection == null || intersection.isEmpty) {
      return [line];
    }
    return [
      new PlainTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: intersection
      })
    ];
  }
  getContainingPairInterior(target, options2) {
    try {
      return this.getContaining(target, options2, {
        type: "surroundingPairInterior",
        delimiter: "any"
      })[0];
    } catch (error) {
      if (error instanceof NoContainingScopeError) {
        return void 0;
      }
      throw error;
    }
  }
  getContainingLine(target, options2) {
    return this.getContaining(target, options2, {
      type: "line"
    })[0];
  }
  getContaining(target, options2, scopeType) {
    return this.modifierStageFactory.create({ type: "containingScope", scopeType }).run(target, options2);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/listUtils.ts
var OutOfRangeError = class extends Error {
  constructor(scopeType, index) {
    const numberStr = index != null ? ` #${index + 1}` : "";
    super(`Scope '${scopeType.type}'${numberStr} is out of range`);
    this.name = "OutOfRangeError";
  }
};
function sliceStrict(scopeType, targets, startIndex, endIndex) {
  assertIndices(scopeType, targets, startIndex, endIndex);
  return targets.slice(startIndex, endIndex + 1);
}
function assertIndices(scopeType, targets, startIndex, endIndex) {
  if (startIndex < 0 || startIndex >= targets.length) {
    throw new OutOfRangeError(scopeType, startIndex);
  }
  if (endIndex < 0 || endIndex >= targets.length) {
    throw new OutOfRangeError(scopeType, endIndex);
  }
}

// ../cursorless-engine/src/processTargets/modifiers/InstanceStage.ts
var InstanceStage = class {
  constructor(modifierStageFactory, storedTargets, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.storedTargets = storedTargets;
    this.modifier = modifier;
  }
  run(inputTarget, options2) {
    const target = new ContainingTokenIfUntypedEmptyStage(
      this.modifierStageFactory
    ).run(inputTarget, options2)[0];
    switch (this.modifier.type) {
      case "everyScope":
        return this.handleEveryScope(target, options2);
      case "ordinalScope":
        return this.handleOrdinalScope(target, options2, this.modifier);
      case "relativeScope":
        return this.handleRelativeScope(target, options2, this.modifier);
      default:
        throw Error(`${this.modifier.type} instance scope not supported`);
    }
  }
  handleEveryScope(target, options2) {
    return Array.from(
      flatmap(
        this.getEveryRanges(target),
        ([editor, searchRange]) => this.getTargetIterable(target, options2, editor, searchRange, "forward")
      )
    );
  }
  handleOrdinalScope(target, options2, { start: start2, length, scopeType }) {
    return this.getEveryRanges(target).flatMap(
      ([editor, searchRange]) => takeFromOffset(
        scopeType,
        this.getTargetIterable(
          target,
          options2,
          editor,
          searchRange,
          start2 >= 0 ? "forward" : "backward"
        ),
        start2 >= 0 ? start2 : -(length + start2),
        length
      )
    );
  }
  handleRelativeScope(target, options2, { direction: direction2, offset, length, scopeType }) {
    const referenceTargets = this.storedTargets.get("instanceReference") ?? [
      target
    ];
    return referenceTargets.flatMap((referenceTarget) => {
      const { editor } = referenceTarget;
      const iterationRange = direction2 === "forward" ? new Range(
        offset === 0 ? referenceTarget.contentRange.start : referenceTarget.contentRange.end,
        editor.document.range.end
      ) : new Range(
        editor.document.range.start,
        offset === 0 ? referenceTarget.contentRange.end : referenceTarget.contentRange.start
      );
      return takeFromOffset(
        scopeType,
        this.getTargetIterable(
          target,
          options2,
          editor,
          iterationRange,
          direction2
        ),
        offset === 0 ? 0 : offset - 1,
        length
      );
    });
  }
  getEveryRanges({
    editor: targetEditor
  }) {
    return this.storedTargets.get("instanceReference")?.map(({ editor, contentRange }) => [editor, contentRange]) ?? [[targetEditor, targetEditor.document.range]];
  }
  getTargetIterable(target, options2, editor, searchRange, direction2) {
    const iterable = imap(
      generateMatchesInRange(
        new RegExp(escapeRegExp_default(target.contentText), "g"),
        editor,
        searchRange,
        direction2
      ),
      (range3) => new PlainTarget({
        contentRange: range3,
        editor,
        isReversed: false,
        textualType: "character"
      })
    );
    const filterScopeType = getFilterScopeType(target);
    if (filterScopeType != null) {
      const containingScopeModifier2 = this.modifierStageFactory.create({
        type: "containingScope",
        scopeType: filterScopeType
      });
      return ifilter(
        imap(iterable, (target2) => {
          try {
            const containingScope = containingScopeModifier2.run(
              target2,
              options2
            );
            if (containingScope.length === 1 && containingScope[0].contentRange.isRangeEqual(target2.contentRange)) {
              return containingScope[0];
            }
            return null;
          } catch (_err) {
            return null;
          }
        }),
        (target2) => target2 != null
      );
    }
    return iterable;
  }
};
function getFilterScopeType(target) {
  switch (target.textualType) {
    case "line":
    case "token":
    case "word":
      return { type: target.textualType };
    default:
      return null;
  }
}
function takeFromOffset(scopeType, iterable, offset, count2) {
  Array.from(itake(offset, iterable));
  const items = Array.from(itake(count2, iterable));
  if (items.length < count2) {
    throw new OutOfRangeError(scopeType, offset + count2 - 1);
  }
  return items;
}

// ../cursorless-engine/src/processTargets/modifiers/InteriorStage.ts
var InteriorOnlyStage = class {
  constructor(modifierHandlerFactory, modifier) {
    this.modifierHandlerFactory = modifierHandlerFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const interior = target.getInterior();
    if (interior != null) {
      return interior;
    }
    const containingModifier = this.modifierHandlerFactory.create({
      type: "containingScope",
      scopeType: {
        type: "interior",
        explicitScopeType: target.hasExplicitScopeType
      }
    });
    return containingModifier.run(target, options2);
  }
};
var ExcludeInteriorStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
    this.containingSurroundingPairIfNoBoundaryStage = getContainingSurroundingPairIfNoBoundaryStage(this.modifierStageFactory);
  }
  run(target, options2) {
    return this.containingSurroundingPairIfNoBoundaryStage.run(target, options2).flatMap((target2) => target2.getBoundary());
  }
};
function getContainingSurroundingPairIfNoBoundaryStage(modifierStageFactory) {
  return new ModifyIfConditionStage(
    modifierStageFactory,
    {
      type: "containingScope",
      scopeType: { type: "surroundingPair", delimiter: "any" }
    },
    (target) => target.getBoundary() == null
  );
}

// ../cursorless-engine/src/processTargets/modifiers/commonContainingScopeIfUntypedModifiers.ts
var containingLineIfUntypedModifier = {
  type: "modifyIfUntyped",
  modifier: {
    type: "containingScope",
    scopeType: { type: "line" }
  }
};
var containingTokenIfUntypedModifier = {
  type: "modifyIfUntyped",
  modifier: {
    type: "containingScope",
    scopeType: { type: "token" }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/LeadingTrailingStages.ts
var NoDelimiterError = class extends Error {
  constructor(type2) {
    super(`Target has no ${type2} delimiter.`);
    this.name = "NoDelimiterError";
  }
};
var LeadingStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    return this.modifierStageFactory.create(containingTokenIfUntypedModifier).run(target, options2).map((target2) => {
      const leading = target2.getLeadingDelimiterTarget();
      if (leading == null) {
        throw new NoDelimiterError("leading");
      }
      return leading;
    });
  }
};
var TrailingStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    return this.modifierStageFactory.create(containingTokenIfUntypedModifier).run(target, options2).map((target2) => {
      const trailing = target2.getTrailingDelimiterTarget();
      if (trailing == null) {
        throw new NoDelimiterError("trailing");
      }
      return trailing;
    });
  }
};

// ../cursorless-engine/src/processTargets/modifiers/targetSequenceUtils.ts
function createRangeTargetFromIndices(scopeType, isReversed, targets, startIndex, endIndex) {
  assertIndices(scopeType, targets, startIndex, endIndex);
  if (startIndex === endIndex) {
    return targets[startIndex];
  }
  return createContinuousRangeTarget(
    isReversed,
    targets[startIndex],
    targets[endIndex],
    true,
    true
  );
}
function getEveryScopeTargets(modifierStageFactory, target, options2, scopeType) {
  const containingStage = modifierStageFactory.create({
    type: "everyScope",
    scopeType
  });
  return containingStage.run(target, options2);
}

// ../cursorless-engine/src/processTargets/modifiers/OrdinalScopeStage.ts
var OrdinalScopeStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const targets = getEveryScopeTargets(
      this.modifierStageFactory,
      target,
      options2,
      this.modifier.scopeType
    );
    const startIndex = this.modifier.start + (this.modifier.start < 0 ? targets.length : 0);
    const endIndex = startIndex + this.modifier.length - 1;
    if (this.modifier.isEvery) {
      return sliceStrict(
        this.modifier.scopeType,
        targets,
        startIndex,
        endIndex
      );
    }
    return [
      createRangeTargetFromIndices(
        this.modifier.scopeType,
        target.isReversed,
        targets,
        startIndex,
        endIndex
      )
    ];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/PositionStage.ts
var PositionStage = class {
  run(target) {
    const parameters = {
      editor: target.editor,
      isReversed: target.isReversed,
      contentRange: this.getContentRange(target.contentRange)
    };
    return [
      target.isRaw ? new RawSelectionTarget(parameters) : new PlainTarget({ ...parameters, textualType: "character" })
    ];
  }
};
var StartOfStage = class extends PositionStage {
  getContentRange(contentRange) {
    return contentRange.start.toEmptyRange();
  }
};
var EndOfStage = class extends PositionStage {
  getContentRange(contentRange) {
    return contentRange.end.toEmptyRange();
  }
};

// ../cursorless-engine/src/processTargets/modifiers/PreferredScopeStage.ts
var PreferredScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target) {
    const { scopeType } = this.modifier;
    const containingScopeStage = new ContainingScopeStage(
      this.modifierStageFactory,
      this.scopeHandlerFactory,
      { type: "containingScope", scopeType }
    );
    try {
      return containingScopeStage.run(target);
    } catch (ex) {
      if (!(ex instanceof NoContainingScopeError)) {
        throw ex;
      }
    }
    const scopeHandler = this.scopeHandlerFactory.create(
      this.modifier.scopeType,
      target.editor.document.languageId
    );
    const closestTargets = getClosestScopeTargets(target, scopeHandler);
    if (closestTargets == null) {
      throw Error(`No scopes found for scope type: ${scopeType.type}`);
    }
    return closestTargets;
  }
};
function getClosestScopeTargets(target, scopeHandler) {
  const previousScopes = scopeHandler.generateScopes(
    target.editor,
    target.contentRange.start,
    "backward"
  );
  const nextScopes = scopeHandler.generateScopes(
    target.editor,
    target.contentRange.end,
    "forward"
  );
  const { active } = target.contentSelection;
  const previousScope = getClosestScope(previousScopes, active);
  const nextScope = getClosestScope(nextScopes, active);
  const preferredScope = previousScope.distance < nextScope.distance ? previousScope.scope : nextScope.scope;
  return preferredScope != null ? preferredScope.getTargets(target.isReversed) : void 0;
}
function getClosestScope(scopes, position) {
  let closestScope;
  let closestDistance = Infinity;
  for (const scope of scopes) {
    const distance = Math.min(
      distanceBetweenPositions(position, scope.domain.start),
      distanceBetweenPositions(position, scope.domain.end)
    );
    if (distance < closestDistance) {
      closestScope = scope;
      closestDistance = distance;
    } else {
      break;
    }
  }
  return { scope: closestScope, distance: closestDistance };
}
function distanceBetweenPositions(a, b) {
  return (
    // 10000 is arbitrary to always pick same-line occurrences first
    Math.abs(a.line - b.line) * 1e4 + Math.abs(a.character - b.character)
  );
}

// ../cursorless-engine/src/processTargets/modifiers/RangeModifierStage.ts
var RangeModifierStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const anchorStage = this.modifierStageFactory.create(this.modifier.anchor);
    const activeStage = this.modifierStageFactory.create(this.modifier.active);
    const anchorTargets = anchorStage.run(target, options2);
    const activeTargets = activeStage.run(target, options2);
    if (anchorTargets.length !== 1 || activeTargets.length !== 1) {
      throw new Error("Expected single anchor and active target");
    }
    return [
      targetsToContinuousTarget(
        anchorTargets[0],
        activeTargets[0],
        this.modifier.excludeAnchor,
        this.modifier.excludeActive
      )
    ];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/RawSelectionStage.ts
var RawSelectionStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return [
      new RawSelectionTarget({
        editor: target.editor,
        contentRange: target.contentRange,
        isReversed: target.isReversed
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/TooFewScopesError.ts
var TooFewScopesError = class extends Error {
  constructor(requestedLength, currentLength, scopeType) {
    super(
      `Requested ${requestedLength} ${scopeType}s, but ${currentLength} are already selected.`
    );
    this.name = "TooFewScopesError";
  }
};

// ../cursorless-engine/src/processTargets/modifiers/relativeScopeLegacy.ts
function runLegacy(modifierStageFactory, modifier, target, options2) {
  const targets = getEveryScopeTargets(
    modifierStageFactory,
    createTargetWithoutExplicitRange(target),
    options2,
    modifier.scopeType
  );
  const containingIndices = getContainingIndices(target.contentRange, targets);
  return calculateIndicesAndCreateTarget(
    modifier,
    target,
    targets,
    containingIndices
  );
}
function calculateIndicesAndCreateTarget(modifier, target, targets, containingIndices) {
  const isForward = modifier.direction === "forward";
  const proximalIndex = computeProximalIndex(
    modifier,
    target.contentRange,
    targets,
    isForward,
    containingIndices
  );
  const distalIndex = isForward ? proximalIndex + modifier.length - 1 : proximalIndex - modifier.length + 1;
  const startIndex = Math.min(proximalIndex, distalIndex);
  const endIndex = Math.max(proximalIndex, distalIndex);
  return [
    createRangeTargetFromIndices(
      modifier.scopeType,
      target.isReversed,
      targets,
      startIndex,
      endIndex
    )
  ];
}
function computeProximalIndex(modifier, inputTargetRange, targets, isForward, containingIndices) {
  const includeIntersectingScopes = modifier.offset === 0;
  if (containingIndices == null) {
    const adjacentTargetIndex = isForward ? targets.findIndex(
      (t) => t.contentRange.start.isAfter(inputTargetRange.start)
    ) : findLastIndex_default(
      targets,
      (t) => t.contentRange.start.isBefore(inputTargetRange.start)
    );
    if (adjacentTargetIndex === -1) {
      throw new OutOfRangeError(modifier.scopeType);
    }
    if (includeIntersectingScopes) {
      return adjacentTargetIndex;
    }
    return isForward ? adjacentTargetIndex + modifier.offset - 1 : adjacentTargetIndex - modifier.offset + 1;
  }
  const intersectingStartIndex = containingIndices.start;
  const intersectingEndIndex = containingIndices.end;
  if (includeIntersectingScopes) {
    const intersectingLength = intersectingEndIndex - intersectingStartIndex + 1;
    if (intersectingLength > modifier.length) {
      throw new TooFewScopesError(
        modifier.length,
        intersectingLength,
        modifier.scopeType.type
      );
    }
    return isForward ? intersectingStartIndex : intersectingEndIndex;
  }
  return isForward ? intersectingEndIndex + modifier.offset : intersectingStartIndex - modifier.offset;
}
function getContainingIndices(inputTargetRange, targets) {
  const targetsWithIntersection = targets.map((t, i2) => ({
    index: i2,
    intersection: t.contentRange.intersection(inputTargetRange)
  })).filter((t) => t.intersection != null);
  if (inputTargetRange.isEmpty) {
    if (targetsWithIntersection.length === 0) {
      return void 0;
    }
    const index = targetsWithIntersection.at(-1).index;
    return { start: index, end: index };
  }
  const targetsWithNonEmptyIntersection = targetsWithIntersection.filter((t) => !t.intersection.isEmpty).map((t) => t.index);
  if (targetsWithNonEmptyIntersection.length === 0) {
    return void 0;
  }
  return {
    start: targetsWithNonEmptyIntersection[0],
    end: targetsWithNonEmptyIntersection.at(-1)
  };
}
function createTargetWithoutExplicitRange(target) {
  return new UntypedTarget({
    editor: target.editor,
    isReversed: target.isReversed,
    contentRange: target.contentRange,
    hasExplicitRange: false
  });
}

// ../cursorless-engine/src/processTargets/modifiers/RelativeScopeStage.ts
var RelativeScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target, options2) {
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      this.modifier.scopeType,
      target.editor.document.languageId
    );
    if (scopeHandler == null) {
      return runLegacy(
        this.modifierStageFactory,
        this.modifier,
        target,
        options2
      );
    }
    const scopes = Array.from(
      this.modifier.offset === 0 ? generateScopesInclusive(scopeHandler, target, this.modifier) : generateScopesExclusive(scopeHandler, target, this.modifier)
    );
    if (scopes.length < this.modifier.length) {
      throw new OutOfRangeError(
        this.modifier.scopeType,
        this.modifier.offset + this.modifier.length - 1
      );
    }
    const { isReversed } = target;
    if (this.modifier.isEvery) {
      return scopes.flatMap((scope) => scope.getTargets(isReversed));
    }
    return constructScopeRangeTarget(
      isReversed,
      scopes[0],
      scopes[scopes.length - 1]
    );
  }
};
function generateScopesInclusive(scopeHandler, target, modifier) {
  const { editor, contentRange } = target;
  const { length: desiredScopeCount, direction: direction2 } = modifier;
  const initialRange = getPreferredScopeTouchingPosition(
    scopeHandler,
    editor,
    direction2 === "forward" ? contentRange.start : contentRange.end,
    direction2
  )?.domain;
  if (initialRange == null) {
    throw new NoContainingScopeError(modifier.scopeType.type);
  }
  return itake(
    desiredScopeCount,
    scopeHandler.generateScopes(
      editor,
      direction2 === "forward" ? initialRange.start : initialRange.end,
      direction2,
      {
        skipAncestorScopes: true
      }
    )
  );
}
function generateScopesExclusive(scopeHandler, target, modifier) {
  const { editor, contentRange: inputRange } = target;
  const { length: desiredScopeCount, direction: direction2, offset } = modifier;
  const initialPosition = direction2 === "forward" ? inputRange.end : inputRange.start;
  const containment = inputRange.isEmpty ? "disallowed" : "disallowedIfStrict";
  return islice(
    scopeHandler.generateScopes(editor, initialPosition, direction2, {
      containment,
      skipAncestorScopes: true
    }),
    offset - 1,
    offset + desiredScopeCount - 1
  );
}

// ../cursorless-engine/src/processTargets/modifiers/VisibleStage.ts
var VisibleStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return target.editor.visibleRanges.map(
      (range3) => new PlainTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: range3
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/ModifierStageFactoryImpl.ts
var ModifierStageFactoryImpl = class {
  constructor(languageDefinitions, storedTargets, scopeHandlerFactory) {
    this.languageDefinitions = languageDefinitions;
    this.storedTargets = storedTargets;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.create = this.create.bind(this);
  }
  create(modifier) {
    switch (modifier.type) {
      case "startOf":
        return new StartOfStage();
      case "endOf":
        return new EndOfStage();
      case "extendThroughStartOf":
      case "extendThroughEndOf":
        return new HeadTailStage(this, modifier);
      case "toRawSelection":
        return new RawSelectionStage(modifier);
      case "interiorOnly":
        return new InteriorOnlyStage(this, modifier);
      case "excludeInterior":
        return new ExcludeInteriorStage(this, modifier);
      case "leading":
        return new LeadingStage(this, modifier);
      case "trailing":
        return new TrailingStage(this, modifier);
      case "visible":
        return new VisibleStage(modifier);
      case "containingScope":
        return new ContainingScopeStage(
          this,
          this.scopeHandlerFactory,
          modifier
        );
      case "preferredScope":
        return new PreferredScopeStage(
          this,
          this.scopeHandlerFactory,
          modifier
        );
      case "everyScope":
        if (modifier.scopeType.type === "instance") {
          return new InstanceStage(this, this.storedTargets, modifier);
        }
        return new EveryScopeStage(this, this.scopeHandlerFactory, modifier);
      case "ordinalScope":
        if (modifier.scopeType.type === "instance") {
          return new InstanceStage(this, this.storedTargets, modifier);
        }
        return new OrdinalScopeStage(this, modifier);
      case "relativeScope":
        if (modifier.scopeType.type === "instance") {
          return new InstanceStage(this, this.storedTargets, modifier);
        }
        return new RelativeScopeStage(this, this.scopeHandlerFactory, modifier);
      case "keepContentFilter":
        return new KeepContentFilterStage(modifier);
      case "keepEmptyFilter":
        return new KeepEmptyFilterStage(modifier);
      case "cascading":
        return new CascadingStage(this, modifier);
      case "modifyIfUntyped":
        return new ModifyIfUntypedStage(this, modifier);
      case "range":
        return new RangeModifierStage(this, modifier);
      case "inferPreviousMark":
        throw Error(
          `Unexpected modifier '${modifier.type}'; it should have been removed during inference`
        );
      default: {
        const _exhaustiveCheck = modifier;
        const { type: type2 } = modifier;
        throw new Error(`Unknown modifier: ${type2}`);
      }
    }
  }
};

// ../cursorless-engine/src/util/performDocumentEdits.ts
async function performDocumentEdits(rangeUpdater, editor, edits) {
  const deregister = rangeUpdater.registerReplaceEditList(
    editor.document,
    edits.filter((edit) => edit.isReplace)
  );
  const wereEditsApplied = await editor.edit(edits);
  deregister();
  return wereEditsApplied;
}

// ../cursorless-engine/src/core/updateSelections/updateSelections.ts
async function performEditsAndUpdateSelections({
  rangeUpdater,
  editor,
  selections,
  preserveCursorSelections: preserveEditorSelections,
  ...rest
}) {
  const keys2 = unsafeKeys(selections);
  const selectionInfos = keys2.map((key) => {
    const selectionValue = selections[key];
    const selectionsWithBehavior = getSelectionsWithBehavior(selectionValue);
    return getFullSelectionInfos(
      editor.document,
      selectionsWithBehavior.selections,
      selectionsWithBehavior.behavior
    );
  });
  if (!preserveEditorSelections) {
    selectionInfos.push(
      getFullSelectionInfos(
        editor.document,
        editor.selections,
        1 /* closedClosed */
      )
    );
  }
  const updatedSelectionsMatrix = await (() => {
    if ("edits" in rest) {
      return performEditsAndUpdateFullSelectionInfos(
        rangeUpdater,
        editor,
        rest.edits,
        selectionInfos
      );
    }
    return callFunctionAndUpdateFullSelectionInfos(
      rangeUpdater,
      rest.callback,
      editor.document,
      selectionInfos
    );
  })();
  if (!preserveEditorSelections) {
    await editor.setSelections(updatedSelectionsMatrix.pop());
  }
  const result = Object.fromEntries(
    keys2.map((key, index) => [key, updatedSelectionsMatrix[index]])
  );
  return result;
}
function getFullSelectionInfos(document2, selections, rangeBehavior) {
  return selections.map(
    (selection) => getSelectionInfoInternal(
      document2,
      selection,
      selection instanceof Selection ? !selection.isReversed : true,
      rangeBehavior
    )
  );
}
function getSelectionsWithBehavior(selections) {
  if ("selections" in selections) {
    return selections;
  }
  return {
    selections,
    behavior: 1 /* closedClosed */
  };
}
function getSelectionInfoInternal(document2, range3, isForward, rangeBehavior) {
  return {
    range: range3,
    isForward,
    expansionBehavior: {
      start: {
        type: rangeBehavior === 1 /* closedClosed */ || rangeBehavior === 3 /* closedOpen */ ? "closed" : "open"
      },
      end: {
        type: rangeBehavior === 1 /* closedClosed */ || rangeBehavior === 2 /* openClosed */ ? "closed" : "open"
      }
    },
    offsets: {
      start: document2.offsetAt(range3.start),
      end: document2.offsetAt(range3.end)
    },
    text: document2.getText(range3)
  };
}
function selectionInfosToSelections(selectionInfoMatrix) {
  return selectionInfoMatrix.map(
    (selectionInfos) => selectionInfos.map(
      ({ range: { start: start2, end }, isForward }) => isForward ? new Selection(start2, end) : new Selection(end, start2)
    )
  );
}
async function callFunctionAndUpdateFullSelectionInfos(rangeUpdater, func2, document2, originalSelectionInfos) {
  const unsubscribe = rangeUpdater.registerRangeInfoList(
    document2,
    flatten_default(originalSelectionInfos)
  );
  await func2();
  unsubscribe();
  return selectionInfosToSelections(originalSelectionInfos);
}
async function performEditsAndUpdateFullSelectionInfos(rangeUpdater, editor, edits, originalSelectionInfos) {
  const func2 = async () => {
    const wereEditsApplied = await performDocumentEdits(
      rangeUpdater,
      editor,
      edits
    );
    if (!wereEditsApplied) {
      throw new Error("Could not apply edits");
    }
  };
  return await callFunctionAndUpdateFullSelectionInfos(
    rangeUpdater,
    func2,
    editor.document,
    originalSelectionInfos
  );
}

// ../cursorless-engine/src/actions/BreakLine.ts
var BreakLine = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const thatSelections = flatten_default(
      await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
        const contentRanges = targets2.map(({ contentRange }) => contentRange);
        const edits = getEdits(editor, contentRanges);
        const editableEditor = ide().getEditableTextEditor(editor);
        const { contentRanges: updatedRanges } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: editableEditor,
          edits,
          selections: {
            contentRanges
          }
        });
        return zip_default(targets2, updatedRanges).map(([target, range3]) => ({
          editor: target.editor,
          selection: range3.toSelection(target.isReversed)
        }));
      })
    );
    return { thatSelections };
  }
};
function getEdits(editor, contentRanges) {
  const { document: document2 } = editor;
  const edits = [];
  for (const range3 of contentRanges) {
    const position = range3.start;
    const line = document2.lineAt(position);
    const indentation = line.text.slice(
      0,
      line.rangeTrimmed?.start?.character ?? line.range.start.character
    );
    const characterTrailingWhitespace = line.text.slice(0, position.character).search(/\s+$/);
    const replacementRange = characterTrailingWhitespace > -1 ? new Range(
      new Position(line.lineNumber, characterTrailingWhitespace),
      position
    ) : position.toEmptyRange();
    edits.push({
      range: replacementRange,
      text: "\n" + indentation,
      isReplace: !replacementRange.isEmpty
    });
  }
  return edits;
}

// ../cursorless-engine/src/util/unifyRanges.ts
function unifyRemovalTargets(targets) {
  if (targets.length < 2) {
    return targets;
  }
  return groupTargetsForEachEditor(targets).flatMap(([_editor, targets2]) => {
    if (targets2.length < 2) {
      return targets2;
    }
    let results = [...targets2];
    results.sort(
      (a, b) => a.contentRange.start.compareTo(b.contentRange.start)
    );
    let run2 = true;
    while (run2) {
      [results, run2] = unifyTargetsOnePass(results);
    }
    return results;
  });
}
function unifyTargetsOnePass(targets) {
  if (targets.length < 2) {
    return [targets, false];
  }
  const results = [];
  let currentGroup = [];
  targets.forEach((target) => {
    if (currentGroup.length && !intersects(currentGroup[currentGroup.length - 1], target)) {
      results.push(mergeTargets(currentGroup));
      currentGroup = [target];
    } else {
      currentGroup.push(target);
    }
  });
  results.push(mergeTargets(currentGroup));
  return [results, results.length !== targets.length];
}
function mergeTargets(targets) {
  if (targets.length === 1) {
    return targets[0];
  }
  const first = targets[0];
  const last2 = targets[targets.length - 1];
  return targetsToContinuousTarget(first, last2);
}
function intersects(targetA, targetB) {
  return !!targetA.getRemovalRange().intersection(targetB.getRemovalRange());
}

// ../cursorless-engine/src/actions/BringMoveSwap.ts
var BringMoveSwap = class {
  constructor(rangeUpdater, type2) {
    this.rangeUpdater = rangeUpdater;
    this.type = type2;
  }
  async decorateTargets(sources, destinations) {
    await Promise.all([
      flashTargets(
        ide(),
        sources,
        this.decoration.sourceStyle,
        this.decoration.getSourceRangeCallback
      ),
      flashTargets(ide(), destinations, this.decoration.destinationStyle)
    ]);
  }
  getEditsBringMove(sources, destinations) {
    const usedSources = [];
    const results = [];
    const shouldJoinSources = sources.length !== destinations.length && destinations.length === 1;
    sources.forEach((source, i2) => {
      let destination = destinations[i2];
      if ((source == null || destination == null) && !shouldJoinSources) {
        throw new Error("Targets must have same number of args");
      }
      if (destination != null) {
        let text;
        if (shouldJoinSources) {
          text = sources.map((source2, i3) => {
            const text2 = source2.contentText;
            const delimiter = (destination.isRaw ? null : destination.insertionDelimiter) ?? (source2.isRaw ? null : source2.insertionDelimiter);
            return i3 > 0 && delimiter != null ? delimiter + text2 : text2;
          }).join("");
        } else {
          text = source.contentText;
        }
        results.push({
          edit: destination.constructChangeEdit(text),
          editor: destination.editor,
          originalTarget: destination.target,
          isSource: false
        });
      } else {
        destination = destinations[0];
      }
      if (!usedSources.includes(source)) {
        usedSources.push(source);
        if (this.type === "bring") {
          results.push({
            edit: source.toDestination("to").constructChangeEdit(destination.target.contentText),
            editor: source.editor,
            originalTarget: source,
            isSource: true
          });
        }
      }
    });
    if (this.type === "move") {
      unifyRemovalTargets(usedSources).forEach((source) => {
        results.push({
          edit: source.constructRemovalEdit(),
          editor: source.editor,
          originalTarget: source,
          isSource: true
        });
      });
    }
    return results;
  }
  async performEditsAndComputeThatMark(edits) {
    return flatten_default(
      await runForEachEditor(
        edits,
        (edit) => edit.editor,
        async (editor, edits2) => {
          const filteredEdits = this.type !== "bring" ? edits2 : edits2.filter(({ isSource }) => !isSource);
          const sourceEdits = this.type === "swap" ? [] : edits2.filter(({ isSource }) => isSource);
          const destinationEdits = this.type === "swap" ? edits2 : edits2.filter(({ isSource }) => !isSource);
          const sourceEditRanges = sourceEdits.map(({ edit }) => edit.range);
          const destinationEditRanges = destinationEdits.map(
            ({ edit }) => edit.range
          );
          const editableEditor = ide().getEditableTextEditor(editor);
          const {
            sourceEditRanges: updatedSourceEditRanges,
            destinationEditRanges: updatedDestinationEditRanges
          } = await performEditsAndUpdateSelections({
            rangeUpdater: this.rangeUpdater,
            editor: editableEditor,
            edits: filteredEdits.map(({ edit }) => edit),
            selections: {
              // Sources should be closedClosed, because they should be logically
              // the same as the original source.
              sourceEditRanges,
              // Destinations should be openOpen, because they should grow to contain
              // the new text.
              destinationEditRanges: {
                selections: destinationEditRanges,
                behavior: 0 /* openOpen */
              }
            }
          });
          const marks2 = [
            ...this.getMarks(sourceEdits, updatedSourceEditRanges),
            ...this.getMarks(destinationEdits, updatedDestinationEditRanges)
          ];
          marks2.sort(
            (a, b) => edits2.findIndex((e) => e.originalTarget === a.target) - edits2.findIndex((e) => e.originalTarget === b.target)
          );
          return marks2;
        }
      )
    );
  }
  getMarks(edits, ranges) {
    return edits.map((edit, index) => {
      const originalRange = ranges[index];
      const range3 = edit.edit.updateRange(originalRange);
      const target = edit.originalTarget;
      return {
        editor: edit.editor,
        selection: range3.toSelection(target.isReversed),
        isSource: edit.isSource,
        target
      };
    });
  }
  async decorateThatMark(thatMark) {
    const getRange = (target) => {
      return toGeneralizedRange(
        target,
        thatMark.find((t) => t.target === target).selection
      );
    };
    return Promise.all([
      flashTargets(
        ide(),
        thatMark.filter(({ isSource }) => isSource).map(({ target }) => target),
        this.decoration.sourceStyle,
        getRange
      ),
      flashTargets(
        ide(),
        thatMark.filter(({ isSource }) => !isSource).map(({ target }) => target),
        this.decoration.destinationStyle,
        getRange
      )
    ]);
  }
  calculateMarksBringMove(markEntries) {
    return {
      thatMark: markEntries.filter(({ isSource }) => !isSource),
      sourceMark: markEntries.filter(({ isSource }) => isSource)
    };
  }
};
function broadcastSource(sources, destinations) {
  if (sources.length === 1) {
    return Array(destinations.length).fill(sources[0]);
  }
  return sources;
}
var Bring = class extends BringMoveSwap {
  constructor(rangeUpdater) {
    super(rangeUpdater, "bring");
    this.decoration = {
      sourceStyle: "referenced" /* referenced */,
      destinationStyle: "pendingModification0" /* pendingModification0 */
    };
    this.run = this.run.bind(this);
  }
  async run(sources, destinations) {
    sources = broadcastSource(sources, destinations);
    await this.decorateTargets(
      sources,
      destinations.map((d) => d.target)
    );
    const edits = this.getEditsBringMove(sources, destinations);
    const markEntries = await this.performEditsAndComputeThatMark(edits);
    const { thatMark, sourceMark } = this.calculateMarksBringMove(markEntries);
    await this.decorateThatMark(thatMark);
    return { thatSelections: thatMark, sourceSelections: sourceMark };
  }
};
var Move = class extends BringMoveSwap {
  constructor(rangeUpdater) {
    super(rangeUpdater, "move");
    this.decoration = {
      sourceStyle: "pendingDelete" /* pendingDelete */,
      destinationStyle: "pendingModification0" /* pendingModification0 */,
      getSourceRangeCallback: getRemovalHighlightRange
    };
    this.run = this.run.bind(this);
  }
  async run(sources, destinations) {
    sources = broadcastSource(sources, destinations);
    await this.decorateTargets(
      sources,
      destinations.map((d) => d.target)
    );
    const edits = this.getEditsBringMove(sources, destinations);
    const markEntries = await this.performEditsAndComputeThatMark(edits);
    const { thatMark, sourceMark } = this.calculateMarksBringMove(markEntries);
    await this.decorateThatMark(thatMark);
    return { thatSelections: thatMark, sourceSelections: sourceMark };
  }
};
var Swap = class extends BringMoveSwap {
  constructor(rangeUpdater) {
    super(rangeUpdater, "swap");
    this.decoration = {
      sourceStyle: "pendingModification1" /* pendingModification1 */,
      destinationStyle: "pendingModification0" /* pendingModification0 */
    };
    this.run = this.run.bind(this);
  }
  async run(targets1, targets2) {
    await this.decorateTargets(targets1, targets2);
    const edits = this.getEditsSwap(targets1, targets2);
    const markEntries = await this.performEditsAndComputeThatMark(edits);
    await this.decorateThatMark(markEntries);
    return { thatSelections: markEntries, sourceSelections: [] };
  }
  getEditsSwap(targets1, targets2) {
    const results = [];
    targets1.forEach((target1, i2) => {
      const target2 = targets2[i2];
      if (target1 == null || target2 == null) {
        throw new Error("Targets must have same number of args");
      }
      results.push({
        edit: target2.toDestination("to").constructChangeEdit(target1.contentText),
        editor: target2.editor,
        originalTarget: target2,
        isSource: false
      });
      results.push({
        edit: target1.toDestination("to").constructChangeEdit(target2.contentText),
        editor: target1.editor,
        originalTarget: target1,
        isSource: true
      });
    });
    return results;
  }
};
function getRemovalHighlightRange(target) {
  return target.getRemovalHighlightRange();
}

// ../cursorless-engine/src/actions/Call.ts
var Call = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(callees, args2) {
    ensureSingleTarget(callees);
    const { returnValue: texts } = await this.actions.getText.run(callees, {
      showDecorations: false
    });
    const { thatSelections: thatMark } = await this.actions.wrapWithPairedDelimiter.run(args2, texts[0] + "(", ")");
    return { thatSelections: thatMark };
  }
};

// ../cursorless-engine/src/actions/Clear.ts
var Clear = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const editor = ensureSingleEditor(targets);
    const plainTargets = targets.map(
      (target) => new PlainTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: target.contentRange
      })
    );
    const { thatTargets } = await this.actions.remove.run(plainTargets);
    if (thatTargets != null) {
      await ide().getEditableTextEditor(editor).setSelections(
        thatTargets.map(({ contentSelection }) => contentSelection),
        { focusEditor: true }
      );
    }
    return { thatTargets };
  }
};

// ../cursorless-engine/src/core/commandRunner/selectionToStoredTarget.ts
var selectionToStoredTarget = (selection) => new UntypedTarget({
  editor: selection.editor,
  isReversed: selection.selection.isReversed,
  contentRange: selection.selection,
  hasExplicitRange: true
});

// ../cursorless-engine/src/actions/CallbackAction.ts
var CallbackAction = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets, options2) {
    if (options2.showDecorations) {
      await flashTargets(ide(), targets, "referenced" /* referenced */);
    }
    if (options2.ensureSingleEditor) {
      ensureSingleEditor(targets);
    }
    if (options2.ensureSingleTarget) {
      ensureSingleTarget(targets);
    }
    const originalEditor = ide().activeEditableTextEditor;
    const runOnTargets = options2.setSelection ? runOnTargetsForEachEditorSequentially : runOnTargetsForEachEditor;
    const thatTargets = flatten_default(
      await runOnTargets(
        targets,
        (editor, targets2) => this.runForEditor(options2, editor, targets2)
      )
    );
    if (options2.setSelection && options2.restoreSelection && originalEditor != null && !originalEditor.isActive) {
      await originalEditor.focus();
    }
    return { thatTargets };
  }
  async runForEditor(options2, editor, targets) {
    const editableEditor = ide().getEditableTextEditor(editor);
    const originalSelections = editor.selections;
    const originalEditorVersion = editor.document.version;
    const targetSelections = targets.map((target) => target.contentSelection);
    if (options2.setSelection) {
      await editableEditor.setSelections(targetSelections, {
        focusEditor: true,
        revealRange: false
      });
    }
    const {
      originalSelections: updatedOriginalSelections,
      targetSelections: updatedTargetSelections
    } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: editableEditor,
      callback: () => options2.callback(editableEditor, targets),
      preserveCursorSelections: true,
      selections: {
        originalSelections,
        targetSelections
      }
    });
    if (options2.setSelection && options2.restoreSelection) {
      await editableEditor.setSelections(updatedOriginalSelections);
    }
    return editor.document.version === originalEditorVersion ? targets : updatedTargetSelections.map(
      (selection) => selectionToStoredTarget({
        editor,
        selection
      })
    );
  }
};

// ../cursorless-engine/src/actions/SimpleIdeCommandActions.ts
var SimpleIdeCommandAction = class {
  constructor(rangeUpdater) {
    this.ensureSingleEditor = false;
    this.ensureSingleTarget = false;
    this.restoreSelection = true;
    this.showDecorations = true;
    this.callbackAction = new CallbackAction(rangeUpdater);
    this.run = this.run.bind(this);
  }
  async run(targets, { showDecorations } = {}) {
    const capabilities = ide().capabilities.commands[this.command];
    if (capabilities == null) {
      throw Error(`Action ${this.command} is not supported by your ide`);
    }
    const { acceptsLocation } = capabilities;
    return this.callbackAction.run(targets, {
      callback: (editor, targets2) => callback(
        editor,
        acceptsLocation ? targets2.map((t) => t.contentRange) : void 0,
        this.command
      ),
      setSelection: !acceptsLocation,
      ensureSingleEditor: this.ensureSingleEditor,
      ensureSingleTarget: this.ensureSingleTarget,
      restoreSelection: this.restoreSelection,
      showDecorations: showDecorations ?? this.showDecorations
    });
  }
};
var CopyToClipboardSimple = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "clipboardCopy";
    this.ensureSingleEditor = true;
  }
};
var ToggleLineComment = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "toggleLineComment";
  }
};
var IndentLineSimpleAction = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "indentLine";
  }
};
var OutdentLineSimpleAction = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "outdentLine";
  }
};
var Fold = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "fold";
  }
};
var Unfold = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "unfold";
  }
};
var Rename = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "rename";
    this.ensureSingleTarget = true;
  }
};
var ShowReferences = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "showReferences";
    this.ensureSingleTarget = true;
  }
};
var ShowQuickFix = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "quickFix";
    this.ensureSingleTarget = true;
  }
};
var RevealDefinition = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "revealDefinition";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
var RevealTypeDefinition = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "revealTypeDefinition";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
var ShowHover = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "showHover";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
var ShowDebugHover = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "showDebugHover";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
var ExtractVariable = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "extractVariable";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
var GitAccept = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "gitAccept";
    this.ensureSingleTarget = true;
  }
};
var GitRevert = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "gitRevert";
    this.ensureSingleTarget = true;
  }
};
var GitStage = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "gitStage";
    this.ensureSingleTarget = true;
  }
};
var GitUnstage = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "gitUnstage";
    this.ensureSingleTarget = true;
  }
};
function callback(editor, ranges, command) {
  switch (command) {
    // Multi target actions
    case "toggleLineComment":
      return editor.toggleLineComment(ranges);
    case "indentLine":
      return editor.indentLine(ranges);
    case "outdentLine":
      return editor.outdentLine(ranges);
    case "clipboardCopy":
      return editor.clipboardCopy(ranges);
    case "fold":
      return editor.fold(ranges);
    case "unfold":
      return editor.unfold(ranges);
    case "insertLineAfter":
      return editor.insertLineAfter(ranges);
    // Single target actions
    case "rename":
      return editor.rename(ranges?.[0]);
    case "showReferences":
      return editor.showReferences(ranges?.[0]);
    case "quickFix":
      return editor.quickFix(ranges?.[0]);
    case "revealDefinition":
      return editor.revealDefinition(ranges?.[0]);
    case "revealTypeDefinition":
      return editor.revealTypeDefinition(ranges?.[0]);
    case "showHover":
      return editor.showHover(ranges?.[0]);
    case "showDebugHover":
      return editor.showDebugHover(ranges?.[0]);
    case "extractVariable":
      return editor.extractVariable(ranges?.[0]);
    case "gitAccept":
      return editor.gitAccept(ranges?.[0]);
    case "gitRevert":
      return editor.gitRevert(ranges?.[0]);
    case "gitStage":
      return editor.gitStage(ranges?.[0]);
    case "gitUnstage":
      return editor.gitUnstage(ranges?.[0]);
    // Unsupported as simple action
    case "highlight":
      throw Error("Highlight command not supported as simple action");
  }
}

// ../cursorless-engine/src/actions/CopyToClipboard.ts
var CopyToClipboard = class {
  constructor(actions, rangeUpdater) {
    this.actions = actions;
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets, options2 = { showDecorations: true }) {
    if (ide().capabilities.commands.clipboardCopy != null) {
      const simpleAction = new CopyToClipboardSimple(this.rangeUpdater);
      return simpleAction.run(targets, options2);
    }
    if (options2.showDecorations) {
      await flashTargets(ide(), targets, "referenced" /* referenced */);
    }
    const text = targets.map((t) => t.contentText).join("\n");
    await ide().clipboard.writeText(text);
    return { thatTargets: targets };
  }
};

// ../cursorless-engine/src/actions/CutToClipboard.ts
var CutToClipboard = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await ide().flashRanges(targets.flatMap(getFlashDescriptors));
    const options2 = { showDecorations: false };
    await this.actions.copyToClipboard.run(targets, options2);
    const { thatTargets } = await this.actions.remove.run(targets, options2);
    return { thatTargets };
  }
};
function getFlashDescriptors(target) {
  const { editor, contentRange } = target;
  const removalHighlightRange = target.getRemovalHighlightRange();
  const flashDescriptors = [
    {
      editor,
      range: toCharacterRange(contentRange),
      style: "referenced" /* referenced */
    }
  ];
  if (removalHighlightRange.type === "line") {
    flashDescriptors.push({
      editor,
      range: removalHighlightRange,
      style: "pendingDelete" /* pendingDelete */
    });
  } else {
    flashDescriptors.push(
      ...getOutsideOverflow(contentRange, removalHighlightRange).map(
        (overflow) => ({
          editor,
          range: toCharacterRange(overflow),
          style: "pendingDelete" /* pendingDelete */
        })
      )
    );
  }
  return flashDescriptors;
}
function getOutsideOverflow(insideRange, outsideRange) {
  const { start: insideStart, end: insideEnd } = insideRange;
  const { start: outsideStart, end: outsideEnd } = outsideRange;
  const result = [];
  if (outsideStart.isBefore(insideStart)) {
    result.push(new Range(outsideStart, insideStart));
  }
  if (outsideEnd.isAfter(insideEnd)) {
    result.push(new Range(insideEnd, outsideEnd));
  }
  return result;
}

// ../cursorless-engine/src/actions/Deselect.ts
var Deselect = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
      const newSelections = editor.selections.filter(
        (selection) => !targets2.some((target) => {
          const intersection = target.contentRange.intersection(selection);
          return intersection && (!intersection.isEmpty || selection.isEmpty);
        })
      );
      if (newSelections.length === 0) {
        throw new SelectionRequiredError();
      }
      await ide().getEditableTextEditor(editor).setSelections(newSelections);
    });
    return {
      thatTargets: targets
    };
  }
};
var SelectionRequiredError = class extends Error {
  constructor() {
    super("Can't deselect every selection. At least one is required");
    this.name = "SelectionRequiredError";
  }
};

// ../cursorless-engine/src/actions/EditNew/runEditTargets.ts
async function runEditTargets(rangeUpdater, editor, state, useAllDestinations) {
  const destinations = state.destinations.map((destination, index) => {
    if (useAllDestinations || state.actionTypes[index] === "edit") {
      return {
        destination,
        index
      };
    }
  }).filter((destination) => !!destination);
  if (destinations.length === 0) {
    return state;
  }
  const edits = destinations.map(
    (destination) => destination.destination.constructChangeEdit("")
  );
  const cursorInfos = state.cursorRanges.map((range3, index) => ({ range: range3, index })).filter(({ range: range3 }) => range3 != null);
  const cursorIndices = cursorInfos.map(({ index }) => index);
  const cursorRanges = cursorInfos.map(({ range: range3 }) => range3);
  const editRanges = edits.map((edit) => edit.range);
  const {
    thatRanges: updatedThatRanges,
    cursorRanges: updatedCursorRanges,
    editRanges: updatedEditRanges
  } = await performEditsAndUpdateSelections({
    rangeUpdater,
    editor,
    edits,
    preserveCursorSelections: true,
    selections: {
      thatRanges: state.thatRanges,
      cursorRanges,
      editRanges: {
        selections: editRanges,
        behavior: 0 /* openOpen */
      }
    }
  });
  const finalCursorRanges = [...state.cursorRanges];
  zip_default(cursorIndices, updatedCursorRanges).forEach(([index, range3]) => {
    finalCursorRanges[index] = range3;
  });
  destinations.forEach((delimiterTarget, index) => {
    const edit = edits[index];
    const range3 = edit.updateRange(updatedEditRanges[index]);
    finalCursorRanges[delimiterTarget.index] = range3;
  });
  return {
    destinations: state.destinations,
    actionTypes: state.actionTypes,
    thatRanges: updatedThatRanges,
    cursorRanges: finalCursorRanges
  };
}

// ../cursorless-engine/src/actions/EditNew/runInsertLineAfterTargets.ts
async function runInsertLineAfterTargets({ acceptsLocation }, rangeUpdater, editor, state) {
  const destinations = state.destinations.map((destination, index) => {
    const actionType = state.actionTypes[index];
    if (actionType === "insertLineAfter") {
      return {
        destination,
        index
      };
    }
  }).filter((destination) => !!destination);
  if (destinations.length === 0) {
    return state;
  }
  const contentRanges = destinations.map(
    ({ destination }) => destination.contentRange
  );
  const targetRanges = state.destinations.map(
    ({ contentRange }) => contentRange
  );
  const callback2 = async () => {
    if (acceptsLocation) {
      await editor.insertLineAfter(contentRanges);
    } else {
      await editor.setSelections(
        contentRanges.map((range3) => range3.toSelection(false))
      );
      await editor.focus();
      await editor.insertLineAfter();
    }
  };
  const { targetRanges: updatedTargetRanges, thatRanges: updatedThatRanges } = await performEditsAndUpdateSelections({
    rangeUpdater,
    editor,
    callback: callback2,
    preserveCursorSelections: true,
    selections: {
      targetRanges,
      thatRanges: state.thatRanges
    }
  });
  const cursorRanges = [...state.cursorRanges];
  destinations.forEach((commandTarget, index) => {
    cursorRanges[commandTarget.index] = editor.selections[index];
  });
  return {
    destinations: state.destinations.map(
      (destination, index) => destination.withTarget(
        destination.target.withContentRange(updatedTargetRanges[index])
      )
    ),
    actionTypes: state.actionTypes,
    thatRanges: updatedThatRanges,
    cursorRanges
  };
}

// ../cursorless-engine/src/actions/EditNew/runNotebookCellTargets.ts
async function runEditNewNotebookCellTargets(actions, destinations) {
  const destination = ensureSingleTarget(destinations);
  const editor = ide().getEditableTextEditor(destination.editor);
  const isAbove = destination.insertionMode === "before";
  if (destination.insertionMode === "to") {
    throw Error(
      `Unsupported insertion mode '${destination.insertionMode}' for notebookcapell`
    );
  }
  await actions.setSelection.run([destination.target]);
  if (isAbove) {
    await editor.editNewNotebookCellAbove();
  } else {
    await editor.editNewNotebookCellBelow();
  }
  const thatMark = createThatMark([destination.target.thatTarget]);
  return { thatSelections: thatMark };
}

// ../cursorless-engine/src/actions/EditNew/EditNew.ts
var EditNew = class {
  constructor(rangeUpdater, actions) {
    this.rangeUpdater = rangeUpdater;
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(destinations) {
    if (destinations.some(({ target }) => target.isNotebookCell)) {
      return runEditNewNotebookCellTargets(this.actions, destinations);
    }
    const editableEditor = ide().getEditableTextEditor(
      ensureSingleEditor(destinations)
    );
    let state = {
      destinations,
      actionTypes: destinations.map((d) => d.getEditNewActionType()),
      thatRanges: destinations.map(
        ({ target }) => target.thatTarget.contentRange
      ),
      cursorRanges: new Array(destinations.length).fill(
        void 0
      )
    };
    const insertLineAfterCapability = ide().capabilities.commands.insertLineAfter;
    const useInsertLineAfter = insertLineAfterCapability != null;
    if (useInsertLineAfter) {
      state = await runInsertLineAfterTargets(
        insertLineAfterCapability,
        this.rangeUpdater,
        editableEditor,
        state
      );
    }
    state = await runEditTargets(
      this.rangeUpdater,
      editableEditor,
      state,
      !useInsertLineAfter
    );
    const newSelections = state.destinations.map((destination, index) => {
      const cursorRange = state.cursorRanges[index];
      if (cursorRange == null) {
        throw Error("Cursor range is undefined for destination");
      }
      return cursorRange.toSelection(destination.target.isReversed);
    });
    await editableEditor.setSelections(newSelections, { focusEditor: true });
    return {
      thatSelections: createThatMark(
        state.destinations.map((d) => d.target),
        state.thatRanges
      )
    };
  }
};

// ../cursorless-engine/src/actions/EditNewLineAction.ts
var EditNewLineAction = class {
  constructor(actions, modifierStageFactory) {
    this.actions = actions;
    this.modifierStageFactory = modifierStageFactory;
    this.run = this.run.bind(this);
  }
  getFinalStages() {
    return [this.modifierStageFactory.create(containingLineIfUntypedModifier)];
  }
  run(targets) {
    return this.actions.editNew.run(
      targets.map((target) => target.toDestination(this.insertionMode))
    );
  }
};
var EditNewBefore = class extends EditNewLineAction {
  constructor() {
    super(...arguments);
    this.insertionMode = "before";
  }
};
var EditNewAfter = class extends EditNewLineAction {
  constructor() {
    super(...arguments);
    this.insertionMode = "after";
  }
};

// ../cursorless-engine/src/actions/ExecuteCommand.ts
var ExecuteCommand = class {
  constructor(rangeUpdater) {
    this.callbackAction = new CallbackAction(rangeUpdater);
    this.run = this.run.bind(this);
  }
  async run(targets, commandId, {
    commandArgs,
    ensureSingleEditor: ensureSingleEditor3,
    ensureSingleTarget: ensureSingleTarget3,
    restoreSelection,
    showDecorations
  } = {}) {
    const args2 = commandArgs ?? [];
    return this.callbackAction.run(targets, {
      callback: () => ide().executeCommand(commandId, ...args2),
      setSelection: true,
      ensureSingleEditor: ensureSingleEditor3 ?? false,
      ensureSingleTarget: ensureSingleTarget3 ?? false,
      restoreSelection: restoreSelection ?? true,
      showDecorations: showDecorations ?? true
    });
  }
};

// ../cursorless-engine/src/actions/Find.ts
var Find = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    ensureSingleTarget(targets);
    const { returnValue, thatTargets } = await this.actions.getText.run(targets);
    const [text] = returnValue;
    let query;
    if (text.length > 200) {
      query = text.substring(0, 200);
      void showWarning(
        ide().messages,
        "truncatedSearchText",
        "Search text is longer than 200 characters; truncating"
      );
    } else {
      query = text;
    }
    await this.find(query);
    return { thatTargets };
  }
};
var FindInDocument = class extends Find {
  find(query) {
    return ide().findInDocument(query);
  }
};
var FindInWorkspace = class extends Find {
  find(query) {
    return ide().findInWorkspace(query);
  }
};

// ../cursorless-engine/src/actions/FlashTargets.ts
var FlashTargets = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await flashTargets(ide(), targets, "referenced" /* referenced */);
    return { thatTargets: targets };
  }
};

// ../cursorless-engine/src/actions/FollowLink.ts
var FollowLink = class {
  constructor(options2) {
    this.options = options2;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const target = ensureSingleTarget(targets);
    await flashTargets(ide(), targets, "referenced" /* referenced */);
    await ide().getEditableTextEditor(target.editor).openLink(target.contentRange, this.options);
    return {
      thatSelections: createThatMark(targets)
    };
  }
};

// ../../node_modules/.pnpm/talon-snippets@1.3.0/node_modules/talon-snippets/lib/esm/parser.js
function parseSnippetFile(content) {
  const documentContents = content.split(/^---$/m);
  const file = { snippets: [] };
  for (const text of documentContents) {
    const match = text.match(/^-$/m);
    const contextText = match != null ? text.slice(0, match.index) : text;
    const bodyText = match != null ? text.slice(match.index + match[0].length) : null;
    const body2 = bodyText ? parseBody(bodyText) : null;
    let context = parseContext(contextText);
    if (body2 != null) {
      if (context == null) {
        context = { variables: [] };
      }
      const { variables, ...rest } = context;
      file.snippets.push({ ...rest, body: body2, variables });
    } else if (context != null) {
      if (file.header != null || file.snippets.length !== 0) {
        throw Error("Header snippet must be first in file");
      }
      file.header = context;
    }
  }
  return file;
}
function parseContext(text) {
  const document2 = { variables: [] };
  const pairs2 = parseContextPairs(text);
  if (Object.keys(pairs2).length === 0) {
    return void 0;
  }
  const variables = {};
  for (const [key, value] of Object.entries(pairs2)) {
    switch (key) {
      case "name":
        document2.name = value;
        break;
      case "description":
        document2.description = value;
        break;
      case "phrase":
        document2.phrases = parseVectorValue(value);
        break;
      case "insertionScope":
        document2.insertionScopes = parseVectorValue(value);
        break;
      case "language":
        document2.languages = parseVectorValue(value);
        break;
      default:
        if (!key.startsWith("$")) {
          throw Error(`Invalid key '${key}'`);
        }
        variables[key] = value;
    }
  }
  document2.variables = parseVariables(variables);
  return document2;
}
function parseContextPairs(text) {
  const lines = text.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
  const pairs2 = {};
  for (const line of lines) {
    const parts2 = line.split(":");
    if (parts2.length !== 2) {
      throw Error(`Invalid line '${line}'`);
    }
    const key = parts2[0].trim();
    const value = parts2[1].trim();
    if (key.length === 0 || value.length === 0) {
      throw Error(`Invalid line '${line}'`);
    }
    if (pairs2[key] != null) {
      throw Error(`Duplicate key '${key}' in '${text}'`);
    }
    pairs2[key] = value;
  }
  return pairs2;
}
function parseVariables(variables) {
  const variablesMap = {};
  const getVariable = (name2) => {
    if (variablesMap[name2] == null) {
      variablesMap[name2] = { name: name2 };
    }
    return variablesMap[name2];
  };
  for (const [key, value] of Object.entries(variables)) {
    const parts2 = key.split(".");
    if (parts2.length !== 2) {
      throw Error(`Invalid variable key '${key}'`);
    }
    const name2 = parts2[0].slice(1);
    const field = parts2[1];
    switch (field) {
      case "insertionFormatter":
        getVariable(name2).insertionFormatters = parseVectorValue(value);
        break;
      case "wrapperPhrase":
        getVariable(name2).wrapperPhrases = parseVectorValue(value);
        break;
      case "wrapperScope":
        getVariable(name2).wrapperScope = value;
        break;
      default:
        throw Error(`Invalid variable key '${key}'`);
    }
  }
  return Object.values(variablesMap);
}
function parseBody(text) {
  const matchLeading = text.match(/^[ \t]*\S/m);
  if (matchLeading?.index == null) {
    return void 0;
  }
  return text.slice(matchLeading.index).trimEnd().split(/\r?\n/).map((l) => l.trimEnd());
}
function parseVectorValue(value) {
  return value.split("|").map((v) => v.trim());
}

// ../../node_modules/.pnpm/talon-snippets@1.3.0/node_modules/talon-snippets/lib/esm/serializer.js
function serializeSnippetFile(snippetFile) {
  const documents = [];
  if (snippetFile.header != null) {
    documents.push(getDocumentText(snippetFile.header));
  }
  documents.push(...snippetFile.snippets.map(getDocumentText));
  const result = documents.filter(Boolean).join("\n---\n\n");
  return result ? result + "\n---\n" : "";
}
function getDocumentText(document2) {
  const parts2 = [
    getOptionalPairString("name", document2.name),
    getOptionalPairString("description", document2.description),
    getOptionalPairString("language", document2.languages),
    getOptionalPairString("phrase", document2.phrases),
    getOptionalPairString("insertionScope", document2.insertionScopes)
  ].filter(Boolean);
  if (document2.variables.length > 0) {
    if (parts2.length > 0) {
      parts2.push("");
    }
    parts2.push(...getSortedVariables(document2.variables));
  }
  if ("body" in document2) {
    parts2.push("-", ...document2.body);
  }
  return parts2.join("\n");
}
function getSortedVariables(variables) {
  const result = [...variables];
  result.sort(compareVariables);
  return result.flatMap((variable) => [
    getOptionalPairString(`$${variable.name}.insertionFormatter`, variable.insertionFormatters),
    getOptionalPairString(`$${variable.name}.wrapperPhrase`, variable.wrapperPhrases),
    getOptionalPairString(`$${variable.name}.wrapperScope`, variable.wrapperScope)
  ]).filter(Boolean);
}
function getOptionalPairString(key, value) {
  if (value == null) {
    return "";
  }
  if (Array.isArray(value)) {
    return `${key}: ${value.join(" | ")}`;
  }
  return `${key}: ${value}`;
}
function compareVariables(a, b) {
  if (a.name === "0") {
    return 1;
  }
  if (b.name === "0") {
    return -1;
  }
  return a.name.localeCompare(b.name);
}

// ../cursorless-engine/src/actions/GenerateSnippet/constructSnippetBody.ts
function constructSnippetBody(text, linePrefix) {
  const outputLines = [];
  let currentTabCount = 0;
  let currentIndentationString = null;
  const [firstLine, ...remainingLines] = text.split(/\r?\n/);
  const lines = [
    {
      text: linePrefix + firstLine,
      startIndex: linePrefix.length
    },
    ...remainingLines.map((line) => ({ text: line, startIndex: 0 }))
  ];
  lines.forEach(({ text: text2, startIndex }) => {
    const newIndentationString = text2.match(/^\s*/)?.[0] ?? "";
    const firstNonWhitespaceCharacterIndex = newIndentationString.length;
    if (currentIndentationString != null) {
      if (newIndentationString.length > currentIndentationString.length) {
        currentTabCount++;
      } else if (newIndentationString.length < currentIndentationString.length) {
        currentTabCount--;
      }
    }
    currentIndentationString = newIndentationString;
    const lineContentStart = Math.max(
      firstNonWhitespaceCharacterIndex,
      startIndex
    );
    const snippetIndentationString = repeat_default("	", currentTabCount);
    const lineContent = text2.slice(lineContentStart);
    outputLines.push(snippetIndentationString + lineContent);
  });
  return outputLines;
}

// ../cursorless-engine/src/actions/GenerateSnippet/editText.ts
function editText(text, edits) {
  const sortedEdits = sortBy_default(edits, (edit) => edit.offsets.start);
  let output = "";
  let currentOffset = 0;
  for (const edit of sortedEdits) {
    output += text.slice(currentOffset, edit.offsets.start) + edit.text;
    currentOffset = edit.offsets.end;
  }
  output += text.slice(currentOffset);
  return output;
}

// ../cursorless-engine/src/actions/GenerateSnippet/GenerateSnippet.ts
var GenerateSnippet = class {
  constructor(snippets) {
    this.snippets = snippets;
    this.run = this.run.bind(this);
  }
  async run(targets, directory, snippetName) {
    if (directory == null) {
      throw new Error(
        "Directory argument is required for GenerateSnippet action. Please update Cursorless Talon"
      );
    }
    const target = ensureSingleTarget(targets);
    const editor = target.editor;
    void flashTargets(ide(), targets, "referenced" /* referenced */);
    if (snippetName == null) {
      snippetName = await ide().showInputBox({
        prompt: "Name of snippet",
        placeHolder: "helloWorld"
      });
      if (!snippetName) {
        return {};
      }
    }
    const baseOffset = editor.document.offsetAt(target.contentRange.start);
    const selections = getsSnippetSelections(editor, target.contentRange);
    const variables = selections.map(
      (selection, index) => ({
        offsets: {
          start: editor.document.offsetAt(selection.start) - baseOffset,
          end: editor.document.offsetAt(selection.end) - baseOffset
        },
        name: index === selections.length - 1 ? "0" : `${index + 1}`
      })
    );
    const linePrefix = editor.document.getText(
      new Range(
        target.contentRange.start.with(void 0, 0),
        target.contentRange.start
      )
    );
    const originalText = editor.document.getText(target.contentRange);
    const snippetBodyText = editText(originalText, [
      ...matchAll(originalText, /\$|\\/g, (match) => ({
        offsets: {
          start: match.index,
          end: match.index + match[0].length
        },
        text: `\\${match[0]}`
      })),
      ...variables.map(({ offsets, name: name2 }) => ({
        offsets,
        text: `$${name2}`
      }))
    ]);
    const snippetLines = constructSnippetBody(snippetBodyText, linePrefix);
    let editableEditor;
    let snippetFile = { snippets: [] };
    if (ide().runMode === "test") {
      editableEditor = ide().getEditableTextEditor(editor);
    } else {
      editableEditor = ide().getEditableTextEditor(
        await this.snippets.openNewSnippetFile(snippetName, directory)
      );
      snippetFile = parseSnippetFile(editableEditor.document.getText());
    }
    await editableEditor.setSelections([
      editableEditor.document.range.toSelection(false)
    ]);
    let currentPlaceholderIndex = 1;
    const { header } = snippetFile;
    const phrases = snippetFile.header?.phrases != null ? void 0 : [`${PLACEHOLDER}${currentPlaceholderIndex++}`];
    const createVariable = (variable) => {
      const hasPhrase = header?.variables?.some(
        (v) => v.name === variable.name && v.wrapperPhrases != null
      );
      return {
        name: variable.name,
        wrapperPhrases: hasPhrase ? void 0 : [`${PLACEHOLDER}${currentPlaceholderIndex++}`]
      };
    };
    const snippet2 = {
      name: header?.name === snippetName ? void 0 : snippetName,
      phrases,
      languages: getSnippetLanguages(editor, header),
      body: snippetLines,
      variables: variables.map(createVariable)
    };
    snippetFile.snippets.push(snippet2);
    const metaSnippetText = serializeSnippetFile(snippetFile).replace(/\$/g, "\\$").replaceAll(PLACEHOLDER, "$");
    await editableEditor.insertSnippet(metaSnippetText);
    return {
      thatSelections: targets.map(({ editor: editor2, contentSelection }) => ({
        editor: editor2,
        selection: contentSelection
      }))
    };
  }
};
function getSnippetLanguages(editor, header) {
  if (header?.languages?.includes(editor.document.languageId)) {
    return void 0;
  }
  return [editor.document.languageId];
}
function getsSnippetSelections(editor, range3) {
  const selections = editor.selections.filter(
    (selection) => range3.contains(selection)
  );
  selections.sort((a, b) => a.start.compareTo(b.start));
  return selections;
}
var PLACEHOLDER = "PLACEHOLDER_VFA77zcbLD6wXNmfMAay";

// ../cursorless-engine/src/actions/GetTargets.ts
var GetTargets = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets) {
    return {
      returnValue: targets.map(({ contentRange }) => ({
        contentRange
      })),
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/GetText.ts
var GetText = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets, {
    showDecorations = true,
    ensureSingleTarget: doEnsureSingleTarget = false
  } = {}) {
    if (showDecorations) {
      await flashTargets(ide(), targets, "referenced" /* referenced */);
    }
    if (doEnsureSingleTarget) {
      ensureSingleTarget(targets);
    }
    return {
      returnValue: targets.map((target) => target.contentText),
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/Highlight.ts
var Highlight = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets, highlightId) {
    if (ide().capabilities.commands["highlight"] == null) {
      throw Error(`The highlight action is not supported by your ide`);
    }
    if (targets.length === 0) {
      await Promise.all(
        ide().visibleTextEditors.map(
          (editor) => ide().setHighlightRanges(highlightId, editor, [])
        )
      );
    } else {
      await runOnTargetsForEachEditor(
        targets,
        (editor, targets2) => ide().setHighlightRanges(
          highlightId,
          editor,
          targets2.map(
            (target) => toGeneralizedRange(target, target.contentRange)
          )
        )
      );
    }
    return {
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/IndentLine.ts
var IndentLineBase = class {
  constructor(rangeUpdater, isIndent) {
    this.rangeUpdater = rangeUpdater;
    this.isIndent = isIndent;
    this.run = this.run.bind(this);
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(targets) {
    if (this.hasCapability()) {
      return this.runSimpleCommandAction(targets);
    }
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const thatTargets = flatten_default(
      await runOnTargetsForEachEditor(targets, this.runForEditor)
    );
    return { thatTargets };
  }
  hasCapability() {
    return this.isIndent ? ide().capabilities.commands.indentLine != null : ide().capabilities.commands.outdentLine != null;
  }
  runSimpleCommandAction(targets) {
    const action = this.isIndent ? new IndentLineSimpleAction(this.rangeUpdater) : new OutdentLineSimpleAction(this.rangeUpdater);
    return action.run(targets);
  }
  async runForEditor(editor, targets) {
    const edits = this.isIndent ? getIndentEdits(editor, targets) : getOutdentEdits(editor, targets);
    const { targetSelections: updatedTargetSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: ide().getEditableTextEditor(editor),
      edits,
      selections: {
        targetSelections: targets.map(
          ({ contentSelection }) => contentSelection
        )
      }
    });
    return zip_default(targets, updatedTargetSelections).map(
      ([target, range3]) => selectionToStoredTarget({
        editor,
        selection: range3.toSelection(target.isReversed)
      })
    );
  }
};
var IndentLine = class extends IndentLineBase {
  constructor(rangeUpdater) {
    super(rangeUpdater, true);
  }
};
var OutdentLine = class extends IndentLineBase {
  constructor(rangeUpdater) {
    super(rangeUpdater, false);
  }
};
function getIndentEdits(editor, targets) {
  const { document: document2 } = editor;
  const lineNumbers = getLineNumbers(targets);
  const indent = getIndent(editor);
  return lineNumbers.map((lineNumber) => {
    const line = document2.lineAt(lineNumber);
    return {
      range: line.range.start.toEmptyRange(),
      text: indent
    };
  });
}
function getOutdentEdits(editor, targets) {
  const { document: document2 } = editor;
  const lineNumbers = getLineNumbers(targets);
  const regex = getRegex(editor);
  return lineNumbers.map((lineNumber) => {
    const line = document2.lineAt(lineNumber);
    const match = line.text.match(regex);
    const { start: start2 } = line.range;
    const end = start2.translate(void 0, match?.[0].length);
    return {
      range: new Range(start2, end),
      text: ""
    };
  });
}
function getLineNumbers(targets) {
  const lineNumbers = /* @__PURE__ */ new Set();
  for (const target of targets) {
    const { start: start2, end } = target.contentRange;
    for (let i2 = start2.line; i2 <= end.line; ++i2) {
      lineNumbers.add(i2);
    }
  }
  return [...lineNumbers];
}
function getIndent(editor) {
  if (editor.options.insertSpaces) {
    const tabSize = getTabSize(editor);
    return " ".repeat(tabSize);
  }
  return "	";
}
function getRegex(editor) {
  if (editor.options.insertSpaces) {
    const tabSize = getTabSize(editor);
    return new RegExp(`^[ ]{1,${tabSize}}`);
  }
  return /^\t/;
}
function getTabSize(editor) {
  return typeof editor.options.tabSize === "number" ? editor.options.tabSize : 4;
}

// ../cursorless-engine/src/actions/InsertCopy.ts
var InsertCopy = class {
  constructor(rangeUpdater, modifierStageFactory, isBefore) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.isBefore = isBefore;
    this.getFinalStages = () => [
      this.modifierStageFactory.create(containingLineIfUntypedModifier)
    ];
    this.run = this.run.bind(this);
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(targets) {
    const results = flatten_default(
      await runOnTargetsForEachEditor(targets, this.runForEditor)
    );
    await ide().flashRanges(
      results.flatMap(
        (result) => result.thatMark.map((that) => ({
          editor: that.editor,
          range: toCharacterRange(that.selection),
          style: "justAdded" /* justAdded */
        }))
      )
    );
    return {
      sourceSelections: results.flatMap(({ sourceMark }) => sourceMark),
      thatSelections: results.flatMap(({ thatMark }) => thatMark)
    };
  }
  async runForEditor(editor, targets) {
    const position = this.isBefore ? "after" : "before";
    const edits = targets.flatMap(
      (target) => target.toDestination(position).constructChangeEdit(target.contentText)
    );
    const contentSelections = targets.map(
      ({ contentSelection }) => contentSelection
    );
    const editRanges = edits.map(({ range: range3 }) => range3);
    const editableEditor = ide().getEditableTextEditor(editor);
    const {
      contentSelections: updatedContentSelections,
      editRanges: updatedEditRanges
    } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: editableEditor,
      edits,
      selections: {
        contentSelections,
        editRanges: {
          selections: editRanges,
          behavior: 0 /* openOpen */
        }
      }
    });
    const insertionRanges = zip_default(edits, updatedEditRanges).map(
      ([edit, range3]) => edit.updateRange(range3)
    );
    const primarySelection = editor.selections[0];
    if (updatedContentSelections.some(
      (selection) => selection.intersection(primarySelection) != null
    )) {
      await editableEditor.revealRange(primarySelection);
    }
    return {
      sourceMark: createThatMark(targets, insertionRanges),
      thatMark: createThatMark(targets, updatedContentSelections)
    };
  }
};
var CopyContentBefore = class extends InsertCopy {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory, true);
  }
};
var CopyContentAfter = class extends InsertCopy {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory, false);
  }
};

// ../cursorless-engine/src/actions/InsertEmptyLines.ts
var InsertEmptyLines = class {
  constructor(rangeUpdater, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.run = this.run.bind(this);
  }
  getFinalStages() {
    return [this.modifierStageFactory.create(containingLineIfUntypedModifier)];
  }
  async run(targets) {
    const results = await runOnTargetsForEachEditor(
      targets,
      async (editor, targets2) => {
        const edits = this.getEdits(targets2);
        const contentSelections = targets2.map(
          (target) => target.thatTarget.contentSelection
        );
        const {
          contentSelections: updatedThatSelections,
          editRanges: updatedEditRanges
        } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits,
          selections: {
            contentSelections,
            editRanges: {
              selections: edits.map((edit) => edit.range),
              behavior: 0 /* openOpen */
            }
          }
        });
        return {
          thatMark: updatedThatSelections.map((selection) => ({
            editor,
            selection
          })),
          flashRanges: zipStrict(edits, updatedEditRanges).map(
            ([edit, editRange]) => ({
              editor,
              // Exclude the new line delimiter from the range for line edits
              range: edit.isLine ? edit.updateRange(editRange) : editRange,
              isLine: edit.isLine
            })
          )
        };
      }
    );
    await ide().flashRanges(
      results.flatMap(
        (result) => result.flashRanges.map(({ editor, range: range3, isLine }) => ({
          editor,
          range: isLine ? toLineRange(range3) : toCharacterRange(range3),
          style: "justAdded" /* justAdded */
        }))
      )
    );
    const thatMark = results.flatMap((result) => result.thatMark);
    return { thatSelections: thatMark };
  }
};
var InsertEmptyLinesAround = class extends InsertEmptyLines {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory);
  }
  getEdits(targets) {
    return targets.flatMap((target) => [
      constructChangeEdit(target, "before"),
      constructChangeEdit(target, "after")
    ]);
  }
};
var InsertEmptyLineAbove = class extends InsertEmptyLines {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory);
  }
  getEdits(targets) {
    return targets.map((target) => constructChangeEdit(target, "before"));
  }
};
var InsertEmptyLineBelow = class extends InsertEmptyLines {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory);
  }
  getEdits(targets) {
    return targets.map((target) => constructChangeEdit(target, "after"));
  }
};
function constructChangeEdit(target, insertionMode2) {
  return {
    ...target.toDestination(insertionMode2).constructChangeEdit("", true),
    isLine: target.textualType === "line"
  };
}

// ../cursorless-engine/src/core/getPreferredSnippet.ts
function getPreferredSnippet(snippetDescription, languageId) {
  if (snippetDescription.type === "named") {
    throw new Error(
      "Cursorless snippets are deprecated. Please use community snippets. Update to latest cursorless-talon and say 'cursorless migrate snippets'."
    );
  }
  if (snippetDescription.type === "custom") {
    return snippetDescription;
  }
  const preferredSnippet = tryToFindPreferredSnippet(
    snippetDescription.snippets,
    languageId,
    snippetDescription.fallbackLanguage
  );
  if (preferredSnippet == null) {
    const languages = getUniqueLanguagesString(snippetDescription.snippets);
    throw new Error(
      `No snippet available for language '${languageId}'. Available languages: ${languages}`
    );
  }
  return preferredSnippet;
}
function getUniqueLanguagesString(snippets) {
  const languages = new Set(
    snippets.flatMap((snippet2) => snippet2.languages ?? [])
  );
  return Array.from(languages).sort().join(", ");
}
function tryToFindPreferredSnippet(snippetDescriptions, languageId, fallbackLanguage) {
  let snippet2 = findSnippetWithFewestLanguages(
    snippetDescriptions.filter((snippetDescription) => {
      return snippetDescription.languages?.includes(languageId);
    })
  );
  if (snippet2 == null && fallbackLanguage != null) {
    snippet2 = findSnippetWithFewestLanguages(
      snippetDescriptions.filter((snippetDescription) => {
        return snippetDescription.languages?.includes(fallbackLanguage);
      })
    );
  }
  if (snippet2 == null) {
    snippet2 = snippetDescriptions.find((snippetDescription) => {
      return snippetDescription.languages == null;
    });
  }
  return snippet2;
}
function findSnippetWithFewestLanguages(snippets) {
  if (snippets.length === 0) {
    return void 0;
  }
  return snippets.reduce((prev, curr) => {
    if (prev.languages == null || curr.languages == null) {
      throw Error(
        "Snippet must have languages defined to find the one with the fewest languages"
      );
    }
    return curr.languages.length < prev.languages.length ? curr : prev;
  });
}

// ../cursorless-engine/src/snippets/vendor/vscodeSnippet/snippetParser.ts
var _Scanner = class _Scanner {
  constructor() {
    this.value = "";
    this.pos = 0;
  }
  static isDigitCharacter(ch) {
    return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;
  }
  static isVariableCharacter(ch) {
    return ch === 95 /* Underline */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 65 /* A */ && ch <= 90 /* Z */;
  }
  text(value) {
    this.value = value;
    this.pos = 0;
  }
  tokenText(token) {
    return this.value.substr(token.pos, token.len);
  }
  next() {
    if (this.pos >= this.value.length) {
      return { type: 14 /* EOF */, pos: this.pos, len: 0 };
    }
    let pos = this.pos;
    let len = 0;
    let ch = this.value.charCodeAt(pos);
    let type2;
    type2 = _Scanner._table[ch];
    if (typeof type2 === "number") {
      this.pos += 1;
      return { type: type2, pos, len: 1 };
    }
    if (_Scanner.isDigitCharacter(ch)) {
      type2 = 8 /* Int */;
      do {
        len += 1;
        ch = this.value.charCodeAt(pos + len);
      } while (_Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type: type2, pos, len };
    }
    if (_Scanner.isVariableCharacter(ch)) {
      type2 = 9 /* VariableName */;
      do {
        ch = this.value.charCodeAt(pos + ++len);
      } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type: type2, pos, len };
    }
    type2 = 10 /* Format */;
    do {
      len += 1;
      ch = this.value.charCodeAt(pos + len);
    } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
    this.pos += len;
    return { type: type2, pos, len };
  }
};
_Scanner._table = {
  [36 /* DollarSign */]: 0 /* Dollar */,
  [58 /* Colon */]: 1 /* Colon */,
  [44 /* Comma */]: 2 /* Comma */,
  [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,
  [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,
  [92 /* Backslash */]: 5 /* Backslash */,
  [47 /* Slash */]: 6 /* Forwardslash */,
  [124 /* Pipe */]: 7 /* Pipe */,
  [43 /* Plus */]: 11 /* Plus */,
  [45 /* Dash */]: 12 /* Dash */,
  [63 /* QuestionMark */]: 13 /* QuestionMark */
};
var Scanner = _Scanner;
var Marker = class {
  constructor() {
    this._children = [];
  }
  appendChild(child) {
    if (child instanceof Text2 && this._children[this._children.length - 1] instanceof Text2) {
      this._children[this._children.length - 1].value += child.value;
    } else {
      child.parent = this;
      this._children.push(child);
    }
    return this;
  }
  replace(child, others) {
    const { parent } = child;
    const idx = parent.children.indexOf(child);
    const newChildren = parent.children.slice(0);
    newChildren.splice(idx, 1, ...others);
    parent._children = newChildren;
    (function _fixParent(children, parent2) {
      for (const child2 of children) {
        child2.parent = parent2;
        _fixParent(child2.children, child2);
      }
    })(others, parent);
  }
  get children() {
    return this._children;
  }
  get snippet() {
    let candidate = this;
    while (true) {
      if (!candidate) {
        return void 0;
      }
      if (candidate instanceof TextmateSnippet) {
        return candidate;
      }
      candidate = candidate.parent;
    }
  }
  toString() {
    return this.children.reduce((prev, cur) => prev + cur.toString(), "");
  }
  len() {
    return 0;
  }
};
var Text2 = class _Text extends Marker {
  constructor(value) {
    super();
    this.value = value;
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  toString() {
    return this.value;
  }
  toTextmateString() {
    return _Text.escape(this.value);
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new _Text(this.value);
  }
};
var TransformableMarker = class extends Marker {
};
var Placeholder = class _Placeholder extends TransformableMarker {
  constructor(index) {
    super();
    this.index = index;
  }
  static compareByIndex(a, b) {
    if (a.index === b.index) {
      return 0;
    } else if (a.isFinalTabstop) {
      return 1;
    } else if (b.isFinalTabstop) {
      return -1;
    } else if (a.index < b.index) {
      return -1;
    } else if (a.index > b.index) {
      return 1;
    } else {
      return 0;
    }
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
  }
  toTextmateString() {
    let transformString = "";
    if (this.transform) {
      transformString = this.transform.toTextmateString();
    }
    if (this.children.length === 0 && !this.transform) {
      return `$${this.index}`;
    } else if (this.children.length === 0) {
      return `\${${this.index}${transformString}}`;
    } else if (this.choice) {
      return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
    } else {
      return `\${${this.index}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
    }
  }
  clone() {
    let ret = new _Placeholder(this.index);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var Choice = class _Choice extends Marker {
  constructor() {
    super(...arguments);
    this.options = [];
  }
  appendChild(marker) {
    if (marker instanceof Text2) {
      marker.parent = this;
      this.options.push(marker);
    }
    return this;
  }
  toString() {
    return this.options[0].value;
  }
  toTextmateString() {
    return this.options.map((option) => option.value.replace(/\||,|\\/g, "\\$&")).join(",");
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    let ret = new _Choice();
    this.options.forEach(ret.appendChild, ret);
    return ret;
  }
};
var Transform = class _Transform extends Marker {
  constructor() {
    super(...arguments);
    this.regexp = new RegExp("");
  }
  resolve(value) {
    const _this = this;
    let didMatch = false;
    let ret = value.replace(this.regexp, function() {
      didMatch = true;
      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
      ret = this._replace([]);
    }
    return ret;
  }
  _replace(groups) {
    let ret = "";
    for (const marker of this._children) {
      if (marker instanceof FormatString) {
        let value = groups[marker.index] || "";
        value = marker.resolve(value);
        ret += value;
      } else {
        ret += marker.toString();
      }
    }
    return ret;
  }
  toString() {
    return "";
  }
  toTextmateString() {
    return `/${this.regexp.source}/${this.children.map((c) => c.toTextmateString())}/${(this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")}`;
  }
  clone() {
    let ret = new _Transform();
    ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var FormatString = class _FormatString extends Marker {
  constructor(index, shorthandName, ifValue, elseValue) {
    super();
    this.index = index;
    this.shorthandName = shorthandName;
    this.ifValue = ifValue;
    this.elseValue = elseValue;
  }
  resolve(value) {
    if (this.shorthandName === "upcase") {
      return !value ? "" : value.toLocaleUpperCase();
    } else if (this.shorthandName === "downcase") {
      return !value ? "" : value.toLocaleLowerCase();
    } else if (this.shorthandName === "capitalize") {
      return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
    } else if (this.shorthandName === "pascalcase") {
      return !value ? "" : this._toPascalCase(value);
    } else if (this.shorthandName === "camelcase") {
      return !value ? "" : this._toCamelCase(value);
    } else if (Boolean(value) && typeof this.ifValue === "string") {
      return this.ifValue;
    } else if (!Boolean(value) && typeof this.elseValue === "string") {
      return this.elseValue;
    } else {
      return value || "";
    }
  }
  _toPascalCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word) => {
      return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
    }).join("");
  }
  _toCamelCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word, index) => {
      if (index === 0) {
        return word.toLowerCase();
      } else {
        return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
      }
    }).join("");
  }
  toTextmateString() {
    let value = "${";
    value += this.index;
    if (this.shorthandName) {
      value += `:/${this.shorthandName}`;
    } else if (this.ifValue && this.elseValue) {
      value += `:?${this.ifValue}:${this.elseValue}`;
    } else if (this.ifValue) {
      value += `:+${this.ifValue}`;
    } else if (this.elseValue) {
      value += `:-${this.elseValue}`;
    }
    value += "}";
    return value;
  }
  clone() {
    let ret = new _FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
    return ret;
  }
};
var Variable = class _Variable extends TransformableMarker {
  constructor(name2) {
    super();
    this.name = name2;
  }
  resolve(resolver) {
    let value = resolver.resolve(this);
    if (this.transform) {
      value = this.transform.resolve(value || "");
    }
    if (value !== void 0) {
      this._children = [new Text2(value)];
      return true;
    }
    return false;
  }
  toTextmateString() {
    let transformString = "";
    if (this.transform) {
      transformString = this.transform.toTextmateString();
    }
    if (this.children.length === 0) {
      return `\${${this.name}${transformString}}`;
    } else {
      return `\${${this.name}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
    }
  }
  clone() {
    const ret = new _Variable(this.name);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var TextmateSnippet = class _TextmateSnippet extends Marker {
  get placeholderInfo() {
    if (!this._placeholders) {
      let all = [];
      let last2;
      this.walk(function(candidate) {
        if (candidate instanceof Placeholder) {
          all.push(candidate);
          last2 = !last2 || last2.index < candidate.index ? candidate : last2;
        }
        return true;
      });
      this._placeholders = { all, last: last2 };
    }
    return this._placeholders;
  }
  get placeholders() {
    const { all } = this.placeholderInfo;
    return all;
  }
  offset(marker) {
    let pos = 0;
    let found = false;
    this.walk((candidate) => {
      if (candidate === marker) {
        found = true;
        return false;
      }
      pos += candidate.len();
      return true;
    });
    if (!found) {
      return -1;
    }
    return pos;
  }
  fullLen(marker) {
    let ret = 0;
    walk([marker], (marker2) => {
      ret += marker2.len();
      return true;
    });
    return ret;
  }
  enclosingPlaceholders(placeholder) {
    let ret = [];
    let { parent } = placeholder;
    while (parent) {
      if (parent instanceof Placeholder) {
        ret.push(parent);
      }
      parent = parent.parent;
    }
    return ret;
  }
  resolveVariables(resolver) {
    this.walk((candidate) => {
      if (candidate instanceof Variable) {
        if (candidate.resolve(resolver)) {
          this._placeholders = void 0;
        }
      }
      return true;
    });
    return this;
  }
  appendChild(child) {
    this._placeholders = void 0;
    return super.appendChild(child);
  }
  replace(child, others) {
    this._placeholders = void 0;
    return super.replace(child, others);
  }
  toTextmateString() {
    return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), "");
  }
  clone() {
    let ret = new _TextmateSnippet();
    this._children = this.children.map((child) => child.clone());
    return ret;
  }
  walk(visitor) {
    walk(this.children, visitor);
  }
};
var SnippetParser = class {
  constructor() {
    this._scanner = new Scanner();
    this._token = { type: 14 /* EOF */, pos: 0, len: 0 };
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(template) {
    return /\${?CLIPBOARD/.test(template);
  }
  text(value) {
    return this.parse(value).toString();
  }
  parse(value, insertFinalTabstop, enforceFinalTabstop) {
    this._scanner.text(value);
    this._token = this._scanner.next();
    const snippet2 = new TextmateSnippet();
    while (this._parse(snippet2)) {
    }
    const placeholderDefaultValues = /* @__PURE__ */ new Map();
    const incompletePlaceholders = [];
    let placeholderCount = 0;
    snippet2.walk((marker) => {
      if (marker instanceof Placeholder) {
        placeholderCount += 1;
        if (marker.isFinalTabstop) {
          placeholderDefaultValues.set(0, void 0);
        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
          placeholderDefaultValues.set(marker.index, marker.children);
        } else {
          incompletePlaceholders.push(marker);
        }
      }
      return true;
    });
    for (const placeholder of incompletePlaceholders) {
      const defaultValues = placeholderDefaultValues.get(placeholder.index);
      if (defaultValues) {
        const clone = new Placeholder(placeholder.index);
        clone.transform = placeholder.transform;
        for (const child of defaultValues) {
          clone.appendChild(child.clone());
        }
        snippet2.replace(placeholder, [clone]);
      }
    }
    if (!enforceFinalTabstop) {
      enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;
    }
    if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {
      snippet2.appendChild(new Placeholder(0));
    }
    return snippet2;
  }
  _accept(type2, value) {
    if (type2 === void 0 || this._token.type === type2) {
      let ret = !value ? true : this._scanner.tokenText(this._token);
      this._token = this._scanner.next();
      return ret;
    }
    return false;
  }
  _backTo(token) {
    this._scanner.pos = token.pos + token.len;
    this._token = token;
    return false;
  }
  _until(type2) {
    const start2 = this._token;
    while (this._token.type !== type2) {
      if (this._token.type === 14 /* EOF */) {
        return false;
      } else if (this._token.type === 5 /* Backslash */) {
        const nextToken = this._scanner.next();
        if (nextToken.type !== 0 /* Dollar */ && nextToken.type !== 4 /* CurlyClose */ && nextToken.type !== 5 /* Backslash */) {
          return false;
        }
      }
      this._token = this._scanner.next();
    }
    const value = this._scanner.value.substring(start2.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    this._token = this._scanner.next();
    return value;
  }
  _parse(marker) {
    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
  }
  // \$, \\, \} -> just text
  _parseEscaped(marker) {
    let value;
    if (value = this._accept(5 /* Backslash */, true)) {
      value = this._accept(0 /* Dollar */, true) || this._accept(4 /* CurlyClose */, true) || this._accept(5 /* Backslash */, true) || value;
      marker.appendChild(new Text2(value));
      return true;
    }
    return false;
  }
  // $foo -> variable, $1 -> tabstop
  _parseTabstopOrVariableName(parent) {
    let value;
    const token = this._token;
    const match = this._accept(0 /* Dollar */) && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));
    if (!match) {
      return this._backTo(token);
    }
    parent.appendChild(
      /^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value)
    );
    return true;
  }
  // ${1:<children>}, ${1} -> placeholder
  _parseComplexPlaceholder(parent) {
    let index;
    const token = this._token;
    const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (index = this._accept(8 /* Int */, true));
    if (!match) {
      return this._backTo(token);
    }
    const placeholder = new Placeholder(Number(index));
    if (this._accept(1 /* Colon */)) {
      while (true) {
        if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(placeholder);
          return true;
        }
        if (this._parse(placeholder)) {
          continue;
        }
        parent.appendChild(new Text2("${" + index + ":"));
        placeholder.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {
      const choice = new Choice();
      while (true) {
        if (this._parseChoiceElement(choice)) {
          if (this._accept(2 /* Comma */)) {
            continue;
          }
          if (this._accept(7 /* Pipe */)) {
            placeholder.appendChild(choice);
            if (this._accept(4 /* CurlyClose */)) {
              parent.appendChild(placeholder);
              return true;
            }
          }
        }
        this._backTo(token);
        return false;
      }
    } else if (this._accept(6 /* Forwardslash */)) {
      if (this._parseTransform(placeholder)) {
        parent.appendChild(placeholder);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4 /* CurlyClose */)) {
      parent.appendChild(placeholder);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseChoiceElement(parent) {
    const token = this._token;
    const values2 = [];
    while (true) {
      if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {
        break;
      }
      let value;
      if (value = this._accept(5 /* Backslash */, true)) {
        value = this._accept(2 /* Comma */, true) || this._accept(7 /* Pipe */, true) || this._accept(5 /* Backslash */, true) || value;
      } else {
        value = this._accept(void 0, true);
      }
      if (!value) {
        this._backTo(token);
        return false;
      }
      values2.push(value);
    }
    if (values2.length === 0) {
      this._backTo(token);
      return false;
    }
    parent.appendChild(new Text2(values2.join("")));
    return true;
  }
  // ${foo:<children>}, ${foo} -> variable
  _parseComplexVariable(parent) {
    let name2;
    const token = this._token;
    const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (name2 = this._accept(9 /* VariableName */, true));
    if (!match) {
      return this._backTo(token);
    }
    const variable = new Variable(name2);
    if (this._accept(1 /* Colon */)) {
      while (true) {
        if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(variable);
          return true;
        }
        if (this._parse(variable)) {
          continue;
        }
        parent.appendChild(new Text2("${" + name2 + ":"));
        variable.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (this._accept(6 /* Forwardslash */)) {
      if (this._parseTransform(variable)) {
        parent.appendChild(variable);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4 /* CurlyClose */)) {
      parent.appendChild(variable);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseTransform(parent) {
    let transform = new Transform();
    let regexValue = "";
    let regexOptions = "";
    while (true) {
      if (this._accept(6 /* Forwardslash */)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5 /* Backslash */, true)) {
        escaped = this._accept(6 /* Forwardslash */, true) || escaped;
        regexValue += escaped;
        continue;
      }
      if (this._token.type !== 14 /* EOF */) {
        regexValue += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(6 /* Forwardslash */)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5 /* Backslash */, true)) {
        escaped = this._accept(5 /* Backslash */, true) || this._accept(6 /* Forwardslash */, true) || escaped;
        transform.appendChild(new Text2(escaped));
        continue;
      }
      if (this._parseFormatString(transform) || this._parseAnything(transform)) {
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(4 /* CurlyClose */)) {
        break;
      }
      if (this._token.type !== 14 /* EOF */) {
        regexOptions += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    try {
      transform.regexp = new RegExp(regexValue, regexOptions);
    } catch (e) {
      return false;
    }
    parent.transform = transform;
    return true;
  }
  _parseFormatString(parent) {
    const token = this._token;
    if (!this._accept(0 /* Dollar */)) {
      return false;
    }
    let complex = false;
    if (this._accept(3 /* CurlyOpen */)) {
      complex = true;
    }
    let index = this._accept(8 /* Int */, true);
    if (!index) {
      this._backTo(token);
      return false;
    } else if (!complex) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (this._accept(4 /* CurlyClose */)) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (!this._accept(1 /* Colon */)) {
      this._backTo(token);
      return false;
    }
    if (this._accept(6 /* Forwardslash */)) {
      let shorthand = this._accept(9 /* VariableName */, true);
      if (!shorthand || !this._accept(4 /* CurlyClose */)) {
        this._backTo(token);
        return false;
      } else {
        parent.appendChild(new FormatString(Number(index), shorthand));
        return true;
      }
    } else if (this._accept(11 /* Plus */)) {
      let ifValue = this._until(4 /* CurlyClose */);
      if (ifValue) {
        parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
        return true;
      }
    } else if (this._accept(12 /* Dash */)) {
      let elseValue = this._until(4 /* CurlyClose */);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    } else if (this._accept(13 /* QuestionMark */)) {
      let ifValue = this._until(1 /* Colon */);
      if (ifValue) {
        let elseValue = this._until(4 /* CurlyClose */);
        if (elseValue) {
          parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
          return true;
        }
      }
    } else {
      let elseValue = this._until(4 /* CurlyClose */);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    }
    this._backTo(token);
    return false;
  }
  _parseAnything(marker) {
    if (this._token.type !== 14 /* EOF */) {
      marker.appendChild(new Text2(this._scanner.tokenText(this._token)));
      this._accept(void 0);
      return true;
    }
    return false;
  }
};

// ../cursorless-engine/src/snippets/vendor/vscodeSnippet/snippetVariables.ts
var KnownSnippetVariableNames = Object.freeze({
  "CURRENT_YEAR": true,
  "CURRENT_YEAR_SHORT": true,
  "CURRENT_MONTH": true,
  "CURRENT_DATE": true,
  "CURRENT_HOUR": true,
  "CURRENT_MINUTE": true,
  "CURRENT_SECOND": true,
  "CURRENT_DAY_NAME": true,
  "CURRENT_DAY_NAME_SHORT": true,
  "CURRENT_MONTH_NAME": true,
  "CURRENT_MONTH_NAME_SHORT": true,
  "CURRENT_SECONDS_UNIX": true,
  "SELECTION": true,
  "CLIPBOARD": true,
  "TM_SELECTED_TEXT": true,
  "TM_CURRENT_LINE": true,
  "TM_CURRENT_WORD": true,
  "TM_LINE_INDEX": true,
  "TM_LINE_NUMBER": true,
  "TM_FILENAME": true,
  "TM_FILENAME_BASE": true,
  "TM_DIRECTORY": true,
  "TM_FILEPATH": true,
  "RELATIVE_FILEPATH": true,
  "BLOCK_COMMENT_START": true,
  "BLOCK_COMMENT_END": true,
  "LINE_COMMENT": true,
  "WORKSPACE_NAME": true,
  "WORKSPACE_FOLDER": true,
  "RANDOM": true,
  "RANDOM_HEX": true,
  "UUID": true
});

// ../cursorless-engine/src/snippets/transformSnippetVariables.ts
function transformSnippetVariables(parsedSnippet, placeholderName, substitutions) {
  let nextPlaceholderIndex = getMaxPlaceholderIndex(parsedSnippet) + 1;
  const placeholderIndexMap = {};
  parsedSnippet.walk((candidate) => {
    if (candidate instanceof Variable) {
      if (candidate.name === placeholderName) {
        candidate.name = "TM_SELECTED_TEXT";
      } else if (substitutions != null && Object.prototype.hasOwnProperty.call(substitutions, candidate.name)) {
        candidate.parent.replace(candidate, [
          new Text2(substitutions[candidate.name])
        ]);
      } else if (!KnownSnippetVariableNames[candidate.name]) {
        let placeholderIndex;
        if (candidate.name in placeholderIndexMap) {
          placeholderIndex = placeholderIndexMap[candidate.name];
        } else {
          placeholderIndex = nextPlaceholderIndex++;
          placeholderIndexMap[candidate.name] = placeholderIndex;
        }
        const placeholder = new Placeholder(placeholderIndex);
        candidate.children.forEach((child) => placeholder.appendChild(child));
        candidate.parent.replace(candidate, [placeholder]);
      }
    } else if (candidate instanceof Placeholder) {
      if (candidate.index.toString() === placeholderName) {
        candidate.parent.replace(candidate, [new Variable("TM_SELECTED_TEXT")]);
      } else if (substitutions != null && Object.prototype.hasOwnProperty.call(substitutions, candidate.index)) {
        candidate.parent.replace(candidate, [
          new Text2(substitutions[candidate.index])
        ]);
      }
    }
    return true;
  });
}
function getMaxPlaceholderIndex(parsedSnippet) {
  let placeholderIndex = 0;
  parsedSnippet.walk((candidate) => {
    if (candidate instanceof Placeholder) {
      placeholderIndex = Math.max(placeholderIndex, candidate.index);
    }
    return true;
  });
  return placeholderIndex;
}

// ../cursorless-engine/src/actions/snippetsLegacy/snippet.ts
function transformSnippetVariables2(parsedSnippet, placeholderName, substitutions) {
  let nextPlaceholderIndex = getMaxPlaceholderIndex2(parsedSnippet) + 1;
  const placeholderIndexMap = {};
  parsedSnippet.walk((candidate) => {
    if (candidate instanceof Variable) {
      if (candidate.name === placeholderName) {
        candidate.name = "TM_SELECTED_TEXT";
      } else if (substitutions != null && Object.prototype.hasOwnProperty.call(substitutions, candidate.name)) {
        candidate.parent.replace(candidate, [
          new Text2(substitutions[candidate.name])
        ]);
      } else if (!KnownSnippetVariableNames[candidate.name]) {
        let placeholderIndex;
        if (candidate.name in placeholderIndexMap) {
          placeholderIndex = placeholderIndexMap[candidate.name];
        } else {
          placeholderIndex = nextPlaceholderIndex++;
          placeholderIndexMap[candidate.name] = placeholderIndex;
        }
        const placeholder = new Placeholder(placeholderIndex);
        candidate.children.forEach((child) => placeholder.appendChild(child));
        candidate.parent.replace(candidate, [placeholder]);
      }
    } else if (candidate instanceof Placeholder) {
      if (candidate.index.toString() === placeholderName) {
        candidate.parent.replace(candidate, [new Variable("TM_SELECTED_TEXT")]);
      }
    }
    return true;
  });
}
function getMaxPlaceholderIndex2(parsedSnippet) {
  let placeholderIndex = 0;
  parsedSnippet.walk((candidate) => {
    if (candidate instanceof Placeholder) {
      placeholderIndex = Math.max(placeholderIndex, candidate.index);
    }
    return true;
  });
  return placeholderIndex;
}
function findMatchingSnippetDefinitionStrict(modifierStageFactory, targets, definitions) {
  const definitionIndices = targets.map(
    (target) => findMatchingSnippetDefinitionForSingleTarget(
      modifierStageFactory,
      target,
      definitions
    )
  );
  const definitionIndex = definitionIndices[0];
  if (!definitionIndices.every((index) => index === definitionIndex)) {
    throw new Error("Multiple snippet definitions match the given context");
  }
  if (definitionIndex === -1) {
    throw new Error("Couldn't find matching snippet definition");
  }
  return definitions[definitionIndex];
}
function findMatchingSnippetDefinitionForSingleTarget(modifierStageFactory, target, definitions) {
  const languageId = target.editor.document.languageId;
  const options2 = {
    multipleTargets: false
  };
  return definitions.findIndex(({ scope }) => {
    if (scope == null) {
      return true;
    }
    const { langIds, scopeTypes, excludeDescendantScopeTypes } = scope;
    if (langIds != null && !langIds.includes(languageId)) {
      return false;
    }
    if (scopeTypes != null) {
      const allScopeTypes = scopeTypes.concat(
        excludeDescendantScopeTypes ?? []
      );
      let matchingTarget = void 0;
      let matchingScopeType = void 0;
      for (const scopeTypeType of allScopeTypes) {
        try {
          let containingTarget = modifierStageFactory.create({
            type: "containingScope",
            scopeType: { type: scopeTypeType }
          }).run(target, options2)[0];
          if (target.contentRange.isRangeEqual(containingTarget.contentRange)) {
            containingTarget = modifierStageFactory.create({
              type: "containingScope",
              scopeType: { type: scopeTypeType },
              ancestorIndex: 1
            }).run(target, options2)[0];
          }
          if (matchingTarget == null || matchingTarget.contentRange.contains(containingTarget.contentRange)) {
            matchingTarget = containingTarget;
            matchingScopeType = scopeTypeType;
          }
        } catch (_e) {
          continue;
        }
      }
      if (matchingScopeType == null) {
        return false;
      }
      return matchingTarget != null && !(excludeDescendantScopeTypes ?? []).includes(matchingScopeType);
    }
    return true;
  });
}

// ../cursorless-engine/src/actions/snippetsLegacy/legacySnippetsNotification.ts
var wasShown = false;
function showLegacySnippetsNotification() {
  if (wasShown) {
    return;
  }
  void showWarning(
    ide().messages,
    "legacySnippets",
    "Talon community snippets are now fully supported in Cursorless! Cursorless's experimental snippets are now deprecated, but in most cases we can help you migrate automatically. Update cursorless-talon and say 'cursorless migrate snippets'."
  );
  wasShown = true;
}

// ../cursorless-engine/src/actions/snippetsLegacy/textFormatters.ts
var textFormatters = {
  camelCase(tokens2) {
    if (tokens2.length === 0) {
      return "";
    }
    const [first, ...rest] = tokens2;
    return first + rest.map(capitalizeToken).join("");
  },
  snakeCase(tokens2) {
    return tokens2.join("_");
  },
  upperSnakeCase(tokens2) {
    return tokens2.map((token) => token.toUpperCase()).join("_");
  },
  pascalCase(tokens2) {
    return tokens2.map(capitalizeToken).join("");
  }
};
function capitalizeToken(token) {
  return token.length === 0 ? "" : token[0].toUpperCase() + token.substr(1);
}

// ../cursorless-engine/src/actions/snippetsLegacy/InsertSnippetLegacy.ts
var InsertSnippetLegacy = class {
  constructor(rangeUpdater, snippets, actions, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.snippets = snippets;
    this.actions = actions;
    this.modifierStageFactory = modifierStageFactory;
    this.snippetParser = new SnippetParser();
    this.run = this.run.bind(this);
  }
  getFinalStages(snippetDescription) {
    const defaultScopeTypes = this.getScopeTypes(snippetDescription);
    return defaultScopeTypes.length === 0 ? [] : [
      new ModifyIfUntypedExplicitStage(this.modifierStageFactory, {
        type: "cascading",
        modifiers: defaultScopeTypes.map((scopeType) => ({
          type: "containingScope",
          scopeType
        }))
      })
    ];
  }
  getScopeTypes(snippetDescription) {
    const { name: name2 } = snippetDescription;
    const snippet2 = this.snippets.getSnippetStrict(name2);
    const scopeTypeTypes = snippet2.insertionScopeTypes;
    return scopeTypeTypes == null ? [] : scopeTypeTypes.map((scopeTypeType) => ({
      type: scopeTypeType
    }));
  }
  getSnippetInfo(snippetDescription, targets) {
    const { name: name2 } = snippetDescription;
    const snippet2 = this.snippets.getSnippetStrict(name2);
    const definition = findMatchingSnippetDefinitionStrict(
      this.modifierStageFactory,
      targets,
      snippet2.definitions
    );
    return {
      body: definition.body.join("\n"),
      formatSubstitutions(substitutions) {
        return substitutions == null ? void 0 : formatSubstitutions(snippet2, definition, substitutions);
      }
    };
  }
  async run(destinations, snippetDescription) {
    showLegacySnippetsNotification();
    const editor = ide().getEditableTextEditor(
      ensureSingleEditor(destinations)
    );
    await this.actions.editNew.run(destinations);
    const { body: body2, formatSubstitutions: formatSubstitutions2 } = this.getSnippetInfo(
      snippetDescription,
      // Use new selection locations instead of original targets because
      // that's where we'll be doing the snippet insertion
      editor.selections.map(
        (selection) => new UntypedTarget({
          editor,
          contentRange: selection,
          isReversed: false,
          hasExplicitRange: true
        })
      )
    );
    const parsedSnippet = this.snippetParser.parse(body2);
    transformSnippetVariables2(
      parsedSnippet,
      null,
      formatSubstitutions2(snippetDescription.substitutions)
    );
    const snippetString = parsedSnippet.toTextmateString();
    const { editorSelections: updatedThatSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      callback: () => editor.insertSnippet(snippetString),
      preserveCursorSelections: true,
      selections: {
        editorSelections: {
          selections: editor.selections,
          behavior: 0 /* openOpen */
        }
      }
    });
    return {
      thatSelections: updatedThatSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
};
function formatSubstitutions(snippet2, definition, substitutions) {
  return Object.fromEntries(
    Object.entries(substitutions).map(([variableName, value]) => {
      const formatterName = (definition.variables ?? {})[variableName]?.formatter ?? (snippet2.variables ?? {})[variableName]?.formatter;
      if (formatterName == null) {
        return [variableName, value];
      }
      const formatter = textFormatters[formatterName];
      if (formatter == null) {
        throw new Error(
          `Couldn't find formatter ${formatterName} for variable ${variableName}`
        );
      }
      return [variableName, formatter(value.split(" "))];
    })
  );
}

// ../cursorless-engine/src/actions/InsertSnippet.ts
var InsertSnippet = class {
  constructor(rangeUpdater, snippets, actions, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.snippets = snippets;
    this.actions = actions;
    this.modifierStageFactory = modifierStageFactory;
    this.snippetParser = new SnippetParser();
    this.run = this.run.bind(this);
  }
  getFinalStages(destinations, snippetDescription) {
    if (snippetDescription.type === "named") {
      return this.legacy().getFinalStages(snippetDescription);
    }
    const editor = ensureSingleEditor(destinations);
    const snippet2 = getPreferredSnippet(
      snippetDescription,
      editor.document.languageId
    );
    const defaultScopeTypes = snippet2.scopeTypes ?? [];
    return defaultScopeTypes.length === 0 ? [] : [
      new ModifyIfUntypedExplicitStage(this.modifierStageFactory, {
        type: "cascading",
        modifiers: defaultScopeTypes.map((scopeType) => ({
          type: "containingScope",
          scopeType
        }))
      })
    ];
  }
  async run(destinations, snippetDescription) {
    if (snippetDescription.type === "named") {
      return this.legacy().run(destinations, snippetDescription);
    }
    const editor = ide().getEditableTextEditor(
      ensureSingleEditor(destinations)
    );
    const snippet2 = getPreferredSnippet(
      snippetDescription,
      editor.document.languageId
    );
    const parsedSnippet = this.snippetParser.parse(snippet2.body);
    const substitutions = snippet2.substitutions ?? snippetDescription.substitutions;
    transformSnippetVariables(parsedSnippet, null, substitutions);
    const snippetString = parsedSnippet.toTextmateString();
    await this.actions.editNew.run(destinations);
    const { editorSelections: updatedThatSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      callback: () => editor.insertSnippet(snippetString),
      preserveCursorSelections: true,
      selections: {
        editorSelections: {
          selections: editor.selections,
          behavior: 0 /* openOpen */
        }
      }
    });
    return {
      thatSelections: updatedThatSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
  // DEPRECATED @ 2025-02-01
  legacy() {
    return new InsertSnippetLegacy(
      this.rangeUpdater,
      this.snippets,
      this.actions,
      this.modifierStageFactory
    );
  }
};

// ../cursorless-engine/src/actions/JoinLines.ts
var JoinLines = class {
  constructor(rangeUpdater, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.run = this.run.bind(this);
  }
  getFinalStages() {
    return [this.modifierStageFactory.create(containingLineIfUntypedModifier)];
  }
  async run(targets) {
    await flashTargets(
      ide(),
      targets.map(({ thatTarget }) => thatTarget),
      "pendingModification0" /* pendingModification0 */
    );
    const thatSelections = flatten_default(
      await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
        const { thatRanges: updatedThatRanges } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits: getEdits2(editor, targets2),
          selections: {
            thatRanges: targets2.map(({ contentRange }) => contentRange)
          }
        });
        return zipStrict(targets2, updatedThatRanges).map(([target, range3]) => ({
          editor,
          selection: range3.toSelection(target.isReversed)
        }));
      })
    );
    return { thatSelections };
  }
};
function getEdits2(editor, targets) {
  const edits = [];
  for (const target of targets) {
    const targetsEdits = target.textualType === "token" ? getTokenTargetEdits(target) : getLineTargetEdits(target);
    edits.push(...targetsEdits);
  }
  return edits;
}
function getTokenTargetEdits(target) {
  const { editor, contentRange } = target;
  const regex = getMatcher(editor.document.languageId).tokenMatcher;
  const matches = generateMatchesInRange(
    regex,
    editor,
    contentRange,
    "forward"
  );
  return Array.from(pairwise(matches)).map(
    ([range1, range22]) => ({
      range: new Range(range1.end, range22.start),
      text: "",
      isReplace: true
    })
  );
}
function getLineTargetEdits(target) {
  const { document: document2 } = target.editor;
  const range3 = target.contentRange;
  const startLine = range3.start.line;
  const endLine = range3.isSingleLine ? Math.min(startLine + 1, document2.lineCount - 1) : range3.end.line;
  const lines = map2(
    range2(startLine, endLine + 1),
    (i2) => document2.lineAt(i2)
  );
  return Array.from(pairwise(lines)).map(
    ([line1, line2]) => ({
      range: new Range(
        line1.rangeTrimmed?.end ?? line1.range.end,
        line2.rangeTrimmed?.start ?? line2.range.start
      ),
      text: line2.isEmptyOrWhitespace ? "" : " ",
      isReplace: true
    })
  );
}

// ../cursorless-engine/src/actions/PasteFromClipboardUsingCommand.ts
var PasteFromClipboardUsingCommand = class {
  constructor(rangeUpdater, actions) {
    this.rangeUpdater = rangeUpdater;
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(destinations) {
    const editor = ide().getEditableTextEditor(
      ensureSingleEditor(destinations)
    );
    const originalEditor = ide().activeEditableTextEditor;
    const callbackEdit = async () => {
      await this.actions.editNew.run(destinations);
    };
    const { cursorSelections: originalCursorSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      preserveCursorSelections: true,
      callback: callbackEdit,
      selections: {
        cursorSelections: editor.selections
      }
    });
    const {
      originalCursorSelections: updatedCursorSelections,
      editorSelections: updatedTargetSelections
    } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      callback: () => editor.clipboardPaste(),
      selections: {
        originalCursorSelections,
        editorSelections: {
          selections: editor.selections,
          behavior: 0 /* openOpen */
        }
      }
    });
    await editor.setSelections(updatedCursorSelections);
    if (originalEditor != null && !originalEditor.isActive) {
      await originalEditor.focus();
    }
    await ide().flashRanges(
      updatedTargetSelections.map((selection) => ({
        editor,
        range: toCharacterRange(selection),
        style: "justAdded" /* justAdded */
      }))
    );
    return {
      thatSelections: updatedTargetSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
};

// ../cursorless-engine/src/actions/PasteFromClipboardDirectly.ts
var PasteFromClipboardDirectly = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(destinations) {
    const text = await ide().clipboard.readText();
    const textLines = text.split(/\r?\n/g);
    const destinationsWithText = destinations.length === textLines.length ? zipStrict(destinations, textLines).map(([destination, text2]) => ({
      destination,
      text: text2
    })) : destinations.map((destination) => ({ destination, text }));
    const thatSelections = flatten_default(
      await runForEachEditor(
        destinationsWithText,
        ({ destination }) => destination.editor,
        this.runForEditor
      )
    );
    return { thatSelections };
  }
  async runForEditor(editor, destinationsWithText) {
    const edits = destinationsWithText.map(
      ({ destination, text }) => destination.constructChangeEdit(text)
    );
    const { editSelections: updatedEditSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: ide().getEditableTextEditor(editor),
      edits,
      selections: {
        editSelections: {
          selections: edits.map(({ range: range3 }) => range3),
          behavior: 0 /* openOpen */
        }
      }
    });
    const thatTargetSelections = zipStrict(edits, updatedEditSelections).map(
      ([edit, selection]) => edit.updateRange(selection).toSelection(selection.isReversed)
    );
    await ide().flashRanges(
      thatTargetSelections.map((selection) => ({
        editor,
        range: toCharacterRange(selection),
        style: "justAdded" /* justAdded */
      }))
    );
    return thatTargetSelections.map((selection) => ({
      editor,
      selection
    }));
  }
};

// ../cursorless-engine/src/actions/PasteFromClipboard.ts
var PasteFromClipboard = class {
  constructor(rangeUpdater, actions) {
    this.run = this.run.bind(this);
    this.runner = ide().capabilities.commands.clipboardPaste != null ? new PasteFromClipboardUsingCommand(rangeUpdater, actions) : new PasteFromClipboardDirectly(rangeUpdater);
  }
  run(destinations) {
    return this.runner.run(destinations);
  }
};

// ../cursorless-engine/src/actions/Remove.ts
var Delete = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(targets, { showDecorations = true } = {}) {
    targets = unifyRemovalTargets(targets);
    if (showDecorations) {
      await flashTargets(
        ide(),
        targets,
        "pendingDelete" /* pendingDelete */,
        (target) => target.getRemovalHighlightRange()
      );
    }
    const thatTargets = flatten_default(
      await runOnTargetsForEachEditor(targets, this.runForEditor)
    );
    return { thatTargets };
  }
  async runForEditor(editor, targets) {
    const edits = targets.map((target) => target.constructRemovalEdit());
    const editableEditor = ide().getEditableTextEditor(editor);
    const { editRanges: updatedEditRanges } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor: editableEditor,
      edits,
      selections: {
        editRanges: edits.map(({ range: range3 }) => range3)
      }
    });
    return zip_default(targets, updatedEditRanges).map(
      ([target, range3]) => new RawSelectionTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: range3
      })
    );
  }
};

// ../cursorless-engine/src/actions/Replace.ts
var Replace = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  getTexts(destinations, replaceWith) {
    if (Array.isArray(replaceWith)) {
      if (replaceWith.length === 1) {
        return Array(destinations.length).fill(replaceWith[0]);
      }
      return replaceWith;
    }
    const numbers2 = [];
    for (let i2 = 0; i2 < destinations.length; ++i2) {
      numbers2[i2] = (replaceWith.start + i2).toString();
    }
    return numbers2;
  }
  async run(destinations, replaceWith) {
    await flashTargets(
      ide(),
      destinations.map((d) => d.target),
      "pendingModification0" /* pendingModification0 */
    );
    const texts = this.getTexts(destinations, replaceWith);
    if (destinations.length !== texts.length) {
      throw new Error("Targets and texts must have same length");
    }
    const edits = zip_default(destinations, texts).map(([destination, text]) => ({
      editor: destination.editor,
      target: destination.target,
      edit: destination.constructChangeEdit(text)
    }));
    const sourceTargets = [];
    const thatSelections = [];
    await runForEachEditor(
      edits,
      (edit) => edit.editor,
      async (editor, editWrappers) => {
        const edits2 = editWrappers.map(({ edit }) => edit);
        const {
          contentSelections: updatedContentSelections,
          editRanges: updatedEditRanges
        } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits: edits2,
          selections: {
            contentSelections: editWrappers.map(
              ({ target }) => target.contentSelection
            ),
            editRanges: {
              selections: edits2.map(({ range: range3 }) => range3),
              behavior: 0 /* openOpen */
            }
          }
        });
        for (const [wrapper, selection] of zip_default(
          editWrappers,
          updatedContentSelections
        )) {
          sourceTargets.push(wrapper.target.withContentRange(selection));
        }
        for (const [wrapper, range3] of zip_default(editWrappers, updatedEditRanges)) {
          thatSelections.push({
            editor,
            selection: wrapper.edit.updateRange(range3).toSelection(false)
          });
        }
      }
    );
    return { sourceTargets, thatSelections };
  }
};

// ../cursorless-engine/src/actions/Rewrap.ts
var Rewrap = class {
  constructor(rangeUpdater, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.getFinalStages = () => [
      getContainingSurroundingPairIfNoBoundaryStage(this.modifierStageFactory)
    ];
    this.run = this.run.bind(this);
  }
  async run(targets, left, right) {
    const boundaryTargets = targets.flatMap((target) => {
      const boundary = target.getBoundary();
      if (boundary.length !== 2) {
        throw Error("Target must have an opening and closing delimiter");
      }
      return boundary;
    });
    await flashTargets(ide(), boundaryTargets, "pendingModification0" /* pendingModification0 */);
    const results = await runOnTargetsForEachEditor(
      boundaryTargets,
      async (editor, boundaryTargets2) => {
        const edits = boundaryTargets2.map((target, i2) => ({
          editor,
          range: target.contentRange,
          text: i2 % 2 === 0 ? left : right
        }));
        const {
          sourceRanges: updatedSourceRanges,
          thatRanges: updatedThatRanges
        } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits,
          selections: {
            sourceRanges: targets.map(
              (target) => target.thatTarget.contentRange
            ),
            thatRanges: targets.map((target) => target.contentRange)
          }
        });
        return {
          sourceMark: createThatMark(targets, updatedSourceRanges),
          thatMark: createThatMark(targets, updatedThatRanges)
        };
      }
    );
    return {
      sourceSelections: results.flatMap(({ sourceMark }) => sourceMark),
      thatSelections: results.flatMap(({ thatMark }) => thatMark)
    };
  }
};

// ../cursorless-engine/src/actions/Scroll.ts
var Scroll = class {
  constructor(at) {
    this.at = at;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const selectionGroups = groupBy(targets, (t) => t.editor);
    const lines = Array.from(selectionGroups, ([editor, targets2]) => {
      return { lineNumber: getLineNumber(targets2, this.at), editor };
    });
    const originalEditor = ide().activeEditableTextEditor;
    for (const lineWithEditor of lines) {
      await ide().getEditableTextEditor(lineWithEditor.editor).revealLine(lineWithEditor.lineNumber, this.at);
    }
    if (originalEditor != null && !originalEditor.isActive) {
      await originalEditor.focus();
    }
    const decorationTargets = targets.filter((target) => {
      const visibleRanges = target.editor.visibleRanges;
      const startLine = visibleRanges[0].start.line;
      const endLine = visibleRanges[visibleRanges.length - 1].end.line;
      return target.contentRange.start.line > startLine || target.contentRange.end.line < endLine || target.contentRange.start.line === startLine && target.contentRange.end.line === endLine;
    });
    await ide().flashRanges(
      decorationTargets.map((target) => ({
        editor: target.editor,
        range: toLineRange(target.contentRange),
        style: "referenced" /* referenced */
      }))
    );
    return {
      thatTargets: targets
    };
  }
};
var ScrollToTop = class extends Scroll {
  constructor() {
    super("top" /* top */);
  }
};
var ScrollToCenter = class extends Scroll {
  constructor() {
    super("center" /* center */);
  }
};
var ScrollToBottom = class extends Scroll {
  constructor() {
    super("bottom" /* bottom */);
  }
};
function getLineNumber(targets, at) {
  let startLine = Number.MAX_SAFE_INTEGER;
  let endLine = 0;
  targets.forEach((target) => {
    startLine = Math.min(startLine, target.contentRange.start.line);
    endLine = Math.max(endLine, target.contentRange.end.line);
  });
  if (at === "top" /* top */) {
    return startLine;
  }
  if (at === "bottom" /* bottom */) {
    return endLine;
  }
  return Math.floor((startLine + endLine) / 2);
}

// ../cursorless-engine/src/actions/SetSelection.ts
var SetSelectionBase = class {
  constructor(selectionMode, rangeMode) {
    this.selectionMode = selectionMode;
    this.rangeMode = rangeMode;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const editor = ensureSingleEditor(targets);
    const targetSelections = this.getSelections(targets);
    const selections = this.selectionMode === "add" ? editor.selections.concat(targetSelections) : targetSelections;
    const highlightWord = this.selectionMode === "set" && selections.length === 1 && selections[0].isEmpty;
    await ide().getEditableTextEditor(editor).setSelections(selections, { focusEditor: true, highlightWord });
    return {
      thatTargets: targets
    };
  }
  getSelections(targets) {
    switch (this.rangeMode) {
      case "content":
        return targets.map((target) => target.contentSelection);
      case "before":
        return targets.map(
          (target) => new Selection(target.contentRange.start, target.contentRange.start)
        );
      case "after":
        return targets.map(
          (target) => new Selection(target.contentRange.end, target.contentRange.end)
        );
    }
  }
};
var SetSelection = class extends SetSelectionBase {
  constructor() {
    super("set", "content");
  }
};
var SetSelectionBefore = class extends SetSelectionBase {
  constructor() {
    super("set", "before");
  }
};
var SetSelectionAfter = class extends SetSelectionBase {
  constructor() {
    super("set", "after");
  }
};
var AddSelection = class extends SetSelectionBase {
  constructor() {
    super("add", "content");
  }
};
var AddSelectionBefore = class extends SetSelectionBase {
  constructor() {
    super("add", "before");
  }
};
var AddSelectionAfter = class extends SetSelectionBase {
  constructor() {
    super("add", "after");
  }
};

// ../cursorless-engine/src/actions/SetSpecialTarget.ts
var SetSpecialTarget = class {
  constructor(key) {
    this.key = key;
    this.noAutomaticTokenExpansion = true;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    return {
      thatTargets: targets,
      [`${this.key}Targets`]: targets
    };
  }
};

// ../cursorless-engine/src/actions/ShowParseTree.ts
var ShowParseTree = class {
  constructor(treeSitter) {
    this.treeSitter = treeSitter;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await flashTargets(ide(), targets, "referenced" /* referenced */);
    const results = ["# Cursorless parse tree"];
    for (const target of targets) {
      const { editor, contentRange } = target;
      const tree = this.treeSitter.getTree(editor.document);
      results.push(parseTree(editor.document, tree, contentRange));
    }
    void ide().openUntitledTextDocument({
      language: "markdown",
      content: results.join("\n\n")
    });
    return { thatTargets: targets };
  }
};
function parseTree(document2, tree, contentRange) {
  const resultPlayground = [];
  const resultQuery = [];
  parseCursor(resultPlayground, resultQuery, contentRange, tree.walk(), 0);
  return [
    `## ${document2.filename} [${contentRange}]
`,
    `\`\`\`${document2.languageId}`,
    document2.getText(contentRange),
    "```",
    "",
    "```scm",
    ...resultQuery,
    "```",
    "",
    "```js",
    ...resultPlayground,
    "```",
    ""
  ].join("\n");
}
function parseCursor(resultPlayground, resultQuery, contentRange, cursor, numIndents) {
  while (true) {
    const nodeRange = new Range(
      cursor.startPosition.row,
      cursor.startPosition.column,
      cursor.endPosition.row,
      cursor.endPosition.column
    );
    if (contentRange.intersection(nodeRange) != null) {
      const indentation = "  ".repeat(numIndents);
      const fieldName = getFieldName(cursor);
      const prefix = indentation + fieldName;
      if (cursor.nodeIsNamed) {
        resultPlayground.push(`${prefix}${cursor.nodeType} [${nodeRange}]`);
        resultQuery.push(`${prefix}(${cursor.nodeType}`);
        if (cursor.gotoFirstChild()) {
          parseCursor(
            resultPlayground,
            resultQuery,
            contentRange,
            cursor,
            numIndents + 1
          );
          cursor.gotoParent();
          resultQuery.push(`${indentation})`);
        } else {
          resultQuery[resultQuery.length - 1] += ")";
        }
      } else {
        const type2 = `"${cursor.nodeType}"`;
        resultPlayground.push(`${prefix}${type2} [${nodeRange}]`);
        resultQuery.push(`${prefix}${type2}`);
      }
    }
    if (!cursor.gotoNextSibling()) {
      return;
    }
  }
}
function getFieldName(cursor) {
  const field = cursor.currentFieldName;
  return field != null ? `${field}: ` : "";
}

// ../cursorless-engine/src/actions/Sort.ts
var SortBase = class {
  constructor(actions) {
    this.actions = actions;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    if (targets.length < 2) {
      void showWarning(
        ide().messages,
        "tooFewTargets",
        'This action works on multiple targets, e.g. "sort every line block" instead of "sort block".'
      );
    }
    const sortedTargets = targets.slice().sort((a, b) => a.contentRange.start.compareTo(b.contentRange.start));
    const { returnValue: unsortedTexts } = await this.actions.getText.run(
      sortedTargets,
      {
        showDecorations: false
      }
    );
    const sortedTexts = this.sortTexts(unsortedTexts);
    const { thatSelections } = await this.actions.replace.run(
      sortedTargets.map((target) => target.toDestination("to")),
      sortedTexts
    );
    return { thatSelections };
  }
};
var Sort = class extends SortBase {
  sortTexts(texts) {
    return texts.sort(
      (a, b) => a.localeCompare(b, void 0, {
        numeric: true,
        caseFirst: "upper"
      })
    );
  }
};
var Reverse = class extends SortBase {
  sortTexts(texts) {
    return texts.reverse();
  }
};
var Random = class extends SortBase {
  sortTexts(texts) {
    return shuffle_default(texts);
  }
};

// ../cursorless-engine/src/actions/ToggleBreakpoint.ts
var ToggleBreakpoint = class {
  constructor(modifierStageFactory) {
    this.modifierStageFactory = modifierStageFactory;
    this.getFinalStages = () => [
      this.modifierStageFactory.create(containingLineIfUntypedModifier)
    ];
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const thatTargets = targets.map(({ thatTarget }) => thatTarget);
    await flashTargets(ide(), thatTargets, "referenced" /* referenced */);
    await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
      const generalizedRanges = targets2.map(
        (target) => toGeneralizedRange(target, target.contentRange)
      );
      await ide().getEditableTextEditor(editor).toggleBreakpoint(generalizedRanges);
    });
    return {
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/Wrap.ts
var Wrap = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets, left, right) {
    const results = await runOnTargetsForEachEditor(
      targets,
      async (editor, targets2) => {
        const boundaries = targets2.map((target) => ({
          start: new Selection(
            target.contentRange.start,
            target.contentRange.start
          ),
          end: new Selection(target.contentRange.end, target.contentRange.end)
        }));
        const edits = boundaries.flatMap(({ start: start2, end }) => [
          {
            text: left,
            range: start2
          },
          {
            text: right,
            range: end,
            isReplace: true
          }
        ]);
        const contentSelections = targets2.map(
          (target) => target.contentSelection
        );
        const {
          boundariesStartSelections: delimiterStartSelections,
          boundariesEndSelections: delimiterEndSelections,
          sourceSelections: sourceMarkSelections,
          thatSelections: thatMarkSelections
        } = await performEditsAndUpdateSelections({
          rangeUpdater: this.rangeUpdater,
          editor: ide().getEditableTextEditor(editor),
          edits,
          selections: {
            boundariesStartSelections: {
              selections: boundaries.map(({ start: start2 }) => start2),
              behavior: 2 /* openClosed */
            },
            boundariesEndSelections: {
              selections: boundaries.map(({ end }) => end),
              behavior: 3 /* closedOpen */
            },
            sourceSelections: {
              selections: contentSelections,
              behavior: 1 /* closedClosed */
            },
            thatSelections: {
              selections: contentSelections,
              behavior: 0 /* openOpen */
            }
          }
        });
        const delimiterSelections = [
          ...delimiterStartSelections,
          ...delimiterEndSelections
        ];
        await ide().flashRanges(
          delimiterSelections.map((selection) => ({
            editor,
            range: toCharacterRange(selection),
            style: "justAdded" /* justAdded */
          }))
        );
        return {
          sourceMark: sourceMarkSelections.map((selection) => ({
            editor,
            selection
          })),
          thatMark: thatMarkSelections.map((selection) => ({
            editor,
            selection
          }))
        };
      }
    );
    return {
      sourceSelections: results.flatMap(({ sourceMark }) => sourceMark),
      thatSelections: results.flatMap(({ thatMark }) => thatMark)
    };
  }
};

// ../cursorless-engine/src/actions/snippetsLegacy/WrapWithSnippetLegacy.ts
var WrapWithSnippetLegacy = class {
  constructor(rangeUpdater, snippets, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.snippets = snippets;
    this.modifierStageFactory = modifierStageFactory;
    this.snippetParser = new SnippetParser();
    this.run = this.run.bind(this);
  }
  getFinalStages(snippet2) {
    const defaultScopeType = this.getScopeType(snippet2);
    if (defaultScopeType == null) {
      return [];
    }
    return [
      new ModifyIfUntypedStage(this.modifierStageFactory, {
        type: "modifyIfUntyped",
        modifier: {
          type: "containingScope",
          scopeType: defaultScopeType
        }
      })
    ];
  }
  getScopeType(snippetDescription) {
    const { name: name2, variableName } = snippetDescription;
    const snippet2 = this.snippets.getSnippetStrict(name2);
    const variables = snippet2.variables ?? {};
    const scopeTypeType = variables[variableName]?.wrapperScopeType;
    return scopeTypeType == null ? void 0 : {
      type: scopeTypeType
    };
  }
  getBody(snippetDescription, targets) {
    const { name: name2 } = snippetDescription;
    const snippet2 = this.snippets.getSnippetStrict(name2);
    const definition = findMatchingSnippetDefinitionStrict(
      this.modifierStageFactory,
      targets,
      snippet2.definitions
    );
    return definition.body.join("\n");
  }
  async run(targets, snippetDescription) {
    showLegacySnippetsNotification();
    const editor = ide().getEditableTextEditor(ensureSingleEditor(targets));
    const body2 = this.getBody(snippetDescription, targets);
    const parsedSnippet = this.snippetParser.parse(body2);
    transformSnippetVariables2(parsedSnippet, snippetDescription.variableName);
    const snippetString = parsedSnippet.toTextmateString();
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const targetSelections = targets.map((target) => target.contentSelection);
    const callback2 = () => editor.insertSnippet(snippetString, targetSelections);
    const { targetSelections: updatedTargetSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      callback: callback2,
      preserveCursorSelections: true,
      selections: {
        targetSelections
      }
    });
    return {
      thatSelections: updatedTargetSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
};

// ../cursorless-engine/src/actions/WrapWithSnippet.ts
var WrapWithSnippet = class {
  constructor(rangeUpdater, snippets, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.snippets = snippets;
    this.modifierStageFactory = modifierStageFactory;
    this.snippetParser = new SnippetParser();
    this.run = this.run.bind(this);
  }
  getFinalStages(targets, snippetDescription) {
    if (snippetDescription.type === "named") {
      return this.legacy().getFinalStages(snippetDescription);
    }
    const editor = ensureSingleEditor(targets);
    const snippet2 = getPreferredSnippet(
      snippetDescription,
      editor.document.languageId
    );
    if (snippet2.scopeType == null) {
      return [];
    }
    return [
      new ModifyIfUntypedStage(this.modifierStageFactory, {
        type: "modifyIfUntyped",
        modifier: {
          type: "containingScope",
          scopeType: snippet2.scopeType
        }
      })
    ];
  }
  async run(targets, snippetDescription) {
    if (snippetDescription.type === "named") {
      return this.legacy().run(targets, snippetDescription);
    }
    const editor = ide().getEditableTextEditor(ensureSingleEditor(targets));
    const snippet2 = getPreferredSnippet(
      snippetDescription,
      editor.document.languageId
    );
    const parsedSnippet = this.snippetParser.parse(snippet2.body);
    transformSnippetVariables(parsedSnippet, snippet2.variableName);
    const snippetString = parsedSnippet.toTextmateString();
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const targetSelections = targets.map((target) => target.contentSelection);
    const { targetSelections: updatedTargetSelections } = await performEditsAndUpdateSelections({
      rangeUpdater: this.rangeUpdater,
      editor,
      callback: () => editor.insertSnippet(snippetString, targetSelections),
      preserveCursorSelections: true,
      selections: {
        targetSelections
      }
    });
    return {
      thatSelections: updatedTargetSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
  // DEPRECATED @ 2025-02-01
  legacy() {
    return new WrapWithSnippetLegacy(
      this.rangeUpdater,
      this.snippets,
      this.modifierStageFactory
    );
  }
};

// ../cursorless-engine/src/actions/incrementDecrement.ts
var REGEX = /-?\d+(\.\d+)?/g;
var IncrementDecrement = class {
  constructor(actions, isIncrement) {
    this.actions = actions;
    this.isIncrement = isIncrement;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const thatSelections = [];
    await runForEachEditor(
      targets,
      (target) => target.editor,
      async (editor, targets2) => {
        const selections = await this.runOnEditor(editor, targets2);
        thatSelections.push(...selections);
      }
    );
    return { thatSelections };
  }
  async runOnEditor(editor, targets) {
    const { document: document2 } = editor;
    const destinations = [];
    const replaceWith = [];
    for (const target of targets) {
      const offset = document2.offsetAt(target.contentRange.start);
      const text = target.contentText;
      const matches = matchText(text, REGEX);
      for (const match of matches) {
        destinations.push(createDestination(editor, offset, match));
        replaceWith.push(updateNumber(this.isIncrement, match.text));
      }
    }
    const { thatSelections } = await this.actions.replace.run(
      destinations,
      replaceWith
    );
    return thatSelections;
  }
};
var Increment = class extends IncrementDecrement {
  constructor(actions) {
    super(actions, true);
  }
};
var Decrement = class extends IncrementDecrement {
  constructor(actions) {
    super(actions, false);
  }
};
function createDestination(editor, offset, match) {
  const target = new PlainTarget({
    editor,
    isReversed: false,
    contentRange: new Range(
      editor.document.positionAt(offset + match.index),
      editor.document.positionAt(offset + match.index + match.text.length)
    )
  });
  return target.toDestination("to");
}
function updateNumber(isIncrement, text) {
  return text.includes(".") ? updateFloat(isIncrement, text).toString() : updateInteger(isIncrement, text).toString();
}
function updateInteger(isIncrement, text) {
  const original = parseInt(text);
  const diff = 1;
  return original + (isIncrement ? diff : -diff);
}
function updateFloat(isIncrement, text) {
  const original = parseFloat(text);
  const isPercentage = Math.abs(original) <= 1;
  const diff = isPercentage ? 0.1 : 1;
  const updated = original + (isIncrement ? diff : -diff);
  return parseFloat(updated.toPrecision(15)) / 1;
}

// ../cursorless-engine/src/actions/Actions.ts
var Actions = class {
  constructor(treeSitter, snippets, rangeUpdater, modifierStageFactory) {
    this.addSelection = new AddSelection();
    this.addSelectionBefore = new AddSelectionBefore();
    this.addSelectionAfter = new AddSelectionAfter();
    this.callAsFunction = new Call(this);
    this.clearAndSetSelection = new Clear(this);
    this.copyToClipboard = new CopyToClipboard(this, rangeUpdater);
    this.cutToClipboard = new CutToClipboard(this);
    this.decrement = new Decrement(this);
    this.deselect = new Deselect();
    this.editNew = new EditNew(rangeUpdater, this);
    this.editNewLineAfter = new EditNewAfter(this, modifierStageFactory);
    this.editNewLineBefore = new EditNewBefore(this, modifierStageFactory);
    this.executeCommand = new ExecuteCommand(rangeUpdater);
    this.extractVariable = new ExtractVariable(rangeUpdater);
    this.findInDocument = new FindInDocument(this);
    this.findInWorkspace = new FindInWorkspace(this);
    this.flashTargets = new FlashTargets();
    this.foldRegion = new Fold(rangeUpdater);
    this.followLink = new FollowLink({ openAside: false });
    this.followLinkAside = new FollowLink({ openAside: true });
    this.generateSnippet = new GenerateSnippet(snippets);
    this.getText = new GetText();
    this.gitAccept = new GitAccept(rangeUpdater);
    this.gitRevert = new GitRevert(rangeUpdater);
    this.gitStage = new GitStage(rangeUpdater);
    this.gitUnstage = new GitUnstage(rangeUpdater);
    this.highlight = new Highlight();
    this.increment = new Increment(this);
    this.indentLine = new IndentLine(rangeUpdater);
    this.insertCopyAfter = new CopyContentAfter(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertCopyBefore = new CopyContentBefore(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertEmptyLineAfter = new InsertEmptyLineBelow(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertEmptyLineBefore = new InsertEmptyLineAbove(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertEmptyLinesAround = new InsertEmptyLinesAround(
      rangeUpdater,
      modifierStageFactory
    );
    this.insertSnippet = new InsertSnippet(
      rangeUpdater,
      snippets,
      this,
      modifierStageFactory
    );
    this.joinLines = new JoinLines(rangeUpdater, modifierStageFactory);
    this.breakLine = new BreakLine(rangeUpdater);
    this.moveToTarget = new Move(rangeUpdater);
    this.outdentLine = new OutdentLine(rangeUpdater);
    this.pasteFromClipboard = new PasteFromClipboard(rangeUpdater, this);
    this.randomizeTargets = new Random(this);
    this.remove = new Delete(rangeUpdater);
    this.rename = new Rename(rangeUpdater);
    this.replace = new Replace(rangeUpdater);
    this.replaceWithTarget = new Bring(rangeUpdater);
    this.revealDefinition = new RevealDefinition(rangeUpdater);
    this.revealTypeDefinition = new RevealTypeDefinition(rangeUpdater);
    this.reverseTargets = new Reverse(this);
    this.rewrapWithPairedDelimiter = new Rewrap(
      rangeUpdater,
      modifierStageFactory
    );
    this.scrollToBottom = new ScrollToBottom();
    this.scrollToCenter = new ScrollToCenter();
    this.scrollToTop = new ScrollToTop();
    this.setSelection = new SetSelection();
    this.setSelectionAfter = new SetSelectionAfter();
    this.setSelectionBefore = new SetSelectionBefore();
    this.showDebugHover = new ShowDebugHover(rangeUpdater);
    this.showHover = new ShowHover(rangeUpdater);
    this.showQuickFix = new ShowQuickFix(rangeUpdater);
    this.showReferences = new ShowReferences(rangeUpdater);
    this.sortTargets = new Sort(this);
    this.swapTargets = new Swap(rangeUpdater);
    this.toggleLineBreakpoint = new ToggleBreakpoint(modifierStageFactory);
    this.toggleLineComment = new ToggleLineComment(rangeUpdater);
    this.unfoldRegion = new Unfold(rangeUpdater);
    this.wrapWithPairedDelimiter = new Wrap(rangeUpdater);
    this.wrapWithSnippet = new WrapWithSnippet(
      rangeUpdater,
      snippets,
      modifierStageFactory
    );
    this["experimental.setInstanceReference"] = new SetSpecialTarget(
      "instanceReference"
    );
    this["private.showParseTree"] = new ShowParseTree(treeSitter);
    this["private.getTargets"] = new GetTargets();
    this["private.setKeyboardTarget"] = new SetSpecialTarget("keyboard");
  }
};

// ../cursorless-engine/src/core/getCommandFallback.ts
async function getCommandFallback(commandServerApi, runAction, command) {
  const focusedElementType = await commandServerApi.getFocusedElementType();
  if (focusedElementType == null || focusedElementType === "textEditor") {
    return null;
  }
  const action = command.action;
  switch (action.name) {
    case "replace":
      return destinationIsSelection(action.destination) && Array.isArray(action.replaceWith) ? {
        action: "insert",
        modifiers: getModifiersFromDestination(action.destination),
        text: action.replaceWith.join("\n")
      } : null;
    case "replaceWithTarget":
      if (destinationIsSelection(action.destination)) {
        return {
          action: "insert",
          modifiers: getModifiersFromDestination(action.destination),
          text: await getText(runAction, action.source)
        };
      }
      return null;
    case "moveToTarget":
      if (destinationIsSelection(action.destination)) {
        const text = await getText(runAction, action.source);
        await remove(runAction, action.source);
        return {
          action: "insert",
          modifiers: getModifiersFromDestination(action.destination),
          text
        };
      }
      return null;
    case "callAsFunction":
      if (targetIsSelection(action.argument)) {
        return {
          action: action.name,
          modifiers: getModifiersFromTarget(action.argument),
          callee: await getText(runAction, action.callee)
        };
      }
      return null;
    case "wrapWithPairedDelimiter":
    case "rewrapWithPairedDelimiter":
      return targetIsSelection(action.target) ? {
        action: action.name,
        modifiers: getModifiersFromTarget(action.target),
        left: action.left,
        right: action.right
      } : null;
    case "pasteFromClipboard":
      return destinationIsSelection(action.destination) ? {
        action: action.name,
        modifiers: getModifiersFromDestination(action.destination)
      } : null;
    case "swapTargets":
    case "editNew":
    case "insertSnippet":
    case "generateSnippet":
    case "wrapWithSnippet":
    case "parsed":
      return null;
    default:
      return targetIsSelection(action.target) ? {
        action: action.name,
        modifiers: getModifiersFromTarget(action.target)
      } : null;
  }
}
function destinationIsSelection(destination) {
  if (destination.type === "implicit") {
    return true;
  }
  if (destination.type === "primitive") {
    return destination.insertionMode === "to" && targetIsSelection(destination.target);
  }
  return false;
}
function targetIsSelection(target) {
  if (target.type === "implicit") {
    return true;
  }
  if (target.type === "primitive") {
    return target.mark == null || target.mark.type === "cursor";
  }
  return false;
}
function getModifiersFromDestination(destination) {
  if (destination.type === "primitive") {
    return getModifiersFromTarget(destination.target);
  }
  return [];
}
function getModifiersFromTarget(target) {
  if (target.type === "primitive") {
    if (target.modifiers != null && target.modifiers.length > 0) {
      return target.modifiers;
    }
  }
  return [];
}
async function getText(runAction, target) {
  const response = await runAction({ name: "getText", target });
  const texts = response.returnValue;
  return texts.join("\n");
}
async function remove(runAction, target) {
  await runAction({ name: "remove", target });
}

// ../cursorless-engine/src/core/handleHoistedModifiers.ts
function handleHoistedModifiers(targetDescriptor, isAnchorMarkImplicit) {
  const { anchor, rangeType, active } = targetDescriptor;
  if (anchor.type !== "primitive" || rangeType !== "continuous") {
    return targetDescriptor;
  }
  const indexedModifiers = anchor.modifiers.map((v, i2) => [v, i2]);
  for (const [modifier, idx] of indexedModifiers.reverse()) {
    for (const hoistedModifierType of hoistedModifierTypes) {
      const acceptanceInfo = hoistedModifierType.accept(modifier);
      if (acceptanceInfo.accepted) {
        const [hoistedModifiers, unhoistedModifiers] = [
          anchor.modifiers.slice(0, idx + 1),
          anchor.modifiers.slice(idx + 1)
        ];
        let pipelineInputDescriptor = {
          ...targetDescriptor,
          anchor: (
            // If they say "every line past bat", the anchor is implicit, even though
            // it comes across the wire as a primitive target due to the "every line",
            // which we've now removed
            unhoistedModifiers.length === 0 && isAnchorMarkImplicit ? { type: "implicit" } : {
              type: "primitive",
              mark: anchor.mark,
              modifiers: unhoistedModifiers
            }
          ),
          // Remove the hoisted modifier (and everything before it) from the
          // active if it ended up there from inference
          active: produce(active, (draft) => {
            draft.modifiers = draft.modifiers.slice(
              findLastIndex_default(
                draft.modifiers,
                (modifier2) => hoistedModifierType.accept(modifier2).accepted
              ) + 1
            );
          })
        };
        pipelineInputDescriptor = acceptanceInfo.transformTarget?.(pipelineInputDescriptor) ?? pipelineInputDescriptor;
        return {
          type: "primitive",
          mark: {
            type: "target",
            target: pipelineInputDescriptor
          },
          modifiers: hoistedModifiers
        };
      }
    }
  }
  return targetDescriptor;
}
var hoistedModifierTypes = [
  // "every" ranges, eg "every line air past bat"
  {
    accept(modifier) {
      return modifier.type === "everyScope" && modifier.scopeType.type !== "instance" ? {
        accepted: true,
        transformTarget(target) {
          return {
            ...target,
            exclusionScopeType: modifier.scopeType
          };
        }
      } : { accepted: false };
    }
  },
  // "instance" modifiers treat the range as the instance to search for, eg
  // "every instance air past bat" searches for instances of the text of the
  // range "air past bat".
  {
    accept(modifier) {
      return {
        accepted: (modifier.type === "everyScope" || modifier.type === "relativeScope" || modifier.type === "ordinalScope") && modifier.scopeType.type === "instance"
      };
    }
  }
];

// ../cursorless-engine/src/core/inferFullTargetDescriptor.ts
function inferFullTargetDescriptor(target, previousTargets) {
  switch (target.type) {
    case "list":
      return inferListTarget(target, previousTargets);
    case "range":
      return inferRangeTargetWithHoist(target, previousTargets);
    case "primitive":
      return inferPrimitiveTarget(target, previousTargets);
    case "implicit":
      return target;
  }
}
function inferListTarget(target, previousTargets) {
  return {
    ...target,
    elements: target.elements.map((element, index) => {
      const elementPreviousTargets = previousTargets.concat(
        target.elements.slice(0, index)
      );
      switch (element.type) {
        case "range":
          return inferRangeTargetWithHoist(element, elementPreviousTargets);
        case "primitive":
          return inferPrimitiveTarget(element, elementPreviousTargets);
      }
    })
  };
}
function inferRangeTargetWithHoist(target, previousTargets) {
  const fullTarget = inferRangeTarget(target, previousTargets);
  const isAnchorMarkImplicit = target.anchor.type === "implicit" || target.anchor.mark == null;
  return handleHoistedModifiers(fullTarget, isAnchorMarkImplicit);
}
function inferRangeTarget(target, previousTargets) {
  return {
    type: "range",
    rangeType: target.rangeType ?? "continuous",
    excludeAnchor: target.excludeAnchor ?? false,
    excludeActive: target.excludeActive ?? false,
    anchor: target.anchor.type === "implicit" ? target.anchor : inferPrimitiveTarget(target.anchor, previousTargets),
    active: inferPrimitiveTarget(
      target.active,
      previousTargets.concat(target.anchor)
    )
  };
}
function inferPrimitiveTarget(target, previousTargets) {
  const mark = handleTargetMark(
    target.mark ?? (shouldInferPreviousMark(target) ? getPreviousMark(previousTargets) : null) ?? {
      type: "cursor"
    }
  );
  const modifiers = getPreservedModifiers(target) ?? getPreviousPreservedModifiers(previousTargets) ?? getPreviousLineNumberMarkModifiers(previousTargets) ?? [];
  return {
    type: target.type,
    mark,
    modifiers
  };
}
function shouldInferPreviousMark(target) {
  return target.modifiers?.some((m) => m.type === "inferPreviousMark") ?? false;
}
function getPreservedModifiers(target) {
  const preservedModifiers = target.modifiers?.filter(
    (modifier) => modifier.type !== "inferPreviousMark"
  ) ?? [];
  return preservedModifiers.length !== 0 ? preservedModifiers : void 0;
}
function getLineNumberMarkModifiers(target) {
  if (isLineNumberMark(target)) {
    return [
      {
        type: "containingScope",
        scopeType: {
          type: "line"
        }
      }
    ];
  }
  return void 0;
}
function isLineNumberMark(target) {
  const isLineNumber = (mark) => mark?.type === "lineNumber";
  if (isLineNumber(target.mark)) {
    return true;
  }
  if (target.mark?.type === "range") {
    return isLineNumber(target.mark.anchor) && isLineNumber(target.mark.active);
  }
  return false;
}
function getPreviousMark(previousTargets) {
  return getPreviousTargetAttribute(
    previousTargets,
    (target) => target.mark
  );
}
function getPreviousPreservedModifiers(previousTargets) {
  return getPreviousTargetAttribute(previousTargets, getPreservedModifiers);
}
function getPreviousLineNumberMarkModifiers(previousTargets) {
  return getPreviousTargetAttribute(
    previousTargets,
    getLineNumberMarkModifiers
  );
}
function getPreviousTargetAttribute(previousTargets, getAttribute) {
  for (let i2 = previousTargets.length - 1; i2 > -1; --i2) {
    const target = previousTargets[i2];
    switch (target.type) {
      case "primitive": {
        const attributeValue = getAttribute(target);
        if (attributeValue != null) {
          return attributeValue;
        }
        break;
      }
      case "range": {
        const attributeValue = getPreviousTargetAttribute(
          [target.anchor],
          getAttribute
        );
        if (attributeValue != null) {
          return attributeValue;
        }
        break;
      }
      case "list": {
        const attributeValue = getPreviousTargetAttribute(
          target.elements,
          getAttribute
        );
        if (attributeValue != null) {
          return attributeValue;
        }
        break;
      }
    }
  }
  return void 0;
}
function handleTargetMark(mark) {
  switch (mark.type) {
    case "range":
      return {
        ...mark,
        anchor: handleTargetMark(mark.anchor),
        active: handleTargetMark(mark.active)
      };
    case "target":
      return {
        type: "target",
        target: inferFullTargetDescriptor(mark.target, [])
      };
    default:
      return mark;
  }
}

// ../cursorless-engine/src/core/commandRunner/CommandRunnerImpl.ts
var CommandRunnerImpl = class {
  constructor(commandServerApi, debug, storedTargets, pipelineRunner, actions) {
    this.commandServerApi = commandServerApi;
    this.debug = debug;
    this.storedTargets = storedTargets;
    this.pipelineRunner = pipelineRunner;
    this.actions = actions;
    this.finalStages = [];
    this.runAction = this.runAction.bind(this);
    this.inferenceContext = new InferenceContext(this.debug);
  }
  /**
   * Runs a Cursorless command. We proceed as follows:
   *
   * 1. Perform inference on targets to fill in details left out using things
   *    like previous targets. For example we would automatically infer that
   *    `"take funk air and bat"` is equivalent to `"take funk air and funk
   *    bat"`. See {@link inferFullTargetDescriptors} for details of how this is done.
   * 2. Call {@link processTargets} to map each abstract {@link Target} object
   *    to a concrete list of {@link Target} objects.
   * 3. Run the requested action on the given selections. The mapping from
   *    action id (eg `remove`) to implementation is defined in {@link Actions}.
   *    To understand how actions work, see some examples, such as `"take"`
   *    {@link SetSelection} and `"chuck"` {@link Delete}. See
   * 4. Update `source` and `that` marks, if they have been returned from the
   *    action, and returns the desired return value indicated by the action, if
   *    it has one.
   */
  async run(command) {
    if (clientSupportsFallback(command)) {
      const fallback = await getCommandFallback(
        this.commandServerApi,
        this.runAction,
        command
      );
      if (fallback != null) {
        return { fallback };
      }
    }
    const {
      returnValue,
      thatSelections: newThatSelections,
      thatTargets: newThatTargets,
      sourceSelections: newSourceSelections,
      sourceTargets: newSourceTargets,
      instanceReferenceTargets: newInstanceReferenceTargets,
      keyboardTargets: newKeyboardTargets
    } = await this.runAction(command.action);
    this.storedTargets.set(
      "that",
      constructStoredTarget(newThatTargets, newThatSelections)
    );
    this.storedTargets.set(
      "source",
      constructStoredTarget(newSourceTargets, newSourceSelections)
    );
    this.storedTargets.set("instanceReference", newInstanceReferenceTargets);
    this.storedTargets.set("keyboard", newKeyboardTargets, { history: true });
    return { returnValue };
  }
  runAction(actionDescriptor) {
    this.inferenceContext.reset();
    this.finalStages = [];
    switch (actionDescriptor.name) {
      case "replaceWithTarget":
        return this.actions.replaceWithTarget.run(
          this.getTargets(actionDescriptor.source),
          this.getDestinations(actionDescriptor.destination)
        );
      case "moveToTarget":
        return this.actions.moveToTarget.run(
          this.getTargets(actionDescriptor.source),
          this.getDestinations(actionDescriptor.destination)
        );
      case "swapTargets":
        return this.actions.swapTargets.run(
          this.getTargets(actionDescriptor.target1),
          this.getTargets(actionDescriptor.target2)
        );
      case "callAsFunction":
        return this.actions.callAsFunction.run(
          this.getTargets(actionDescriptor.callee),
          this.getTargets(actionDescriptor.argument)
        );
      case "wrapWithPairedDelimiter":
        return this.actions.wrapWithPairedDelimiter.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.left,
          actionDescriptor.right
        );
      case "rewrapWithPairedDelimiter":
        this.finalStages = this.actions.rewrapWithPairedDelimiter.getFinalStages();
        return this.actions.rewrapWithPairedDelimiter.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.left,
          actionDescriptor.right
        );
      case "pasteFromClipboard":
        return this.actions.pasteFromClipboard.run(
          this.getDestinations(actionDescriptor.destination)
        );
      case "executeCommand":
        return this.actions.executeCommand.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.commandId,
          actionDescriptor.options
        );
      case "replace":
        return this.actions.replace.run(
          this.getDestinations(actionDescriptor.destination),
          actionDescriptor.replaceWith
        );
      case "highlight":
        return this.actions.highlight.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.highlightId
        );
      case "generateSnippet":
        return this.actions.generateSnippet.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.directory,
          actionDescriptor.snippetName
        );
      case "insertSnippet":
        this.finalStages = this.actions.insertSnippet.getFinalStages(
          this.getDestinations(actionDescriptor.destination),
          actionDescriptor.snippetDescription
        );
        return this.actions.insertSnippet.run(
          this.getDestinations(actionDescriptor.destination),
          actionDescriptor.snippetDescription
        );
      case "wrapWithSnippet":
        this.finalStages = this.actions.wrapWithSnippet.getFinalStages(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.snippetDescription
        );
        return this.actions.wrapWithSnippet.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.snippetDescription
        );
      case "editNew":
        return this.actions.editNew.run(
          this.getDestinations(actionDescriptor.destination)
        );
      case "getText":
        return this.actions.getText.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.options
        );
      case "parsed":
        return this.runAction(
          parseAndFillOutAction(
            actionDescriptor.content,
            actionDescriptor.arguments
          )
        );
      default: {
        const action = this.actions[actionDescriptor.name];
        if (action == null) {
          throw new Error(`Unknown action: ${actionDescriptor.name}`);
        }
        this.finalStages = action.getFinalStages?.() ?? [];
        this.noAutomaticTokenExpansion = action.noAutomaticTokenExpansion ?? false;
        return action.run(this.getTargets(actionDescriptor.target));
      }
    }
  }
  getTargets(partialTargetsDescriptor) {
    const targetDescriptor = this.inferenceContext.run(
      partialTargetsDescriptor
    );
    return this.pipelineRunner.run(targetDescriptor, {
      actionFinalStages: this.finalStages,
      noAutomaticTokenExpansion: this.noAutomaticTokenExpansion
    });
  }
  getDestinations(destinationDescriptor) {
    switch (destinationDescriptor.type) {
      case "list":
        return destinationDescriptor.destinations.flatMap(
          (destination) => this.getDestinations(destination)
        );
      case "primitive":
        return this.getTargets(destinationDescriptor.target).map(
          (target) => target.toDestination(destinationDescriptor.insertionMode)
        );
      case "implicit":
        return this.getTargets({ type: "implicit" }).map(
          (target) => target.toDestination("to")
        );
    }
  }
};
var InferenceContext = class {
  constructor(debug) {
    this.debug = debug;
    this.previousTargets = [];
  }
  run(target) {
    const ret = inferFullTargetDescriptor(target, this.previousTargets);
    if (this.debug.active) {
      this.debug.log("Full target:");
      this.debug.log(JSON.stringify(ret, null, 2));
    }
    this.previousTargets.push(target);
    return ret;
  }
  reset() {
    this.previousTargets = [];
  }
};
function constructStoredTarget(targets, selections) {
  if (targets != null && selections != null) {
    throw Error(
      "Actions may only return full targets or selections for that mark"
    );
  }
  if (selections != null) {
    return selections.map(selectionToStoredTarget);
  } else {
    return targets;
  }
}

// ../cursorless-engine/src/processTargets/marks/DecoratedSymbolStage.ts
var DecoratedSymbolStage = class {
  constructor(readableHatMap, mark) {
    this.readableHatMap = readableHatMap;
    this.mark = mark;
  }
  run() {
    const token = this.readableHatMap.getToken(
      this.mark.symbolColor,
      this.mark.character
    );
    if (token == null) {
      throw new Error(
        `Couldn't find mark ${this.mark.symbolColor} '${this.mark.character}'`
      );
    }
    return [
      new UntypedTarget({
        editor: token.editor,
        contentRange: token.range,
        isReversed: false,
        hasExplicitRange: false
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/marks/ExplicitMarkStage.ts
var ExplicitMarkStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    const {
      editorId,
      range: { start: start2, end }
    } = this.mark;
    const editor = ide().visibleTextEditors.find((e) => e.id === editorId);
    if (editor == null) {
      throw new Error(`Couldn't find editor '${editorId}'`);
    }
    const contentRange = new Range(
      start2.line,
      start2.character,
      end.line,
      end.character
    );
    return [
      new UntypedTarget({
        editor,
        contentRange,
        isReversed: false,
        hasExplicitRange: false
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/marks/LineNumberStage.ts
var LineNumberStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    const editor = ide().activeTextEditor;
    if (editor == null) {
      return [];
    }
    const lineNumber = getLineNumber2(
      editor,
      this.mark.lineNumberType,
      this.mark.lineNumber
    );
    const contentRange = editor.document.lineAt(lineNumber).range;
    return [createLineTarget(editor, false, contentRange)];
  }
};
var getLineNumber2 = (editor, lineNumberType, lineNumber) => {
  switch (lineNumberType) {
    case "absolute":
      return lineNumber;
    case "relative":
      return editor.selections[0].active.line + lineNumber;
    case "modulo100": {
      const stepSize = 100;
      const startLine = editor.visibleRanges[0].start.line;
      const endLine = editor.visibleRanges[editor.visibleRanges.length - 1].end.line;
      const base = Math.floor(startLine / stepSize) * stepSize;
      const visibleLines = [];
      const invisibleLines = [];
      let currentLineNumber = base + lineNumber;
      while (currentLineNumber <= endLine) {
        if (currentLineNumber >= startLine) {
          const visible = editor.visibleRanges.find(
            (r) => currentLineNumber >= r.start.line && currentLineNumber <= r.end.line
          );
          if (visible) {
            visibleLines.push(currentLineNumber);
          } else {
            invisibleLines.push(currentLineNumber);
          }
        }
        currentLineNumber += stepSize;
      }
      if (visibleLines.length === 1) {
        return visibleLines[0];
      }
      if (visibleLines.length + invisibleLines.length > 1) {
        throw new Error("Multiple lines matching");
      }
      if (invisibleLines.length === 1) {
        return invisibleLines[0];
      }
      throw new Error("Line is not in viewport");
    }
  }
};

// ../cursorless-engine/src/processTargets/marks/NothingStage.ts
var NothingStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    return [];
  }
};

// ../cursorless-engine/src/processTargets/marks/RangeMarkStage.ts
var RangeMarkStage = class {
  constructor(markStageFactory, mark) {
    this.markStageFactory = markStageFactory;
    this.mark = mark;
  }
  run() {
    const anchorStage = this.markStageFactory.create(this.mark.anchor);
    const activeStage = this.markStageFactory.create(this.mark.active);
    const anchorTargets = anchorStage.run();
    const activeTargets = activeStage.run();
    if (anchorTargets.length !== 1 || activeTargets.length !== 1) {
      throw new Error("Expected single anchor and active target");
    }
    return [
      targetsToContinuousTarget(
        anchorTargets[0],
        activeTargets[0],
        this.mark.excludeAnchor,
        this.mark.excludeActive
      )
    ];
  }
};

// ../cursorless-engine/src/processTargets/marks/StoredTargetStage.ts
var StoredTargetStage = class {
  constructor(storedTargets, key) {
    this.storedTargets = storedTargets;
    this.key = key;
  }
  run() {
    const targets = this.storedTargets.get(this.key);
    if (targets == null || targets.length === 0) {
      throw Error(`No available ${this.key} marks`);
    }
    return targets;
  }
};

// ../cursorless-engine/src/processTargets/marks/TargetMarkStage.ts
var TargetMarkStage = class {
  constructor(targetPipelineRunner, mark) {
    this.targetPipelineRunner = targetPipelineRunner;
    this.mark = mark;
  }
  run() {
    return this.targetPipelineRunner.run(this.mark.target);
  }
};

// ../cursorless-engine/src/processTargets/MarkStageFactoryImpl.ts
var MarkStageFactoryImpl = class {
  constructor(readableHatMap, storedTargets) {
    this.readableHatMap = readableHatMap;
    this.storedTargets = storedTargets;
    this.create = this.create.bind(this);
  }
  setPipelineRunner(targetPipelineRunner) {
    this.targetPipelineRunner = targetPipelineRunner;
  }
  create(mark) {
    switch (mark.type) {
      case "cursor":
        return new CursorStage();
      case "that":
      case "source":
      case "keyboard":
        return new StoredTargetStage(this.storedTargets, mark.type);
      case "decoratedSymbol":
        return new DecoratedSymbolStage(this.readableHatMap, mark);
      case "lineNumber":
        return new LineNumberStage(mark);
      case "range":
        return new RangeMarkStage(this, mark);
      case "nothing":
        return new NothingStage(mark);
      case "target":
        return new TargetMarkStage(this.targetPipelineRunner, mark);
      case "explicit":
        return new ExplicitMarkStage(mark);
      default: {
        const _exhaustiveCheck = mark;
        const { type: type2 } = mark;
        throw new Error(`Unknown mark: ${type2}`);
      }
    }
  }
};

// ../cursorless-engine/src/runCommand.ts
async function runCommand(treeSitter, commandServerApi, debug, hatTokenMap, snippets, storedTargets, languageDefinitions, rangeUpdater, commandRunnerDecorators, command) {
  if (debug.active) {
    debug.log(`command:`);
    debug.log(JSON.stringify(command, null, 2));
  }
  const commandComplete = canonicalizeAndValidateCommand(command);
  const readableHatMap = await hatTokenMap.getReadableMap(
    commandComplete.usePrePhraseSnapshot
  );
  let commandRunner = createCommandRunner(
    treeSitter,
    commandServerApi,
    languageDefinitions,
    debug,
    storedTargets,
    readableHatMap,
    snippets,
    rangeUpdater
  );
  for (const decorator of commandRunnerDecorators) {
    commandRunner = decorator.wrapCommandRunner(readableHatMap, commandRunner);
  }
  const response = await commandRunner.run(commandComplete);
  return await unwrapLegacyCommandResponse(command, response);
}
async function unwrapLegacyCommandResponse(command, response) {
  if (clientSupportsFallback(command)) {
    return response;
  }
  if ("returnValue" in response) {
    return response.returnValue;
  }
  return void 0;
}
function createCommandRunner(treeSitter, commandServerApi, languageDefinitions, debug, storedTargets, readableHatMap, snippets, rangeUpdater) {
  const modifierStageFactory = new ModifierStageFactoryImpl(
    languageDefinitions,
    storedTargets,
    new ScopeHandlerFactoryImpl(languageDefinitions)
  );
  const markStageFactory = new MarkStageFactoryImpl(
    readableHatMap,
    storedTargets
  );
  const targetPipelineRunner = new TargetPipelineRunner(
    modifierStageFactory,
    markStageFactory
  );
  markStageFactory.setPipelineRunner(targetPipelineRunner);
  return new CommandRunnerImpl(
    commandServerApi,
    debug,
    storedTargets,
    targetPipelineRunner,
    new Actions(treeSitter, snippets, rangeUpdater, modifierStageFactory)
  );
}

// ../cursorless-engine/src/scopeProviders/scopeTypeToString.ts
function scopeTypeToString(scopeType) {
  if (isSimpleScopeType(scopeType)) {
    return camelCaseToAllDown(scopeType.type).replace(".", " ");
  }
  if (scopeType.type === "surroundingPair") {
    return `Matching pair of ${camelCaseToAllDown(scopeType.delimiter)}`;
  }
  if (scopeType.type === "customRegex") {
    return `Regex \`${scopeType.regex}\``;
  }
  return "Unknown scope type";
}

// ../cursorless-engine/src/scopeProviders/ScopeInfoProvider.ts
var ScopeInfoProvider = class {
  constructor(customSpokenFormGenerator) {
    this.customSpokenFormGenerator = customSpokenFormGenerator;
    this.listeners = [];
    this.disposable = customSpokenFormGenerator.onDidChangeCustomSpokenForms(
      () => this.onChange()
    );
    this.onDidChangeScopeInfo = this.onDidChangeScopeInfo.bind(this);
    this.getScopeTypeInfo = this.getScopeTypeInfo.bind(this);
    this.updateScopeTypeInfos();
  }
  /**
   * Registers a callback to be run when the scope info changes.  The callback
   * will be run immediately once with the current scope info.
   *
   * Includes information about the available scopes, including their custom
   * spoken forms, if available. Note that even custom regex scopes will be
   * available, as reported to the engine by Talon.
   * @param callback The callback to run when the scope support changes
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeScopeInfo(callback2) {
    callback2(this.getScopeTypeInfos());
    this.listeners.push(callback2);
    return {
      dispose: () => {
        pull_default(this.listeners, callback2);
      }
    };
  }
  async onChange() {
    this.updateScopeTypeInfos();
    this.listeners.forEach((listener) => listener(this.scopeInfos));
  }
  updateScopeTypeInfos() {
    const scopeTypes = [
      ...simpleScopeTypeTypes.filter((scopeTypeType) => scopeTypeType !== "instance").map((scopeTypeType) => ({
        type: scopeTypeType
      })),
      ...surroundingPairNames.map(
        (surroundingPairName) => ({
          type: "surroundingPair",
          delimiter: surroundingPairName
        })
      ),
      ...this.customSpokenFormGenerator.getCustomRegexScopeTypes()
    ];
    this.scopeInfos = scopeTypes.map(
      (scopeType) => this.getScopeTypeInfo(scopeType)
    );
  }
  getScopeTypeInfos() {
    return this.scopeInfos;
  }
  getScopeTypeInfo(scopeType) {
    return {
      scopeType,
      spokenForm: this.customSpokenFormGenerator.scopeTypeToSpokenForm(scopeType),
      humanReadableName: scopeTypeToString(scopeType),
      isLanguageSpecific: isLanguageSpecific(scopeType)
    };
  }
  dispose() {
    this.disposable.dispose();
  }
};
function isLanguageSpecific(scopeType) {
  switch (scopeType.type) {
    case "string":
    case "argumentOrParameter":
    case "argumentList":
    case "anonymousFunction":
    case "attribute":
    case "branch":
    case "class":
    case "className":
    case "collectionItem":
    case "collectionKey":
    case "command":
    case "comment":
    case "private.fieldAccess":
    case "functionCall":
    case "functionCallee":
    case "functionName":
    case "ifStatement":
    case "instance":
    case "interior":
    case "list":
    case "map":
    case "name":
    case "namedFunction":
    case "regularExpression":
    case "statement":
    case "type":
    case "value":
    case "condition":
    case "section":
    case "sectionLevelOne":
    case "sectionLevelTwo":
    case "sectionLevelThree":
    case "sectionLevelFour":
    case "sectionLevelFive":
    case "sectionLevelSix":
    case "selector":
    case "private.switchStatementSubject":
    case "unit":
    case "xmlBothTags":
    case "xmlElement":
    case "xmlEndTag":
    case "xmlStartTag":
    case "part":
    case "chapter":
    case "subSection":
    case "subSubSection":
    case "namedParagraph":
    case "subParagraph":
    case "environment":
    case "textFragment":
    case "disqualifyDelimiter":
    case "pairDelimiter":
      return true;
    case "character":
    case "word":
    case "token":
    case "identifier":
    case "line":
    case "sentence":
    case "paragraph":
    case "boundedParagraph":
    case "document":
    case "nonWhitespaceSequence":
    case "boundedNonWhitespaceSequence":
    case "url":
    case "notebookCell":
    case "surroundingPair":
    case "surroundingPairInterior":
    case "customRegex":
    case "glyph":
      return false;
    case "oneOf":
      throw Error(
        `Can't decide whether scope type ${JSON.stringify(
          scopeType,
          void 0,
          3
        )} is language-specific`
      );
  }
}

// ../cursorless-engine/src/scopeProviders/getIterationRange.ts
function getIterationRange(editor, scopeHandler, visibleOnly) {
  if (!visibleOnly) {
    return editor.document.range;
  }
  let visibleRange = editor.visibleRanges.reduce(
    (acc, range3) => acc.union(range3)
  );
  visibleRange = editor.document.range.intersection(
    visibleRange.with(
      visibleRange.start.translate(-10),
      visibleRange.end.translate(10)
    )
  );
  const expandedStart = last_default(
    Array.from(
      scopeHandler.generateScopes(editor, visibleRange.start, "forward", {
        containment: "required"
      })
    )
  )?.domain ?? visibleRange;
  const expandedEnd = last_default(
    Array.from(
      scopeHandler.generateScopes(editor, visibleRange.end, "forward", {
        containment: "required"
      })
    )
  )?.domain ?? visibleRange;
  return expandedStart.union(expandedEnd);
}

// ../cursorless-engine/src/scopeProviders/getTargetRanges.ts
function getTargetRanges(target) {
  return {
    contentRange: target.contentRange,
    removalRange: target.getRemovalRange(),
    removalHighlightRange: target.getRemovalHighlightRange(),
    leadingDelimiter: getOptionalTarget(target.getLeadingDelimiterTarget()),
    trailingDelimiter: getOptionalTarget(target.getTrailingDelimiterTarget()),
    interior: target.getInterior()?.map(getTargetRanges),
    boundary: target.getBoundary()?.map(getTargetRanges),
    insertionDelimiter: target.insertionDelimiter
  };
}
function getOptionalTarget(target) {
  return target != null ? getTargetRanges(target) : void 0;
}

// ../cursorless-engine/src/scopeProviders/getIterationScopeRanges.ts
function getIterationScopeRanges(editor, iterationScopeHandler, everyStage, iterationRange, includeIterationNestedTargets) {
  const options2 = {
    multipleTargets: true
  };
  return map2(
    iterationScopeHandler.generateScopes(
      editor,
      iterationRange.start,
      "forward",
      {
        includeDescendantScopes: true,
        distalPosition: iterationRange.end
      }
    ),
    (scope) => {
      return {
        domain: scope.domain,
        ranges: scope.getTargets(false).map((target) => ({
          range: target.contentRange,
          targets: includeIterationNestedTargets ? getEveryScopeLenient(everyStage, target, options2).map(
            getTargetRanges
          ) : void 0
        }))
      };
    }
  );
}
function getEveryScopeLenient(everyStage, target, options2) {
  try {
    return everyStage.run(target, options2);
  } catch (err2) {
    if (err2.name === "NoContainingScopeError") {
      return [];
    }
    throw err2;
  }
}

// ../cursorless-engine/src/scopeProviders/getScopeRanges.ts
function getScopeRanges(editor, scopeHandler, iterationRange) {
  return map2(
    scopeHandler.generateScopes(editor, iterationRange.start, "forward", {
      includeDescendantScopes: true,
      distalPosition: iterationRange.end
    }),
    (scope) => ({
      domain: scope.domain,
      targets: scope.getTargets(false).map(getTargetRanges)
    })
  );
}

// ../cursorless-engine/src/scopeProviders/ScopeRangeProvider.ts
var ScopeRangeProvider = class {
  constructor(scopeHandlerFactory, modifierStageFactory) {
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifierStageFactory = modifierStageFactory;
    this.provideScopeRanges = this.provideScopeRanges.bind(this);
    this.provideIterationScopeRanges = this.provideIterationScopeRanges.bind(this);
  }
  provideScopeRanges(editor, { scopeType, visibleOnly }) {
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      editor.document.languageId
    );
    if (scopeHandler == null) {
      return [];
    }
    return getScopeRanges(
      editor,
      scopeHandler,
      getIterationRange(editor, scopeHandler, visibleOnly)
    );
  }
  provideIterationScopeRanges(editor, { scopeType, visibleOnly, includeNestedTargets }) {
    const { languageId } = editor.document;
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      languageId
    );
    if (scopeHandler == null) {
      return [];
    }
    const iterationScopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeHandler.iterationScopeType,
      languageId
    );
    if (iterationScopeHandler == null) {
      return [];
    }
    return getIterationScopeRanges(
      editor,
      iterationScopeHandler,
      this.modifierStageFactory.create({
        type: "everyScope",
        scopeType
      }),
      getIterationRange(editor, scopeHandler, visibleOnly),
      includeNestedTargets
    );
  }
};

// ../cursorless-engine/src/scopeProviders/ScopeRangeWatcher.ts
var ScopeRangeWatcher = class {
  constructor(languageDefinitions, scopeRangeProvider) {
    this.scopeRangeProvider = scopeRangeProvider;
    this.disposables = [];
    this.listeners = [];
    this.onChange = this.onChange.bind(this);
    this.onDidChangeScopeRanges = this.onDidChangeScopeRanges.bind(this);
    this.onDidChangeIterationScopeRanges = this.onDidChangeIterationScopeRanges.bind(this);
    const debouncer = new DecorationDebouncer(
      ide().configuration,
      () => this.onChange()
    );
    this.disposables.push(
      // An Event which fires when the array of visible editors has changed.
      ide().onDidChangeVisibleTextEditors(debouncer.run),
      // An event that fires when a text document opens
      ide().onDidOpenTextDocument(debouncer.run),
      // An Event that fires when a text document closes
      ide().onDidCloseTextDocument(debouncer.run),
      // An event that is emitted when a text document is changed. This usually
      // happens when the contents changes but also when other things like the
      // dirty-state changes.
      ide().onDidChangeTextDocument(debouncer.run),
      ide().onDidChangeTextEditorVisibleRanges(debouncer.run),
      languageDefinitions.onDidChangeDefinition(this.onChange),
      debouncer
    );
  }
  /**
   * Registers a callback to be run when the scope ranges change for any visible
   * editor.  The callback will be run immediately once for each visible editor
   * with the current scope ranges.
   * @param callback The callback to run when the scope ranges change
   * @param config The configuration for the scope ranges
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeScopeRanges(callback2, config) {
    const fn = () => {
      ide().visibleTextEditors.forEach((editor) => {
        let scopeRanges;
        try {
          scopeRanges = this.scopeRangeProvider.provideScopeRanges(
            editor,
            config
          );
        } catch (err2) {
          void showError(
            ide().messages,
            "ScopeRangeWatcher.provide",
            err2.message
          );
          scopeRanges = [];
          if (ide().runMode === "test") {
            throw err2;
          }
        }
        callback2(editor, scopeRanges);
      });
    };
    this.listeners.push(fn);
    fn();
    return {
      dispose: () => {
        pull_default(this.listeners, fn);
      }
    };
  }
  /**
   * Registers a callback to be run when the iteration scope ranges change for
   * any visible editor.  The callback will be run immediately once for each
   * visible editor with the current iteration scope ranges.
   * @param callback The callback to run when the scope ranges change
   * @param config The configuration for the scope ranges
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeIterationScopeRanges(callback2, config) {
    const fn = () => {
      ide().visibleTextEditors.forEach((editor) => {
        callback2(
          editor,
          this.scopeRangeProvider.provideIterationScopeRanges(editor, config)
        );
      });
    };
    this.listeners.push(fn);
    fn();
    return {
      dispose: () => {
        pull_default(this.listeners, fn);
      }
    };
  }
  onChange() {
    this.listeners.forEach((listener) => listener());
  }
  dispose() {
    this.disposables.forEach(({ dispose }) => {
      try {
        dispose();
      } catch (_e) {
      }
    });
  }
};

// ../cursorless-engine/src/scopeProviders/ScopeSupportChecker.ts
var ScopeSupportChecker = class {
  constructor(scopeHandlerFactory) {
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.getScopeSupport = this.getScopeSupport.bind(this);
    this.getIterationScopeSupport = this.getIterationScopeSupport.bind(this);
  }
  /**
   * Determine the level of support for {@link scopeType} in {@link editor}, as
   * determined by its language id.
   * @param editor The editor to check
   * @param scopeType The scope type to check
   * @returns The level of support for {@link scopeType} in {@link editor}
   */
  getScopeSupport(editor, scopeType) {
    const { languageId } = editor.document;
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      languageId
    );
    if (scopeHandler == null) {
      return 2 /* unsupported */;
    }
    return editorContainsScope(editor, scopeHandler) ? 0 /* supportedAndPresentInEditor */ : 1 /* supportedButNotPresentInEditor */;
  }
  /**
   * Determine the level of support for the iteration scope of {@link scopeType}
   * in {@link editor}, as determined by its language id.
   * @param editor The editor to check
   * @param scopeType The scope type to check
   * @returns The level of support for the iteration scope of {@link scopeType}
   * in {@link editor}
   */
  getIterationScopeSupport(editor, scopeType) {
    const { languageId } = editor.document;
    const scopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeType,
      languageId
    );
    if (scopeHandler == null) {
      return 2 /* unsupported */;
    }
    const iterationScopeHandler = this.scopeHandlerFactory.maybeCreate(
      scopeHandler.iterationScopeType,
      languageId
    );
    if (iterationScopeHandler == null) {
      return 2 /* unsupported */;
    }
    return editorContainsScope(editor, iterationScopeHandler) ? 0 /* supportedAndPresentInEditor */ : 1 /* supportedButNotPresentInEditor */;
  }
};
function editorContainsScope(editor, scopeHandler) {
  return !isEmptyIterable(
    scopeHandler.generateScopes(editor, new Position(0, 0), "forward")
  );
}

// ../cursorless-engine/src/scopeProviders/ScopeSupportWatcher.ts
var ScopeSupportWatcher = class {
  constructor(languageDefinitions, scopeSupportChecker, scopeInfoProvider) {
    this.scopeSupportChecker = scopeSupportChecker;
    this.scopeInfoProvider = scopeInfoProvider;
    this.listeners = [];
    this.onChange = this.onChange.bind(this);
    this.onDidChangeScopeSupport = this.onDidChangeScopeSupport.bind(this);
    const debouncer = new DecorationDebouncer(
      ide().configuration,
      () => this.onChange()
    );
    this.disposable = disposableFrom(
      // An event that fires when a text document opens
      ide().onDidOpenTextDocument(debouncer.run),
      // An Event that fires when a text document closes
      ide().onDidCloseTextDocument(debouncer.run),
      // An Event which fires when the active editor has changed. Note that the event also fires when the active editor changes to undefined.
      ide().onDidChangeActiveTextEditor(debouncer.run),
      // An event that is emitted when a text document is changed. This usually
      // happens when the contents changes but also when other things like the
      // dirty-state changes.
      ide().onDidChangeTextDocument(debouncer.run),
      languageDefinitions.onDidChangeDefinition(debouncer.run),
      this.scopeInfoProvider.onDidChangeScopeInfo(this.onChange),
      debouncer
    );
  }
  /**
   * Registers a callback to be run when the scope support changes for the active
   * editor.  The callback will be run immediately once with the current support
   * levels for the active editor.
   *
   * Note that this watcher could be expensive, because it runs all the scope
   * handlers for the active editor every time the content of the active editor
   * changes. If you only need info about the available scopes, including their
   * spoken forms, you should use {@link onDidChangeScopeInfo} instead.
   * @param callback The callback to run when the scope support changes
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeScopeSupport(callback2) {
    callback2(this.getSupportLevels());
    this.listeners.push(callback2);
    return {
      dispose: () => {
        pull_default(this.listeners, callback2);
      }
    };
  }
  onChange() {
    if (this.listeners.length === 0) {
      return;
    }
    const supportLevels = this.getSupportLevels();
    this.listeners.forEach((listener) => listener(supportLevels));
  }
  getSupportLevels() {
    const activeTextEditor = ide().activeTextEditor;
    const getScopeTypeSupport = activeTextEditor == null ? () => 2 /* unsupported */ : (scopeType) => this.scopeSupportChecker.getScopeSupport(
      activeTextEditor,
      scopeType
    );
    const getIterationScopeTypeSupport = activeTextEditor == null ? () => 2 /* unsupported */ : (scopeType) => this.scopeSupportChecker.getIterationScopeSupport(
      activeTextEditor,
      scopeType
    );
    const scopeTypeInfos = this.scopeInfoProvider.getScopeTypeInfos();
    return scopeTypeInfos.map((scopeTypeInfo) => ({
      ...scopeTypeInfo,
      support: getScopeTypeSupport(scopeTypeInfo.scopeType),
      iterationScopeSupport: getIterationScopeTypeSupport(
        scopeTypeInfo.scopeType
      )
    }));
  }
  dispose() {
    this.disposable.dispose();
  }
};

// ../cursorless-engine/src/cursorlessEngine.ts
async function createCursorlessEngine({
  ide: ide2,
  hats,
  treeSitterQueryProvider,
  treeSitter = new DisabledTreeSitter(),
  commandServerApi = new DisabledCommandServerApi(),
  talonSpokenForms = new DisabledTalonSpokenForms(),
  snippets = new DisabledSnippets()
}) {
  injectIde(ide2);
  const debug = new Debug(ide2);
  const rangeUpdater = new RangeUpdater();
  const storedTargets = new StoredTargetMap();
  const keyboardTargetUpdater = new KeyboardTargetUpdater(ide2, storedTargets);
  const customSpokenFormGenerator = new CustomSpokenFormGeneratorImpl(
    talonSpokenForms
  );
  const hatTokenMap = hats != null ? new HatTokenMapImpl(rangeUpdater, debug, hats, commandServerApi) : new DisabledHatTokenMap();
  void hatTokenMap.allocateHats();
  const languageDefinitions = treeSitterQueryProvider ? await LanguageDefinitionsImpl.create(
    ide2,
    treeSitter,
    treeSitterQueryProvider
  ) : new DisabledLanguageDefinitions();
  ide2.disposeOnExit(
    rangeUpdater,
    languageDefinitions,
    hatTokenMap,
    debug,
    keyboardTargetUpdater
  );
  const commandRunnerDecorators = [];
  let previousCommand = void 0;
  const runCommandClosure = (command) => {
    previousCommand = command;
    return runCommand(
      treeSitter,
      commandServerApi,
      debug,
      hatTokenMap,
      snippets,
      storedTargets,
      languageDefinitions,
      rangeUpdater,
      commandRunnerDecorators,
      command
    );
  };
  return {
    commandApi: {
      runCommand(command) {
        return runCommandClosure(command);
      },
      runCommandSafe(...args2) {
        return runCommandClosure(ensureCommandShape(args2));
      },
      repeatPreviousCommand() {
        if (previousCommand == null) {
          throw new Error("No previous command");
        }
        return runCommandClosure(previousCommand);
      }
    },
    scopeProvider: createScopeProvider(
      languageDefinitions,
      storedTargets,
      customSpokenFormGenerator
    ),
    customSpokenFormGenerator,
    storedTargets,
    hatTokenMap,
    injectIde,
    addCommandRunnerDecorator: (decorator) => {
      commandRunnerDecorators.push(decorator);
    }
  };
}
function createScopeProvider(languageDefinitions, storedTargets, customSpokenFormGenerator) {
  const scopeHandlerFactory = new ScopeHandlerFactoryImpl(languageDefinitions);
  const rangeProvider = new ScopeRangeProvider(
    scopeHandlerFactory,
    new ModifierStageFactoryImpl(
      languageDefinitions,
      storedTargets,
      scopeHandlerFactory
    )
  );
  const rangeWatcher = new ScopeRangeWatcher(
    languageDefinitions,
    rangeProvider
  );
  const supportChecker = new ScopeSupportChecker(scopeHandlerFactory);
  const infoProvider = new ScopeInfoProvider(customSpokenFormGenerator);
  const supportWatcher = new ScopeSupportWatcher(
    languageDefinitions,
    supportChecker,
    infoProvider
  );
  return {
    provideScopeRanges: rangeProvider.provideScopeRanges,
    provideIterationScopeRanges: rangeProvider.provideIterationScopeRanges,
    onDidChangeScopeRanges: rangeWatcher.onDidChangeScopeRanges,
    onDidChangeIterationScopeRanges: rangeWatcher.onDidChangeIterationScopeRanges,
    getScopeSupport: supportChecker.getScopeSupport,
    getIterationScopeSupport: supportChecker.getIterationScopeSupport,
    onDidChangeScopeSupport: supportWatcher.onDidChangeScopeSupport,
    getScopeInfo: infoProvider.getScopeTypeInfo,
    onDidChangeScopeInfo: infoProvider.onDidChangeScopeInfo
  };
}

// ../cursorless-engine/src/util/grammarHelpers.ts
var UNUSED = Symbol("unused");
var ArgPosition = class {
  constructor(position) {
    this.position = position;
  }
};
var argPositions = {
  $0: new ArgPosition(0),
  $1: new ArgPosition(1),
  $2: new ArgPosition(2)
};

// ../../node_modules/.pnpm/web-tree-sitter@0.25.6/node_modules/web-tree-sitter/tree-sitter.js
var __defProp2 = Object.defineProperty;
var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
var SIZE_OF_SHORT = 2;
var SIZE_OF_INT = 4;
var SIZE_OF_CURSOR = 4 * SIZE_OF_INT;
var SIZE_OF_NODE = 5 * SIZE_OF_INT;
var SIZE_OF_POINT = 2 * SIZE_OF_INT;
var SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT;
var ZERO_POINT = { row: 0, column: 0 };
var INTERNAL = Symbol("INTERNAL");
function assertInternal(x) {
  if (x !== INTERNAL) throw new Error("Illegal constructor");
}
__name(assertInternal, "assertInternal");
function isPoint(point) {
  return !!point && typeof point.row === "number" && typeof point.column === "number";
}
__name(isPoint, "isPoint");
function setModule(module2) {
  C = module2;
}
__name(setModule, "setModule");
var C;
var _a;
var LookaheadIterator = (_a = class {
  /** @internal */
  constructor(internal, address, language) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "language");
    assertInternal(internal);
    this[0] = address;
    this.language = language;
  }
  /** Get the current symbol of the lookahead iterator. */
  get currentTypeId() {
    return C._ts_lookahead_iterator_current_symbol(this[0]);
  }
  /** Get the current symbol name of the lookahead iterator. */
  get currentType() {
    return this.language.types[this.currentTypeId] || "ERROR";
  }
  /** Delete the lookahead iterator, freeing its resources. */
  delete() {
    C._ts_lookahead_iterator_delete(this[0]);
    this[0] = 0;
  }
  /**
   * Reset the lookahead iterator.
   *
   * This returns `true` if the language was set successfully and `false`
   * otherwise.
   */
  reset(language, stateId) {
    if (C._ts_lookahead_iterator_reset(this[0], language[0], stateId)) {
      this.language = language;
      return true;
    }
    return false;
  }
  /**
   * Reset the lookahead iterator to another state.
   *
   * This returns `true` if the iterator was reset to the given state and
   * `false` otherwise.
   */
  resetState(stateId) {
    return Boolean(C._ts_lookahead_iterator_reset_state(this[0], stateId));
  }
  /**
   * Returns an iterator that iterates over the symbols of the lookahead iterator.
   *
   * The iterator will yield the current symbol name as a string for each step
   * until there are no more symbols to iterate over.
   */
  [Symbol.iterator]() {
    return {
      next: /* @__PURE__ */ __name(() => {
        if (C._ts_lookahead_iterator_next(this[0])) {
          return { done: false, value: this.currentType };
        }
        return { done: true, value: "" };
      }, "next")
    };
  }
}, __name(_a, "LookaheadIterator"), _a);
function getText2(tree, startIndex, endIndex, startPosition) {
  const length = endIndex - startIndex;
  let result = tree.textCallback(startIndex, startPosition);
  if (result) {
    startIndex += result.length;
    while (startIndex < endIndex) {
      const string2 = tree.textCallback(startIndex, startPosition);
      if (string2 && string2.length > 0) {
        startIndex += string2.length;
        result += string2;
      } else {
        break;
      }
    }
    if (startIndex > endIndex) {
      result = result.slice(0, length);
    }
  }
  return result ?? "";
}
__name(getText2, "getText");
var _a2;
var Tree = (_a2 = class {
  /** @internal */
  constructor(internal, address, language, textCallback) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "textCallback");
    /** The language that was used to parse the syntax tree. */
    __publicField(this, "language");
    assertInternal(internal);
    this[0] = address;
    this.language = language;
    this.textCallback = textCallback;
  }
  /** Create a shallow copy of the syntax tree. This is very fast. */
  copy() {
    const address = C._ts_tree_copy(this[0]);
    return new _a2(INTERNAL, address, this.language, this.textCallback);
  }
  /** Delete the syntax tree, freeing its resources. */
  delete() {
    C._ts_tree_delete(this[0]);
    this[0] = 0;
  }
  /** Get the root node of the syntax tree. */
  get rootNode() {
    C._ts_tree_root_node_wasm(this[0]);
    return unmarshalNode(this);
  }
  /**
   * Get the root node of the syntax tree, but with its position shifted
   * forward by the given offset.
   */
  rootNodeWithOffset(offsetBytes, offsetExtent) {
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, offsetBytes, "i32");
    marshalPoint(address + SIZE_OF_INT, offsetExtent);
    C._ts_tree_root_node_with_offset_wasm(this[0]);
    return unmarshalNode(this);
  }
  /**
   * Edit the syntax tree to keep it in sync with source code that has been
   * edited.
   *
   * You must describe the edit both in terms of byte offsets and in terms of
   * row/column coordinates.
   */
  edit(edit) {
    marshalEdit(edit);
    C._ts_tree_edit_wasm(this[0]);
  }
  /** Create a new {@link TreeCursor} starting from the root of the tree. */
  walk() {
    return this.rootNode.walk();
  }
  /**
   * Compare this old edited syntax tree to a new syntax tree representing
   * the same document, returning a sequence of ranges whose syntactic
   * structure has changed.
   *
   * For this to work correctly, this syntax tree must have been edited such
   * that its ranges match up to the new tree. Generally, you'll want to
   * call this method right after calling one of the [`Parser::parse`]
   * functions. Call it on the old tree that was passed to parse, and
   * pass the new tree that was returned from `parse`.
   */
  getChangedRanges(other) {
    if (!(other instanceof _a2)) {
      throw new TypeError("Argument must be a Tree");
    }
    C._ts_tree_get_changed_ranges_wasm(this[0], other[0]);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = unmarshalRange(address);
        address += SIZE_OF_RANGE;
      }
      C._free(buffer);
    }
    return result;
  }
  /** Get the included ranges that were used to parse the syntax tree. */
  getIncludedRanges() {
    C._ts_tree_included_ranges_wasm(this[0]);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = unmarshalRange(address);
        address += SIZE_OF_RANGE;
      }
      C._free(buffer);
    }
    return result;
  }
}, __name(_a2, "Tree"), _a2);
var _a3;
var TreeCursor = (_a3 = class {
  /** @internal */
  constructor(internal, tree) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, 1, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, 2, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, 3, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "tree");
    assertInternal(internal);
    this.tree = tree;
    unmarshalTreeCursor(this);
  }
  /** Creates a deep copy of the tree cursor. This allocates new memory. */
  copy() {
    const copy = new _a3(INTERNAL, this.tree);
    C._ts_tree_cursor_copy_wasm(this.tree[0]);
    unmarshalTreeCursor(copy);
    return copy;
  }
  /** Delete the tree cursor, freeing its resources. */
  delete() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_delete_wasm(this.tree[0]);
    this[0] = this[1] = this[2] = 0;
  }
  /** Get the tree cursor's current {@link Node}. */
  get currentNode() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_current_node_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get the numerical field id of this tree cursor's current node.
   *
   * See also {@link TreeCursor#currentFieldName}.
   */
  get currentFieldId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);
  }
  /** Get the field name of this tree cursor's current node. */
  get currentFieldName() {
    return this.tree.language.fields[this.currentFieldId];
  }
  /**
   * Get the depth of the cursor's current node relative to the original
   * node that the cursor was constructed with.
   */
  get currentDepth() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_depth_wasm(this.tree[0]);
  }
  /**
   * Get the index of the cursor's current node out of all of the
   * descendants of the original node that the cursor was constructed with.
   */
  get currentDescendantIndex() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_descendant_index_wasm(this.tree[0]);
  }
  /** Get the type of the cursor's current node. */
  get nodeType() {
    return this.tree.language.types[this.nodeTypeId] || "ERROR";
  }
  /** Get the type id of the cursor's current node. */
  get nodeTypeId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);
  }
  /** Get the state id of the cursor's current node. */
  get nodeStateId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_state_id_wasm(this.tree[0]);
  }
  /** Get the id of the cursor's current node. */
  get nodeId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);
  }
  /**
   * Check if the cursor's current node is *named*.
   *
   * Named nodes correspond to named rules in the grammar, whereas
   * *anonymous* nodes correspond to string literals in the grammar.
   */
  get nodeIsNamed() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if the cursor's current node is *missing*.
   *
   * Missing nodes are inserted by the parser in order to recover from
   * certain kinds of syntax errors.
   */
  get nodeIsMissing() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;
  }
  /** Get the string content of the cursor's current node. */
  get nodeText() {
    marshalTreeCursor(this);
    const startIndex = C._ts_tree_cursor_start_index_wasm(this.tree[0]);
    const endIndex = C._ts_tree_cursor_end_index_wasm(this.tree[0]);
    C._ts_tree_cursor_start_position_wasm(this.tree[0]);
    const startPosition = unmarshalPoint(TRANSFER_BUFFER);
    return getText2(this.tree, startIndex, endIndex, startPosition);
  }
  /** Get the start position of the cursor's current node. */
  get startPosition() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_start_position_wasm(this.tree[0]);
    return unmarshalPoint(TRANSFER_BUFFER);
  }
  /** Get the end position of the cursor's current node. */
  get endPosition() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_end_position_wasm(this.tree[0]);
    return unmarshalPoint(TRANSFER_BUFFER);
  }
  /** Get the start index of the cursor's current node. */
  get startIndex() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_start_index_wasm(this.tree[0]);
  }
  /** Get the end index of the cursor's current node. */
  get endIndex() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_end_index_wasm(this.tree[0]);
  }
  /**
   * Move this cursor to the first child of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there were no children.
   */
  gotoFirstChild() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the last child of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there were no children.
   *
   * Note that this function may be slower than
   * {@link TreeCursor#gotoFirstChild} because it needs to
   * iterate through all the children to compute the child's position.
   */
  gotoLastChild() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_last_child_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the parent of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there was no parent node (the cursor was already on the
   * root node).
   *
   * Note that the node the cursor was constructed with is considered the root
   * of the cursor, and the cursor cannot walk outside this node.
   */
  gotoParent() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the next sibling of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there was no next sibling node.
   *
   * Note that the node the cursor was constructed with is considered the root
   * of the cursor, and the cursor cannot walk outside this node.
   */
  gotoNextSibling() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the previous sibling of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there was no previous sibling node.
   *
   * Note that this function may be slower than
   * {@link TreeCursor#gotoNextSibling} due to how node
   * positions are stored. In the worst case, this will need to iterate
   * through all the children up to the previous sibling node to recalculate
   * its position. Also note that the node the cursor was constructed with is
   * considered the root of the cursor, and the cursor cannot walk outside this node.
   */
  gotoPreviousSibling() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_previous_sibling_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move the cursor to the node that is the nth descendant of
   * the original node that the cursor was constructed with, where
   * zero represents the original node itself.
   */
  gotoDescendant(goalDescendantIndex) {
    marshalTreeCursor(this);
    C._ts_tree_cursor_goto_descendant_wasm(this.tree[0], goalDescendantIndex);
    unmarshalTreeCursor(this);
  }
  /**
   * Move this cursor to the first child of its current node that contains or
   * starts after the given byte offset.
   *
   * This returns `true` if the cursor successfully moved to a child node, and returns
   * `false` if no such child was found.
   */
  gotoFirstChildForIndex(goalIndex) {
    marshalTreeCursor(this);
    C.setValue(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalIndex, "i32");
    const result = C._ts_tree_cursor_goto_first_child_for_index_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the first child of its current node that contains or
   * starts after the given byte offset.
   *
   * This returns the index of the child node if one was found, and returns
   * `null` if no such child was found.
   */
  gotoFirstChildForPosition(goalPosition) {
    marshalTreeCursor(this);
    marshalPoint(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalPosition);
    const result = C._ts_tree_cursor_goto_first_child_for_position_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Re-initialize this tree cursor to start at the original node that the
   * cursor was constructed with.
   */
  reset(node) {
    marshalNode(node);
    marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE);
    C._ts_tree_cursor_reset_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
  }
  /**
   * Re-initialize a tree cursor to the same position as another cursor.
   *
   * Unlike {@link TreeCursor#reset}, this will not lose parent
   * information and allows reusing already created cursors.
   */
  resetTo(cursor) {
    marshalTreeCursor(this, TRANSFER_BUFFER);
    marshalTreeCursor(cursor, TRANSFER_BUFFER + SIZE_OF_CURSOR);
    C._ts_tree_cursor_reset_to_wasm(this.tree[0], cursor.tree[0]);
    unmarshalTreeCursor(this);
  }
}, __name(_a3, "TreeCursor"), _a3);
var _a4;
var Node = (_a4 = class {
  /** @internal */
  constructor(internal, {
    id: id2,
    tree,
    startIndex,
    startPosition,
    other
  }) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "_children");
    /** @internal */
    __publicField(this, "_namedChildren");
    /**
     * The numeric id for this node that is unique.
     *
     * Within a given syntax tree, no two nodes have the same id. However:
     *
     * * If a new tree is created based on an older tree, and a node from the old tree is reused in
     *   the process, then that node will have the same id in both trees.
     *
     * * A node not marked as having changes does not guarantee it was reused.
     *
     * * If a node is marked as having changed in the old tree, it will not be reused.
     */
    __publicField(this, "id");
    /** The byte index where this node starts. */
    __publicField(this, "startIndex");
    /** The position where this node starts. */
    __publicField(this, "startPosition");
    /** The tree that this node belongs to. */
    __publicField(this, "tree");
    assertInternal(internal);
    this[0] = other;
    this.id = id2;
    this.tree = tree;
    this.startIndex = startIndex;
    this.startPosition = startPosition;
  }
  /** Get this node's type as a numerical id. */
  get typeId() {
    marshalNode(this);
    return C._ts_node_symbol_wasm(this.tree[0]);
  }
  /**
   * Get the node's type as a numerical id as it appears in the grammar,
   * ignoring aliases.
   */
  get grammarId() {
    marshalNode(this);
    return C._ts_node_grammar_symbol_wasm(this.tree[0]);
  }
  /** Get this node's type as a string. */
  get type() {
    return this.tree.language.types[this.typeId] || "ERROR";
  }
  /**
   * Get this node's symbol name as it appears in the grammar, ignoring
   * aliases as a string.
   */
  get grammarType() {
    return this.tree.language.types[this.grammarId] || "ERROR";
  }
  /**
   * Check if this node is *named*.
   *
   * Named nodes correspond to named rules in the grammar, whereas
   * *anonymous* nodes correspond to string literals in the grammar.
   */
  get isNamed() {
    marshalNode(this);
    return C._ts_node_is_named_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node is *extra*.
   *
   * Extra nodes represent things like comments, which are not required
   * by the grammar, but can appear anywhere.
   */
  get isExtra() {
    marshalNode(this);
    return C._ts_node_is_extra_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node represents a syntax error.
   *
   * Syntax errors represent parts of the code that could not be incorporated
   * into a valid syntax tree.
   */
  get isError() {
    marshalNode(this);
    return C._ts_node_is_error_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node is *missing*.
   *
   * Missing nodes are inserted by the parser in order to recover from
   * certain kinds of syntax errors.
   */
  get isMissing() {
    marshalNode(this);
    return C._ts_node_is_missing_wasm(this.tree[0]) === 1;
  }
  /** Check if this node has been edited. */
  get hasChanges() {
    marshalNode(this);
    return C._ts_node_has_changes_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node represents a syntax error or contains any syntax
   * errors anywhere within it.
   */
  get hasError() {
    marshalNode(this);
    return C._ts_node_has_error_wasm(this.tree[0]) === 1;
  }
  /** Get the byte index where this node ends. */
  get endIndex() {
    marshalNode(this);
    return C._ts_node_end_index_wasm(this.tree[0]);
  }
  /** Get the position where this node ends. */
  get endPosition() {
    marshalNode(this);
    C._ts_node_end_point_wasm(this.tree[0]);
    return unmarshalPoint(TRANSFER_BUFFER);
  }
  /** Get the string content of this node. */
  get text() {
    return getText2(this.tree, this.startIndex, this.endIndex, this.startPosition);
  }
  /** Get this node's parse state. */
  get parseState() {
    marshalNode(this);
    return C._ts_node_parse_state_wasm(this.tree[0]);
  }
  /** Get the parse state after this node. */
  get nextParseState() {
    marshalNode(this);
    return C._ts_node_next_parse_state_wasm(this.tree[0]);
  }
  /** Check if this node is equal to another node. */
  equals(other) {
    return this.tree === other.tree && this.id === other.id;
  }
  /**
   * Get the node's child at the given index, where zero represents the first child.
   *
   * This method is fairly fast, but its cost is technically log(n), so if
   * you might be iterating over a long list of children, you should use
   * {@link Node#children} instead.
   */
  child(index) {
    marshalNode(this);
    C._ts_node_child_wasm(this.tree[0], index);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's *named* child at the given index.
   *
   * See also {@link Node#isNamed}.
   * This method is fairly fast, but its cost is technically log(n), so if
   * you might be iterating over a long list of children, you should use
   * {@link Node#namedChildren} instead.
   */
  namedChild(index) {
    marshalNode(this);
    C._ts_node_named_child_wasm(this.tree[0], index);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's child with the given numerical field id.
   *
   * See also {@link Node#childForFieldName}. You can
   * convert a field name to an id using {@link Language#fieldIdForName}.
   */
  childForFieldId(fieldId) {
    marshalNode(this);
    C._ts_node_child_by_field_id_wasm(this.tree[0], fieldId);
    return unmarshalNode(this.tree);
  }
  /**
   * Get the first child with the given field name.
   *
   * If multiple children may have the same field name, access them using
   * {@link Node#childrenForFieldName}.
   */
  childForFieldName(fieldName) {
    const fieldId = this.tree.language.fields.indexOf(fieldName);
    if (fieldId !== -1) return this.childForFieldId(fieldId);
    return null;
  }
  /** Get the field name of this node's child at the given index. */
  fieldNameForChild(index) {
    marshalNode(this);
    const address = C._ts_node_field_name_for_child_wasm(this.tree[0], index);
    if (!address) return null;
    return C.AsciiToString(address);
  }
  /** Get the field name of this node's named child at the given index. */
  fieldNameForNamedChild(index) {
    marshalNode(this);
    const address = C._ts_node_field_name_for_named_child_wasm(this.tree[0], index);
    if (!address) return null;
    return C.AsciiToString(address);
  }
  /**
   * Get an array of this node's children with a given field name.
   *
   * See also {@link Node#children}.
   */
  childrenForFieldName(fieldName) {
    const fieldId = this.tree.language.fields.indexOf(fieldName);
    if (fieldId !== -1 && fieldId !== 0) return this.childrenForFieldId(fieldId);
    return [];
  }
  /**
    * Get an array of this node's children with a given field id.
    *
    * See also {@link Node#childrenForFieldName}.
    */
  childrenForFieldId(fieldId) {
    marshalNode(this);
    C._ts_node_children_by_field_id_wasm(this.tree[0], fieldId);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = unmarshalNode(this.tree, address);
        address += SIZE_OF_NODE;
      }
      C._free(buffer);
    }
    return result;
  }
  /** Get the node's first child that contains or starts after the given byte offset. */
  firstChildForIndex(index) {
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, index, "i32");
    C._ts_node_first_child_for_byte_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the node's first named child that contains or starts after the given byte offset. */
  firstNamedChildForIndex(index) {
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, index, "i32");
    C._ts_node_first_named_child_for_byte_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get this node's number of children. */
  get childCount() {
    marshalNode(this);
    return C._ts_node_child_count_wasm(this.tree[0]);
  }
  /**
   * Get this node's number of *named* children.
   *
   * See also {@link Node#isNamed}.
   */
  get namedChildCount() {
    marshalNode(this);
    return C._ts_node_named_child_count_wasm(this.tree[0]);
  }
  /** Get this node's first child. */
  get firstChild() {
    return this.child(0);
  }
  /**
   * Get this node's first named child.
   *
   * See also {@link Node#isNamed}.
   */
  get firstNamedChild() {
    return this.namedChild(0);
  }
  /** Get this node's last child. */
  get lastChild() {
    return this.child(this.childCount - 1);
  }
  /**
   * Get this node's last named child.
   *
   * See also {@link Node#isNamed}.
   */
  get lastNamedChild() {
    return this.namedChild(this.namedChildCount - 1);
  }
  /**
   * Iterate over this node's children.
   *
   * If you're walking the tree recursively, you may want to use the
   * {@link TreeCursor} APIs directly instead.
   */
  get children() {
    if (!this._children) {
      marshalNode(this);
      C._ts_node_children_wasm(this.tree[0]);
      const count2 = C.getValue(TRANSFER_BUFFER, "i32");
      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
      this._children = new Array(count2);
      if (count2 > 0) {
        let address = buffer;
        for (let i2 = 0; i2 < count2; i2++) {
          this._children[i2] = unmarshalNode(this.tree, address);
          address += SIZE_OF_NODE;
        }
        C._free(buffer);
      }
    }
    return this._children;
  }
  /**
   * Iterate over this node's named children.
   *
   * See also {@link Node#children}.
   */
  get namedChildren() {
    if (!this._namedChildren) {
      marshalNode(this);
      C._ts_node_named_children_wasm(this.tree[0]);
      const count2 = C.getValue(TRANSFER_BUFFER, "i32");
      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
      this._namedChildren = new Array(count2);
      if (count2 > 0) {
        let address = buffer;
        for (let i2 = 0; i2 < count2; i2++) {
          this._namedChildren[i2] = unmarshalNode(this.tree, address);
          address += SIZE_OF_NODE;
        }
        C._free(buffer);
      }
    }
    return this._namedChildren;
  }
  /**
   * Get the descendants of this node that are the given type, or in the given types array.
   *
   * The types array should contain node type strings, which can be retrieved from {@link Language#types}.
   *
   * Additionally, a `startPosition` and `endPosition` can be passed in to restrict the search to a byte range.
   */
  descendantsOfType(types, startPosition = ZERO_POINT, endPosition = ZERO_POINT) {
    if (!Array.isArray(types)) types = [types];
    const symbols2 = [];
    const typesBySymbol = this.tree.language.types;
    for (const node_type of types) {
      if (node_type == "ERROR") {
        symbols2.push(65535);
      }
    }
    for (let i2 = 0, n = typesBySymbol.length; i2 < n; i2++) {
      if (types.includes(typesBySymbol[i2])) {
        symbols2.push(i2);
      }
    }
    const symbolsAddress = C._malloc(SIZE_OF_INT * symbols2.length);
    for (let i2 = 0, n = symbols2.length; i2 < n; i2++) {
      C.setValue(symbolsAddress + i2 * SIZE_OF_INT, symbols2[i2], "i32");
    }
    marshalNode(this);
    C._ts_node_descendants_of_type_wasm(
      this.tree[0],
      symbolsAddress,
      symbols2.length,
      startPosition.row,
      startPosition.column,
      endPosition.row,
      endPosition.column
    );
    const descendantCount = C.getValue(TRANSFER_BUFFER, "i32");
    const descendantAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(descendantCount);
    if (descendantCount > 0) {
      let address = descendantAddress;
      for (let i2 = 0; i2 < descendantCount; i2++) {
        result[i2] = unmarshalNode(this.tree, address);
        address += SIZE_OF_NODE;
      }
    }
    C._free(descendantAddress);
    C._free(symbolsAddress);
    return result;
  }
  /** Get this node's next sibling. */
  get nextSibling() {
    marshalNode(this);
    C._ts_node_next_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get this node's previous sibling. */
  get previousSibling() {
    marshalNode(this);
    C._ts_node_prev_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's next *named* sibling.
   *
   * See also {@link Node#isNamed}.
   */
  get nextNamedSibling() {
    marshalNode(this);
    C._ts_node_next_named_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's previous *named* sibling.
   *
   * See also {@link Node#isNamed}.
   */
  get previousNamedSibling() {
    marshalNode(this);
    C._ts_node_prev_named_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the node's number of descendants, including one for the node itself. */
  get descendantCount() {
    marshalNode(this);
    return C._ts_node_descendant_count_wasm(this.tree[0]);
  }
  /**
   * Get this node's immediate parent.
   * Prefer {@link Node#childWithDescendant} for iterating over this node's ancestors.
   */
  get parent() {
    marshalNode(this);
    C._ts_node_parent_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get the node that contains `descendant`.
   *
   * Note that this can return `descendant` itself.
   */
  childWithDescendant(descendant) {
    marshalNode(this);
    marshalNode(descendant, 1);
    C._ts_node_child_with_descendant_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest node within this node that spans the given byte range. */
  descendantForIndex(start2, end = start2) {
    if (typeof start2 !== "number" || typeof end !== "number") {
      throw new Error("Arguments must be numbers");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, start2, "i32");
    C.setValue(address + SIZE_OF_INT, end, "i32");
    C._ts_node_descendant_for_index_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest named node within this node that spans the given byte range. */
  namedDescendantForIndex(start2, end = start2) {
    if (typeof start2 !== "number" || typeof end !== "number") {
      throw new Error("Arguments must be numbers");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, start2, "i32");
    C.setValue(address + SIZE_OF_INT, end, "i32");
    C._ts_node_named_descendant_for_index_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest node within this node that spans the given point range. */
  descendantForPosition(start2, end = start2) {
    if (!isPoint(start2) || !isPoint(end)) {
      throw new Error("Arguments must be {row, column} objects");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    marshalPoint(address, start2);
    marshalPoint(address + SIZE_OF_POINT, end);
    C._ts_node_descendant_for_position_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest named node within this node that spans the given point range. */
  namedDescendantForPosition(start2, end = start2) {
    if (!isPoint(start2) || !isPoint(end)) {
      throw new Error("Arguments must be {row, column} objects");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    marshalPoint(address, start2);
    marshalPoint(address + SIZE_OF_POINT, end);
    C._ts_node_named_descendant_for_position_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Create a new {@link TreeCursor} starting from this node.
   *
   * Note that the given node is considered the root of the cursor,
   * and the cursor cannot walk outside this node.
   */
  walk() {
    marshalNode(this);
    C._ts_tree_cursor_new_wasm(this.tree[0]);
    return new TreeCursor(INTERNAL, this.tree);
  }
  /**
   * Edit this node to keep it in-sync with source code that has been edited.
   *
   * This function is only rarely needed. When you edit a syntax tree with
   * the {@link Tree#edit} method, all of the nodes that you retrieve from
   * the tree afterward will already reflect the edit. You only need to
   * use {@link Node#edit} when you have a specific {@link Node} instance that
   * you want to keep and continue to use after an edit.
   */
  edit(edit) {
    if (this.startIndex >= edit.oldEndIndex) {
      this.startIndex = edit.newEndIndex + (this.startIndex - edit.oldEndIndex);
      let subbedPointRow;
      let subbedPointColumn;
      if (this.startPosition.row > edit.oldEndPosition.row) {
        subbedPointRow = this.startPosition.row - edit.oldEndPosition.row;
        subbedPointColumn = this.startPosition.column;
      } else {
        subbedPointRow = 0;
        subbedPointColumn = this.startPosition.column;
        if (this.startPosition.column >= edit.oldEndPosition.column) {
          subbedPointColumn = this.startPosition.column - edit.oldEndPosition.column;
        }
      }
      if (subbedPointRow > 0) {
        this.startPosition.row += subbedPointRow;
        this.startPosition.column = subbedPointColumn;
      } else {
        this.startPosition.column += subbedPointColumn;
      }
    } else if (this.startIndex > edit.startIndex) {
      this.startIndex = edit.newEndIndex;
      this.startPosition.row = edit.newEndPosition.row;
      this.startPosition.column = edit.newEndPosition.column;
    }
  }
  /** Get the S-expression representation of this node. */
  toString() {
    marshalNode(this);
    const address = C._ts_node_to_string_wasm(this.tree[0]);
    const result = C.AsciiToString(address);
    C._free(address);
    return result;
  }
}, __name(_a4, "Node"), _a4);
function unmarshalCaptures(query, tree, address, patternIndex, result) {
  for (let i2 = 0, n = result.length; i2 < n; i2++) {
    const captureIndex = C.getValue(address, "i32");
    address += SIZE_OF_INT;
    const node = unmarshalNode(tree, address);
    address += SIZE_OF_NODE;
    result[i2] = { patternIndex, name: query.captureNames[captureIndex], node };
  }
  return address;
}
__name(unmarshalCaptures, "unmarshalCaptures");
function marshalNode(node, index = 0) {
  let address = TRANSFER_BUFFER + index * SIZE_OF_NODE;
  C.setValue(address, node.id, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node.startIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node.startPosition.row, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node.startPosition.column, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node[0], "i32");
}
__name(marshalNode, "marshalNode");
function unmarshalNode(tree, address = TRANSFER_BUFFER) {
  const id2 = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  if (id2 === 0) return null;
  const index = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  const row = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  const column = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  const other = C.getValue(address, "i32");
  const result = new Node(INTERNAL, {
    id: id2,
    tree,
    startIndex: index,
    startPosition: { row, column },
    other
  });
  return result;
}
__name(unmarshalNode, "unmarshalNode");
function marshalTreeCursor(cursor, address = TRANSFER_BUFFER) {
  C.setValue(address + 0 * SIZE_OF_INT, cursor[0], "i32");
  C.setValue(address + 1 * SIZE_OF_INT, cursor[1], "i32");
  C.setValue(address + 2 * SIZE_OF_INT, cursor[2], "i32");
  C.setValue(address + 3 * SIZE_OF_INT, cursor[3], "i32");
}
__name(marshalTreeCursor, "marshalTreeCursor");
function unmarshalTreeCursor(cursor) {
  cursor[0] = C.getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, "i32");
  cursor[1] = C.getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, "i32");
  cursor[2] = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
  cursor[3] = C.getValue(TRANSFER_BUFFER + 3 * SIZE_OF_INT, "i32");
}
__name(unmarshalTreeCursor, "unmarshalTreeCursor");
function marshalPoint(address, point) {
  C.setValue(address, point.row, "i32");
  C.setValue(address + SIZE_OF_INT, point.column, "i32");
}
__name(marshalPoint, "marshalPoint");
function unmarshalPoint(address) {
  const result = {
    row: C.getValue(address, "i32") >>> 0,
    column: C.getValue(address + SIZE_OF_INT, "i32") >>> 0
  };
  return result;
}
__name(unmarshalPoint, "unmarshalPoint");
function marshalRange(address, range3) {
  marshalPoint(address, range3.startPosition);
  address += SIZE_OF_POINT;
  marshalPoint(address, range3.endPosition);
  address += SIZE_OF_POINT;
  C.setValue(address, range3.startIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, range3.endIndex, "i32");
  address += SIZE_OF_INT;
}
__name(marshalRange, "marshalRange");
function unmarshalRange(address) {
  const result = {};
  result.startPosition = unmarshalPoint(address);
  address += SIZE_OF_POINT;
  result.endPosition = unmarshalPoint(address);
  address += SIZE_OF_POINT;
  result.startIndex = C.getValue(address, "i32") >>> 0;
  address += SIZE_OF_INT;
  result.endIndex = C.getValue(address, "i32") >>> 0;
  return result;
}
__name(unmarshalRange, "unmarshalRange");
function marshalEdit(edit, address = TRANSFER_BUFFER) {
  marshalPoint(address, edit.startPosition);
  address += SIZE_OF_POINT;
  marshalPoint(address, edit.oldEndPosition);
  address += SIZE_OF_POINT;
  marshalPoint(address, edit.newEndPosition);
  address += SIZE_OF_POINT;
  C.setValue(address, edit.startIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, edit.oldEndIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, edit.newEndIndex, "i32");
  address += SIZE_OF_INT;
}
__name(marshalEdit, "marshalEdit");
function unmarshalLanguageMetadata(address) {
  const result = {};
  result.major_version = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  result.minor_version = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  result.field_count = C.getValue(address, "i32");
  return result;
}
__name(unmarshalLanguageMetadata, "unmarshalLanguageMetadata");
var PREDICATE_STEP_TYPE_CAPTURE = 1;
var PREDICATE_STEP_TYPE_STRING = 2;
var QUERY_WORD_REGEX = /[\w-]+/g;
var CaptureQuantifier = {
  Zero: 0,
  ZeroOrOne: 1,
  ZeroOrMore: 2,
  One: 3,
  OneOrMore: 4
};
var isCaptureStep = /* @__PURE__ */ __name((step) => step.type === "capture", "isCaptureStep");
var isStringStep = /* @__PURE__ */ __name((step) => step.type === "string", "isStringStep");
var QueryErrorKind = {
  Syntax: 1,
  NodeName: 2,
  FieldName: 3,
  CaptureName: 4,
  PatternStructure: 5
};
var _a5;
var QueryError = (_a5 = class extends Error {
  constructor(kind, info2, index, length) {
    super(_a5.formatMessage(kind, info2));
    this.kind = kind;
    this.info = info2;
    this.index = index;
    this.length = length;
    this.name = "QueryError";
  }
  /** Formats an error message based on the error kind and info */
  static formatMessage(kind, info2) {
    switch (kind) {
      case QueryErrorKind.NodeName:
        return `Bad node name '${info2.word}'`;
      case QueryErrorKind.FieldName:
        return `Bad field name '${info2.word}'`;
      case QueryErrorKind.CaptureName:
        return `Bad capture name @${info2.word}`;
      case QueryErrorKind.PatternStructure:
        return `Bad pattern structure at offset ${info2.suffix}`;
      case QueryErrorKind.Syntax:
        return `Bad syntax at offset ${info2.suffix}`;
    }
  }
}, __name(_a5, "QueryError"), _a5);
function parseAnyPredicate(steps, index, operator, textPredicates) {
  if (steps.length !== 3) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected 2, got ${steps.length - 1}`
    );
  }
  if (!isCaptureStep(steps[1])) {
    throw new Error(
      `First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}"`
    );
  }
  const isPositive = operator === "eq?" || operator === "any-eq?";
  const matchAll2 = !operator.startsWith("any-");
  if (isCaptureStep(steps[2])) {
    const captureName1 = steps[1].name;
    const captureName2 = steps[2].name;
    textPredicates[index].push((captures) => {
      const nodes1 = [];
      const nodes2 = [];
      for (const c of captures) {
        if (c.name === captureName1) nodes1.push(c.node);
        if (c.name === captureName2) nodes2.push(c.node);
      }
      const compare = /* @__PURE__ */ __name((n1, n2, positive) => {
        return positive ? n1.text === n2.text : n1.text !== n2.text;
      }, "compare");
      return matchAll2 ? nodes1.every((n1) => nodes2.some((n2) => compare(n1, n2, isPositive))) : nodes1.some((n1) => nodes2.some((n2) => compare(n1, n2, isPositive)));
    });
  } else {
    const captureName = steps[1].name;
    const stringValue = steps[2].value;
    const matches = /* @__PURE__ */ __name((n) => n.text === stringValue, "matches");
    const doesNotMatch = /* @__PURE__ */ __name((n) => n.text !== stringValue, "doesNotMatch");
    textPredicates[index].push((captures) => {
      const nodes = [];
      for (const c of captures) {
        if (c.name === captureName) nodes.push(c.node);
      }
      const test = isPositive ? matches : doesNotMatch;
      return matchAll2 ? nodes.every(test) : nodes.some(test);
    });
  }
}
__name(parseAnyPredicate, "parseAnyPredicate");
function parseMatchPredicate(steps, index, operator, textPredicates) {
  if (steps.length !== 3) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected 2, got ${steps.length - 1}.`
    );
  }
  if (steps[1].type !== "capture") {
    throw new Error(
      `First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}".`
    );
  }
  if (steps[2].type !== "string") {
    throw new Error(
      `Second argument of \`#${operator}\` predicate must be a string. Got @${steps[2].name}.`
    );
  }
  const isPositive = operator === "match?" || operator === "any-match?";
  const matchAll2 = !operator.startsWith("any-");
  const captureName = steps[1].name;
  const regex = new RegExp(steps[2].value);
  textPredicates[index].push((captures) => {
    const nodes = [];
    for (const c of captures) {
      if (c.name === captureName) nodes.push(c.node.text);
    }
    const test = /* @__PURE__ */ __name((text, positive) => {
      return positive ? regex.test(text) : !regex.test(text);
    }, "test");
    if (nodes.length === 0) return !isPositive;
    return matchAll2 ? nodes.every((text) => test(text, isPositive)) : nodes.some((text) => test(text, isPositive));
  });
}
__name(parseMatchPredicate, "parseMatchPredicate");
function parseAnyOfPredicate(steps, index, operator, textPredicates) {
  if (steps.length < 2) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected at least 1. Got ${steps.length - 1}.`
    );
  }
  if (steps[1].type !== "capture") {
    throw new Error(
      `First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}".`
    );
  }
  const isPositive = operator === "any-of?";
  const captureName = steps[1].name;
  const stringSteps = steps.slice(2);
  if (!stringSteps.every(isStringStep)) {
    throw new Error(
      `Arguments to \`#${operator}\` predicate must be strings.".`
    );
  }
  const values2 = stringSteps.map((s) => s.value);
  textPredicates[index].push((captures) => {
    const nodes = [];
    for (const c of captures) {
      if (c.name === captureName) nodes.push(c.node.text);
    }
    if (nodes.length === 0) return !isPositive;
    return nodes.every((text) => values2.includes(text)) === isPositive;
  });
}
__name(parseAnyOfPredicate, "parseAnyOfPredicate");
function parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties) {
  if (steps.length < 2 || steps.length > 3) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`
    );
  }
  if (!steps.every(isStringStep)) {
    throw new Error(
      `Arguments to \`#${operator}\` predicate must be strings.".`
    );
  }
  const properties = operator === "is?" ? assertedProperties : refutedProperties;
  if (!properties[index]) properties[index] = {};
  properties[index][steps[1].value] = steps[2]?.value ?? null;
}
__name(parseIsPredicate, "parseIsPredicate");
function parseSetDirective(steps, index, setProperties) {
  if (steps.length < 2 || steps.length > 3) {
    throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`);
  }
  if (!steps.every(isStringStep)) {
    throw new Error(`Arguments to \`#set!\` predicate must be strings.".`);
  }
  if (!setProperties[index]) setProperties[index] = {};
  setProperties[index][steps[1].value] = steps[2]?.value ?? null;
}
__name(parseSetDirective, "parseSetDirective");
function parsePattern(index, stepType, stepValueId, captureNames2, stringValues, steps, textPredicates, predicates, setProperties, assertedProperties, refutedProperties) {
  if (stepType === PREDICATE_STEP_TYPE_CAPTURE) {
    const name2 = captureNames2[stepValueId];
    steps.push({ type: "capture", name: name2 });
  } else if (stepType === PREDICATE_STEP_TYPE_STRING) {
    steps.push({ type: "string", value: stringValues[stepValueId] });
  } else if (steps.length > 0) {
    if (steps[0].type !== "string") {
      throw new Error("Predicates must begin with a literal value");
    }
    const operator = steps[0].value;
    switch (operator) {
      case "any-not-eq?":
      case "not-eq?":
      case "any-eq?":
      case "eq?":
        parseAnyPredicate(steps, index, operator, textPredicates);
        break;
      case "any-not-match?":
      case "not-match?":
      case "any-match?":
      case "match?":
        parseMatchPredicate(steps, index, operator, textPredicates);
        break;
      case "not-any-of?":
      case "any-of?":
        parseAnyOfPredicate(steps, index, operator, textPredicates);
        break;
      case "is?":
      case "is-not?":
        parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties);
        break;
      case "set!":
        parseSetDirective(steps, index, setProperties);
        break;
      default:
        predicates[index].push({ operator, operands: steps.slice(1) });
    }
    steps.length = 0;
  }
}
__name(parsePattern, "parsePattern");
var _a6;
var Query = (_a6 = class {
  /**
   * Create a new query from a string containing one or more S-expression
   * patterns.
   *
   * The query is associated with a particular language, and can only be run
   * on syntax nodes parsed with that language. References to Queries can be
   * shared between multiple threads.
   *
   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}
   */
  constructor(language, source) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "exceededMatchLimit");
    /** @internal */
    __publicField(this, "textPredicates");
    /** The names of the captures used in the query. */
    __publicField(this, "captureNames");
    /** The quantifiers of the captures used in the query. */
    __publicField(this, "captureQuantifiers");
    /**
     * The other user-defined predicates associated with the given index.
     *
     * This includes predicates with operators other than:
     * - `match?`
     * - `eq?` and `not-eq?`
     * - `any-of?` and `not-any-of?`
     * - `is?` and `is-not?`
     * - `set!`
     */
    __publicField(this, "predicates");
    /** The properties for predicates with the operator `set!`. */
    __publicField(this, "setProperties");
    /** The properties for predicates with the operator `is?`. */
    __publicField(this, "assertedProperties");
    /** The properties for predicates with the operator `is-not?`. */
    __publicField(this, "refutedProperties");
    /** The maximum number of in-progress matches for this cursor. */
    __publicField(this, "matchLimit");
    const sourceLength = C.lengthBytesUTF8(source);
    const sourceAddress = C._malloc(sourceLength + 1);
    C.stringToUTF8(source, sourceAddress, sourceLength + 1);
    const address = C._ts_query_new(
      language[0],
      sourceAddress,
      sourceLength,
      TRANSFER_BUFFER,
      TRANSFER_BUFFER + SIZE_OF_INT
    );
    if (!address) {
      const errorId = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
      const errorByte = C.getValue(TRANSFER_BUFFER, "i32");
      const errorIndex = C.UTF8ToString(sourceAddress, errorByte).length;
      const suffix = source.slice(errorIndex, errorIndex + 100).split("\n")[0];
      const word = suffix.match(QUERY_WORD_REGEX)?.[0] ?? "";
      C._free(sourceAddress);
      switch (errorId) {
        case QueryErrorKind.Syntax:
          throw new QueryError(QueryErrorKind.Syntax, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);
        case QueryErrorKind.NodeName:
          throw new QueryError(errorId, { word }, errorIndex, word.length);
        case QueryErrorKind.FieldName:
          throw new QueryError(errorId, { word }, errorIndex, word.length);
        case QueryErrorKind.CaptureName:
          throw new QueryError(errorId, { word }, errorIndex, word.length);
        case QueryErrorKind.PatternStructure:
          throw new QueryError(errorId, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);
      }
    }
    const stringCount = C._ts_query_string_count(address);
    const captureCount = C._ts_query_capture_count(address);
    const patternCount = C._ts_query_pattern_count(address);
    const captureNames2 = new Array(captureCount);
    const captureQuantifiers = new Array(patternCount);
    const stringValues = new Array(stringCount);
    for (let i2 = 0; i2 < captureCount; i2++) {
      const nameAddress = C._ts_query_capture_name_for_id(
        address,
        i2,
        TRANSFER_BUFFER
      );
      const nameLength = C.getValue(TRANSFER_BUFFER, "i32");
      captureNames2[i2] = C.UTF8ToString(nameAddress, nameLength);
    }
    for (let i2 = 0; i2 < patternCount; i2++) {
      const captureQuantifiersArray = new Array(captureCount);
      for (let j = 0; j < captureCount; j++) {
        const quantifier = C._ts_query_capture_quantifier_for_id(address, i2, j);
        captureQuantifiersArray[j] = quantifier;
      }
      captureQuantifiers[i2] = captureQuantifiersArray;
    }
    for (let i2 = 0; i2 < stringCount; i2++) {
      const valueAddress = C._ts_query_string_value_for_id(
        address,
        i2,
        TRANSFER_BUFFER
      );
      const nameLength = C.getValue(TRANSFER_BUFFER, "i32");
      stringValues[i2] = C.UTF8ToString(valueAddress, nameLength);
    }
    const setProperties = new Array(patternCount);
    const assertedProperties = new Array(patternCount);
    const refutedProperties = new Array(patternCount);
    const predicates = new Array(patternCount);
    const textPredicates = new Array(patternCount);
    for (let i2 = 0; i2 < patternCount; i2++) {
      const predicatesAddress = C._ts_query_predicates_for_pattern(address, i2, TRANSFER_BUFFER);
      const stepCount = C.getValue(TRANSFER_BUFFER, "i32");
      predicates[i2] = [];
      textPredicates[i2] = [];
      const steps = new Array();
      let stepAddress = predicatesAddress;
      for (let j = 0; j < stepCount; j++) {
        const stepType = C.getValue(stepAddress, "i32");
        stepAddress += SIZE_OF_INT;
        const stepValueId = C.getValue(stepAddress, "i32");
        stepAddress += SIZE_OF_INT;
        parsePattern(
          i2,
          stepType,
          stepValueId,
          captureNames2,
          stringValues,
          steps,
          textPredicates,
          predicates,
          setProperties,
          assertedProperties,
          refutedProperties
        );
      }
      Object.freeze(textPredicates[i2]);
      Object.freeze(predicates[i2]);
      Object.freeze(setProperties[i2]);
      Object.freeze(assertedProperties[i2]);
      Object.freeze(refutedProperties[i2]);
    }
    C._free(sourceAddress);
    this[0] = address;
    this.captureNames = captureNames2;
    this.captureQuantifiers = captureQuantifiers;
    this.textPredicates = textPredicates;
    this.predicates = predicates;
    this.setProperties = setProperties;
    this.assertedProperties = assertedProperties;
    this.refutedProperties = refutedProperties;
    this.exceededMatchLimit = false;
  }
  /** Delete the query, freeing its resources. */
  delete() {
    C._ts_query_delete(this[0]);
    this[0] = 0;
  }
  /**
   * Iterate over all of the matches in the order that they were found.
   *
   * Each match contains the index of the pattern that matched, and a list of
   * captures. Because multiple patterns can match the same set of nodes,
   * one match may contain captures that appear *before* some of the
   * captures from a previous match.
   *
   * @param {Node} node - The node to execute the query on.
   *
   * @param {QueryOptions} options - Options for query execution.
   */
  matches(node, options2 = {}) {
    const startPosition = options2.startPosition ?? ZERO_POINT;
    const endPosition = options2.endPosition ?? ZERO_POINT;
    const startIndex = options2.startIndex ?? 0;
    const endIndex = options2.endIndex ?? 0;
    const matchLimit = options2.matchLimit ?? 4294967295;
    const maxStartDepth = options2.maxStartDepth ?? 4294967295;
    const timeoutMicros = options2.timeoutMicros ?? 0;
    const progressCallback = options2.progressCallback;
    if (typeof matchLimit !== "number") {
      throw new Error("Arguments must be numbers");
    }
    this.matchLimit = matchLimit;
    if (endIndex !== 0 && startIndex > endIndex) {
      throw new Error("`startIndex` cannot be greater than `endIndex`");
    }
    if (endPosition !== ZERO_POINT && (startPosition.row > endPosition.row || startPosition.row === endPosition.row && startPosition.column > endPosition.column)) {
      throw new Error("`startPosition` cannot be greater than `endPosition`");
    }
    if (progressCallback) {
      C.currentQueryProgressCallback = progressCallback;
    }
    marshalNode(node);
    C._ts_query_matches_wasm(
      this[0],
      node.tree[0],
      startPosition.row,
      startPosition.column,
      endPosition.row,
      endPosition.column,
      startIndex,
      endIndex,
      matchLimit,
      maxStartDepth,
      timeoutMicros
    );
    const rawCount = C.getValue(TRANSFER_BUFFER, "i32");
    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
    const result = new Array(rawCount);
    this.exceededMatchLimit = Boolean(didExceedMatchLimit);
    let filteredCount = 0;
    let address = startAddress;
    for (let i2 = 0; i2 < rawCount; i2++) {
      const patternIndex = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captureCount = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captures = new Array(captureCount);
      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);
      if (this.textPredicates[patternIndex].every((p) => p(captures))) {
        result[filteredCount] = { pattern: patternIndex, patternIndex, captures };
        const setProperties = this.setProperties[patternIndex];
        result[filteredCount].setProperties = setProperties;
        const assertedProperties = this.assertedProperties[patternIndex];
        result[filteredCount].assertedProperties = assertedProperties;
        const refutedProperties = this.refutedProperties[patternIndex];
        result[filteredCount].refutedProperties = refutedProperties;
        filteredCount++;
      }
    }
    result.length = filteredCount;
    C._free(startAddress);
    C.currentQueryProgressCallback = null;
    return result;
  }
  /**
   * Iterate over all of the individual captures in the order that they
   * appear.
   *
   * This is useful if you don't care about which pattern matched, and just
   * want a single, ordered sequence of captures.
   *
   * @param {Node} node - The node to execute the query on.
   *
   * @param {QueryOptions} options - Options for query execution.
   */
  captures(node, options2 = {}) {
    const startPosition = options2.startPosition ?? ZERO_POINT;
    const endPosition = options2.endPosition ?? ZERO_POINT;
    const startIndex = options2.startIndex ?? 0;
    const endIndex = options2.endIndex ?? 0;
    const matchLimit = options2.matchLimit ?? 4294967295;
    const maxStartDepth = options2.maxStartDepth ?? 4294967295;
    const timeoutMicros = options2.timeoutMicros ?? 0;
    const progressCallback = options2.progressCallback;
    if (typeof matchLimit !== "number") {
      throw new Error("Arguments must be numbers");
    }
    this.matchLimit = matchLimit;
    if (endIndex !== 0 && startIndex > endIndex) {
      throw new Error("`startIndex` cannot be greater than `endIndex`");
    }
    if (endPosition !== ZERO_POINT && (startPosition.row > endPosition.row || startPosition.row === endPosition.row && startPosition.column > endPosition.column)) {
      throw new Error("`startPosition` cannot be greater than `endPosition`");
    }
    if (progressCallback) {
      C.currentQueryProgressCallback = progressCallback;
    }
    marshalNode(node);
    C._ts_query_captures_wasm(
      this[0],
      node.tree[0],
      startPosition.row,
      startPosition.column,
      endPosition.row,
      endPosition.column,
      startIndex,
      endIndex,
      matchLimit,
      maxStartDepth,
      timeoutMicros
    );
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
    const result = new Array();
    this.exceededMatchLimit = Boolean(didExceedMatchLimit);
    const captures = new Array();
    let address = startAddress;
    for (let i2 = 0; i2 < count2; i2++) {
      const patternIndex = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captureCount = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captureIndex = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      captures.length = captureCount;
      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);
      if (this.textPredicates[patternIndex].every((p) => p(captures))) {
        const capture = captures[captureIndex];
        const setProperties = this.setProperties[patternIndex];
        capture.setProperties = setProperties;
        const assertedProperties = this.assertedProperties[patternIndex];
        capture.assertedProperties = assertedProperties;
        const refutedProperties = this.refutedProperties[patternIndex];
        capture.refutedProperties = refutedProperties;
        result.push(capture);
      }
    }
    C._free(startAddress);
    C.currentQueryProgressCallback = null;
    return result;
  }
  /** Get the predicates for a given pattern. */
  predicatesForPattern(patternIndex) {
    return this.predicates[patternIndex];
  }
  /**
   * Disable a certain capture within a query.
   *
   * This prevents the capture from being returned in matches, and also
   * avoids any resource usage associated with recording the capture.
   */
  disableCapture(captureName) {
    const captureNameLength = C.lengthBytesUTF8(captureName);
    const captureNameAddress = C._malloc(captureNameLength + 1);
    C.stringToUTF8(captureName, captureNameAddress, captureNameLength + 1);
    C._ts_query_disable_capture(this[0], captureNameAddress, captureNameLength);
    C._free(captureNameAddress);
  }
  /**
   * Disable a certain pattern within a query.
   *
   * This prevents the pattern from matching, and also avoids any resource
   * usage associated with the pattern. This throws an error if the pattern
   * index is out of bounds.
   */
  disablePattern(patternIndex) {
    if (patternIndex >= this.predicates.length) {
      throw new Error(
        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`
      );
    }
    C._ts_query_disable_pattern(this[0], patternIndex);
  }
  /**
   * Check if, on its last execution, this cursor exceeded its maximum number
   * of in-progress matches.
   */
  didExceedMatchLimit() {
    return this.exceededMatchLimit;
  }
  /** Get the byte offset where the given pattern starts in the query's source. */
  startIndexForPattern(patternIndex) {
    if (patternIndex >= this.predicates.length) {
      throw new Error(
        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`
      );
    }
    return C._ts_query_start_byte_for_pattern(this[0], patternIndex);
  }
  /** Get the byte offset where the given pattern ends in the query's source. */
  endIndexForPattern(patternIndex) {
    if (patternIndex >= this.predicates.length) {
      throw new Error(
        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`
      );
    }
    return C._ts_query_end_byte_for_pattern(this[0], patternIndex);
  }
  /** Get the number of patterns in the query. */
  patternCount() {
    return C._ts_query_pattern_count(this[0]);
  }
  /** Get the index for a given capture name. */
  captureIndexForName(captureName) {
    return this.captureNames.indexOf(captureName);
  }
  /** Check if a given pattern within a query has a single root node. */
  isPatternRooted(patternIndex) {
    return C._ts_query_is_pattern_rooted(this[0], patternIndex) === 1;
  }
  /** Check if a given pattern within a query has a single root node. */
  isPatternNonLocal(patternIndex) {
    return C._ts_query_is_pattern_non_local(this[0], patternIndex) === 1;
  }
  /**
   * Check if a given step in a query is 'definite'.
   *
   * A query step is 'definite' if its parent pattern will be guaranteed to
   * match successfully once it reaches the step.
   */
  isPatternGuaranteedAtStep(byteIndex) {
    return C._ts_query_is_pattern_guaranteed_at_step(this[0], byteIndex) === 1;
  }
}, __name(_a6, "Query"), _a6);
var LANGUAGE_FUNCTION_REGEX = /^tree_sitter_\w+$/;
var _a7;
var Language = (_a7 = class {
  /** @internal */
  constructor(internal, address) {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /**
     * A list of all node types in the language. The index of each type in this
     * array is its node type id.
     */
    __publicField(this, "types");
    /**
     * A list of all field names in the language. The index of each field name in
     * this array is its field id.
     */
    __publicField(this, "fields");
    assertInternal(internal);
    this[0] = address;
    this.types = new Array(C._ts_language_symbol_count(this[0]));
    for (let i2 = 0, n = this.types.length; i2 < n; i2++) {
      if (C._ts_language_symbol_type(this[0], i2) < 2) {
        this.types[i2] = C.UTF8ToString(C._ts_language_symbol_name(this[0], i2));
      }
    }
    this.fields = new Array(C._ts_language_field_count(this[0]) + 1);
    for (let i2 = 0, n = this.fields.length; i2 < n; i2++) {
      const fieldName = C._ts_language_field_name_for_id(this[0], i2);
      if (fieldName !== 0) {
        this.fields[i2] = C.UTF8ToString(fieldName);
      } else {
        this.fields[i2] = null;
      }
    }
  }
  /**
   * Gets the name of the language.
   */
  get name() {
    const ptr = C._ts_language_name(this[0]);
    if (ptr === 0) return null;
    return C.UTF8ToString(ptr);
  }
  /**
   * @deprecated since version 0.25.0, use {@link Language#abiVersion} instead
   * Gets the version of the language.
   */
  get version() {
    return C._ts_language_version(this[0]);
  }
  /**
   * Gets the ABI version of the language.
   */
  get abiVersion() {
    return C._ts_language_abi_version(this[0]);
  }
  /**
  * Get the metadata for this language. This information is generated by the
  * CLI, and relies on the language author providing the correct metadata in
  * the language's `tree-sitter.json` file.
  */
  get metadata() {
    C._ts_language_metadata(this[0]);
    const length = C.getValue(TRANSFER_BUFFER, "i32");
    const address = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    if (length === 0) return null;
    return unmarshalLanguageMetadata(address);
  }
  /**
   * Gets the number of fields in the language.
   */
  get fieldCount() {
    return this.fields.length - 1;
  }
  /**
   * Gets the number of states in the language.
   */
  get stateCount() {
    return C._ts_language_state_count(this[0]);
  }
  /**
   * Get the field id for a field name.
   */
  fieldIdForName(fieldName) {
    const result = this.fields.indexOf(fieldName);
    return result !== -1 ? result : null;
  }
  /**
   * Get the field name for a field id.
   */
  fieldNameForId(fieldId) {
    return this.fields[fieldId] ?? null;
  }
  /**
   * Get the node type id for a node type name.
   */
  idForNodeType(type2, named) {
    const typeLength = C.lengthBytesUTF8(type2);
    const typeAddress = C._malloc(typeLength + 1);
    C.stringToUTF8(type2, typeAddress, typeLength + 1);
    const result = C._ts_language_symbol_for_name(this[0], typeAddress, typeLength, named ? 1 : 0);
    C._free(typeAddress);
    return result || null;
  }
  /**
   * Gets the number of node types in the language.
   */
  get nodeTypeCount() {
    return C._ts_language_symbol_count(this[0]);
  }
  /**
   * Get the node type name for a node type id.
   */
  nodeTypeForId(typeId) {
    const name2 = C._ts_language_symbol_name(this[0], typeId);
    return name2 ? C.UTF8ToString(name2) : null;
  }
  /**
   * Check if a node type is named.
   *
   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/2-basic-parsing.html#named-vs-anonymous-nodes}
   */
  nodeTypeIsNamed(typeId) {
    return C._ts_language_type_is_named_wasm(this[0], typeId) ? true : false;
  }
  /**
   * Check if a node type is visible.
   */
  nodeTypeIsVisible(typeId) {
    return C._ts_language_type_is_visible_wasm(this[0], typeId) ? true : false;
  }
  /**
   * Get the supertypes ids of this language.
   *
   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/6-static-node-types.html?highlight=supertype#supertype-nodes}
   */
  get supertypes() {
    C._ts_language_supertypes_wasm(this[0]);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = C.getValue(address, "i16");
        address += SIZE_OF_SHORT;
      }
    }
    return result;
  }
  /**
   * Get the subtype ids for a given supertype node id.
   */
  subtypes(supertype) {
    C._ts_language_subtypes_wasm(this[0], supertype);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = C.getValue(address, "i16");
        address += SIZE_OF_SHORT;
      }
    }
    return result;
  }
  /**
   * Get the next state id for a given state id and node type id.
   */
  nextState(stateId, typeId) {
    return C._ts_language_next_state(this[0], stateId, typeId);
  }
  /**
   * Create a new lookahead iterator for this language and parse state.
   *
   * This returns `null` if state is invalid for this language.
   *
   * Iterating {@link LookaheadIterator} will yield valid symbols in the given
   * parse state. Newly created lookahead iterators will return the `ERROR`
   * symbol from {@link LookaheadIterator#currentType}.
   *
   * Lookahead iterators can be useful for generating suggestions and improving
   * syntax error diagnostics. To get symbols valid in an `ERROR` node, use the
   * lookahead iterator on its first leaf node state. For `MISSING` nodes, a
   * lookahead iterator created on the previous non-extra leaf node may be
   * appropriate.
   */
  lookaheadIterator(stateId) {
    const address = C._ts_lookahead_iterator_new(this[0], stateId);
    if (address) return new LookaheadIterator(INTERNAL, address, this);
    return null;
  }
  /**
   * @deprecated since version 0.25.0, call `new` on a {@link Query} instead
   *
   * Create a new query from a string containing one or more S-expression
   * patterns.
   *
   * The query is associated with a particular language, and can only be run
   * on syntax nodes parsed with that language. References to Queries can be
   * shared between multiple threads.
   *
   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}
   */
  query(source) {
    console.warn("Language.query is deprecated. Use new Query(language, source) instead.");
    return new Query(this, source);
  }
  /**
   * Load a language from a WebAssembly module.
   * The module can be provided as a path to a file or as a buffer.
   */
  static async load(input) {
    let bytes;
    if (input instanceof Uint8Array) {
      bytes = Promise.resolve(input);
    } else {
      if (globalThis.process?.versions.node) {
        const fs2 = await import("fs/promises");
        bytes = fs2.readFile(input);
      } else {
        bytes = fetch(input).then((response) => response.arrayBuffer().then((buffer) => {
          if (response.ok) {
            return new Uint8Array(buffer);
          } else {
            const body2 = new TextDecoder("utf-8").decode(buffer);
            throw new Error(`Language.load failed with status ${response.status}.

${body2}`);
          }
        }));
      }
    }
    const mod = await C.loadWebAssemblyModule(await bytes, { loadAsync: true });
    const symbolNames = Object.keys(mod);
    const functionName = symbolNames.find((key) => LANGUAGE_FUNCTION_REGEX.test(key) && !key.includes("external_scanner_"));
    if (!functionName) {
      console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(symbolNames, null, 2)}`);
      throw new Error("Language.load failed: no language function found in WASM file");
    }
    const languageAddress = mod[functionName]();
    return new _a7(INTERNAL, languageAddress);
  }
}, __name(_a7, "Language"), _a7);
var Module2 = (() => {
  var _scriptName = import.meta.url;
  return async function(moduleArg = {}) {
    var moduleRtn;
    var Module = moduleArg;
    var readyPromiseResolve, readyPromiseReject;
    var readyPromise = new Promise((resolve, reject) => {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    var ENVIRONMENT_IS_WEB = typeof window == "object";
    var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != "undefined";
    var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
    if (ENVIRONMENT_IS_NODE) {
      const { createRequire } = await import("module");
      var require = createRequire(import.meta.url);
    }
    Module.currentQueryProgressCallback = null;
    Module.currentProgressCallback = null;
    Module.currentLogCallback = null;
    Module.currentParseCallback = null;
    var moduleOverrides = Object.assign({}, Module);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = /* @__PURE__ */ __name((status, toThrow) => {
      throw toThrow;
    }, "quit_");
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    __name(locateFile, "locateFile");
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_NODE) {
      var fs = require("fs");
      var nodePath = require("path");
      if (!import.meta.url.startsWith("data:")) {
        scriptDirectory = nodePath.dirname(require("url").fileURLToPath(import.meta.url)) + "/";
      }
      readBinary = /* @__PURE__ */ __name((filename) => {
        filename = isFileURI(filename) ? new URL(filename) : filename;
        var ret = fs.readFileSync(filename);
        return ret;
      }, "readBinary");
      readAsync = /* @__PURE__ */ __name(async (filename, binary22 = true) => {
        filename = isFileURI(filename) ? new URL(filename) : filename;
        var ret = fs.readFileSync(filename, binary22 ? void 0 : "utf8");
        return ret;
      }, "readAsync");
      if (!Module["thisProgram"] && process.argv.length > 1) {
        thisProgram = process.argv[1].replace(/\\/g, "/");
      }
      arguments_ = process.argv.slice(2);
      quit_ = /* @__PURE__ */ __name((status, toThrow) => {
        process.exitCode = status;
        throw toThrow;
      }, "quit_");
    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptName) {
        scriptDirectory = _scriptName;
      }
      if (scriptDirectory.startsWith("blob:")) {
        scriptDirectory = "";
      } else {
        scriptDirectory = scriptDirectory.slice(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      }
      {
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = /* @__PURE__ */ __name((url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(
              /** @type{!ArrayBuffer} */
              xhr.response
            );
          }, "readBinary");
        }
        readAsync = /* @__PURE__ */ __name(async (url) => {
          if (isFileURI(url)) {
            return new Promise((resolve, reject) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = () => {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  resolve(xhr.response);
                  return;
                }
                reject(xhr.status);
              };
              xhr.onerror = reject;
              xhr.send(null);
            });
          }
          var response = await fetch(url, {
            credentials: "same-origin"
          });
          if (response.ok) {
            return response.arrayBuffer();
          }
          throw new Error(response.status + " : " + response.url);
        }, "readAsync");
      }
    } else {
    }
    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.error.bind(console);
    Object.assign(Module, moduleOverrides);
    moduleOverrides = null;
    if (Module["arguments"]) arguments_ = Module["arguments"];
    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
    var dynamicLibraries = Module["dynamicLibraries"] || [];
    var wasmBinary = Module["wasmBinary"];
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }
    __name(assert, "assert");
    var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
    var HEAP_DATA_VIEW;
    var runtimeInitialized = false;
    var isFileURI = /* @__PURE__ */ __name((filename) => filename.startsWith("file://"), "isFileURI");
    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module["HEAP_DATA_VIEW"] = HEAP_DATA_VIEW = new DataView(b);
      Module["HEAP8"] = HEAP8 = new Int8Array(b);
      Module["HEAP16"] = HEAP16 = new Int16Array(b);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
      Module["HEAP32"] = HEAP32 = new Int32Array(b);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
      Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
      Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
    }
    __name(updateMemoryViews, "updateMemoryViews");
    if (Module["wasmMemory"]) {
      wasmMemory = Module["wasmMemory"];
    } else {
      var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 33554432;
      wasmMemory = new WebAssembly.Memory({
        "initial": INITIAL_MEMORY / 65536,
        // In theory we should not need to emit the maximum if we want "unlimited"
        // or 4GB of memory, but VMs error on that atm, see
        // https://github.com/emscripten-core/emscripten/issues/14130
        // And in the pthreads case we definitely need to emit a maximum. So
        // always emit one.
        "maximum": 32768
      });
    }
    updateMemoryViews();
    var __RELOC_FUNCS__ = [];
    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];
        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }
      callRuntimeCallbacks(onPreRuns);
    }
    __name(preRun, "preRun");
    function initRuntime() {
      runtimeInitialized = true;
      callRuntimeCallbacks(__RELOC_FUNCS__);
      wasmExports["__wasm_call_ctors"]();
      callRuntimeCallbacks(onPostCtors);
    }
    __name(initRuntime, "initRuntime");
    function preMain() {
    }
    __name(preMain, "preMain");
    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];
        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }
      callRuntimeCallbacks(onPostRuns);
    }
    __name(postRun, "postRun");
    var runDependencies = 0;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id2) {
      return id2;
    }
    __name(getUniqueRunDependency, "getUniqueRunDependency");
    function addRunDependency(id2) {
      runDependencies++;
      Module["monitorRunDependencies"]?.(runDependencies);
    }
    __name(addRunDependency, "addRunDependency");
    function removeRunDependency(id2) {
      runDependencies--;
      Module["monitorRunDependencies"]?.(runDependencies);
      if (runDependencies == 0) {
        if (dependenciesFulfilled) {
          var callback2 = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback2();
        }
      }
    }
    __name(removeRunDependency, "removeRunDependency");
    function abort(what) {
      Module["onAbort"]?.(what);
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      what += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    __name(abort, "abort");
    var wasmBinaryFile;
    function findWasmBinary() {
      if (Module["locateFile"]) {
        return locateFile("tree-sitter.wasm");
      }
      return new URL("tree-sitter.wasm", import.meta.url).href;
    }
    __name(findWasmBinary, "findWasmBinary");
    function getBinarySync(file) {
      if (file == wasmBinaryFile && wasmBinary) {
        return new Uint8Array(wasmBinary);
      }
      if (readBinary) {
        return readBinary(file);
      }
      throw "both async and sync fetching of the wasm failed";
    }
    __name(getBinarySync, "getBinarySync");
    async function getWasmBinary(binaryFile) {
      if (!wasmBinary) {
        try {
          var response = await readAsync(binaryFile);
          return new Uint8Array(response);
        } catch {
        }
      }
      return getBinarySync(binaryFile);
    }
    __name(getWasmBinary, "getWasmBinary");
    async function instantiateArrayBuffer(binaryFile, imports) {
      try {
        var binary22 = await getWasmBinary(binaryFile);
        var instance2 = await WebAssembly.instantiate(binary22, imports);
        return instance2;
      } catch (reason) {
        err(`failed to asynchronously prepare wasm: ${reason}`);
        abort(reason);
      }
    }
    __name(instantiateArrayBuffer, "instantiateArrayBuffer");
    async function instantiateAsync(binary22, binaryFile, imports) {
      if (!binary22 && typeof WebAssembly.instantiateStreaming == "function" && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE) {
        try {
          var response = fetch(binaryFile, {
            credentials: "same-origin"
          });
          var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
          return instantiationResult;
        } catch (reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
        }
      }
      return instantiateArrayBuffer(binaryFile, imports);
    }
    __name(instantiateAsync, "instantiateAsync");
    function getWasmImports() {
      return {
        "env": wasmImports,
        "wasi_snapshot_preview1": wasmImports,
        "GOT.mem": new Proxy(wasmImports, GOTHandler),
        "GOT.func": new Proxy(wasmImports, GOTHandler)
      };
    }
    __name(getWasmImports, "getWasmImports");
    async function createWasm() {
      function receiveInstance(instance2, module2) {
        wasmExports = instance2.exports;
        wasmExports = relocateExports(wasmExports, 1024);
        var metadata2 = getDylinkMetadata(module2);
        if (metadata2.neededDynlibs) {
          dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries);
        }
        mergeLibSymbols(wasmExports, "main");
        LDSO.init();
        loadDylibs();
        __RELOC_FUNCS__.push(wasmExports["__wasm_apply_data_relocs"]);
        removeRunDependency("wasm-instantiate");
        return wasmExports;
      }
      __name(receiveInstance, "receiveInstance");
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result2) {
        return receiveInstance(result2["instance"], result2["module"]);
      }
      __name(receiveInstantiationResult, "receiveInstantiationResult");
      var info2 = getWasmImports();
      if (Module["instantiateWasm"]) {
        return new Promise((resolve, reject) => {
          Module["instantiateWasm"](info2, (mod, inst) => {
            receiveInstance(mod, inst);
            resolve(mod.exports);
          });
        });
      }
      wasmBinaryFile ?? (wasmBinaryFile = findWasmBinary());
      try {
        var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info2);
        var exports2 = receiveInstantiationResult(result);
        return exports2;
      } catch (e) {
        readyPromiseReject(e);
        return Promise.reject(e);
      }
    }
    __name(createWasm, "createWasm");
    var ASM_CONSTS = {};
    const _ExitStatus = class _ExitStatus {
      constructor(status) {
        __publicField(this, "name", "ExitStatus");
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
    };
    __name(_ExitStatus, "ExitStatus");
    let ExitStatus = _ExitStatus;
    var GOT = {};
    var currentModuleWeakSymbols = /* @__PURE__ */ new Set([]);
    var GOTHandler = {
      get(obj, symName) {
        var rtn = GOT[symName];
        if (!rtn) {
          rtn = GOT[symName] = new WebAssembly.Global({
            "value": "i32",
            "mutable": true
          });
        }
        if (!currentModuleWeakSymbols.has(symName)) {
          rtn.required = true;
        }
        return rtn;
      }
    };
    var LE_HEAP_LOAD_F32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getFloat32(byteOffset, true), "LE_HEAP_LOAD_F32");
    var LE_HEAP_LOAD_F64 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getFloat64(byteOffset, true), "LE_HEAP_LOAD_F64");
    var LE_HEAP_LOAD_I16 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getInt16(byteOffset, true), "LE_HEAP_LOAD_I16");
    var LE_HEAP_LOAD_I32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getInt32(byteOffset, true), "LE_HEAP_LOAD_I32");
    var LE_HEAP_LOAD_U16 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getUint16(byteOffset, true), "LE_HEAP_LOAD_U16");
    var LE_HEAP_LOAD_U32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getUint32(byteOffset, true), "LE_HEAP_LOAD_U32");
    var LE_HEAP_STORE_F32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setFloat32(byteOffset, value, true), "LE_HEAP_STORE_F32");
    var LE_HEAP_STORE_F64 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setFloat64(byteOffset, value, true), "LE_HEAP_STORE_F64");
    var LE_HEAP_STORE_I16 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setInt16(byteOffset, value, true), "LE_HEAP_STORE_I16");
    var LE_HEAP_STORE_I32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setInt32(byteOffset, value, true), "LE_HEAP_STORE_I32");
    var LE_HEAP_STORE_U16 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setUint16(byteOffset, value, true), "LE_HEAP_STORE_U16");
    var LE_HEAP_STORE_U32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setUint32(byteOffset, value, true), "LE_HEAP_STORE_U32");
    var callRuntimeCallbacks = /* @__PURE__ */ __name((callbacks) => {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    }, "callRuntimeCallbacks");
    var onPostRuns = [];
    var addOnPostRun = /* @__PURE__ */ __name((cb) => onPostRuns.unshift(cb), "addOnPostRun");
    var onPreRuns = [];
    var addOnPreRun = /* @__PURE__ */ __name((cb) => onPreRuns.unshift(cb), "addOnPreRun");
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
    var UTF8ArrayToString = /* @__PURE__ */ __name((heapOrArray, idx = 0, maxBytesToRead = NaN) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str2 = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str2 += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str2 += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str2 += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str2 += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
      return str2;
    }, "UTF8ArrayToString");
    var getDylinkMetadata = /* @__PURE__ */ __name((binary22) => {
      var offset = 0;
      var end = 0;
      function getU8() {
        return binary22[offset++];
      }
      __name(getU8, "getU8");
      function getLEB() {
        var ret = 0;
        var mul = 1;
        while (1) {
          var byte = binary22[offset++];
          ret += (byte & 127) * mul;
          mul *= 128;
          if (!(byte & 128)) break;
        }
        return ret;
      }
      __name(getLEB, "getLEB");
      function getString() {
        var len = getLEB();
        offset += len;
        return UTF8ArrayToString(binary22, offset - len, len);
      }
      __name(getString, "getString");
      function failIf(condition, message) {
        if (condition) throw new Error(message);
      }
      __name(failIf, "failIf");
      var name2 = "dylink.0";
      if (binary22 instanceof WebAssembly.Module) {
        var dylinkSection = WebAssembly.Module.customSections(binary22, name2);
        if (dylinkSection.length === 0) {
          name2 = "dylink";
          dylinkSection = WebAssembly.Module.customSections(binary22, name2);
        }
        failIf(dylinkSection.length === 0, "need dylink section");
        binary22 = new Uint8Array(dylinkSection[0]);
        end = binary22.length;
      } else {
        var int32View = new Uint32Array(new Uint8Array(binary22.subarray(0, 24)).buffer);
        var magicNumberFound = int32View[0] == 1836278016 || int32View[0] == 6386541;
        failIf(!magicNumberFound, "need to see wasm magic number");
        failIf(binary22[8] !== 0, "need the dylink section to be first");
        offset = 9;
        var section_size = getLEB();
        end = offset + section_size;
        name2 = getString();
      }
      var customSection = {
        neededDynlibs: [],
        tlsExports: /* @__PURE__ */ new Set(),
        weakImports: /* @__PURE__ */ new Set()
      };
      if (name2 == "dylink") {
        customSection.memorySize = getLEB();
        customSection.memoryAlign = getLEB();
        customSection.tableSize = getLEB();
        customSection.tableAlign = getLEB();
        var neededDynlibsCount = getLEB();
        for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
          var libname = getString();
          customSection.neededDynlibs.push(libname);
        }
      } else {
        failIf(name2 !== "dylink.0");
        var WASM_DYLINK_MEM_INFO = 1;
        var WASM_DYLINK_NEEDED = 2;
        var WASM_DYLINK_EXPORT_INFO = 3;
        var WASM_DYLINK_IMPORT_INFO = 4;
        var WASM_SYMBOL_TLS = 256;
        var WASM_SYMBOL_BINDING_MASK = 3;
        var WASM_SYMBOL_BINDING_WEAK = 1;
        while (offset < end) {
          var subsectionType = getU8();
          var subsectionSize = getLEB();
          if (subsectionType === WASM_DYLINK_MEM_INFO) {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
          } else if (subsectionType === WASM_DYLINK_NEEDED) {
            var neededDynlibsCount = getLEB();
            for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
              libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
            var count2 = getLEB();
            while (count2--) {
              var symname = getString();
              var flags2 = getLEB();
              if (flags2 & WASM_SYMBOL_TLS) {
                customSection.tlsExports.add(symname);
              }
            }
          } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
            var count2 = getLEB();
            while (count2--) {
              var modname = getString();
              var symname = getString();
              var flags2 = getLEB();
              if ((flags2 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                customSection.weakImports.add(symname);
              }
            }
          } else {
            offset += subsectionSize;
          }
        }
      }
      return customSection;
    }, "getDylinkMetadata");
    function getValue(ptr, type2 = "i8") {
      if (type2.endsWith("*")) type2 = "*";
      switch (type2) {
        case "i1":
          return HEAP8[ptr];
        case "i8":
          return HEAP8[ptr];
        case "i16":
          return LE_HEAP_LOAD_I16((ptr >> 1) * 2);
        case "i32":
          return LE_HEAP_LOAD_I32((ptr >> 2) * 4);
        case "i64":
          return HEAP64[ptr >> 3];
        case "float":
          return LE_HEAP_LOAD_F32((ptr >> 2) * 4);
        case "double":
          return LE_HEAP_LOAD_F64((ptr >> 3) * 8);
        case "*":
          return LE_HEAP_LOAD_U32((ptr >> 2) * 4);
        default:
          abort(`invalid type for getValue: ${type2}`);
      }
    }
    __name(getValue, "getValue");
    var newDSO = /* @__PURE__ */ __name((name2, handle2, syms) => {
      var dso = {
        refcount: Infinity,
        name: name2,
        exports: syms,
        global: true
      };
      LDSO.loadedLibsByName[name2] = dso;
      if (handle2 != void 0) {
        LDSO.loadedLibsByHandle[handle2] = dso;
      }
      return dso;
    }, "newDSO");
    var LDSO = {
      loadedLibsByName: {},
      loadedLibsByHandle: {},
      init() {
        newDSO("__main__", 0, wasmImports);
      }
    };
    var ___heap_base = 78224;
    var alignMemory = /* @__PURE__ */ __name((size, alignment) => Math.ceil(size / alignment) * alignment, "alignMemory");
    var getMemory = /* @__PURE__ */ __name((size) => {
      if (runtimeInitialized) {
        return _calloc(size, 1);
      }
      var ret = ___heap_base;
      var end = ret + alignMemory(size, 16);
      ___heap_base = end;
      GOT["__heap_base"].value = end;
      return ret;
    }, "getMemory");
    var isInternalSym = /* @__PURE__ */ __name((symName) => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(symName) || symName.startsWith("__em_js__"), "isInternalSym");
    var uleb128Encode = /* @__PURE__ */ __name((n, target) => {
      if (n < 128) {
        target.push(n);
      } else {
        target.push(n % 128 | 128, n >> 7);
      }
    }, "uleb128Encode");
    var sigToWasmTypes = /* @__PURE__ */ __name((sig) => {
      var typeNames = {
        "i": "i32",
        "j": "i64",
        "f": "f32",
        "d": "f64",
        "e": "externref",
        "p": "i32"
      };
      var type2 = {
        parameters: [],
        results: sig[0] == "v" ? [] : [typeNames[sig[0]]]
      };
      for (var i2 = 1; i2 < sig.length; ++i2) {
        type2.parameters.push(typeNames[sig[i2]]);
      }
      return type2;
    }, "sigToWasmTypes");
    var generateFuncType = /* @__PURE__ */ __name((sig, target) => {
      var sigRet = sig.slice(0, 1);
      var sigParam = sig.slice(1);
      var typeCodes = {
        "i": 127,
        // i32
        "p": 127,
        // i32
        "j": 126,
        // i64
        "f": 125,
        // f32
        "d": 124,
        // f64
        "e": 111
      };
      target.push(96);
      uleb128Encode(sigParam.length, target);
      for (var i2 = 0; i2 < sigParam.length; ++i2) {
        target.push(typeCodes[sigParam[i2]]);
      }
      if (sigRet == "v") {
        target.push(0);
      } else {
        target.push(1, typeCodes[sigRet]);
      }
    }, "generateFuncType");
    var convertJsFunctionToWasm = /* @__PURE__ */ __name((func2, sig) => {
      if (typeof WebAssembly.Function == "function") {
        return new WebAssembly.Function(sigToWasmTypes(sig), func2);
      }
      var typeSectionBody = [1];
      generateFuncType(sig, typeSectionBody);
      var bytes = [
        0,
        97,
        115,
        109,
        // magic ("\0asm")
        1,
        0,
        0,
        0,
        // version: 1
        1
      ];
      uleb128Encode(typeSectionBody.length, bytes);
      bytes.push(...typeSectionBody);
      bytes.push(
        2,
        7,
        // import section
        // (import "e" "f" (func 0 (type 0)))
        1,
        1,
        101,
        1,
        102,
        0,
        0,
        7,
        5,
        // export section
        // (export "f" (func 0 (type 0)))
        1,
        1,
        102,
        0,
        0
      );
      var module2 = new WebAssembly.Module(new Uint8Array(bytes));
      var instance2 = new WebAssembly.Instance(module2, {
        "e": {
          "f": func2
        }
      });
      var wrappedFunc = instance2.exports["f"];
      return wrappedFunc;
    }, "convertJsFunctionToWasm");
    var wasmTableMirror = [];
    var wasmTable = new WebAssembly.Table({
      "initial": 31,
      "element": "anyfunc"
    });
    var getWasmTableEntry = /* @__PURE__ */ __name((funcPtr) => {
      var func2 = wasmTableMirror[funcPtr];
      if (!func2) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func2 = wasmTable.get(funcPtr);
      }
      return func2;
    }, "getWasmTableEntry");
    var updateTableMap = /* @__PURE__ */ __name((offset, count2) => {
      if (functionsInTableMap) {
        for (var i2 = offset; i2 < offset + count2; i2++) {
          var item = getWasmTableEntry(i2);
          if (item) {
            functionsInTableMap.set(item, i2);
          }
        }
      }
    }, "updateTableMap");
    var functionsInTableMap;
    var getFunctionAddress = /* @__PURE__ */ __name((func2) => {
      if (!functionsInTableMap) {
        functionsInTableMap = /* @__PURE__ */ new WeakMap();
        updateTableMap(0, wasmTable.length);
      }
      return functionsInTableMap.get(func2) || 0;
    }, "getFunctionAddress");
    var freeTableIndexes = [];
    var getEmptyTableSlot = /* @__PURE__ */ __name(() => {
      if (freeTableIndexes.length) {
        return freeTableIndexes.pop();
      }
      try {
        wasmTable.grow(1);
      } catch (err2) {
        if (!(err2 instanceof RangeError)) {
          throw err2;
        }
        throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
      }
      return wasmTable.length - 1;
    }, "getEmptyTableSlot");
    var setWasmTableEntry = /* @__PURE__ */ __name((idx, func2) => {
      wasmTable.set(idx, func2);
      wasmTableMirror[idx] = wasmTable.get(idx);
    }, "setWasmTableEntry");
    var addFunction = /* @__PURE__ */ __name((func2, sig) => {
      var rtn = getFunctionAddress(func2);
      if (rtn) {
        return rtn;
      }
      var ret = getEmptyTableSlot();
      try {
        setWasmTableEntry(ret, func2);
      } catch (err2) {
        if (!(err2 instanceof TypeError)) {
          throw err2;
        }
        var wrapped = convertJsFunctionToWasm(func2, sig);
        setWasmTableEntry(ret, wrapped);
      }
      functionsInTableMap.set(func2, ret);
      return ret;
    }, "addFunction");
    var updateGOT = /* @__PURE__ */ __name((exports2, replace) => {
      for (var symName in exports2) {
        if (isInternalSym(symName)) {
          continue;
        }
        var value = exports2[symName];
        GOT[symName] || (GOT[symName] = new WebAssembly.Global({
          "value": "i32",
          "mutable": true
        }));
        if (replace || GOT[symName].value == 0) {
          if (typeof value == "function") {
            GOT[symName].value = addFunction(value);
          } else if (typeof value == "number") {
            GOT[symName].value = value;
          } else {
            err(`unhandled export type for '${symName}': ${typeof value}`);
          }
        }
      }
    }, "updateGOT");
    var relocateExports = /* @__PURE__ */ __name((exports2, memoryBase2, replace) => {
      var relocated = {};
      for (var e in exports2) {
        var value = exports2[e];
        if (typeof value == "object") {
          value = value.value;
        }
        if (typeof value == "number") {
          value += memoryBase2;
        }
        relocated[e] = value;
      }
      updateGOT(relocated, replace);
      return relocated;
    }, "relocateExports");
    var isSymbolDefined = /* @__PURE__ */ __name((symName) => {
      var existing = wasmImports[symName];
      if (!existing || existing.stub) {
        return false;
      }
      return true;
    }, "isSymbolDefined");
    var dynCall = /* @__PURE__ */ __name((sig, ptr, args2 = []) => {
      var rtn = getWasmTableEntry(ptr)(...args2);
      return rtn;
    }, "dynCall");
    var stackSave = /* @__PURE__ */ __name(() => _emscripten_stack_get_current(), "stackSave");
    var stackRestore = /* @__PURE__ */ __name((val) => __emscripten_stack_restore(val), "stackRestore");
    var createInvokeFunction = /* @__PURE__ */ __name((sig) => (ptr, ...args2) => {
      var sp = stackSave();
      try {
        return dynCall(sig, ptr, args2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0) throw e;
        _setThrew(1, 0);
        if (sig[0] == "j") return 0n;
      }
    }, "createInvokeFunction");
    var resolveGlobalSymbol = /* @__PURE__ */ __name((symName, direct = false) => {
      var sym;
      if (isSymbolDefined(symName)) {
        sym = wasmImports[symName];
      } else if (symName.startsWith("invoke_")) {
        sym = wasmImports[symName] = createInvokeFunction(symName.split("_")[1]);
      }
      return {
        sym,
        name: symName
      };
    }, "resolveGlobalSymbol");
    var onPostCtors = [];
    var addOnPostCtor = /* @__PURE__ */ __name((cb) => onPostCtors.unshift(cb), "addOnPostCtor");
    var UTF8ToString = /* @__PURE__ */ __name((ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "", "UTF8ToString");
    var loadWebAssemblyModule = /* @__PURE__ */ __name((binary, flags, libName, localScope, handle) => {
      var metadata = getDylinkMetadata(binary);
      currentModuleWeakSymbols = metadata.weakImports;
      function loadModule() {
        var memAlign = Math.pow(2, metadata.memoryAlign);
        var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;
        var tableBase = metadata.tableSize ? wasmTable.length : 0;
        if (handle) {
          HEAP8[handle + 8] = 1;
          LE_HEAP_STORE_U32((handle + 12 >> 2) * 4, memoryBase);
          LE_HEAP_STORE_I32((handle + 16 >> 2) * 4, metadata.memorySize);
          LE_HEAP_STORE_U32((handle + 20 >> 2) * 4, tableBase);
          LE_HEAP_STORE_I32((handle + 24 >> 2) * 4, metadata.tableSize);
        }
        if (metadata.tableSize) {
          wasmTable.grow(metadata.tableSize);
        }
        var moduleExports;
        function resolveSymbol(sym) {
          var resolved = resolveGlobalSymbol(sym).sym;
          if (!resolved && localScope) {
            resolved = localScope[sym];
          }
          if (!resolved) {
            resolved = moduleExports[sym];
          }
          return resolved;
        }
        __name(resolveSymbol, "resolveSymbol");
        var proxyHandler = {
          get(stubs, prop) {
            switch (prop) {
              case "__memory_base":
                return memoryBase;
              case "__table_base":
                return tableBase;
            }
            if (prop in wasmImports && !wasmImports[prop].stub) {
              var res = wasmImports[prop];
              return res;
            }
            if (!(prop in stubs)) {
              var resolved;
              stubs[prop] = (...args2) => {
                resolved || (resolved = resolveSymbol(prop));
                return resolved(...args2);
              };
            }
            return stubs[prop];
          }
        };
        var proxy = new Proxy({}, proxyHandler);
        var info = {
          "GOT.mem": new Proxy({}, GOTHandler),
          "GOT.func": new Proxy({}, GOTHandler),
          "env": proxy,
          "wasi_snapshot_preview1": proxy
        };
        function postInstantiation(module, instance) {
          updateTableMap(tableBase, metadata.tableSize);
          moduleExports = relocateExports(instance.exports, memoryBase);
          if (!flags.allowUndefined) {
            reportUndefinedSymbols();
          }
          function addEmAsm(addr, body) {
            var args = [];
            var arity = 0;
            for (; arity < 16; arity++) {
              if (body.indexOf("$" + arity) != -1) {
                args.push("$" + arity);
              } else {
                break;
              }
            }
            args = args.join(",");
            var func = `(${args}) => { ${body} };`;
            ASM_CONSTS[start] = eval(func);
          }
          __name(addEmAsm, "addEmAsm");
          if ("__start_em_asm" in moduleExports) {
            var start = moduleExports["__start_em_asm"];
            var stop = moduleExports["__stop_em_asm"];
            while (start < stop) {
              var jsString = UTF8ToString(start);
              addEmAsm(start, jsString);
              start = HEAPU8.indexOf(0, start) + 1;
            }
          }
          function addEmJs(name, cSig, body) {
            var jsArgs = [];
            cSig = cSig.slice(1, -1);
            if (cSig != "void") {
              cSig = cSig.split(",");
              for (var i in cSig) {
                var jsArg = cSig[i].split(" ").pop();
                jsArgs.push(jsArg.replace("*", ""));
              }
            }
            var func = `(${jsArgs}) => ${body};`;
            moduleExports[name] = eval(func);
          }
          __name(addEmJs, "addEmJs");
          for (var name in moduleExports) {
            if (name.startsWith("__em_js__")) {
              var start = moduleExports[name];
              var jsString = UTF8ToString(start);
              var parts = jsString.split("<::>");
              addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]);
              delete moduleExports[name];
            }
          }
          var applyRelocs = moduleExports["__wasm_apply_data_relocs"];
          if (applyRelocs) {
            if (runtimeInitialized) {
              applyRelocs();
            } else {
              __RELOC_FUNCS__.push(applyRelocs);
            }
          }
          var init = moduleExports["__wasm_call_ctors"];
          if (init) {
            if (runtimeInitialized) {
              init();
            } else {
              addOnPostCtor(init);
            }
          }
          return moduleExports;
        }
        __name(postInstantiation, "postInstantiation");
        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(binary, instance));
          }
          return WebAssembly.instantiate(binary, info).then((result) => postInstantiation(result.module, result.instance));
        }
        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
        var instance = new WebAssembly.Instance(module, info);
        return postInstantiation(module, instance);
      }
      __name(loadModule, "loadModule");
      if (flags.loadAsync) {
        return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags, localScope)), Promise.resolve()).then(loadModule);
      }
      metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
      return loadModule();
    }, "loadWebAssemblyModule");
    var mergeLibSymbols = /* @__PURE__ */ __name((exports2, libName2) => {
      for (var [sym, exp] of Object.entries(exports2)) {
        const setImport = /* @__PURE__ */ __name((target) => {
          if (!isSymbolDefined(target)) {
            wasmImports[target] = exp;
          }
        }, "setImport");
        setImport(sym);
        const main_alias = "__main_argc_argv";
        if (sym == "main") {
          setImport(main_alias);
        }
        if (sym == main_alias) {
          setImport("main");
        }
      }
    }, "mergeLibSymbols");
    var asyncLoad = /* @__PURE__ */ __name(async (url) => {
      var arrayBuffer = await readAsync(url);
      return new Uint8Array(arrayBuffer);
    }, "asyncLoad");
    function loadDynamicLibrary(libName2, flags2 = {
      global: true,
      nodelete: true
    }, localScope2, handle2) {
      var dso = LDSO.loadedLibsByName[libName2];
      if (dso) {
        if (!flags2.global) {
          if (localScope2) {
            Object.assign(localScope2, dso.exports);
          }
        } else if (!dso.global) {
          dso.global = true;
          mergeLibSymbols(dso.exports, libName2);
        }
        if (flags2.nodelete && dso.refcount !== Infinity) {
          dso.refcount = Infinity;
        }
        dso.refcount++;
        if (handle2) {
          LDSO.loadedLibsByHandle[handle2] = dso;
        }
        return flags2.loadAsync ? Promise.resolve(true) : true;
      }
      dso = newDSO(libName2, handle2, "loading");
      dso.refcount = flags2.nodelete ? Infinity : 1;
      dso.global = flags2.global;
      function loadLibData() {
        if (handle2) {
          var data = LE_HEAP_LOAD_U32((handle2 + 28 >> 2) * 4);
          var dataSize = LE_HEAP_LOAD_U32((handle2 + 32 >> 2) * 4);
          if (data && dataSize) {
            var libData = HEAP8.slice(data, data + dataSize);
            return flags2.loadAsync ? Promise.resolve(libData) : libData;
          }
        }
        var libFile = locateFile(libName2);
        if (flags2.loadAsync) {
          return asyncLoad(libFile);
        }
        if (!readBinary) {
          throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
        }
        return readBinary(libFile);
      }
      __name(loadLibData, "loadLibData");
      function getExports() {
        if (flags2.loadAsync) {
          return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags2, libName2, localScope2, handle2));
        }
        return loadWebAssemblyModule(loadLibData(), flags2, libName2, localScope2, handle2);
      }
      __name(getExports, "getExports");
      function moduleLoaded(exports2) {
        if (dso.global) {
          mergeLibSymbols(exports2, libName2);
        } else if (localScope2) {
          Object.assign(localScope2, exports2);
        }
        dso.exports = exports2;
      }
      __name(moduleLoaded, "moduleLoaded");
      if (flags2.loadAsync) {
        return getExports().then((exports2) => {
          moduleLoaded(exports2);
          return true;
        });
      }
      moduleLoaded(getExports());
      return true;
    }
    __name(loadDynamicLibrary, "loadDynamicLibrary");
    var reportUndefinedSymbols = /* @__PURE__ */ __name(() => {
      for (var [symName, entry] of Object.entries(GOT)) {
        if (entry.value == 0) {
          var value = resolveGlobalSymbol(symName, true).sym;
          if (!value && !entry.required) {
            continue;
          }
          if (typeof value == "function") {
            entry.value = addFunction(value, value.sig);
          } else if (typeof value == "number") {
            entry.value = value;
          } else {
            throw new Error(`bad export type for '${symName}': ${typeof value}`);
          }
        }
      }
    }, "reportUndefinedSymbols");
    var loadDylibs = /* @__PURE__ */ __name(() => {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }
      addRunDependency("loadDylibs");
      dynamicLibraries.reduce((chain, lib) => chain.then(() => loadDynamicLibrary(lib, {
        loadAsync: true,
        global: true,
        nodelete: true,
        allowUndefined: true
      })), Promise.resolve()).then(() => {
        reportUndefinedSymbols();
        removeRunDependency("loadDylibs");
      });
    }, "loadDylibs");
    var noExitRuntime = Module["noExitRuntime"] || true;
    function setValue(ptr, value, type2 = "i8") {
      if (type2.endsWith("*")) type2 = "*";
      switch (type2) {
        case "i1":
          HEAP8[ptr] = value;
          break;
        case "i8":
          HEAP8[ptr] = value;
          break;
        case "i16":
          LE_HEAP_STORE_I16((ptr >> 1) * 2, value);
          break;
        case "i32":
          LE_HEAP_STORE_I32((ptr >> 2) * 4, value);
          break;
        case "i64":
          HEAP64[ptr >> 3] = BigInt(value);
          break;
        case "float":
          LE_HEAP_STORE_F32((ptr >> 2) * 4, value);
          break;
        case "double":
          LE_HEAP_STORE_F64((ptr >> 3) * 8, value);
          break;
        case "*":
          LE_HEAP_STORE_U32((ptr >> 2) * 4, value);
          break;
        default:
          abort(`invalid type for setValue: ${type2}`);
      }
    }
    __name(setValue, "setValue");
    var ___memory_base = new WebAssembly.Global({
      "value": "i32",
      "mutable": false
    }, 1024);
    var ___stack_pointer = new WebAssembly.Global({
      "value": "i32",
      "mutable": true
    }, 78224);
    var ___table_base = new WebAssembly.Global({
      "value": "i32",
      "mutable": false
    }, 1);
    var __abort_js = /* @__PURE__ */ __name(() => abort(""), "__abort_js");
    __abort_js.sig = "v";
    var _emscripten_get_now = /* @__PURE__ */ __name(() => performance.now(), "_emscripten_get_now");
    _emscripten_get_now.sig = "d";
    var _emscripten_date_now = /* @__PURE__ */ __name(() => Date.now(), "_emscripten_date_now");
    _emscripten_date_now.sig = "d";
    var nowIsMonotonic = 1;
    var checkWasiClock = /* @__PURE__ */ __name((clock_id) => clock_id >= 0 && clock_id <= 3, "checkWasiClock");
    var INT53_MAX = 9007199254740992;
    var INT53_MIN = -9007199254740992;
    var bigintToI53Checked = /* @__PURE__ */ __name((num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num), "bigintToI53Checked");
    function _clock_time_get(clk_id, ignored_precision, ptime) {
      ignored_precision = bigintToI53Checked(ignored_precision);
      if (!checkWasiClock(clk_id)) {
        return 28;
      }
      var now;
      if (clk_id === 0) {
        now = _emscripten_date_now();
      } else if (nowIsMonotonic) {
        now = _emscripten_get_now();
      } else {
        return 52;
      }
      var nsec = Math.round(now * 1e3 * 1e3);
      HEAP64[ptime >> 3] = BigInt(nsec);
      return 0;
    }
    __name(_clock_time_get, "_clock_time_get");
    _clock_time_get.sig = "iijp";
    var getHeapMax = /* @__PURE__ */ __name(() => (
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648
    ), "getHeapMax");
    var growMemory = /* @__PURE__ */ __name((size) => {
      var b = wasmMemory.buffer;
      var pages = (size - b.byteLength + 65535) / 65536 | 0;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e) {
      }
    }, "growMemory");
    var _emscripten_resize_heap = /* @__PURE__ */ __name((requestedSize) => {
      var oldSize = HEAPU8.length;
      requestedSize >>>= 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }, "_emscripten_resize_heap");
    _emscripten_resize_heap.sig = "ip";
    var _fd_close = /* @__PURE__ */ __name((fd) => 52, "_fd_close");
    _fd_close.sig = "ii";
    function _fd_seek(fd, offset, whence, newOffset) {
      offset = bigintToI53Checked(offset);
      return 70;
    }
    __name(_fd_seek, "_fd_seek");
    _fd_seek.sig = "iijip";
    var printCharBuffers = [null, [], []];
    var printChar = /* @__PURE__ */ __name((stream, curr) => {
      var buffer = printCharBuffers[stream];
      if (curr === 0 || curr === 10) {
        (stream === 1 ? out : err)(UTF8ArrayToString(buffer));
        buffer.length = 0;
      } else {
        buffer.push(curr);
      }
    }, "printChar");
    var flush_NO_FILESYSTEM = /* @__PURE__ */ __name(() => {
      if (printCharBuffers[1].length) printChar(1, 10);
      if (printCharBuffers[2].length) printChar(2, 10);
    }, "flush_NO_FILESYSTEM");
    var SYSCALLS = {
      varargs: void 0,
      getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }
    };
    var _fd_write = /* @__PURE__ */ __name((fd, iov, iovcnt, pnum) => {
      var num = 0;
      for (var i2 = 0; i2 < iovcnt; i2++) {
        var ptr = LE_HEAP_LOAD_U32((iov >> 2) * 4);
        var len = LE_HEAP_LOAD_U32((iov + 4 >> 2) * 4);
        iov += 8;
        for (var j = 0; j < len; j++) {
          printChar(fd, HEAPU8[ptr + j]);
        }
        num += len;
      }
      LE_HEAP_STORE_U32((pnum >> 2) * 4, num);
      return 0;
    }, "_fd_write");
    _fd_write.sig = "iippp";
    function _tree_sitter_log_callback(isLexMessage, messageAddress) {
      if (Module.currentLogCallback) {
        const message = UTF8ToString(messageAddress);
        Module.currentLogCallback(message, isLexMessage !== 0);
      }
    }
    __name(_tree_sitter_log_callback, "_tree_sitter_log_callback");
    function _tree_sitter_parse_callback(inputBufferAddress, index, row, column, lengthAddress) {
      const INPUT_BUFFER_SIZE = 10 * 1024;
      const string2 = Module.currentParseCallback(index, {
        row,
        column
      });
      if (typeof string2 === "string") {
        setValue(lengthAddress, string2.length, "i32");
        stringToUTF16(string2, inputBufferAddress, INPUT_BUFFER_SIZE);
      } else {
        setValue(lengthAddress, 0, "i32");
      }
    }
    __name(_tree_sitter_parse_callback, "_tree_sitter_parse_callback");
    function _tree_sitter_progress_callback(currentOffset, hasError) {
      if (Module.currentProgressCallback) {
        return Module.currentProgressCallback({
          currentOffset,
          hasError
        });
      }
      return false;
    }
    __name(_tree_sitter_progress_callback, "_tree_sitter_progress_callback");
    function _tree_sitter_query_progress_callback(currentOffset) {
      if (Module.currentQueryProgressCallback) {
        return Module.currentQueryProgressCallback({
          currentOffset
        });
      }
      return false;
    }
    __name(_tree_sitter_query_progress_callback, "_tree_sitter_query_progress_callback");
    var runtimeKeepaliveCounter = 0;
    var keepRuntimeAlive = /* @__PURE__ */ __name(() => noExitRuntime || runtimeKeepaliveCounter > 0, "keepRuntimeAlive");
    var _proc_exit = /* @__PURE__ */ __name((code) => {
      EXITSTATUS = code;
      if (!keepRuntimeAlive()) {
        Module["onExit"]?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    }, "_proc_exit");
    _proc_exit.sig = "vi";
    var exitJS = /* @__PURE__ */ __name((status, implicit) => {
      EXITSTATUS = status;
      _proc_exit(status);
    }, "exitJS");
    var handleException = /* @__PURE__ */ __name((e) => {
      if (e instanceof ExitStatus || e == "unwind") {
        return EXITSTATUS;
      }
      quit_(1, e);
    }, "handleException");
    var lengthBytesUTF8 = /* @__PURE__ */ __name((str2) => {
      var len = 0;
      for (var i2 = 0; i2 < str2.length; ++i2) {
        var c = str2.charCodeAt(i2);
        if (c <= 127) {
          len++;
        } else if (c <= 2047) {
          len += 2;
        } else if (c >= 55296 && c <= 57343) {
          len += 4;
          ++i2;
        } else {
          len += 3;
        }
      }
      return len;
    }, "lengthBytesUTF8");
    var stringToUTF8Array = /* @__PURE__ */ __name((str2, heap, outIdx, maxBytesToWrite) => {
      if (!(maxBytesToWrite > 0)) return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i2 = 0; i2 < str2.length; ++i2) {
        var u = str2.charCodeAt(i2);
        if (u >= 55296 && u <= 57343) {
          var u1 = str2.charCodeAt(++i2);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }, "stringToUTF8Array");
    var stringToUTF8 = /* @__PURE__ */ __name((str2, outPtr, maxBytesToWrite) => stringToUTF8Array(str2, HEAPU8, outPtr, maxBytesToWrite), "stringToUTF8");
    var stackAlloc = /* @__PURE__ */ __name((sz) => __emscripten_stack_alloc(sz), "stackAlloc");
    var stringToUTF8OnStack = /* @__PURE__ */ __name((str2) => {
      var size = lengthBytesUTF8(str2) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str2, ret, size);
      return ret;
    }, "stringToUTF8OnStack");
    var AsciiToString = /* @__PURE__ */ __name((ptr) => {
      var str2 = "";
      while (1) {
        var ch = HEAPU8[ptr++];
        if (!ch) return str2;
        str2 += String.fromCharCode(ch);
      }
    }, "AsciiToString");
    var stringToUTF16 = /* @__PURE__ */ __name((str2, outPtr, maxBytesToWrite) => {
      maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2;
      var startPtr = outPtr;
      var numCharsToWrite = maxBytesToWrite < str2.length * 2 ? maxBytesToWrite / 2 : str2.length;
      for (var i2 = 0; i2 < numCharsToWrite; ++i2) {
        var codeUnit = str2.charCodeAt(i2);
        LE_HEAP_STORE_I16((outPtr >> 1) * 2, codeUnit);
        outPtr += 2;
      }
      LE_HEAP_STORE_I16((outPtr >> 1) * 2, 0);
      return outPtr - startPtr;
    }, "stringToUTF16");
    var wasmImports = {
      /** @export */
      __heap_base: ___heap_base,
      /** @export */
      __indirect_function_table: wasmTable,
      /** @export */
      __memory_base: ___memory_base,
      /** @export */
      __stack_pointer: ___stack_pointer,
      /** @export */
      __table_base: ___table_base,
      /** @export */
      _abort_js: __abort_js,
      /** @export */
      clock_time_get: _clock_time_get,
      /** @export */
      emscripten_resize_heap: _emscripten_resize_heap,
      /** @export */
      fd_close: _fd_close,
      /** @export */
      fd_seek: _fd_seek,
      /** @export */
      fd_write: _fd_write,
      /** @export */
      memory: wasmMemory,
      /** @export */
      tree_sitter_log_callback: _tree_sitter_log_callback,
      /** @export */
      tree_sitter_parse_callback: _tree_sitter_parse_callback,
      /** @export */
      tree_sitter_progress_callback: _tree_sitter_progress_callback,
      /** @export */
      tree_sitter_query_progress_callback: _tree_sitter_query_progress_callback
    };
    var wasmExports = await createWasm();
    var ___wasm_call_ctors = wasmExports["__wasm_call_ctors"];
    var _malloc = Module["_malloc"] = wasmExports["malloc"];
    var _calloc = Module["_calloc"] = wasmExports["calloc"];
    var _realloc = Module["_realloc"] = wasmExports["realloc"];
    var _free = Module["_free"] = wasmExports["free"];
    var _memcmp = Module["_memcmp"] = wasmExports["memcmp"];
    var _ts_language_symbol_count = Module["_ts_language_symbol_count"] = wasmExports["ts_language_symbol_count"];
    var _ts_language_state_count = Module["_ts_language_state_count"] = wasmExports["ts_language_state_count"];
    var _ts_language_version = Module["_ts_language_version"] = wasmExports["ts_language_version"];
    var _ts_language_abi_version = Module["_ts_language_abi_version"] = wasmExports["ts_language_abi_version"];
    var _ts_language_metadata = Module["_ts_language_metadata"] = wasmExports["ts_language_metadata"];
    var _ts_language_name = Module["_ts_language_name"] = wasmExports["ts_language_name"];
    var _ts_language_field_count = Module["_ts_language_field_count"] = wasmExports["ts_language_field_count"];
    var _ts_language_next_state = Module["_ts_language_next_state"] = wasmExports["ts_language_next_state"];
    var _ts_language_symbol_name = Module["_ts_language_symbol_name"] = wasmExports["ts_language_symbol_name"];
    var _ts_language_symbol_for_name = Module["_ts_language_symbol_for_name"] = wasmExports["ts_language_symbol_for_name"];
    var _strncmp = Module["_strncmp"] = wasmExports["strncmp"];
    var _ts_language_symbol_type = Module["_ts_language_symbol_type"] = wasmExports["ts_language_symbol_type"];
    var _ts_language_field_name_for_id = Module["_ts_language_field_name_for_id"] = wasmExports["ts_language_field_name_for_id"];
    var _ts_lookahead_iterator_new = Module["_ts_lookahead_iterator_new"] = wasmExports["ts_lookahead_iterator_new"];
    var _ts_lookahead_iterator_delete = Module["_ts_lookahead_iterator_delete"] = wasmExports["ts_lookahead_iterator_delete"];
    var _ts_lookahead_iterator_reset_state = Module["_ts_lookahead_iterator_reset_state"] = wasmExports["ts_lookahead_iterator_reset_state"];
    var _ts_lookahead_iterator_reset = Module["_ts_lookahead_iterator_reset"] = wasmExports["ts_lookahead_iterator_reset"];
    var _ts_lookahead_iterator_next = Module["_ts_lookahead_iterator_next"] = wasmExports["ts_lookahead_iterator_next"];
    var _ts_lookahead_iterator_current_symbol = Module["_ts_lookahead_iterator_current_symbol"] = wasmExports["ts_lookahead_iterator_current_symbol"];
    var _ts_parser_delete = Module["_ts_parser_delete"] = wasmExports["ts_parser_delete"];
    var _ts_parser_reset = Module["_ts_parser_reset"] = wasmExports["ts_parser_reset"];
    var _ts_parser_set_language = Module["_ts_parser_set_language"] = wasmExports["ts_parser_set_language"];
    var _ts_parser_timeout_micros = Module["_ts_parser_timeout_micros"] = wasmExports["ts_parser_timeout_micros"];
    var _ts_parser_set_timeout_micros = Module["_ts_parser_set_timeout_micros"] = wasmExports["ts_parser_set_timeout_micros"];
    var _ts_parser_set_included_ranges = Module["_ts_parser_set_included_ranges"] = wasmExports["ts_parser_set_included_ranges"];
    var _ts_query_new = Module["_ts_query_new"] = wasmExports["ts_query_new"];
    var _ts_query_delete = Module["_ts_query_delete"] = wasmExports["ts_query_delete"];
    var _iswspace = Module["_iswspace"] = wasmExports["iswspace"];
    var _iswalnum = Module["_iswalnum"] = wasmExports["iswalnum"];
    var _ts_query_pattern_count = Module["_ts_query_pattern_count"] = wasmExports["ts_query_pattern_count"];
    var _ts_query_capture_count = Module["_ts_query_capture_count"] = wasmExports["ts_query_capture_count"];
    var _ts_query_string_count = Module["_ts_query_string_count"] = wasmExports["ts_query_string_count"];
    var _ts_query_capture_name_for_id = Module["_ts_query_capture_name_for_id"] = wasmExports["ts_query_capture_name_for_id"];
    var _ts_query_capture_quantifier_for_id = Module["_ts_query_capture_quantifier_for_id"] = wasmExports["ts_query_capture_quantifier_for_id"];
    var _ts_query_string_value_for_id = Module["_ts_query_string_value_for_id"] = wasmExports["ts_query_string_value_for_id"];
    var _ts_query_predicates_for_pattern = Module["_ts_query_predicates_for_pattern"] = wasmExports["ts_query_predicates_for_pattern"];
    var _ts_query_start_byte_for_pattern = Module["_ts_query_start_byte_for_pattern"] = wasmExports["ts_query_start_byte_for_pattern"];
    var _ts_query_end_byte_for_pattern = Module["_ts_query_end_byte_for_pattern"] = wasmExports["ts_query_end_byte_for_pattern"];
    var _ts_query_is_pattern_rooted = Module["_ts_query_is_pattern_rooted"] = wasmExports["ts_query_is_pattern_rooted"];
    var _ts_query_is_pattern_non_local = Module["_ts_query_is_pattern_non_local"] = wasmExports["ts_query_is_pattern_non_local"];
    var _ts_query_is_pattern_guaranteed_at_step = Module["_ts_query_is_pattern_guaranteed_at_step"] = wasmExports["ts_query_is_pattern_guaranteed_at_step"];
    var _ts_query_disable_capture = Module["_ts_query_disable_capture"] = wasmExports["ts_query_disable_capture"];
    var _ts_query_disable_pattern = Module["_ts_query_disable_pattern"] = wasmExports["ts_query_disable_pattern"];
    var _ts_tree_copy = Module["_ts_tree_copy"] = wasmExports["ts_tree_copy"];
    var _ts_tree_delete = Module["_ts_tree_delete"] = wasmExports["ts_tree_delete"];
    var _ts_init = Module["_ts_init"] = wasmExports["ts_init"];
    var _ts_parser_new_wasm = Module["_ts_parser_new_wasm"] = wasmExports["ts_parser_new_wasm"];
    var _ts_parser_enable_logger_wasm = Module["_ts_parser_enable_logger_wasm"] = wasmExports["ts_parser_enable_logger_wasm"];
    var _ts_parser_parse_wasm = Module["_ts_parser_parse_wasm"] = wasmExports["ts_parser_parse_wasm"];
    var _ts_parser_included_ranges_wasm = Module["_ts_parser_included_ranges_wasm"] = wasmExports["ts_parser_included_ranges_wasm"];
    var _ts_language_type_is_named_wasm = Module["_ts_language_type_is_named_wasm"] = wasmExports["ts_language_type_is_named_wasm"];
    var _ts_language_type_is_visible_wasm = Module["_ts_language_type_is_visible_wasm"] = wasmExports["ts_language_type_is_visible_wasm"];
    var _ts_language_supertypes_wasm = Module["_ts_language_supertypes_wasm"] = wasmExports["ts_language_supertypes_wasm"];
    var _ts_language_subtypes_wasm = Module["_ts_language_subtypes_wasm"] = wasmExports["ts_language_subtypes_wasm"];
    var _ts_tree_root_node_wasm = Module["_ts_tree_root_node_wasm"] = wasmExports["ts_tree_root_node_wasm"];
    var _ts_tree_root_node_with_offset_wasm = Module["_ts_tree_root_node_with_offset_wasm"] = wasmExports["ts_tree_root_node_with_offset_wasm"];
    var _ts_tree_edit_wasm = Module["_ts_tree_edit_wasm"] = wasmExports["ts_tree_edit_wasm"];
    var _ts_tree_included_ranges_wasm = Module["_ts_tree_included_ranges_wasm"] = wasmExports["ts_tree_included_ranges_wasm"];
    var _ts_tree_get_changed_ranges_wasm = Module["_ts_tree_get_changed_ranges_wasm"] = wasmExports["ts_tree_get_changed_ranges_wasm"];
    var _ts_tree_cursor_new_wasm = Module["_ts_tree_cursor_new_wasm"] = wasmExports["ts_tree_cursor_new_wasm"];
    var _ts_tree_cursor_copy_wasm = Module["_ts_tree_cursor_copy_wasm"] = wasmExports["ts_tree_cursor_copy_wasm"];
    var _ts_tree_cursor_delete_wasm = Module["_ts_tree_cursor_delete_wasm"] = wasmExports["ts_tree_cursor_delete_wasm"];
    var _ts_tree_cursor_reset_wasm = Module["_ts_tree_cursor_reset_wasm"] = wasmExports["ts_tree_cursor_reset_wasm"];
    var _ts_tree_cursor_reset_to_wasm = Module["_ts_tree_cursor_reset_to_wasm"] = wasmExports["ts_tree_cursor_reset_to_wasm"];
    var _ts_tree_cursor_goto_first_child_wasm = Module["_ts_tree_cursor_goto_first_child_wasm"] = wasmExports["ts_tree_cursor_goto_first_child_wasm"];
    var _ts_tree_cursor_goto_last_child_wasm = Module["_ts_tree_cursor_goto_last_child_wasm"] = wasmExports["ts_tree_cursor_goto_last_child_wasm"];
    var _ts_tree_cursor_goto_first_child_for_index_wasm = Module["_ts_tree_cursor_goto_first_child_for_index_wasm"] = wasmExports["ts_tree_cursor_goto_first_child_for_index_wasm"];
    var _ts_tree_cursor_goto_first_child_for_position_wasm = Module["_ts_tree_cursor_goto_first_child_for_position_wasm"] = wasmExports["ts_tree_cursor_goto_first_child_for_position_wasm"];
    var _ts_tree_cursor_goto_next_sibling_wasm = Module["_ts_tree_cursor_goto_next_sibling_wasm"] = wasmExports["ts_tree_cursor_goto_next_sibling_wasm"];
    var _ts_tree_cursor_goto_previous_sibling_wasm = Module["_ts_tree_cursor_goto_previous_sibling_wasm"] = wasmExports["ts_tree_cursor_goto_previous_sibling_wasm"];
    var _ts_tree_cursor_goto_descendant_wasm = Module["_ts_tree_cursor_goto_descendant_wasm"] = wasmExports["ts_tree_cursor_goto_descendant_wasm"];
    var _ts_tree_cursor_goto_parent_wasm = Module["_ts_tree_cursor_goto_parent_wasm"] = wasmExports["ts_tree_cursor_goto_parent_wasm"];
    var _ts_tree_cursor_current_node_type_id_wasm = Module["_ts_tree_cursor_current_node_type_id_wasm"] = wasmExports["ts_tree_cursor_current_node_type_id_wasm"];
    var _ts_tree_cursor_current_node_state_id_wasm = Module["_ts_tree_cursor_current_node_state_id_wasm"] = wasmExports["ts_tree_cursor_current_node_state_id_wasm"];
    var _ts_tree_cursor_current_node_is_named_wasm = Module["_ts_tree_cursor_current_node_is_named_wasm"] = wasmExports["ts_tree_cursor_current_node_is_named_wasm"];
    var _ts_tree_cursor_current_node_is_missing_wasm = Module["_ts_tree_cursor_current_node_is_missing_wasm"] = wasmExports["ts_tree_cursor_current_node_is_missing_wasm"];
    var _ts_tree_cursor_current_node_id_wasm = Module["_ts_tree_cursor_current_node_id_wasm"] = wasmExports["ts_tree_cursor_current_node_id_wasm"];
    var _ts_tree_cursor_start_position_wasm = Module["_ts_tree_cursor_start_position_wasm"] = wasmExports["ts_tree_cursor_start_position_wasm"];
    var _ts_tree_cursor_end_position_wasm = Module["_ts_tree_cursor_end_position_wasm"] = wasmExports["ts_tree_cursor_end_position_wasm"];
    var _ts_tree_cursor_start_index_wasm = Module["_ts_tree_cursor_start_index_wasm"] = wasmExports["ts_tree_cursor_start_index_wasm"];
    var _ts_tree_cursor_end_index_wasm = Module["_ts_tree_cursor_end_index_wasm"] = wasmExports["ts_tree_cursor_end_index_wasm"];
    var _ts_tree_cursor_current_field_id_wasm = Module["_ts_tree_cursor_current_field_id_wasm"] = wasmExports["ts_tree_cursor_current_field_id_wasm"];
    var _ts_tree_cursor_current_depth_wasm = Module["_ts_tree_cursor_current_depth_wasm"] = wasmExports["ts_tree_cursor_current_depth_wasm"];
    var _ts_tree_cursor_current_descendant_index_wasm = Module["_ts_tree_cursor_current_descendant_index_wasm"] = wasmExports["ts_tree_cursor_current_descendant_index_wasm"];
    var _ts_tree_cursor_current_node_wasm = Module["_ts_tree_cursor_current_node_wasm"] = wasmExports["ts_tree_cursor_current_node_wasm"];
    var _ts_node_symbol_wasm = Module["_ts_node_symbol_wasm"] = wasmExports["ts_node_symbol_wasm"];
    var _ts_node_field_name_for_child_wasm = Module["_ts_node_field_name_for_child_wasm"] = wasmExports["ts_node_field_name_for_child_wasm"];
    var _ts_node_field_name_for_named_child_wasm = Module["_ts_node_field_name_for_named_child_wasm"] = wasmExports["ts_node_field_name_for_named_child_wasm"];
    var _ts_node_children_by_field_id_wasm = Module["_ts_node_children_by_field_id_wasm"] = wasmExports["ts_node_children_by_field_id_wasm"];
    var _ts_node_first_child_for_byte_wasm = Module["_ts_node_first_child_for_byte_wasm"] = wasmExports["ts_node_first_child_for_byte_wasm"];
    var _ts_node_first_named_child_for_byte_wasm = Module["_ts_node_first_named_child_for_byte_wasm"] = wasmExports["ts_node_first_named_child_for_byte_wasm"];
    var _ts_node_grammar_symbol_wasm = Module["_ts_node_grammar_symbol_wasm"] = wasmExports["ts_node_grammar_symbol_wasm"];
    var _ts_node_child_count_wasm = Module["_ts_node_child_count_wasm"] = wasmExports["ts_node_child_count_wasm"];
    var _ts_node_named_child_count_wasm = Module["_ts_node_named_child_count_wasm"] = wasmExports["ts_node_named_child_count_wasm"];
    var _ts_node_child_wasm = Module["_ts_node_child_wasm"] = wasmExports["ts_node_child_wasm"];
    var _ts_node_named_child_wasm = Module["_ts_node_named_child_wasm"] = wasmExports["ts_node_named_child_wasm"];
    var _ts_node_child_by_field_id_wasm = Module["_ts_node_child_by_field_id_wasm"] = wasmExports["ts_node_child_by_field_id_wasm"];
    var _ts_node_next_sibling_wasm = Module["_ts_node_next_sibling_wasm"] = wasmExports["ts_node_next_sibling_wasm"];
    var _ts_node_prev_sibling_wasm = Module["_ts_node_prev_sibling_wasm"] = wasmExports["ts_node_prev_sibling_wasm"];
    var _ts_node_next_named_sibling_wasm = Module["_ts_node_next_named_sibling_wasm"] = wasmExports["ts_node_next_named_sibling_wasm"];
    var _ts_node_prev_named_sibling_wasm = Module["_ts_node_prev_named_sibling_wasm"] = wasmExports["ts_node_prev_named_sibling_wasm"];
    var _ts_node_descendant_count_wasm = Module["_ts_node_descendant_count_wasm"] = wasmExports["ts_node_descendant_count_wasm"];
    var _ts_node_parent_wasm = Module["_ts_node_parent_wasm"] = wasmExports["ts_node_parent_wasm"];
    var _ts_node_child_with_descendant_wasm = Module["_ts_node_child_with_descendant_wasm"] = wasmExports["ts_node_child_with_descendant_wasm"];
    var _ts_node_descendant_for_index_wasm = Module["_ts_node_descendant_for_index_wasm"] = wasmExports["ts_node_descendant_for_index_wasm"];
    var _ts_node_named_descendant_for_index_wasm = Module["_ts_node_named_descendant_for_index_wasm"] = wasmExports["ts_node_named_descendant_for_index_wasm"];
    var _ts_node_descendant_for_position_wasm = Module["_ts_node_descendant_for_position_wasm"] = wasmExports["ts_node_descendant_for_position_wasm"];
    var _ts_node_named_descendant_for_position_wasm = Module["_ts_node_named_descendant_for_position_wasm"] = wasmExports["ts_node_named_descendant_for_position_wasm"];
    var _ts_node_start_point_wasm = Module["_ts_node_start_point_wasm"] = wasmExports["ts_node_start_point_wasm"];
    var _ts_node_end_point_wasm = Module["_ts_node_end_point_wasm"] = wasmExports["ts_node_end_point_wasm"];
    var _ts_node_start_index_wasm = Module["_ts_node_start_index_wasm"] = wasmExports["ts_node_start_index_wasm"];
    var _ts_node_end_index_wasm = Module["_ts_node_end_index_wasm"] = wasmExports["ts_node_end_index_wasm"];
    var _ts_node_to_string_wasm = Module["_ts_node_to_string_wasm"] = wasmExports["ts_node_to_string_wasm"];
    var _ts_node_children_wasm = Module["_ts_node_children_wasm"] = wasmExports["ts_node_children_wasm"];
    var _ts_node_named_children_wasm = Module["_ts_node_named_children_wasm"] = wasmExports["ts_node_named_children_wasm"];
    var _ts_node_descendants_of_type_wasm = Module["_ts_node_descendants_of_type_wasm"] = wasmExports["ts_node_descendants_of_type_wasm"];
    var _ts_node_is_named_wasm = Module["_ts_node_is_named_wasm"] = wasmExports["ts_node_is_named_wasm"];
    var _ts_node_has_changes_wasm = Module["_ts_node_has_changes_wasm"] = wasmExports["ts_node_has_changes_wasm"];
    var _ts_node_has_error_wasm = Module["_ts_node_has_error_wasm"] = wasmExports["ts_node_has_error_wasm"];
    var _ts_node_is_error_wasm = Module["_ts_node_is_error_wasm"] = wasmExports["ts_node_is_error_wasm"];
    var _ts_node_is_missing_wasm = Module["_ts_node_is_missing_wasm"] = wasmExports["ts_node_is_missing_wasm"];
    var _ts_node_is_extra_wasm = Module["_ts_node_is_extra_wasm"] = wasmExports["ts_node_is_extra_wasm"];
    var _ts_node_parse_state_wasm = Module["_ts_node_parse_state_wasm"] = wasmExports["ts_node_parse_state_wasm"];
    var _ts_node_next_parse_state_wasm = Module["_ts_node_next_parse_state_wasm"] = wasmExports["ts_node_next_parse_state_wasm"];
    var _ts_query_matches_wasm = Module["_ts_query_matches_wasm"] = wasmExports["ts_query_matches_wasm"];
    var _ts_query_captures_wasm = Module["_ts_query_captures_wasm"] = wasmExports["ts_query_captures_wasm"];
    var _memset = Module["_memset"] = wasmExports["memset"];
    var _memcpy = Module["_memcpy"] = wasmExports["memcpy"];
    var _memmove = Module["_memmove"] = wasmExports["memmove"];
    var _iswalpha = Module["_iswalpha"] = wasmExports["iswalpha"];
    var _iswblank = Module["_iswblank"] = wasmExports["iswblank"];
    var _iswdigit = Module["_iswdigit"] = wasmExports["iswdigit"];
    var _iswlower = Module["_iswlower"] = wasmExports["iswlower"];
    var _iswupper = Module["_iswupper"] = wasmExports["iswupper"];
    var _iswxdigit = Module["_iswxdigit"] = wasmExports["iswxdigit"];
    var _memchr = Module["_memchr"] = wasmExports["memchr"];
    var _strlen = Module["_strlen"] = wasmExports["strlen"];
    var _strcmp = Module["_strcmp"] = wasmExports["strcmp"];
    var _strncat = Module["_strncat"] = wasmExports["strncat"];
    var _strncpy = Module["_strncpy"] = wasmExports["strncpy"];
    var _towlower = Module["_towlower"] = wasmExports["towlower"];
    var _towupper = Module["_towupper"] = wasmExports["towupper"];
    var _setThrew = wasmExports["setThrew"];
    var __emscripten_stack_restore = wasmExports["_emscripten_stack_restore"];
    var __emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"];
    var _emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"];
    var ___wasm_apply_data_relocs = wasmExports["__wasm_apply_data_relocs"];
    Module["setValue"] = setValue;
    Module["getValue"] = getValue;
    Module["UTF8ToString"] = UTF8ToString;
    Module["stringToUTF8"] = stringToUTF8;
    Module["lengthBytesUTF8"] = lengthBytesUTF8;
    Module["AsciiToString"] = AsciiToString;
    Module["stringToUTF16"] = stringToUTF16;
    Module["loadWebAssemblyModule"] = loadWebAssemblyModule;
    function callMain(args2 = []) {
      var entryFunction = resolveGlobalSymbol("main").sym;
      if (!entryFunction) return;
      args2.unshift(thisProgram);
      var argc = args2.length;
      var argv = stackAlloc((argc + 1) * 4);
      var argv_ptr = argv;
      args2.forEach((arg) => {
        LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, stringToUTF8OnStack(arg));
        argv_ptr += 4;
      });
      LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, 0);
      try {
        var ret = entryFunction(argc, argv);
        exitJS(
          ret,
          /* implicit = */
          true
        );
        return ret;
      } catch (e) {
        return handleException(e);
      }
    }
    __name(callMain, "callMain");
    function run(args2 = arguments_) {
      if (runDependencies > 0) {
        dependenciesFulfilled = run;
        return;
      }
      preRun();
      if (runDependencies > 0) {
        dependenciesFulfilled = run;
        return;
      }
      function doRun() {
        Module["calledRun"] = true;
        if (ABORT) return;
        initRuntime();
        preMain();
        readyPromiseResolve(Module);
        Module["onRuntimeInitialized"]?.();
        var noInitialRun = Module["noInitialRun"];
        if (!noInitialRun) callMain(args2);
        postRun();
      }
      __name(doRun, "doRun");
      if (Module["setStatus"]) {
        Module["setStatus"]("Running...");
        setTimeout(() => {
          setTimeout(() => Module["setStatus"](""), 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    __name(run, "run");
    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];
      while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }
    run();
    moduleRtn = readyPromise;
    return moduleRtn;
  };
})();
var tree_sitter_default = Module2;
var Module3 = null;
async function initializeBinding(moduleOptions) {
  if (!Module3) {
    Module3 = await tree_sitter_default(moduleOptions);
  }
  return Module3;
}
__name(initializeBinding, "initializeBinding");
function checkModule() {
  return !!Module3;
}
__name(checkModule, "checkModule");
var TRANSFER_BUFFER;
var LANGUAGE_VERSION;
var MIN_COMPATIBLE_VERSION;
var _a8;
var Parser2 = (_a8 = class {
  /**
   * Create a new parser.
   */
  constructor() {
    /** @internal */
    __publicField(this, 0, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, 1, 0);
    // Internal handle for WASM
    /** @internal */
    __publicField(this, "logCallback", null);
    /** The parser's current language. */
    __publicField(this, "language", null);
    this.initialize();
  }
  /**
   * This must always be called before creating a Parser.
   *
   * You can optionally pass in options to configure the WASM module, the most common
   * one being `locateFile` to help the module find the `.wasm` file.
   */
  static async init(moduleOptions) {
    setModule(await initializeBinding(moduleOptions));
    TRANSFER_BUFFER = C._ts_init();
    LANGUAGE_VERSION = C.getValue(TRANSFER_BUFFER, "i32");
    MIN_COMPATIBLE_VERSION = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
  }
  /** @internal */
  initialize() {
    if (!checkModule()) {
      throw new Error("cannot construct a Parser before calling `init()`");
    }
    C._ts_parser_new_wasm();
    this[0] = C.getValue(TRANSFER_BUFFER, "i32");
    this[1] = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
  }
  /** Delete the parser, freeing its resources. */
  delete() {
    C._ts_parser_delete(this[0]);
    C._free(this[1]);
    this[0] = 0;
    this[1] = 0;
  }
  /**
   * Set the language that the parser should use for parsing.
   *
   * If the language was not successfully assigned, an error will be thrown.
   * This happens if the language was generated with an incompatible
   * version of the Tree-sitter CLI. Check the language's version using
   * {@link Language#version} and compare it to this library's
   * {@link LANGUAGE_VERSION} and {@link MIN_COMPATIBLE_VERSION} constants.
   */
  setLanguage(language) {
    let address;
    if (!language) {
      address = 0;
      this.language = null;
    } else if (language.constructor === Language) {
      address = language[0];
      const version = C._ts_language_version(address);
      if (version < MIN_COMPATIBLE_VERSION || LANGUAGE_VERSION < version) {
        throw new Error(
          `Incompatible language version ${version}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${LANGUAGE_VERSION}.`
        );
      }
      this.language = language;
    } else {
      throw new Error("Argument must be a Language");
    }
    C._ts_parser_set_language(this[0], address);
    return this;
  }
  /**
   * Parse a slice of UTF8 text.
   *
   * @param {string | ParseCallback} callback - The UTF8-encoded text to parse or a callback function.
   *
   * @param {Tree | null} [oldTree] - A previous syntax tree parsed from the same document. If the text of the
   *   document has changed since `oldTree` was created, then you must edit `oldTree` to match
   *   the new text using {@link Tree#edit}.
   *
   * @param {ParseOptions} [options] - Options for parsing the text.
   *  This can be used to set the included ranges, or a progress callback.
   *
   * @returns {Tree | null} A {@link Tree} if parsing succeeded, or `null` if:
   *  - The parser has not yet had a language assigned with {@link Parser#setLanguage}.
   *  - The progress callback returned true.
   */
  parse(callback2, oldTree, options2) {
    if (typeof callback2 === "string") {
      C.currentParseCallback = (index) => callback2.slice(index);
    } else if (typeof callback2 === "function") {
      C.currentParseCallback = callback2;
    } else {
      throw new Error("Argument must be a string or a function");
    }
    if (options2?.progressCallback) {
      C.currentProgressCallback = options2.progressCallback;
    } else {
      C.currentProgressCallback = null;
    }
    if (this.logCallback) {
      C.currentLogCallback = this.logCallback;
      C._ts_parser_enable_logger_wasm(this[0], 1);
    } else {
      C.currentLogCallback = null;
      C._ts_parser_enable_logger_wasm(this[0], 0);
    }
    let rangeCount = 0;
    let rangeAddress = 0;
    if (options2?.includedRanges) {
      rangeCount = options2.includedRanges.length;
      rangeAddress = C._calloc(rangeCount, SIZE_OF_RANGE);
      let address = rangeAddress;
      for (let i2 = 0; i2 < rangeCount; i2++) {
        marshalRange(address, options2.includedRanges[i2]);
        address += SIZE_OF_RANGE;
      }
    }
    const treeAddress = C._ts_parser_parse_wasm(
      this[0],
      this[1],
      oldTree ? oldTree[0] : 0,
      rangeAddress,
      rangeCount
    );
    if (!treeAddress) {
      C.currentParseCallback = null;
      C.currentLogCallback = null;
      C.currentProgressCallback = null;
      return null;
    }
    if (!this.language) {
      throw new Error("Parser must have a language to parse");
    }
    const result = new Tree(INTERNAL, treeAddress, this.language, C.currentParseCallback);
    C.currentParseCallback = null;
    C.currentLogCallback = null;
    C.currentProgressCallback = null;
    return result;
  }
  /**
   * Instruct the parser to start the next parse from the beginning.
   *
   * If the parser previously failed because of a timeout, cancellation,
   * or callback, then by default, it will resume where it left off on the
   * next call to {@link Parser#parse} or other parsing functions.
   * If you don't want to resume, and instead intend to use this parser to
   * parse some other document, you must call `reset` first.
   */
  reset() {
    C._ts_parser_reset(this[0]);
  }
  /** Get the ranges of text that the parser will include when parsing. */
  getIncludedRanges() {
    C._ts_parser_included_ranges_wasm(this[0]);
    const count2 = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count2);
    if (count2 > 0) {
      let address = buffer;
      for (let i2 = 0; i2 < count2; i2++) {
        result[i2] = unmarshalRange(address);
        address += SIZE_OF_RANGE;
      }
      C._free(buffer);
    }
    return result;
  }
  /**
   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}
   *
   * Get the duration in microseconds that parsing is allowed to take.
   *
   * This is set via {@link Parser#setTimeoutMicros}.
   */
  getTimeoutMicros() {
    return C._ts_parser_timeout_micros(this[0]);
  }
  /**
   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}
   *
   * Set the maximum duration in microseconds that parsing should be allowed
   * to take before halting.
   *
   * If parsing takes longer than this, it will halt early, returning `null`.
   * See {@link Parser#parse} for more information.
   */
  setTimeoutMicros(timeout) {
    C._ts_parser_set_timeout_micros(this[0], 0, timeout);
  }
  /** Set the logging callback that a parser should use during parsing. */
  setLogger(callback2) {
    if (!callback2) {
      this.logCallback = null;
    } else if (typeof callback2 !== "function") {
      throw new Error("Logger callback must be a function");
    } else {
      this.logCallback = callback2;
    }
    return this;
  }
  /** Get the parser's current logger. */
  getLogger() {
    return this.logCallback;
  }
}, __name(_a8, "Parser"), _a8);

// src/ide/pathJoin.ts
function pathJoin(...segments) {
  return segments.join(pathSep());
}
function pathSep() {
  if (/^win/i.test(process.platform)) {
    return "\\";
  } else {
    return "/";
  }
}

// src/ide/JetbrainsTreeSitter.ts
var JetbrainsTreeSitter = class {
  constructor(wasmDirectory) {
    this.wasmDirectory = wasmDirectory;
    this.parsers = /* @__PURE__ */ new Map();
  }
  getTree(document2) {
    if (this.getLanguage(document2.languageId)) {
      const parser = this.parsers.get(document2.languageId);
      if (parser) {
        const tree = parser.parse(document2.getText());
        if (!tree) {
          throw new Error("Failed to parse document");
        }
        return tree;
      }
    }
    throw new Error("Language not supported");
  }
  async loadLanguage(languageId) {
    const parser = new Parser2();
    const filePath = pathJoin(
      this.wasmDirectory,
      `tree-sitter-${languageId}.wasm`
    );
    const language = await Language.load(filePath);
    parser.setLanguage(language);
    this.parsers.set(languageId, parser);
    return true;
  }
  getLanguage(languageId) {
    const parser = this.parsers.get(languageId);
    return parser?.language || void 0;
  }
  getNodeAtLocation(document2, range3) {
    const tree = this.getTree(document2);
    const node = tree.rootNode.descendantForPosition(
      {
        row: range3.start.line,
        column: range3.start.character
      },
      {
        row: range3.end.line,
        column: range3.end.character
      }
    );
    if (!node) {
      throw new Error("Node not found at location");
    }
    return node;
  }
  createQuery(languageId, source) {
    const language = this.getLanguage(languageId);
    if (!language) {
      return void 0;
    }
    try {
      return new Query(language, source);
    } catch (error) {
      console.error(`Failed to create query for language ${languageId}:`, error);
      return void 0;
    }
  }
};

// src/ide/JetbrainsTreeSitterQueryProvider.ts
var JetbrainsTreeSitterQueryProvider = class {
  constructor(ide2) {
    this.ide = ide2;
    this.notifier = new Notifier();
    this.disposables = [];
    this.onChanges = this.notifier.registerListener;
  }
  async readQuery(filename) {
    const queryContents = await this.ide.readQuery(filename);
    return queryContents;
  }
  dispose() {
    this.disposables.forEach((disposable) => disposable.dispose());
  }
};

// src/ide/JetbrainsCommandServer.ts
var JetbrainsCommandServer = class {
  constructor(client) {
    this.signals = {
      prePhrase: {
        getVersion: async () => {
          return this.client.prePhraseVersion();
        }
      }
    };
    this.client = client;
  }
  getFocusedElementType() {
    return Promise.resolve(void 0);
  }
};

// src/extension.ts
async function activate(plugin, wasmDirectory) {
  console.log("activate started");
  await Parser2.init({
    locateFile(scriptName, _scriptDirectory) {
      const fullPath = pathJoin(wasmDirectory, scriptName);
      return fullPath;
    }
  });
  console.log("Parser initialized");
  const commandServerApi = new JetbrainsCommandServer(plugin.client);
  const queryProvider = new JetbrainsTreeSitterQueryProvider(plugin.ide);
  const engine = await createCursorlessEngine({
    ide: plugin.ide,
    hats: plugin.hats,
    treeSitterQueryProvider: queryProvider,
    treeSitter: new JetbrainsTreeSitter(wasmDirectory),
    commandServerApi
  });
  console.log("activate completed");
  return engine;
}
export {
  JetbrainsConfiguration,
  JetbrainsIDE,
  JetbrainsPlugin,
  activate,
  createIDE,
  createJetbrainsConfiguration,
  createPlugin
};
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)

itertools/dist/index.js:
  (* istanbul ignore else -- @preserve *)
  (* istanbul ignore if -- @preserve *)
*/
//# sourceMappingURL=cursorless.js.map
